"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./node_modules/@thirdweb-dev/sdk/dist/defineProperty-e24c82ea.esm.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/sdk/dist/defineProperty-e24c82ea.esm.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"_\": function() { return /* binding */ _defineProperty; }\n/* harmony export */ });\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi9zZGsvZGlzdC9kZWZpbmVQcm9wZXJ0eS1lMjRjODJlYS5lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi9zZGsvZGlzdC9kZWZpbmVQcm9wZXJ0eS1lMjRjODJlYS5lc20uanM/MWUyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG5cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuZXhwb3J0IHsgX2RlZmluZVByb3BlcnR5IGFzIF8gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@thirdweb-dev/sdk/dist/defineProperty-e24c82ea.esm.js\n"));

/***/ }),

/***/ "./node_modules/@thirdweb-dev/sdk/dist/thirdweb-checkout-aa7869f7.esm.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/sdk/dist/thirdweb-checkout-aa7869f7.esm.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$\": function() { return /* binding */ FactoryDeploymentSchema; },\n/* harmony export */   \"A\": function() { return /* binding */ MintRequest1155; },\n/* harmony export */   \"B\": function() { return /* binding */ BaseSignaturePayloadInput; },\n/* harmony export */   \"C\": function() { return /* binding */ CommonContractSchema; },\n/* harmony export */   \"D\": function() { return /* binding */ MintRequest721withQuantity; },\n/* harmony export */   \"E\": function() { return /* binding */ EditionMetadataOutputSchema; },\n/* harmony export */   \"F\": function() { return /* binding */ MerkleSchema; },\n/* harmony export */   \"G\": function() { return /* binding */ GenericRequest; },\n/* harmony export */   \"H\": function() { return /* binding */ SnapshotEntryInput; },\n/* harmony export */   \"I\": function() { return /* binding */ SnapshotInputSchema; },\n/* harmony export */   \"J\": function() { return /* binding */ SnapshotEntryWithProofSchema; },\n/* harmony export */   \"K\": function() { return /* binding */ SnapshotSchema; },\n/* harmony export */   \"L\": function() { return /* binding */ SnapshotInfoSchema; },\n/* harmony export */   \"M\": function() { return /* binding */ MintRequest20; },\n/* harmony export */   \"N\": function() { return /* binding */ BYOCContractMetadataSchema; },\n/* harmony export */   \"O\": function() { return /* binding */ OptionalPropertiesInput; },\n/* harmony export */   \"P\": function() { return /* binding */ PartialClaimConditionInputSchema; },\n/* harmony export */   \"Q\": function() { return /* binding */ CustomContractInput; },\n/* harmony export */   \"R\": function() { return /* binding */ CustomContractOutput; },\n/* harmony export */   \"S\": function() { return /* binding */ SUPPORTED_CHAIN_IDS; },\n/* harmony export */   \"T\": function() { return /* binding */ TokenMintInputSchema; },\n/* harmony export */   \"U\": function() { return /* binding */ CustomContractDeploy; },\n/* harmony export */   \"V\": function() { return /* binding */ CustomContractSchema; },\n/* harmony export */   \"W\": function() { return /* binding */ AbiTypeSchema; },\n/* harmony export */   \"X\": function() { return /* binding */ AbiObjectSchema; },\n/* harmony export */   \"Y\": function() { return /* binding */ AbiSchema; },\n/* harmony export */   \"Z\": function() { return /* binding */ PreDeployMetadata; },\n/* harmony export */   \"_\": function() { return /* binding */ ChainIdToAddressSchema; },\n/* harmony export */   \"a\": function() { return /* binding */ ClaimConditionMetadataSchema; },\n/* harmony export */   \"a$\": function() { return /* binding */ ThirdwebSDK; },\n/* harmony export */   \"a0\": function() { return /* binding */ ExtraPublishMetadataSchemaInput; },\n/* harmony export */   \"a1\": function() { return /* binding */ ExtraPublishMetadataSchemaOutput; },\n/* harmony export */   \"a2\": function() { return /* binding */ FullPublishMetadataSchemaInput; },\n/* harmony export */   \"a3\": function() { return /* binding */ FullPublishMetadataSchemaOutput; },\n/* harmony export */   \"a4\": function() { return /* binding */ ProfileSchemaInput; },\n/* harmony export */   \"a5\": function() { return /* binding */ ProfileSchemaOutput; },\n/* harmony export */   \"a6\": function() { return /* binding */ PublishedContractSchema; },\n/* harmony export */   \"a7\": function() { return /* binding */ ContractInfoSchema; },\n/* harmony export */   \"a8\": function() { return /* binding */ CompilerMetadataFetchedSchema; },\n/* harmony export */   \"a9\": function() { return /* binding */ PreDeployMetadataFetchedSchema; },\n/* harmony export */   \"aA\": function() { return /* binding */ Erc721ClaimableWithConditions; },\n/* harmony export */   \"aB\": function() { return /* binding */ Erc721WithQuantitySignatureMintable; },\n/* harmony export */   \"aC\": function() { return /* binding */ Erc721Supply; },\n/* harmony export */   \"aD\": function() { return /* binding */ Erc721Enumerable; },\n/* harmony export */   \"aE\": function() { return /* binding */ Erc721Mintable; },\n/* harmony export */   \"aF\": function() { return /* binding */ Erc721BatchMintable; },\n/* harmony export */   \"aG\": function() { return /* binding */ Erc721Burnable; },\n/* harmony export */   \"aH\": function() { return /* binding */ StandardErc721; },\n/* harmony export */   \"aI\": function() { return /* binding */ Erc1155; },\n/* harmony export */   \"aJ\": function() { return /* binding */ Erc1155Enumerable; },\n/* harmony export */   \"aK\": function() { return /* binding */ Erc1155Mintable; },\n/* harmony export */   \"aL\": function() { return /* binding */ Erc1155BatchMintable; },\n/* harmony export */   \"aM\": function() { return /* binding */ Erc1155SignatureMintable; },\n/* harmony export */   \"aN\": function() { return /* binding */ Erc1155Burnable; },\n/* harmony export */   \"aO\": function() { return /* binding */ Erc1155LazyMintable; },\n/* harmony export */   \"aP\": function() { return /* binding */ StandardErc1155; },\n/* harmony export */   \"aQ\": function() { return /* binding */ MarketplaceDirect; },\n/* harmony export */   \"aR\": function() { return /* binding */ MarketplaceAuction; },\n/* harmony export */   \"aS\": function() { return /* binding */ ContractDeployer; },\n/* harmony export */   \"aT\": function() { return /* binding */ GasCostEstimator; },\n/* harmony export */   \"aU\": function() { return /* binding */ ContractEvents; },\n/* harmony export */   \"aV\": function() { return /* binding */ ContractInterceptor; },\n/* harmony export */   \"aW\": function() { return /* binding */ ContractPlatformFee; },\n/* harmony export */   \"aX\": function() { return /* binding */ ContractPublishedMetadata; },\n/* harmony export */   \"aY\": function() { return /* binding */ ContractOwner; },\n/* harmony export */   \"aZ\": function() { return /* binding */ TransactionTask; },\n/* harmony export */   \"a_\": function() { return /* binding */ UserWallet; },\n/* harmony export */   \"aa\": function() { return /* binding */ LoginOptionsSchema; },\n/* harmony export */   \"ab\": function() { return /* binding */ LoginPayloadDataSchema; },\n/* harmony export */   \"ac\": function() { return /* binding */ LoginPayloadSchema; },\n/* harmony export */   \"ad\": function() { return /* binding */ VerifyOptionsSchema; },\n/* harmony export */   \"ae\": function() { return /* binding */ AuthenticationOptionsSchema; },\n/* harmony export */   \"af\": function() { return /* binding */ AuthenticationPayloadDataSchema; },\n/* harmony export */   \"ag\": function() { return /* binding */ AuthenticationPayloadSchema; },\n/* harmony export */   \"ah\": function() { return /* binding */ WalletAuthenticator; },\n/* harmony export */   \"ai\": function() { return /* binding */ ContractEncoder; },\n/* harmony export */   \"aj\": function() { return /* binding */ ContractMetadata; },\n/* harmony export */   \"ak\": function() { return /* binding */ ContractRoles; },\n/* harmony export */   \"al\": function() { return /* binding */ ContractRoyalty; },\n/* harmony export */   \"am\": function() { return /* binding */ ContractPrimarySale; },\n/* harmony export */   \"an\": function() { return /* binding */ DelayedReveal; },\n/* harmony export */   \"ao\": function() { return /* binding */ DropClaimConditions; },\n/* harmony export */   \"ap\": function() { return /* binding */ DropErc1155ClaimConditions; },\n/* harmony export */   \"aq\": function() { return /* binding */ DropErc1155History; },\n/* harmony export */   \"ar\": function() { return /* binding */ Erc20; },\n/* harmony export */   \"as\": function() { return /* binding */ Erc20Mintable; },\n/* harmony export */   \"at\": function() { return /* binding */ Erc20BatchMintable; },\n/* harmony export */   \"au\": function() { return /* binding */ TokenERC20History; },\n/* harmony export */   \"av\": function() { return /* binding */ Erc20SignatureMintable; },\n/* harmony export */   \"aw\": function() { return /* binding */ Erc20Burnable; },\n/* harmony export */   \"ax\": function() { return /* binding */ StandardErc20; },\n/* harmony export */   \"ay\": function() { return /* binding */ Erc721; },\n/* harmony export */   \"az\": function() { return /* binding */ Erc721LazyMintable; },\n/* harmony export */   \"b\": function() { return /* binding */ ClaimConditionInputSchema; },\n/* harmony export */   \"b$\": function() { return /* binding */ APPROVED_IMPLEMENTATIONS; },\n/* harmony export */   \"b0\": function() { return /* binding */ ListingType; },\n/* harmony export */   \"b1\": function() { return /* binding */ ProposalState; },\n/* harmony export */   \"b2\": function() { return /* binding */ VoteType; },\n/* harmony export */   \"b3\": function() { return /* binding */ ClaimEligibility; },\n/* harmony export */   \"b4\": function() { return /* binding */ fetchCurrencyValue; },\n/* harmony export */   \"b5\": function() { return /* binding */ fetchCurrencyMetadata; },\n/* harmony export */   \"b6\": function() { return /* binding */ normalizePriceValue; },\n/* harmony export */   \"b7\": function() { return /* binding */ convertToReadableQuantity; },\n/* harmony export */   \"b8\": function() { return /* binding */ NotFoundError; },\n/* harmony export */   \"b9\": function() { return /* binding */ InvalidAddressError; },\n/* harmony export */   \"bA\": function() { return /* binding */ extractConstructorParams; },\n/* harmony export */   \"bB\": function() { return /* binding */ extractFunctions; },\n/* harmony export */   \"bC\": function() { return /* binding */ extractConstructorParamsFromAbi; },\n/* harmony export */   \"bD\": function() { return /* binding */ extractFunctionParamsFromAbi; },\n/* harmony export */   \"bE\": function() { return /* binding */ extractFunctionsFromAbi; },\n/* harmony export */   \"bF\": function() { return /* binding */ extractEventsFromAbi; },\n/* harmony export */   \"bG\": function() { return /* binding */ extractMinimalProxyImplementationAddress; },\n/* harmony export */   \"bH\": function() { return /* binding */ resolveContractUriFromAddress; },\n/* harmony export */   \"bI\": function() { return /* binding */ extractIPFSHashFromBytecode; },\n/* harmony export */   \"bJ\": function() { return /* binding */ fetchContractMetadataFromAddress; },\n/* harmony export */   \"bK\": function() { return /* binding */ fetchContractMetadata; },\n/* harmony export */   \"bL\": function() { return /* binding */ fetchSourceFilesFromMetadata; },\n/* harmony export */   \"bM\": function() { return /* binding */ fetchRawPredeployMetadata; },\n/* harmony export */   \"bN\": function() { return /* binding */ fetchPreDeployMetadata; },\n/* harmony export */   \"bO\": function() { return /* binding */ fetchExtendedReleaseMetadata; },\n/* harmony export */   \"bP\": function() { return /* binding */ detectFeatures; },\n/* harmony export */   \"bQ\": function() { return /* binding */ getAllDetectedFeatures; },\n/* harmony export */   \"bR\": function() { return /* binding */ getAllDetectedFeatureNames; },\n/* harmony export */   \"bS\": function() { return /* binding */ isFeatureEnabled; },\n/* harmony export */   \"bT\": function() { return /* binding */ assertEnabled; },\n/* harmony export */   \"bU\": function() { return /* binding */ detectContractFeature; },\n/* harmony export */   \"bV\": function() { return /* binding */ hasFunction; },\n/* harmony export */   \"bW\": function() { return /* binding */ toSemver; },\n/* harmony export */   \"bX\": function() { return /* binding */ isIncrementalVersion; },\n/* harmony export */   \"bY\": function() { return /* binding */ isDowngradeVersion; },\n/* harmony export */   \"bZ\": function() { return /* binding */ OZ_DEFENDER_FORWARDER_ADDRESS; },\n/* harmony export */   \"b_\": function() { return /* binding */ CONTRACT_ADDRESSES; },\n/* harmony export */   \"ba\": function() { return /* binding */ MissingRoleError; },\n/* harmony export */   \"bb\": function() { return /* binding */ AssetNotFoundError; },\n/* harmony export */   \"bc\": function() { return /* binding */ UploadError; },\n/* harmony export */   \"bd\": function() { return /* binding */ FileNameMissingError; },\n/* harmony export */   \"be\": function() { return /* binding */ DuplicateFileNameError; },\n/* harmony export */   \"bf\": function() { return /* binding */ NotEnoughTokensError; },\n/* harmony export */   \"bg\": function() { return /* binding */ MissingOwnerRoleError; },\n/* harmony export */   \"bh\": function() { return /* binding */ QuantityAboveLimitError; },\n/* harmony export */   \"bi\": function() { return /* binding */ FetchError; },\n/* harmony export */   \"bj\": function() { return /* binding */ DuplicateLeafsError; },\n/* harmony export */   \"bk\": function() { return /* binding */ AuctionAlreadyStartedError; },\n/* harmony export */   \"bl\": function() { return /* binding */ FunctionDeprecatedError; },\n/* harmony export */   \"bm\": function() { return /* binding */ ListingNotFoundError; },\n/* harmony export */   \"bn\": function() { return /* binding */ WrongListingTypeError; },\n/* harmony export */   \"bo\": function() { return /* binding */ RestrictedTransferError; },\n/* harmony export */   \"bp\": function() { return /* binding */ AdminRoleMissingError; },\n/* harmony export */   \"bq\": function() { return /* binding */ AuctionHasNotEndedError; },\n/* harmony export */   \"br\": function() { return /* binding */ ExtensionNotImplementedError; },\n/* harmony export */   \"bs\": function() { return /* binding */ TransactionError; },\n/* harmony export */   \"bt\": function() { return /* binding */ convertToTWError; },\n/* harmony export */   \"bu\": function() { return /* binding */ includesErrorMessage; },\n/* harmony export */   \"bv\": function() { return /* binding */ createSnapshot; },\n/* harmony export */   \"bw\": function() { return /* binding */ ALL_ROLES; },\n/* harmony export */   \"bx\": function() { return /* binding */ getRoleHash; },\n/* harmony export */   \"by\": function() { return /* binding */ matchesPrebuiltAbi; },\n/* harmony export */   \"bz\": function() { return /* binding */ hasMatchingAbi; },\n/* harmony export */   \"c\": function() { return /* binding */ ClaimConditionInputArray; },\n/* harmony export */   \"c0\": function() { return /* binding */ getApprovedImplementation; },\n/* harmony export */   \"c1\": function() { return /* binding */ getContractAddressByChainId; },\n/* harmony export */   \"c2\": function() { return /* binding */ getContractPublisherAddress; },\n/* harmony export */   \"c3\": function() { return /* binding */ getDefaultTrustedForwarders; },\n/* harmony export */   \"c4\": function() { return /* binding */ InterfaceId_IERC721; },\n/* harmony export */   \"c5\": function() { return /* binding */ InterfaceId_IERC1155; },\n/* harmony export */   \"c6\": function() { return /* binding */ NATIVE_TOKEN_ADDRESS; },\n/* harmony export */   \"c7\": function() { return /* binding */ NATIVE_TOKENS; },\n/* harmony export */   \"c8\": function() { return /* binding */ getNativeTokenByChainId; },\n/* harmony export */   \"c9\": function() { return /* binding */ EventType; },\n/* harmony export */   \"cA\": function() { return /* binding */ PaperCheckout; },\n/* harmony export */   \"cB\": function() { return /* binding */ ContractWrapper; },\n/* harmony export */   \"cC\": function() { return /* binding */ DropErc1155ContractSchema; },\n/* harmony export */   \"cD\": function() { return /* binding */ TokenErc1155ContractSchema; },\n/* harmony export */   \"cE\": function() { return /* binding */ MarketplaceContractSchema; },\n/* harmony export */   \"cF\": function() { return /* binding */ mapOffer; },\n/* harmony export */   \"cG\": function() { return /* binding */ isNativeToken; },\n/* harmony export */   \"cH\": function() { return /* binding */ MultiwrapContractSchema; },\n/* harmony export */   \"cI\": function() { return /* binding */ uploadOrExtractURI; },\n/* harmony export */   \"cJ\": function() { return /* binding */ hasERC20Allowance; },\n/* harmony export */   \"cK\": function() { return /* binding */ isTokenApprovedForTransfer; },\n/* harmony export */   \"cL\": function() { return /* binding */ TokenErc721ContractSchema; },\n/* harmony export */   \"cM\": function() { return /* binding */ DropErc721ContractSchema; },\n/* harmony export */   \"cN\": function() { return /* binding */ FEATURE_NFT_REVEALABLE; },\n/* harmony export */   \"cO\": function() { return /* binding */ AddressSchema; },\n/* harmony export */   \"cP\": function() { return /* binding */ BigNumberishSchema; },\n/* harmony export */   \"cQ\": function() { return /* binding */ RawDateSchema; },\n/* harmony export */   \"cR\": function() { return /* binding */ PackContractSchema; },\n/* harmony export */   \"cS\": function() { return /* binding */ SplitsContractSchema; },\n/* harmony export */   \"cT\": function() { return /* binding */ DropErc20ContractSchema; },\n/* harmony export */   \"cU\": function() { return /* binding */ TokenErc20ContractSchema; },\n/* harmony export */   \"cV\": function() { return /* binding */ VoteContractSchema; },\n/* harmony export */   \"ca\": function() { return /* binding */ DEFAULT_IPFS_GATEWAY; },\n/* harmony export */   \"cb\": function() { return /* binding */ CHAIN_NAME_TO_ID; },\n/* harmony export */   \"cc\": function() { return /* binding */ CHAIN_ID_TO_NAME; },\n/* harmony export */   \"cd\": function() { return /* binding */ DEFAULT_RPC_URLS; },\n/* harmony export */   \"ce\": function() { return /* binding */ getProviderForNetwork; },\n/* harmony export */   \"cf\": function() { return /* binding */ getReadOnlyProvider; },\n/* harmony export */   \"cg\": function() { return /* binding */ EditionDropInitializer; },\n/* harmony export */   \"ch\": function() { return /* binding */ EditionInitializer; },\n/* harmony export */   \"ci\": function() { return /* binding */ MarketplaceInitializer; },\n/* harmony export */   \"cj\": function() { return /* binding */ MultiwrapInitializer; },\n/* harmony export */   \"ck\": function() { return /* binding */ NFTCollectionInitializer; },\n/* harmony export */   \"cl\": function() { return /* binding */ NFTDropInitializer; },\n/* harmony export */   \"cm\": function() { return /* binding */ PackInitializer; },\n/* harmony export */   \"cn\": function() { return /* binding */ SignatureDropInitializer; },\n/* harmony export */   \"co\": function() { return /* binding */ SplitInitializer; },\n/* harmony export */   \"cp\": function() { return /* binding */ TokenDropInitializer; },\n/* harmony export */   \"cq\": function() { return /* binding */ TokenInitializer; },\n/* harmony export */   \"cr\": function() { return /* binding */ VoteInitializer; },\n/* harmony export */   \"cs\": function() { return /* binding */ PREBUILT_CONTRACTS_MAP; },\n/* harmony export */   \"ct\": function() { return /* binding */ CONTRACTS_MAP; },\n/* harmony export */   \"cu\": function() { return /* binding */ getContractTypeForRemoteName; },\n/* harmony export */   \"cv\": function() { return /* binding */ getContractName; },\n/* harmony export */   \"cw\": function() { return /* binding */ PAPER_API_URL; },\n/* harmony export */   \"cx\": function() { return /* binding */ parseChainIdToPaperChain; },\n/* harmony export */   \"cy\": function() { return /* binding */ fetchRegisteredCheckoutId; },\n/* harmony export */   \"cz\": function() { return /* binding */ createCheckoutLinkIntent; },\n/* harmony export */   \"d\": function() { return /* binding */ ClaimConditionOutputSchema; },\n/* harmony export */   \"e\": function() { return /* binding */ ChainId; },\n/* harmony export */   \"f\": function() { return /* binding */ EditionMetadataWithOwnerOutputSchema; },\n/* harmony export */   \"g\": function() { return /* binding */ EditionMetadataInputSchema; },\n/* harmony export */   \"h\": function() { return /* binding */ EditionMetadataInputOrUriSchema; },\n/* harmony export */   \"i\": function() { return /* binding */ CommonContractOutputSchema; },\n/* harmony export */   \"j\": function() { return /* binding */ CommonRoyaltySchema; },\n/* harmony export */   \"k\": function() { return /* binding */ CommonPrimarySaleSchema; },\n/* harmony export */   \"l\": function() { return /* binding */ CommonPlatformFeeSchema; },\n/* harmony export */   \"m\": function() { return /* binding */ CommonTrustedForwarderSchema; },\n/* harmony export */   \"n\": function() { return /* binding */ CommonSymbolSchema; },\n/* harmony export */   \"o\": function() { return /* binding */ CurrencySchema; },\n/* harmony export */   \"p\": function() { return /* binding */ CurrencyValueSchema; },\n/* harmony export */   \"q\": function() { return /* binding */ Signature20PayloadInput; },\n/* harmony export */   \"r\": function() { return /* binding */ Signature20PayloadOutput; },\n/* harmony export */   \"s\": function() { return /* binding */ Signature721PayloadInput; },\n/* harmony export */   \"t\": function() { return /* binding */ Signature721PayloadOutput; },\n/* harmony export */   \"u\": function() { return /* binding */ Signature1155PayloadInput; },\n/* harmony export */   \"v\": function() { return /* binding */ Signature1155PayloadInputWithTokenId; },\n/* harmony export */   \"w\": function() { return /* binding */ Signature1155PayloadOutput; },\n/* harmony export */   \"x\": function() { return /* binding */ Signature721WithQuantityInput; },\n/* harmony export */   \"y\": function() { return /* binding */ Signature721WithQuantityOutput; },\n/* harmony export */   \"z\": function() { return /* binding */ MintRequest721; }\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! zod */ \"./node_modules/zod/lib/index.mjs\");\n/* harmony import */ var _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./QueryParams-ac0149c6.esm.js */ \"./node_modules/@thirdweb-dev/sdk/dist/QueryParams-ac0149c6.esm.js\");\n/* harmony import */ var _defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./defineProperty-e24c82ea.esm.js */ \"./node_modules/@thirdweb-dev/sdk/dist/defineProperty-e24c82ea.esm.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IERC165_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IERC165.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC165.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IERC721_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IERC721.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IERC1155_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IERC1155.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155.json\");\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tiny-invariant */ \"./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IThirdwebContract_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IThirdwebContract.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IThirdwebContract.json\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! eventemitter3 */ \"./node_modules/@thirdweb-dev/sdk/node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cross-fetch */ \"./node_modules/cross-fetch/dist/browser-ponyfill.js\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(cross_fetch__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_Forwarder_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/Forwarder.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/Forwarder.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_DropERC20_V2_json__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/DropERC20_V2.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/DropERC20_V2.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IBurnableERC20_json__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IBurnableERC20.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IBurnableERC20.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IDrop_json__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IDrop.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IDrop.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IDropSinglePhase_json__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IDropSinglePhase_V1_json__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase_V1.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase_V1.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IERC20_json__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IERC20.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IMintableERC20_json__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IMintableERC20.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IMintableERC20.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IMulticall_json__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IMulticall.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IMulticall.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_ISignatureMintERC20_json__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC20.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC20.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_DropERC721_V3_json__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/DropERC721_V3.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/DropERC721_V3.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IBurnableERC721_json__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IBurnableERC721.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IBurnableERC721.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IClaimableERC721_json__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IClaimableERC721.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IClaimableERC721.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IDelayedReveal_json__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IDelayedReveal.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IDelayedReveal.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IERC721Enumerable_json__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IERC721Enumerable.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721Enumerable.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IERC721Supply_json__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IERC721Supply.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721Supply.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_ILazyMint_json__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/ILazyMint.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/ILazyMint.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IMintableERC721_json__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IMintableERC721.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IMintableERC721.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_ISignatureMintERC721_json__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_ISignatureMintERC721_V1_json__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721_V1.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721_V1.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_LazyMintWithTier_json__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/LazyMintWithTier.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/LazyMintWithTier.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_DropERC1155_V2_json__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/DropERC1155_V2.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/DropERC1155_V2.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IBurnableERC1155_json__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IBurnableERC1155.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IBurnableERC1155.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IClaimableERC1155_json__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IClaimableERC1155.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IClaimableERC1155.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IDrop1155_json__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IDrop1155.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IDrop1155.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IDropSinglePhase1155_json__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IDropSinglePhase1155_V1_json__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155_V1.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155_V1.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IERC1155Enumerable_json__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IERC1155Enumerable.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155Enumerable.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IMintableERC1155_json__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IMintableERC1155.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IMintableERC1155.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_ISignatureMintERC1155_json__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC1155.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC1155.json\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! bs58 */ \"./node_modules/@thirdweb-dev/sdk/node_modules/bs58/index.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_37___default = /*#__PURE__*/__webpack_require__.n(bs58__WEBPACK_IMPORTED_MODULE_37__);\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IERC20Metadata_json__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IERC20Metadata.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20Metadata.json\");\n/* harmony import */ var merkletreejs__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! merkletreejs */ \"./node_modules/merkletreejs/dist/index.js\");\n/* harmony import */ var merkletreejs__WEBPACK_IMPORTED_MODULE_39___default = /*#__PURE__*/__webpack_require__.n(merkletreejs__WEBPACK_IMPORTED_MODULE_39__);\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! fast-deep-equal */ \"./node_modules/fast-deep-equal/index.js\");\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_40___default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal__WEBPACK_IMPORTED_MODULE_40__);\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! uuid */ \"./node_modules/@thirdweb-dev/sdk/node_modules/uuid/dist/esm-browser/index.js\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IERC721Metadata_json__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IERC1155Metadata_json__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IDelayedRevealDeprecated_json__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IDelayedRevealDeprecated.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IDelayedRevealDeprecated.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_TWFactory_json__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/TWFactory.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/TWFactory.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_TWRegistry_json__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/TWRegistry.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/TWRegistry.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_ContractPublisher_json__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/ContractPublisher.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/ContractPublisher.json\");\n/* harmony import */ var _thirdweb_dev_storage__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! @thirdweb-dev/storage */ \"./node_modules/@thirdweb-dev/storage/dist/thirdweb-dev-storage.esm.js\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_ERC2771Context_json__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/ERC2771Context.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/ERC2771Context.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IAppURI_json__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IAppURI.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IAppURI.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IContractMetadata_json__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IContractMetadata.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IContractMetadata.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IPermissions_json__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IPermissions.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IPermissions.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IPermissionsEnumerable_json__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IPermissionsEnumerable.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IPermissionsEnumerable.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IPlatformFee_json__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IPlatformFee.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IPlatformFee.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IPrimarySale_json__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IPrimarySale.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IPrimarySale.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IRoyalty_json__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IRoyalty.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IRoyalty.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_Ownable_json__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/Ownable.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/Ownable.json\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst BigNumberSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.union([zod__WEBPACK_IMPORTED_MODULE_57__.z.string(), zod__WEBPACK_IMPORTED_MODULE_57__.z.number(), zod__WEBPACK_IMPORTED_MODULE_57__.z.bigint(), zod__WEBPACK_IMPORTED_MODULE_57__.z.custom(data => {\n  return ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.isBigNumber(data);\n})]).transform(arg => ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(arg));\nconst BigNumberishSchema = BigNumberSchema.transform(arg => arg.toString());\nconst BigNumberTransformSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.union([zod__WEBPACK_IMPORTED_MODULE_57__.z.bigint(), zod__WEBPACK_IMPORTED_MODULE_57__.z.custom(data => {\n  return ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.isBigNumber(data);\n})]).transform(arg => {\n  return ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(arg).toString();\n});\nconst AddressSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.string().refine(arg => ethers__WEBPACK_IMPORTED_MODULE_58__.utils.isAddress(arg), out => {\n  return {\n    message: `${out} is not a valid address`\n  };\n});\nconst RawDateSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.date().transform(i => {\n  return ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(Math.floor(i.getTime() / 1000));\n});\n\n/**\n * Default to now\n */\nconst StartDateSchema = RawDateSchema.default(new Date(0));\n\n/**\n * Default to 10 years from now\n */\nconst EndDateSchema = RawDateSchema.default(new Date(Date.now() + 1000 * 60 * 60 * 24 * 365 * 10));\nconst CallOverrideSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  gasLimit: BigNumberishSchema.optional(),\n  gasPrice: BigNumberishSchema.optional(),\n  maxFeePerGas: BigNumberishSchema.optional(),\n  maxPriorityFeePerGas: BigNumberishSchema.optional(),\n  nonce: BigNumberishSchema.optional(),\n  value: BigNumberishSchema.optional(),\n  blockTag: zod__WEBPACK_IMPORTED_MODULE_57__.z.union([zod__WEBPACK_IMPORTED_MODULE_57__.z.string(), zod__WEBPACK_IMPORTED_MODULE_57__.z.number()]).optional(),\n  from: AddressSchema.optional(),\n  type: zod__WEBPACK_IMPORTED_MODULE_57__.z.number().optional()\n}).strict();\n\n/**\n * @public\n */\nlet ChainId;\n\n/**\n * @public\n */\n(function (ChainId) {\n  ChainId[ChainId[\"Mainnet\"] = 1] = \"Mainnet\";\n  ChainId[ChainId[\"Goerli\"] = 5] = \"Goerli\";\n  ChainId[ChainId[\"Polygon\"] = 137] = \"Polygon\";\n  ChainId[ChainId[\"Mumbai\"] = 80001] = \"Mumbai\";\n  ChainId[ChainId[\"Localhost\"] = 1337] = \"Localhost\";\n  ChainId[ChainId[\"Hardhat\"] = 31337] = \"Hardhat\";\n  ChainId[ChainId[\"Fantom\"] = 250] = \"Fantom\";\n  ChainId[ChainId[\"FantomTestnet\"] = 4002] = \"FantomTestnet\";\n  ChainId[ChainId[\"Avalanche\"] = 43114] = \"Avalanche\";\n  ChainId[ChainId[\"AvalancheFujiTestnet\"] = 43113] = \"AvalancheFujiTestnet\";\n  ChainId[ChainId[\"Optimism\"] = 10] = \"Optimism\";\n  ChainId[ChainId[\"OptimismGoerli\"] = 420] = \"OptimismGoerli\";\n  ChainId[ChainId[\"Arbitrum\"] = 42161] = \"Arbitrum\";\n  ChainId[ChainId[\"ArbitrumGoerli\"] = 421613] = \"ArbitrumGoerli\";\n  ChainId[ChainId[\"BinanceSmartChainMainnet\"] = 56] = \"BinanceSmartChainMainnet\";\n  ChainId[ChainId[\"BinanceSmartChainTestnet\"] = 97] = \"BinanceSmartChainTestnet\";\n})(ChainId || (ChainId = {}));\n/**\n * @public\n */\nconst SUPPORTED_CHAIN_IDS = [ChainId.Mainnet, ChainId.Goerli, ChainId.Polygon, ChainId.Mumbai, ChainId.Fantom, ChainId.FantomTestnet, ChainId.Avalanche, ChainId.AvalancheFujiTestnet, ChainId.Optimism, ChainId.OptimismGoerli, ChainId.Arbitrum, ChainId.ArbitrumGoerli, ChainId.BinanceSmartChainMainnet, ChainId.BinanceSmartChainTestnet];\n\n/**\n * @public\n */\nconst NATIVE_TOKEN_ADDRESS = \"0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\";\n\n/**\n * @public\n */\nconst NATIVE_TOKENS = {\n  [ChainId.Mainnet]: {\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.Goerli]: {\n    name: \"Görli Ether\",\n    symbol: \"GOR\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.Polygon]: {\n    name: \"Matic\",\n    symbol: \"MATIC\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270\",\n      name: \"Wrapped Matic\",\n      symbol: \"WMATIC\"\n    }\n  },\n  [ChainId.Mumbai]: {\n    name: \"Matic\",\n    symbol: \"MATIC\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889\",\n      name: \"Wrapped Matic\",\n      symbol: \"WMATIC\"\n    }\n  },\n  [ChainId.Avalanche]: {\n    name: \"Avalanche\",\n    symbol: \"AVAX\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7\",\n      name: \"Wrapped AVAX\",\n      symbol: \"WAVAX\"\n    }\n  },\n  [ChainId.AvalancheFujiTestnet]: {\n    name: \"Avalanche\",\n    symbol: \"AVAX\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xd00ae08403B9bbb9124bB305C09058E32C39A48c\",\n      name: \"Wrapped AVAX\",\n      symbol: \"WAVAX\"\n    }\n  },\n  [ChainId.Fantom]: {\n    name: \"Fantom\",\n    symbol: \"FTM\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83\",\n      name: \"Wrapped Fantom\",\n      symbol: \"WFTM\"\n    }\n  },\n  [ChainId.FantomTestnet]: {\n    name: \"Fantom\",\n    symbol: \"FTM\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xf1277d1Ed8AD466beddF92ef448A132661956621\",\n      name: \"Wrapped Fantom\",\n      symbol: \"WFTM\"\n    }\n  },\n  [ChainId.Arbitrum]: {\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x82af49447d8a07e3bd95bd0d56f35241523fbab1\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.ArbitrumGoerli]: {\n    name: \"Arbitrum Goerli Ether\",\n    symbol: \"AGOR\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.Optimism]: {\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x4200000000000000000000000000000000000006\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.OptimismGoerli]: {\n    name: \"Goerli Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x4200000000000000000000000000000000000006\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.Hardhat]: {\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x5FbDB2315678afecb367f032d93F642f64180aa3\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.BinanceSmartChainMainnet]: {\n    name: \"Binance Chain Native Token\",\n    symbol: \"BNB\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\",\n      name: \"Wrapped Binance Chain Token\",\n      symbol: \"WBNB\"\n    }\n  },\n  [ChainId.BinanceSmartChainTestnet]: {\n    name: \"Binance Chain Native Token\",\n    symbol: \"TBNB\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd\",\n      name: \"Wrapped Binance Chain Testnet Token\",\n      symbol: \"WBNB\"\n    }\n  }\n};\n\n/**\n * Returns the native token for a given chain\n * @param chainId - the chain id\n * @public\n */\nfunction getNativeTokenByChainId(chainId) {\n  return NATIVE_TOKENS[chainId];\n}\n\n/**\n * @internal\n */\nconst CurrencySchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  name: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n  symbol: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n  decimals: zod__WEBPACK_IMPORTED_MODULE_57__.z.number()\n});\n\n/**\n * @internal\n */\nconst CurrencyValueSchema = CurrencySchema.extend({\n  value: BigNumberSchema,\n  displayValue: zod__WEBPACK_IMPORTED_MODULE_57__.z.string()\n});\n\n/**\n * @internal\n */\nconst MerkleSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  merkle: zod__WEBPACK_IMPORTED_MODULE_57__.z.record(zod__WEBPACK_IMPORTED_MODULE_57__.z.string()).default({})\n});\nconst SnapshotEntryInput = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  address: AddressSchema,\n  maxClaimable: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.Q[\"default\"](0),\n  // defaults to 0\n  price: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.Q.optional(),\n  // defaults to unlimited, but can be undefined in old snapshots\n  currencyAddress: AddressSchema.default(ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.AddressZero).optional() // defaults to AddressZero, but can be undefined for old snapshots\n});\n\n/**\n * @internal\n */\nconst SnapshotInputSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.union([zod__WEBPACK_IMPORTED_MODULE_57__.z.array(zod__WEBPACK_IMPORTED_MODULE_57__.z.string()).transform(strings => strings.map(address => SnapshotEntryInput.parse({\n  address\n}))), zod__WEBPACK_IMPORTED_MODULE_57__.z.array(SnapshotEntryInput)]);\nconst SnapshotEntryWithProofSchema = SnapshotEntryInput.extend({\n  proof: zod__WEBPACK_IMPORTED_MODULE_57__.z.array(zod__WEBPACK_IMPORTED_MODULE_57__.z.string())\n});\n/**\n * @internal\n */\nconst SnapshotSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  /**\n   * The merkle root\n   */\n  merkleRoot: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n  claims: zod__WEBPACK_IMPORTED_MODULE_57__.z.array(SnapshotEntryWithProofSchema)\n});\n/**\n * @internal\n */\n\n/**\n * @internal\n */\nconst SnapshotInfoSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  merkleRoot: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n  snapshotUri: zod__WEBPACK_IMPORTED_MODULE_57__.z.string()\n});\n\n/**\n * @internal\n */\nconst ClaimConditionMetadataSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  name: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional()\n}).catchall(zod__WEBPACK_IMPORTED_MODULE_57__.z.unknown());\n\n/**\n * @internal\n */\nconst ClaimConditionInputSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  startTime: StartDateSchema,\n  currencyAddress: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().default(NATIVE_TOKEN_ADDRESS),\n  price: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.A[\"default\"](0),\n  maxClaimableSupply: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.Q,\n  maxClaimablePerWallet: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.Q,\n  waitInSeconds: BigNumberishSchema.default(0),\n  merkleRootHash: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.B[\"default\"](ethers__WEBPACK_IMPORTED_MODULE_58__.utils.hexZeroPad([0], 32)),\n  snapshot: zod__WEBPACK_IMPORTED_MODULE_57__.z.optional(SnapshotInputSchema).nullable(),\n  metadata: ClaimConditionMetadataSchema.optional()\n});\n\n/**\n * @internal\n */\nconst ClaimConditionInputArray = zod__WEBPACK_IMPORTED_MODULE_57__.z.array(ClaimConditionInputSchema);\n\n/**\n * @internal\n */\nconst PartialClaimConditionInputSchema = ClaimConditionInputSchema.partial();\n\n/**\n * @internal\n */\nconst ClaimConditionOutputSchema = ClaimConditionInputSchema.extend({\n  availableSupply: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.Q,\n  currentMintSupply: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.Q,\n  currencyMetadata: CurrencyValueSchema.default({\n    value: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(\"0\"),\n    displayValue: \"0\",\n    symbol: \"\",\n    decimals: 18,\n    name: \"\"\n  }),\n  price: BigNumberSchema,\n  waitInSeconds: BigNumberSchema,\n  startTime: BigNumberSchema.transform(n => new Date(n.toNumber() * 1000)),\n  snapshot: SnapshotInputSchema.optional().nullable()\n});\n\nfunction resolveOrGenerateId(requestUId) {\n  if (requestUId === undefined) {\n    const buffer = Buffer.alloc(16);\n    (0,uuid__WEBPACK_IMPORTED_MODULE_60__.v4)({}, buffer);\n    return ethers__WEBPACK_IMPORTED_MODULE_58__.utils.hexlify(ethers__WEBPACK_IMPORTED_MODULE_58__.utils.toUtf8Bytes(buffer.toString(\"hex\")));\n  } else {\n    return ethers__WEBPACK_IMPORTED_MODULE_58__.utils.hexlify(requestUId);\n  }\n}\n\n/**\n * @internal\n */\nconst BaseSignaturePayloadInput = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  to: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().refine(address => address.toLowerCase() !== ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero, {\n    message: \"Cannot create payload to mint to zero address\"\n  }),\n  price: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.A[\"default\"](0),\n  currencyAddress: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().default(NATIVE_TOKEN_ADDRESS),\n  mintStartTime: StartDateSchema,\n  mintEndTime: EndDateSchema,\n  uid: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional().transform(arg => resolveOrGenerateId(arg)),\n  primarySaleRecipient: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().default(ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero)\n});\n\n/**\n * @internal\n */\nconst Signature20PayloadInput = BaseSignaturePayloadInput.extend({\n  quantity: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.A\n});\n\n/**\n * @internal\n */\nconst Signature20PayloadOutput = Signature20PayloadInput.extend({\n  mintStartTime: BigNumberSchema,\n  mintEndTime: BigNumberSchema\n});\n\n/**\n * @internal\n */\nconst Signature721PayloadInput = BaseSignaturePayloadInput.extend({\n  metadata: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.N,\n  royaltyRecipient: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().default(ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero),\n  royaltyBps: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.a[\"default\"](0)\n});\n\n/**\n * @internal\n */\nconst Signature721PayloadOutput = Signature721PayloadInput.extend({\n  uri: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n  royaltyBps: BigNumberSchema,\n  mintStartTime: BigNumberSchema,\n  mintEndTime: BigNumberSchema\n});\n\n/**\n * @internal\n */\nconst Signature1155PayloadInput = Signature721PayloadInput.extend({\n  metadata: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.N[\"default\"](\"\"),\n  quantity: BigNumberishSchema\n});\n\n/**\n * @internal\n */\nconst Signature1155PayloadInputWithTokenId = Signature1155PayloadInput.extend({\n  tokenId: BigNumberishSchema\n});\n\n/**\n * @internal\n */\nconst Signature1155PayloadOutput = Signature721PayloadOutput.extend({\n  tokenId: BigNumberSchema,\n  quantity: BigNumberSchema\n});\n\n/**\n * @internal\n */\nconst Signature721WithQuantityInput = Signature721PayloadInput.extend({\n  metadata: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.N[\"default\"](\"\"),\n  quantity: BigNumberSchema.default(1)\n});\n\n/**\n * @internal\n */\nconst Signature721WithQuantityOutput = Signature721PayloadOutput.extend({\n  quantity: BigNumberSchema.default(1)\n});\n\n/**\n * @public\n */\n\nconst MintRequest20 = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"quantity\",\n  type: \"uint256\"\n}, {\n  name: \"price\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst MintRequest721 = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"royaltyRecipient\",\n  type: \"address\"\n}, {\n  name: \"royaltyBps\",\n  type: \"uint256\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"uri\",\n  type: \"string\"\n}, {\n  name: \"price\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst MintRequest1155 = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"royaltyRecipient\",\n  type: \"address\"\n}, {\n  name: \"royaltyBps\",\n  type: \"uint256\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"tokenId\",\n  type: \"uint256\"\n}, {\n  name: \"uri\",\n  type: \"string\"\n}, {\n  name: \"quantity\",\n  type: \"uint256\"\n}, {\n  name: \"pricePerToken\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst MintRequest721withQuantity = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"royaltyRecipient\",\n  type: \"address\"\n}, {\n  name: \"royaltyBps\",\n  type: \"uint256\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"uri\",\n  type: \"string\"\n}, {\n  name: \"quantity\",\n  type: \"uint256\"\n}, {\n  name: \"pricePerToken\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst GenericRequest = [{\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}, {\n  name: \"data\",\n  type: \"bytes\"\n}];\n\n/**\n * @internal\n */\nconst CommonContractSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  name: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n  description: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  image: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.F.optional(),\n  external_link: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().url().optional()\n});\n/**\n * @internal\n */\nconst CommonContractOutputSchema = CommonContractSchema.extend({\n  image: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional()\n}).catchall(zod__WEBPACK_IMPORTED_MODULE_57__.z.unknown());\n\n/**\n * @internal\n */\nconst CommonRoyaltySchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  /**\n   * The amount of royalty collected on all royalties represented as basis points.\n   * The default is 0 (no royalties).\n   *\n   * 1 basis point = 0.01%\n   *\n   * For example: if this value is 100, then the royalty is 1% of the total sales.\n   *\n   *  @internalremarks used by OpenSea \"seller_fee_basis_points\"\n   */\n  seller_fee_basis_points: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.a[\"default\"](0),\n  /**\n   * The address of the royalty recipient. All royalties will be sent\n   * to this address.\n   * @internalremarks used by OpenSea \"fee_recipient\"\n   */\n  fee_recipient: AddressSchema.default(ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero)\n});\n\n/**\n * @internal\n */\nconst CommonPrimarySaleSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  /**\n   * primary sale recipient address\n   */\n  primary_sale_recipient: AddressSchema\n});\n\n/**\n * @internal\n */\nconst CommonPlatformFeeSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  /**\n   * platform fee basis points\n   */\n  platform_fee_basis_points: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.a[\"default\"](0),\n  /**\n   * platform fee recipient address\n   */\n  platform_fee_recipient: AddressSchema.default(ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero)\n});\n\n/**\n * @internal\n */\nconst CommonTrustedForwarderSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  trusted_forwarders: zod__WEBPACK_IMPORTED_MODULE_57__.z.array(AddressSchema).default([])\n});\n\n/**\n * @internal\n */\nconst CommonSymbolSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  symbol: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional().default(\"\")\n});\n\nconst PropertiesInput = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({}).catchall(zod__WEBPACK_IMPORTED_MODULE_57__.z.union([BigNumberTransformSchema, zod__WEBPACK_IMPORTED_MODULE_57__.z.unknown()]));\n\n/**\n * @internal\n */\nconst OptionalPropertiesInput = zod__WEBPACK_IMPORTED_MODULE_57__.z.union([zod__WEBPACK_IMPORTED_MODULE_57__.z.array(PropertiesInput), PropertiesInput]).optional();\n\n/**\n * @internal\n */\nconst TokenMintInputSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  toAddress: AddressSchema,\n  amount: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.A\n});\n\n/**\n * @public\n */\n\n/**\n * @internal\n */\nconst EditionMetadataOutputSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  supply: BigNumberSchema,\n  metadata: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.C\n});\n\n/**\n * @internal\n */\nconst EditionMetadataWithOwnerOutputSchema = EditionMetadataOutputSchema.extend({\n  owner: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n  quantityOwned: BigNumberSchema\n});\n\n/**\n * @internal\n */\nconst EditionMetadataInputSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  supply: BigNumberishSchema,\n  metadata: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.b\n});\n\n/**\n * @internal\n */\nconst EditionMetadataInputOrUriSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  supply: BigNumberishSchema,\n  metadata: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.N\n});\n\n/**\n * @public\n */\n\n/**\n * @internal\n */\nconst OZ_DEFENDER_FORWARDER_ADDRESS = \"0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81\";\nconst TWRegistry_address = \"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd\";\nconst TWFactory_address = \"0x5DBC7B840baa9daBcBe9D2492E45D7244B54A2A0\";\nconst ContractPublisher_address = \"0x664244560eBa21Bf82d7150C791bE1AbcD5B4cd7\"; // Polygon only\n\n/**\n * @internal\n */\nconst CONTRACT_ADDRESSES = {\n  [ChainId.Mainnet]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0x76ce2CB1Ae48Fa067f4fb8c5f803111AE0B24BEA\",\n    biconomyForwarder: \"0x84a0856b038eaAd1cC7E297cF34A7e72685A8693\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero\n  },\n  [ChainId.Goerli]: {\n    openzeppelinForwarder: \"0x5001A14CA6163143316a7C614e30e6041033Ac20\",\n    openzeppelinForwarderEOA: \"0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2\",\n    biconomyForwarder: \"0xE041608922d06a4F26C0d4c27d8bCD01daf1f792\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: \"0xB1Bd9d7942A250BA2Dce27DD601F2ED4211A60C4\"\n  },\n  [ChainId.Polygon]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F\",\n    biconomyForwarder: \"0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: \"0x308473Be900F4185A56587dE54bDFF5E8f7a6AE7\"\n  },\n  [ChainId.Mumbai]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250\",\n    biconomyForwarder: \"0x9399BB24DBB5C4b782C70c2969F58716Ebbd6a3b\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: \"0x3F17972CB27506eb4a6a3D59659e0B57a43fd16C\"\n  },\n  [ChainId.Avalanche]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250\",\n    biconomyForwarder: \"0x64CD353384109423a966dCd3Aa30D884C9b2E057\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero\n  },\n  [ChainId.AvalancheFujiTestnet]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2\",\n    biconomyForwarder: \"0x6271Ca63D30507f2Dcbf99B52787032506D75BBF\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: \"0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23\"\n  },\n  [ChainId.Fantom]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250\",\n    biconomyForwarder: \"0x64CD353384109423a966dCd3Aa30D884C9b2E057\",\n    twFactory: \"0x97EA0Fcc552D5A8Fb5e9101316AAd0D62Ea0876B\",\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero\n  },\n  [ChainId.FantomTestnet]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0x42D3048b595B6e1c28a588d70366CcC2AA4dB47b\",\n    biconomyForwarder: \"0x69FB8Dca8067A5D38703b9e8b39cf2D51473E4b4\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: \"0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23\"\n  },\n  [ChainId.Arbitrum]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F\",\n    biconomyForwarder: \"0xfe0fa3C06d03bDC7fb49c892BbB39113B534fB57\",\n    twFactory: \"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0\",\n    twRegistry: \"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd\",\n    twBYOCRegistry: ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero\n  },\n  [ChainId.ArbitrumGoerli]: {\n    openzeppelinForwarder: \"0x8cbc8B5d71702032904750A66AEfE8B603eBC538\",\n    openzeppelinForwarderEOA: \"0x119704314Ef304EaAAE4b3c7C9ABd59272A28310\",\n    biconomyForwarder: ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero,\n    twFactory: \"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0\",\n    twRegistry: \"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd\",\n    twBYOCRegistry: ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero\n  },\n  [ChainId.Optimism]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0x7e80648EB2071E26937F9D42A513ccf4815fc702\",\n    biconomyForwarder: \"0xefba8a2a82ec1fb1273806174f5e28fbb917cf95\",\n    twFactory: \"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0\",\n    twRegistry: \"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd\",\n    twBYOCRegistry: ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero\n  },\n  [ChainId.OptimismGoerli]: {\n    openzeppelinForwarder: \"0x8cbc8B5d71702032904750A66AEfE8B603eBC538\",\n    openzeppelinForwarderEOA: \"0x119704314Ef304EaAAE4b3c7C9ABd59272A28310\",\n    biconomyForwarder: ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero,\n    twFactory: \"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0\",\n    twRegistry: \"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd\",\n    twBYOCRegistry: ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero\n  },\n  [ChainId.BinanceSmartChainMainnet]: {\n    openzeppelinForwarder: \"0x8cbc8B5d71702032904750A66AEfE8B603eBC538\",\n    openzeppelinForwarderEOA: \"0xE8dd2Ff0212F86d3197b4AfDC6dAC6ac47eb10aC\",\n    biconomyForwarder: \"0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8\",\n    twBYOCRegistry: ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero,\n    twFactory: \"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0\",\n    twRegistry: \"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd\"\n  },\n  [ChainId.BinanceSmartChainTestnet]: {\n    openzeppelinForwarder: \"0x8cbc8B5d71702032904750A66AEfE8B603eBC538\",\n    openzeppelinForwarderEOA: \"0x7e80648EB2071E26937F9D42A513ccf4815fc702\",\n    biconomyForwarder: \"0x61456BF1715C1415730076BB79ae118E806E74d2\",\n    twBYOCRegistry: ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero,\n    twFactory: \"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0\",\n    twRegistry: \"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd\"\n  }\n};\nconst APPROVED_IMPLEMENTATIONS = {\n  [ChainId.Mainnet]: {\n    \"nft-drop\": \"0x60fF9952e0084A6DEac44203838cDC91ABeC8736\",\n    \"edition-drop\": \"0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550\",\n    \"token-drop\": \"0xE1eE43D23f247b6A9aF81fcE2766E76709482728\",\n    \"signature-drop\": \"0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A\"\n  },\n  [ChainId.Polygon]: {\n    \"nft-drop\": \"0xB96508050Ba0925256184103560EBADA912Fcc69\",\n    \"edition-drop\": \"0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550\",\n    \"token-drop\": \"0x5A8eA4Adad8289746D073947BA06D69A62499aaf\",\n    \"signature-drop\": \"0xBE2fDc35410E268e41Bec62DBb01AEb43245c7d5\"\n  },\n  [ChainId.Fantom]: {\n    \"nft-drop\": \"0x2A396b2D90BAcEF19cDa973586B2633d22710fC2\",\n    \"edition-drop\": \"0x06395FCF9AC6ED827f9dD6e776809cEF1Be0d21B\",\n    \"token-drop\": \"0x0148b28a38efaaC31b6aa0a6D9FEb70FE7C91FFa\",\n    \"signature-drop\": \"0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10\"\n  },\n  [ChainId.Avalanche]: {\n    \"nft-drop\": \"0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6\",\n    \"edition-drop\": \"0x135fC9D26E5eC51260ece1DF4ED424E2f55c7766\",\n    \"token-drop\": \"0xca0B071899E575BA86495D46c5066971b6f3A901\",\n    \"signature-drop\": \"0x1d47526C3292B0130ef0afD5F02c1DA052A017B3\"\n  },\n  [ChainId.Optimism]: {\n    \"nft-drop\": \"0xFBd7D24d80ee005671E731a7287DEB6073264dD1\",\n    \"edition-drop\": \"0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10\",\n    \"token-drop\": \"0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE\",\n    \"signature-drop\": \"0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD\"\n  },\n  [ChainId.Arbitrum]: {\n    \"nft-drop\": \"0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a\",\n    \"edition-drop\": \"0xCcddcec1831646Beff2753249f1B9C580327E89F\",\n    \"token-drop\": \"0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9\",\n    \"signature-drop\": \"0x2dF9851af45dd41C8584ac55D983C604da985Bc7\"\n  },\n  [ChainId.BinanceSmartChainMainnet]: {\n    \"nft-drop\": \"0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE\",\n    \"edition-drop\": \"0x2A396b2D90BAcEF19cDa973586B2633d22710fC2\",\n    \"token-drop\": \"0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10\",\n    \"signature-drop\": \"0xFBd7D24d80ee005671E731a7287DEB6073264dD1\"\n  },\n  [ChainId.Goerli]: {\n    \"nft-drop\": \"0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C\",\n    \"edition-drop\": \"0x5A8eA4Adad8289746D073947BA06D69A62499aaf\",\n    \"token-drop\": \"0x5680933221B752EB443654a014f88B101F868d50\",\n    \"signature-drop\": \"0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9\"\n  },\n  [ChainId.Mumbai]: {\n    \"nft-drop\": \"0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a\",\n    \"edition-drop\": \"0xCcddcec1831646Beff2753249f1B9C580327E89F\",\n    \"token-drop\": \"0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9\",\n    \"signature-drop\": \"0x2dF9851af45dd41C8584ac55D983C604da985Bc7\"\n  },\n  [ChainId.FantomTestnet]: {\n    \"nft-drop\": \"0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD\",\n    \"edition-drop\": \"0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE\",\n    \"token-drop\": \"0xFBd7D24d80ee005671E731a7287DEB6073264dD1\",\n    \"signature-drop\": \"0x5A8eA4Adad8289746D073947BA06D69A62499aaf\"\n  },\n  [ChainId.AvalancheFujiTestnet]: {\n    \"nft-drop\": \"0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C\",\n    \"edition-drop\": \"0xE1eE43D23f247b6A9aF81fcE2766E76709482728\",\n    \"token-drop\": \"0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A\",\n    \"signature-drop\": \"0xCcddcec1831646Beff2753249f1B9C580327E89F\"\n  },\n  [ChainId.OptimismGoerli]: {\n    \"nft-drop\": \"0xCcddcec1831646Beff2753249f1B9C580327E89F\",\n    \"edition-drop\": \"0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A\",\n    \"token-drop\": \"0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C\",\n    \"signature-drop\": \"0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9\"\n  },\n  [ChainId.ArbitrumGoerli]: {\n    \"nft-drop\": \"0x9CfE807a5b124b962064Fa8F7FD823Cc701255b6\",\n    \"edition-drop\": \"0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6\",\n    \"token-drop\": \"0x1d47526C3292B0130ef0afD5F02c1DA052A017B3\",\n    \"signature-drop\": \"0xE1eE43D23f247b6A9aF81fcE2766E76709482728\"\n  },\n  [ChainId.BinanceSmartChainTestnet]: {\n    \"nft-drop\": \"\",\n    \"edition-drop\": \"\",\n    \"token-drop\": \"\",\n    \"signature-drop\": \"\" // TODO\n  }\n};\n\n/**\n * @internal\n * @param chainId\n * @param contractType\n */\nfunction getApprovedImplementation(chainId,\n// TODO use SupportedChainId once we deploy to all chains\ncontractType) {\n  if (chainId in APPROVED_IMPLEMENTATIONS) {\n    const approvedImpls = APPROVED_IMPLEMENTATIONS[chainId];\n    if (contractType in approvedImpls) {\n      return approvedImpls[contractType];\n    }\n  }\n  return null;\n}\n\n/**\n * @internal\n */\nfunction getContractAddressByChainId(chainId, contractName) {\n  // for testing only\n  if (chainId === ChainId.Hardhat) {\n    if (contractName === \"twFactory\") {\n      // eslint-disable-next-line turbo/no-undeclared-env-vars\n      return process.env.factoryAddress;\n    } else if (contractName === \"twRegistry\") {\n      // eslint-disable-next-line turbo/no-undeclared-env-vars\n      return process.env.registryAddress;\n    } else {\n      return ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero;\n    }\n  }\n  // real output here\n  return CONTRACT_ADDRESSES[chainId][contractName];\n}\n\n/**\n * @internal\n */\nfunction getContractPublisherAddress() {\n  // eslint-disable-next-line turbo/no-undeclared-env-vars\n  if (process.env.contractPublisherAddress) {\n    // eslint-disable-next-line turbo/no-undeclared-env-vars\n    return process.env.contractPublisherAddress;\n  } else {\n    return ContractPublisher_address;\n  }\n}\n\n/**\n *\n * @param chainId - chain id\n * @returns the array of trusted forwarders for the given chain id\n * @internal\n */\nfunction getDefaultTrustedForwarders(chainId) {\n  const chainEnum = SUPPORTED_CHAIN_IDS.find(c => c === chainId);\n  const biconomyForwarder = chainEnum ? CONTRACT_ADDRESSES[chainEnum].biconomyForwarder : ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero;\n  const openzeppelinForwarder = chainEnum ? CONTRACT_ADDRESSES[chainEnum].openzeppelinForwarder : ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero;\n  return biconomyForwarder !== ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero ? [openzeppelinForwarder, biconomyForwarder] : [openzeppelinForwarder];\n}\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\nconst InterfaceId_IERC721 = ethers__WEBPACK_IMPORTED_MODULE_58__.utils.arrayify(\"0x80ac58cd\");\n\n/**\n * @internal\n */\nconst InterfaceId_IERC1155 = ethers__WEBPACK_IMPORTED_MODULE_58__.utils.arrayify(\"0xd9b67a26\");\n\n/**\n * @public\n */\nlet EventType;\n(function (EventType) {\n  EventType[\"Transaction\"] = \"transaction\";\n  EventType[\"Signature\"] = \"signature\";\n})(EventType || (EventType = {}));\n\nconst DEFAULT_BATCH_TIME_LIMIT_MS = 50;\nconst DEFAULT_BATCH_SIZE_LIMIT = 250;\nconst DEFAULT_BATCH_OPTIONS = {\n  timeLimitMs: DEFAULT_BATCH_TIME_LIMIT_MS,\n  sizeLimit: DEFAULT_BATCH_SIZE_LIMIT\n};\n// mostly copied from ethers.js directly but make it a StaticJsonRpcProvider\nclass StaticJsonRpcBatchProvider extends ethers__WEBPACK_IMPORTED_MODULE_58__.providers.StaticJsonRpcProvider {\n  constructor(url, network) {\n    let batchOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_BATCH_OPTIONS;\n    super(url, network);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"_timeLimitMs\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"_sizeLimit\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"_pendingBatchAggregator\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"_pendingBatch\", void 0);\n    this._timeLimitMs = batchOptions.timeLimitMs || DEFAULT_BATCH_SIZE_LIMIT;\n    this._sizeLimit = batchOptions.sizeLimit || DEFAULT_BATCH_TIME_LIMIT_MS;\n    this._pendingBatchAggregator = null;\n    this._pendingBatch = null;\n  }\n  sendCurrentBatch(request) {\n    // if we still have a timeout clear that first\n    if (this._pendingBatchAggregator) {\n      clearTimeout(this._pendingBatchAggregator);\n    }\n    // Get the current batch and clear it, so new requests\n    // go into the next batch\n    const batch = this._pendingBatch || [];\n    this._pendingBatch = null;\n    this._pendingBatchAggregator = null;\n\n    // Get the request as an array of requests\n    const request_ = batch.map(inflight => inflight.request);\n    this.emit(\"debug\", {\n      action: \"requestBatch\",\n      request: ethers__WEBPACK_IMPORTED_MODULE_58__.utils.deepCopy(request),\n      provider: this\n    });\n    return ethers__WEBPACK_IMPORTED_MODULE_58__.utils.fetchJson(this.connection, JSON.stringify(request_)).then(result => {\n      this.emit(\"debug\", {\n        action: \"response\",\n        request: request_,\n        response: result,\n        provider: this\n      });\n\n      // For each result, feed it to the correct Promise, depending\n      // on whether it was a success or error\n      batch.forEach((inflightRequest_, index) => {\n        const payload = result[index];\n        if (payload.error) {\n          const error = new Error(payload.error.message);\n          error.code = payload.error.code;\n          error.data = payload.error.data;\n          inflightRequest_.reject(error);\n        } else {\n          inflightRequest_.resolve(payload.result);\n        }\n      });\n    }, error => {\n      this.emit(\"debug\", {\n        action: \"response\",\n        error: error,\n        request: request_,\n        provider: this\n      });\n\n      // If there was an error, reject all the requests\n      batch.forEach(inflightRequest_ => {\n        inflightRequest_.reject(error);\n      });\n    });\n  }\n  send(method, params) {\n    const request = {\n      method: method,\n      params: params,\n      id: this._nextId++,\n      jsonrpc: \"2.0\"\n    };\n    if (this._pendingBatch === null) {\n      this._pendingBatch = [];\n    }\n    const inflightRequest = {\n      request,\n      resolve: null,\n      reject: null\n    };\n    const promise = new Promise((resolve, reject) => {\n      inflightRequest.resolve = resolve;\n      inflightRequest.reject = reject;\n    });\n\n    // if we would go *over* the size limit of the batch with this request, send the batch now\n    if (this._pendingBatch.length === this._sizeLimit) {\n      this.sendCurrentBatch(request);\n    }\n    this._pendingBatch.push(inflightRequest);\n    if (!this._pendingBatchAggregator) {\n      // Schedule batch for next event loop + short duration\n      this._pendingBatchAggregator = setTimeout(() => {\n        this.sendCurrentBatch(request);\n      }, this._timeLimitMs);\n    }\n    return promise;\n  }\n}\n\n/**\n * @internal\n */\nconst DEFAULT_IPFS_GATEWAY = \"https://gateway.ipfscdn.io/ipfs/\";\nconst CHAIN_NAME_TO_ID = {\n  \"avalanche-fuji\": ChainId.AvalancheFujiTestnet,\n  \"avalanche-testnet\": ChainId.AvalancheFujiTestnet,\n  \"fantom-testnet\": ChainId.FantomTestnet,\n  ethereum: ChainId.Mainnet,\n  matic: ChainId.Polygon,\n  mumbai: ChainId.Mumbai,\n  goerli: ChainId.Goerli,\n  polygon: ChainId.Polygon,\n  mainnet: ChainId.Mainnet,\n  optimism: ChainId.Optimism,\n  \"optimism-goerli\": ChainId.OptimismGoerli,\n  arbitrum: ChainId.Arbitrum,\n  \"arbitrum-goerli\": ChainId.ArbitrumGoerli,\n  fantom: ChainId.Fantom,\n  avalanche: ChainId.Avalanche,\n  binance: ChainId.BinanceSmartChainMainnet,\n  \"binance-testnet\": ChainId.BinanceSmartChainTestnet\n};\nconst CHAIN_ID_TO_NAME = Object.fromEntries(Object.entries(CHAIN_NAME_TO_ID).map(_ref => {\n  let [name, id] = _ref;\n  return [id, name];\n}));\nfunction buildDefaultMap() {\n  return SUPPORTED_CHAIN_IDS.reduce((previousValue, currentValue) => {\n    previousValue[currentValue] = getProviderForNetwork(CHAIN_ID_TO_NAME[currentValue]);\n    return previousValue;\n  }, {});\n}\nconst DEFAULT_RPC_URLS = buildDefaultMap();\n\n/**\n * @internal\n * @param network - the chain name or rpc url\n * @returns the rpc url for that chain\n */\nfunction getProviderForNetwork(network) {\n  if (typeof network !== \"string\") {\n    return network;\n  }\n  switch (network) {\n    case \"mainnet\":\n    case \"ethereum\":\n      return (0,_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.g)(\"ethereum\");\n    case \"goerli\":\n      return (0,_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.g)(\"goerli\");\n    case \"polygon\":\n    case \"matic\":\n      return (0,_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.g)(\"polygon\");\n    case \"mumbai\":\n      return (0,_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.g)(\"mumbai\");\n    case \"optimism\":\n      return (0,_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.g)(\"optimism\");\n    case \"optimism-goerli\":\n      return (0,_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.g)(\"optimism-goerli\");\n    case \"arbitrum\":\n      return (0,_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.g)(\"arbitrum\");\n    case \"arbitrum-goerli\":\n      return (0,_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.g)(\"arbitrum-goerli\");\n    case \"fantom\":\n      return (0,_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.g)(\"fantom\");\n    case \"fantom-testnet\":\n      return (0,_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.g)(\"fantom-testnet\");\n    case \"avalanche\":\n      return (0,_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.g)(\"avalanche\");\n    case \"avalanche-testnet\":\n    case \"avalanche-fuji\":\n      return (0,_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.g)(\"avalanche-fuji\");\n    case \"binance\":\n      return (0,_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.g)(\"binance\");\n    case \"binance-testnet\":\n      return (0,_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.g)(\"binance-testnet\");\n    default:\n      if (network.startsWith(\"http\") || network.startsWith(\"ws\")) {\n        return network;\n      } else {\n        throw new Error(`Unrecognized chain name or RPC url: ${network}`);\n      }\n  }\n}\nconst READONLY_PROVIDER_MAP = new Map();\n\n/**\n *\n * @param network - the chain name or rpc url\n * @param chainId - the optional chain id\n * @returns the provider\n */\nfunction getReadOnlyProvider(network, chainId) {\n  try {\n    const match = network.match(/^(ws|http)s?:/i);\n    // try the JSON batch provider if available\n    if (match) {\n      switch (match[1]) {\n        case \"http\":\n          const seralizedOpts = `${network}-${chainId || -1}`;\n          const existingProvider = READONLY_PROVIDER_MAP.get(seralizedOpts);\n          if (existingProvider) {\n            return existingProvider;\n          }\n          const newProvider = chainId ?\n          // if we know the chainId we should use the StaticJsonRpcBatchProvider\n          new StaticJsonRpcBatchProvider(network, chainId) :\n          // otherwise fall back to the built in json rpc batch provider\n          new ethers__WEBPACK_IMPORTED_MODULE_58__.providers.JsonRpcBatchProvider(network, chainId);\n          READONLY_PROVIDER_MAP.set(seralizedOpts, newProvider);\n          return newProvider;\n        case \"ws\":\n          return new ethers__WEBPACK_IMPORTED_MODULE_58__.providers.WebSocketProvider(network, chainId);\n        default:\n          return ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.getDefaultProvider(network);\n      }\n    } else {\n      return ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.getDefaultProvider(network);\n    }\n  } catch (e) {\n    // fallback to the default provider\n    return ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.getDefaultProvider(network);\n  }\n}\n\n/**\n * Error that may get thrown if IPFS returns nothing for a given uri.\n * @internal\n */\nclass NotFoundError extends Error {\n  /** @internal */\n  constructor(identifier) {\n    super(identifier ? `Object with id ${identifier} NOT FOUND` : \"NOT_FOUND\");\n  }\n}\n\n/**\n * Error that may get thrown if an invalid address was passed\n * @internal\n */\nclass InvalidAddressError extends Error {\n  /** @internal */\n  constructor(address) {\n    super(address ? `'${address}' is an invalid address` : \"Invalid address passed\");\n  }\n}\n\n/**\n * @internal\n */\nclass MissingRoleError extends Error {\n  /** @internal */\n  /** @internal */\n  constructor(address, role) {\n    super(`MISSING ROLE: ${address} does not have the '${role}' role`);\n  }\n}\n\n/**\n * @internal\n */\nclass AssetNotFoundError extends Error {\n  /** @internal */\n  /** @internal */\n  constructor() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"The asset you're trying to use could not be found.\";\n    super(`message: ${message}`);\n  }\n}\n\n/**\n * @internal\n */\nclass UploadError extends Error {\n  /** @internal */\n  constructor(message) {\n    super(`UPLOAD_FAILED: ${message}`);\n  }\n}\n\n/**\n * @internal\n */\nclass FileNameMissingError extends Error {\n  /** @internal */\n  constructor() {\n    super(\"File name is required when object is not a `File` type object.\");\n  }\n}\n\n/**\n * @internal\n */\nclass DuplicateFileNameError extends Error {\n  /** @internal */\n  constructor(fileName) {\n    super(`DUPLICATE_FILE_NAME_ERROR: File name ${fileName} was passed for more than one file.`);\n  }\n}\n\n/**\n * @internal\n */\nclass NotEnoughTokensError extends Error {\n  /** @internal */\n  constructor(contractAddress, quantity, available) {\n    super(`BALANCE ERROR: you do not have enough balance on contract ${contractAddress} to use ${quantity} tokens. You have ${available} tokens available.`);\n  }\n}\n\n/**\n * @internal\n */\nclass MissingOwnerRoleError extends Error {\n  /** @internal */\n  constructor() {\n    super(`LIST ERROR: you should be the owner of the token to list it.`);\n  }\n}\n\n/**\n * @internal\n */\nclass QuantityAboveLimitError extends Error {\n  /** @internal */\n  constructor(quantity) {\n    super(`BUY ERROR: You cannot buy more than ${quantity} tokens`);\n  }\n}\n\n/**\n * Thrown when data fails to fetch from storage.\n * @internal\n */\nclass FetchError extends Error {\n  /** @internal */\n  constructor(message, innerError) {\n    super(`FETCH_FAILED: ${message}`);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"innerError\", void 0);\n    this.innerError = innerError;\n  }\n}\n\n/**\n * Thrown when attempting to create a snapshot with duplicate leafs\n * @internal\n */\nclass DuplicateLeafsError extends Error {\n  constructor(message) {\n    super(`DUPLICATE_LEAFS${message ? ` : ${message}` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when attempting to update/cancel an auction that already started\n * @internal\n */\nclass AuctionAlreadyStartedError extends Error {\n  constructor(id) {\n    super(`Auction already started with existing bid${id ? `, id: ${id}` : \"\"}`);\n  }\n}\n\n/**\n * @internal\n */\nclass FunctionDeprecatedError extends Error {\n  /** @internal */\n  constructor(message) {\n    super(`FUNCTION DEPRECATED. ${message ? `Use ${message} instead` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when trying to retrieve a listing from a marketplace that doesn't exist\n * @internal\n */\nclass ListingNotFoundError extends Error {\n  constructor(marketplaceContractAddress, listingId) {\n    super(`Could not find listing.${marketplaceContractAddress ? ` marketplace address: ${marketplaceContractAddress}` : \"\"}${listingId ? ` listing id: ${listingId}` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when trying to retrieve a listing of the wrong type\n * @internal\n */\nclass WrongListingTypeError extends Error {\n  constructor(marketplaceContractAddress, listingId, actualType, expectedType) {\n    super(`Incorrect listing type. Are you sure you're using the right method?.${marketplaceContractAddress ? ` marketplace address: ${marketplaceContractAddress}` : \"\"}${listingId ? ` listing id: ${listingId}` : \"\"}${expectedType ? ` expected type: ${expectedType}` : \"\"}${actualType ? ` actual type: ${actualType}` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when attempting to transfer an asset that has restricted transferability\n * @internal\n */\nclass RestrictedTransferError extends Error {\n  constructor(assetAddress) {\n    super(`Failed to transfer asset, transfer is restricted.${assetAddress ? ` Address : ${assetAddress}` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when attempting to execute an admin-role function.\n * @internal\n */\nclass AdminRoleMissingError extends Error {\n  constructor(address, contractAddress) {\n    let message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Failed to execute transaction\";\n    super(`${message}, admin role is missing${address ? ` on address: ${address}` : \"\"}${contractAddress ? ` on contract: ${contractAddress}` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when attempting to close an auction that has not ended\n * @internal\n */\nclass AuctionHasNotEndedError extends Error {\n  constructor(id, endTime) {\n    super(`Auction has not ended yet${id ? `, id: ${id}` : \"\"}${endTime ? `, end time: ${endTime.toString()}` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when attempting to call a contract function that is not implemented\n * @internal\n */\nclass ExtensionNotImplementedError extends Error {\n  constructor(feature) {\n    super(`This functionality is not available because the contract does not implement the '${feature.docLinks.contracts}' Extension. Learn how to unlock this functionality at https://portal.thirdweb.com/extensions `);\n  }\n}\n\n/**\n * @internal\n */\n\n/**\n * @public\n */\nclass TransactionError extends Error {\n  constructor(reason, from, to, data, network, rpcUrl, raw, functionInfo) {\n    let builtErrorMsg = \"Contract transaction failed\\n\\n\";\n    builtErrorMsg += `Message: ${reason}`;\n    builtErrorMsg += \"\\n\\n| Transaction info |\\n\";\n    builtErrorMsg += withSpaces(\"from\", from);\n    builtErrorMsg += withSpaces(\"to\", to);\n    builtErrorMsg += withSpaces(`chain`, `${network.name} (${network.chainId})`);\n    if (functionInfo) {\n      builtErrorMsg += \"\\n\\n| Failed contract call info |\\n\";\n      builtErrorMsg += withSpaces(\"function\", functionInfo.signature);\n      builtErrorMsg += withSpaces(`arguments`, JSON.stringify(functionInfo.inputs, null, 2));\n      if (functionInfo.value.gt(0)) {\n        builtErrorMsg += withSpaces(\"value\", `${ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.formatEther(functionInfo.value)} ${NATIVE_TOKENS[network.chainId]?.symbol}`);\n      }\n    }\n    try {\n      const url = new URL(rpcUrl);\n      builtErrorMsg += withSpaces(`RPC`, url.hostname);\n    } catch (e2) {\n      // ignore if can't parse URL\n    }\n    builtErrorMsg += \"\\n\\n\";\n    builtErrorMsg += \"Need help with this error? Join our community: https://discord.gg/thirdweb\";\n    builtErrorMsg += \"\\n\\n\\n\\n\";\n    builtErrorMsg += \"| Raw error |\";\n    builtErrorMsg += \"\\n\\n\";\n    builtErrorMsg += raw;\n    super(builtErrorMsg);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"reason\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"from\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"to\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"data\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"chain\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"rpcUrl\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"functionInfo\", void 0);\n    this.reason = reason;\n    this.from = from;\n    this.to = to;\n    this.data = data;\n    this.chain = network;\n    this.rpcUrl = rpcUrl;\n    this.functionInfo = functionInfo;\n  }\n}\n\n/**\n * @internal\n * @param data\n * @param contractInterface\n */\nfunction parseFunctionInfo(data, contractInterface) {\n  try {\n    const fnFragment = contractInterface.parseTransaction({\n      data\n    });\n    const results = {};\n    const args = fnFragment.args;\n    fnFragment.functionFragment.inputs.forEach((param, index) => {\n      if (Array.isArray(args[index])) {\n        const obj = {};\n        const components = param.components;\n        if (components) {\n          const arr = args[index];\n          for (let i = 0; i < components.length; i++) {\n            const name = components[i].name;\n            obj[name] = arr[i];\n          }\n          results[param.name] = obj;\n        }\n      } else {\n        results[param.name] = args[index];\n      }\n    });\n    return {\n      signature: fnFragment.signature,\n      inputs: results,\n      value: fnFragment.value\n    };\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\n * @internal\n * @param error\n * @param network\n * @param signerAddress\n * @param contractAddress\n * @param contractInterface\n */\nasync function convertToTWError(error, network, signerAddress, contractAddress, contractInterface) {\n  let raw;\n  if (typeof error === \"object\") {\n    // metamask errors comes as objects, apply parsing on data object\n    raw = JSON.stringify(error);\n  } else {\n    // not sure what this is, just throw it back\n    raw = error.toString();\n  }\n  const reason = parseMessageParts(/.*?\"message[^a-zA-Z0-9]*([^\"\\\\]*).*?/, raw) || parseMessageParts(/.*?\"reason[^a-zA-Z0-9]*([^\"\\\\]*).*?/, raw);\n  const data = parseMessageParts(/.*?\"data[^a-zA-Z0-9]*([^\"\\\\]*).*?/, raw);\n  const rpcUrl = parseMessageParts(/.*?\"url[^a-zA-Z0-9]*([^\"\\\\]*).*?/, raw);\n  let from = parseMessageParts(/.*?\"from[^a-zA-Z0-9]*([^\"\\\\]*).*?/, raw);\n  let to = parseMessageParts(/.*?\"to[^a-zA-Z0-9]*([^\"\\\\]*).*?/, raw);\n  if (to === \"\") {\n    // fallback to contractAddress\n    to = contractAddress;\n  }\n  if (from === \"\") {\n    // fallback to signerAddress\n    from = signerAddress;\n  }\n  const functionInfo = data.length > 0 ? parseFunctionInfo(data, contractInterface) : undefined;\n  return new TransactionError(reason, from, to, data, network, rpcUrl, raw, functionInfo);\n}\nfunction withSpaces(label, content) {\n  if (content === \"\") {\n    return content;\n  }\n  const spaces = Array(10 - label.length).fill(\" \").join(\"\");\n  return `\\n${label}:${spaces}${content}`;\n}\nfunction parseMessageParts(regex, raw) {\n  const msgMatches = raw.match(regex) || [];\n  let extracted = \"\";\n  if (msgMatches?.length > 0) {\n    extracted += msgMatches[1];\n  }\n  return extracted;\n}\n\n/**\n * @internal\n * @param err\n * @param message\n */\nfunction includesErrorMessage(err, message) {\n  if (!err) {\n    return false;\n  }\n  return err && err.toString().includes(message) || err && err.message && err.message.toString().includes(message) || err && err.error && err.error.toString().includes(message);\n}\n\nconst DropErc721ContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);\nconst DropErc721ContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);\nconst DropErc721ContractDeploy = DropErc721ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);\nconst DropErc721ContractSchema = {\n  deploy: DropErc721ContractDeploy,\n  output: DropErc721ContractOutput,\n  input: DropErc721ContractInput\n};\n\nconst DropErc1155ContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);\nconst DropErc1155ContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);\nconst DropErc1155ContractDeploy = DropErc1155ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);\nconst DropErc1155ContractSchema = {\n  deploy: DropErc1155ContractDeploy,\n  output: DropErc1155ContractOutput,\n  input: DropErc1155ContractInput\n};\n\nconst MarketplaceContractInput = CommonContractSchema;\nconst MarketplaceContractOutput = CommonContractOutputSchema;\nconst MarketplaceContractDeploy = MarketplaceContractInput.merge(CommonPlatformFeeSchema).merge(CommonTrustedForwarderSchema);\nconst MarketplaceContractSchema = {\n  deploy: MarketplaceContractDeploy,\n  output: MarketplaceContractOutput,\n  input: MarketplaceContractInput\n};\n\nconst PackContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst PackContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst PackContractDeploy = PackContractInput.merge(CommonPlatformFeeSchema).merge(CommonTrustedForwarderSchema);\nconst PackContractSchema = {\n  deploy: PackContractDeploy,\n  output: PackContractOutput,\n  input: PackContractInput\n};\n\nconst SplitRecipientInputSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  address: AddressSchema,\n  sharesBps: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.a.gt(0, \"Shares must be greater than 0\")\n});\nconst SplitRecipientOuputSchema = SplitRecipientInputSchema.extend({\n  address: AddressSchema,\n  sharesBps: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.a\n});\nconst SplitsContractInput = CommonContractSchema.extend({\n  recipients: zod__WEBPACK_IMPORTED_MODULE_57__.z.array(SplitRecipientInputSchema).default([]).superRefine((val, context) => {\n    const addressMap = {};\n    let totalShares = 0;\n    for (let index = 0; index < val.length; index++) {\n      const entry = val[index];\n      if (addressMap[entry.address]) {\n        context.addIssue({\n          code: zod__WEBPACK_IMPORTED_MODULE_57__.z.ZodIssueCode.custom,\n          message: `Duplicate address.`,\n          path: [index, `address`]\n        });\n      }\n      addressMap[entry.address] = true;\n      totalShares += entry.sharesBps;\n      if (totalShares > 10000) {\n        context.addIssue({\n          code: zod__WEBPACK_IMPORTED_MODULE_57__.z.ZodIssueCode.custom,\n          message: `Total shares cannot go over 100%.`,\n          path: [index, `sharesBps`]\n        });\n      }\n    }\n    if (totalShares !== 10000) {\n      context.addIssue({\n        code: zod__WEBPACK_IMPORTED_MODULE_57__.z.ZodIssueCode.custom,\n        message: `Total shares need to add up to 100%. Total shares are currently ${totalShares / 100}%`,\n        path: []\n      });\n    }\n  })\n});\nconst SplitsContractOutput = CommonContractOutputSchema.extend({\n  recipients: zod__WEBPACK_IMPORTED_MODULE_57__.z.array(SplitRecipientOuputSchema)\n});\nconst SplitsContractDeploy = SplitsContractInput.merge(SplitsContractInput).merge(CommonTrustedForwarderSchema);\nconst SplitsContractSchema = {\n  deploy: SplitsContractDeploy,\n  output: SplitsContractOutput,\n  input: SplitsContractInput\n};\n\nconst TokenErc20ContractInput = CommonContractSchema.merge(CommonSymbolSchema);\nconst TokenErc20ContractOutput = CommonContractOutputSchema.merge(CommonSymbolSchema);\nconst TokenErc20ContractDeploy = TokenErc20ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);\nconst TokenErc20ContractSchema = {\n  deploy: TokenErc20ContractDeploy,\n  output: TokenErc20ContractOutput,\n  input: TokenErc20ContractInput\n};\n\nconst TokenErc721ContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst TokenErc721ContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst TokenErc721ContractDeploy = TokenErc721ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);\nconst TokenErc721ContractSchema = {\n  deploy: TokenErc721ContractDeploy,\n  output: TokenErc721ContractOutput,\n  input: TokenErc721ContractInput\n};\n\nconst TokenErc1155ContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst TokenErc1155ContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst TokenErc1155ContractDeploy = TokenErc1155ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);\nconst TokenErc1155ContractSchema = {\n  deploy: TokenErc1155ContractDeploy,\n  output: TokenErc1155ContractOutput,\n  input: TokenErc1155ContractInput\n};\n\nconst VoteSettingsInputSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  voting_delay_in_blocks: zod__WEBPACK_IMPORTED_MODULE_57__.z.number().min(0).default(0),\n  voting_period_in_blocks: zod__WEBPACK_IMPORTED_MODULE_57__.z.number().min(1).default(1),\n  voting_token_address: AddressSchema,\n  voting_quorum_fraction: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.P[\"default\"](0),\n  proposal_token_threshold: BigNumberishSchema.default(1)\n});\nconst VoteSettingsOuputSchema = VoteSettingsInputSchema.extend({\n  proposal_token_threshold: BigNumberSchema\n});\nconst VoteContractInput = CommonContractSchema.merge(VoteSettingsInputSchema);\nconst VoteContractOutput = CommonContractOutputSchema.merge(VoteSettingsOuputSchema);\nconst VoteContractDeploy = VoteContractInput.merge(CommonTrustedForwarderSchema);\nconst VoteContractSchema = {\n  deploy: VoteContractDeploy,\n  output: VoteContractOutput,\n  input: VoteContractInput\n};\nzod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  proposalId: BigNumberSchema,\n  proposer: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n  targets: zod__WEBPACK_IMPORTED_MODULE_57__.z.array(zod__WEBPACK_IMPORTED_MODULE_57__.z.string()),\n  values: zod__WEBPACK_IMPORTED_MODULE_57__.z.array(BigNumberSchema),\n  signatures: zod__WEBPACK_IMPORTED_MODULE_57__.z.array(zod__WEBPACK_IMPORTED_MODULE_57__.z.string()),\n  calldatas: zod__WEBPACK_IMPORTED_MODULE_57__.z.array(zod__WEBPACK_IMPORTED_MODULE_57__.z.string()),\n  startBlock: BigNumberSchema,\n  endBlock: BigNumberSchema,\n  description: zod__WEBPACK_IMPORTED_MODULE_57__.z.string()\n});\n\n/**\n * @public\n */\nconst SDKOptionsSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  readonlySettings: zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n    rpcUrl: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().url(),\n    chainId: zod__WEBPACK_IMPORTED_MODULE_57__.z.number().optional()\n  }).optional(),\n  gasSettings: zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n    maxPriceInGwei: zod__WEBPACK_IMPORTED_MODULE_57__.z.number().min(1, \"gas price cannot be less than 1\").default(300),\n    speed: zod__WEBPACK_IMPORTED_MODULE_57__.z[\"enum\"]([\"standard\", \"fast\", \"fastest\"]).default(\"fastest\")\n  }).default({\n    maxPriceInGwei: 300,\n    speed: \"fastest\"\n  }),\n  gasless: zod__WEBPACK_IMPORTED_MODULE_57__.z.union([zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n    openzeppelin: zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n      relayerUrl: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().url(),\n      relayerForwarderAddress: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n      useEOAForwarder: zod__WEBPACK_IMPORTED_MODULE_57__.z.boolean().default(false)\n    }),\n    experimentalChainlessSupport: zod__WEBPACK_IMPORTED_MODULE_57__.z.boolean().default(false)\n  }), zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n    biconomy: zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n      apiId: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n      apiKey: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n      deadlineSeconds: zod__WEBPACK_IMPORTED_MODULE_57__.z.number().min(1, \"deadlineSeconds cannot be les than 1\").default(3600)\n    })\n  })]).optional()\n}).default({\n  gasSettings: {\n    maxPriceInGwei: 300,\n    speed: \"fastest\"\n  }\n});\n\n/**\n * @public\n * All these configuration options are optional with sane defaults:\n * @example\n * ```javascript\n * {\n *   readonlySettings: {\n *     rpcUrl, // force read calls to go through your own RPC url\n *     chainId, // reduce RPC calls by sepcifying your chain ID\n *   },\n *   gasSettings: {\n *     maxPriceInGwei, // Maximum gas price for transactions (default 300 gwei)\n *     speed, // the tx speed setting: 'standard'|'fast|'fastest' (default: 'fastest')\n *   },\n *   gasless: {\n *     // By specifying a gasless configuration - all transactions will get forwarded to enable gasless transactions\n *     openzeppelin: {\n *       relayerUrl, // your OZ Defender relayer URL\n *       relayerForwarderAddress, // the OZ defender relayer address (defaults to the standard one)\n *     },\n *     biconomy: {\n *       apiId, // your Biconomy API Id\n *       apiKey, // your Biconomy API Key\n *       deadlineSeconds, // your Biconomy timeout preference\n *     },\n *   },\n * }\n * ```\n */\n\n/**\n * @internal\n */\nconst LoginOptionsSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  /**\n   * The optional nonce of the login request used to prevent replay attacks\n   */\n  nonce: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  /**\n   * The optional time after which the login payload will be invalid\n   */\n  expirationTime: zod__WEBPACK_IMPORTED_MODULE_57__.z.date().optional(),\n  /**\n   * The optional chain ID that the login request was intended for\n   */\n  chainId: zod__WEBPACK_IMPORTED_MODULE_57__.z.number().optional()\n}).optional();\n\n/**\n * @internal\n */\nconst LoginPayloadDataSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  /**\n   * The domain that the user is attempting to login to\n   */\n  domain: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n  /**\n   * The address of the account that is logging in\n   */\n  address: AddressSchema,\n  /**\n   * The nonce of the login request used to prevent replay attacks, defaults to a random UUID\n   */\n  nonce: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().default((0,uuid__WEBPACK_IMPORTED_MODULE_60__.v4)()),\n  /**\n   * The time after which the login payload will be invalid, defaults to 5 minutes from now\n   */\n  expiration_time: zod__WEBPACK_IMPORTED_MODULE_57__.z.date().transform(d => d.toISOString()),\n  /**\n   * The chain ID that the login request was intended for, defaults to none\n   */\n  chain_id: zod__WEBPACK_IMPORTED_MODULE_57__.z.number().optional()\n});\n\n/**\n * @internal\n */\nconst LoginPayloadSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  /**\n   * The payload data used for login\n   */\n  payload: LoginPayloadDataSchema,\n  /**\n   * The signature of the login request used for verification\n   */\n  signature: zod__WEBPACK_IMPORTED_MODULE_57__.z.string()\n});\n\n/**\n * @internal\n */\nconst VerifyOptionsSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  /**\n   * The optional chain ID to expect the request to be for\n   */\n  chainId: zod__WEBPACK_IMPORTED_MODULE_57__.z.number().optional()\n}).optional();\n\n/**\n * @internal\n */\nconst AuthenticationOptionsSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  /**\n   * The date before which the authentication payload is invalid\n   */\n  invalidBefore: zod__WEBPACK_IMPORTED_MODULE_57__.z.date().optional(),\n  /**\n   * The date after which the authentication payload is invalid\n   */\n  expirationTime: zod__WEBPACK_IMPORTED_MODULE_57__.z.date().optional()\n}).optional();\n\n/**\n * @internal\n */\nconst AuthenticationPayloadDataSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  /**\n   * The address of the wallet issuing the payload\n   */\n  iss: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n  /**\n   * The address of the wallet requesting to authenticate\n   */\n  sub: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n  /**\n   * The domain intended to receive the authentication payload\n   */\n  aud: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n  /**\n   * The date before which the authentication payload is invalid\n   */\n  exp: RawDateSchema.transform(b => b.toNumber()),\n  /**\n   * The date after which the authentication payload is invalid\n   */\n  nbf: RawDateSchema.transform(b => b.toNumber()),\n  /**\n   * The date on which the payload was issued\n   */\n  iat: RawDateSchema.transform(b => b.toNumber()),\n  /**\n   * The unique identifier of the payload\n   */\n  jti: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().default((0,uuid__WEBPACK_IMPORTED_MODULE_60__.v4)())\n});\n\n/**\n * @internal\n */\nconst AuthenticationPayloadSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  /**\n   * The payload data used for authentication\n   */\n  payload: AuthenticationPayloadDataSchema,\n  /**\n   * The signature of the authentication payload used for authentication\n   */\n  signature: zod__WEBPACK_IMPORTED_MODULE_57__.z.string()\n});\n\n/**\n * @public\n */\n\n/**\n * @internal\n */\nconst ForwardRequest = [{\n  name: \"from\",\n  type: \"address\"\n}, {\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"value\",\n  type: \"uint256\"\n}, {\n  name: \"gas\",\n  type: \"uint256\"\n}, {\n  name: \"nonce\",\n  type: \"uint256\"\n}, {\n  name: \"data\",\n  type: \"bytes\"\n}];\nconst ChainAwareForwardRequest = [{\n  name: \"from\",\n  type: \"address\"\n}, {\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"value\",\n  type: \"uint256\"\n}, {\n  name: \"gas\",\n  type: \"uint256\"\n}, {\n  name: \"nonce\",\n  type: \"uint256\"\n}, {\n  name: \"data\",\n  type: \"bytes\"\n}, {\n  name: \"chainid\",\n  type: \"uint256\"\n}];\n\n/**\n * @internal\n */\nconst BiconomyForwarderAbi = [{\n  inputs: [{\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"batchId\",\n    type: \"uint256\"\n  }],\n  name: \"getNonce\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nconst _nonces = {};\nconst _noncesSyncTimestamp = {};\n\n/**\n * @internal\n */\nasync function getAndIncrementNonce(forwarder, forwarderFunction, forwarderArgs) {\n  // address is only used for internal caching :)\n  const address = forwarderArgs.join(\"|\");\n  const timestamp = _noncesSyncTimestamp[address];\n  // if it's within 2 seconds we're optimistically increment the nonce\n  // should we always sync?\n  const shouldSync = Date.now() - timestamp >= 2000;\n  if (!(address in _nonces) || shouldSync) {\n    const nonceResult = await forwarder.functions[forwarderFunction](...forwarderArgs);\n    if (Array.isArray(nonceResult) && nonceResult.length > 0) {\n      _nonces[address] = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(nonceResult[0]);\n    } else {\n      _nonces[address] = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(nonceResult);\n    }\n    _noncesSyncTimestamp[address] = Date.now();\n  }\n  const nonce = _nonces[address];\n  _nonces[address] = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(_nonces[address]).add(1);\n  return nonce;\n}\n\n/**\n * @internal\n */\nfunction getGasStationUrl(chainId) {\n  switch (chainId) {\n    case ChainId.Polygon:\n      return \"https://gasstation-mainnet.matic.network/v2\";\n    case ChainId.Mumbai:\n      return \"https://gasstation-mumbai.matic.today/v2\";\n  }\n}\nconst MIN_POLYGON_GAS_PRICE = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.parseUnits(\"31\", \"gwei\");\nconst MIN_MUMBAI_GAS_PRICE = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.parseUnits(\"1\", \"gwei\");\n\n/**\n * @internal\n */\nfunction getDefaultGasFee(chainId) {\n  switch (chainId) {\n    case ChainId.Polygon:\n      return MIN_POLYGON_GAS_PRICE;\n    case ChainId.Mumbai:\n      return MIN_MUMBAI_GAS_PRICE;\n  }\n}\n\n/**\n *\n * @returns the gas price\n * @internal\n */\nasync function getPolygonGasPriorityFee(chainId) {\n  const gasStationUrl = getGasStationUrl(chainId);\n  try {\n    const data = await (await cross_fetch__WEBPACK_IMPORTED_MODULE_6___default()(gasStationUrl)).json();\n    // take the standard speed here, SDK options will define the extra tip\n    const priorityFee = data[\"standard\"][\"maxPriorityFee\"];\n    if (priorityFee > 0) {\n      const fixedFee = parseFloat(priorityFee).toFixed(9);\n      return ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.parseUnits(fixedFee, \"gwei\");\n    }\n  } catch (e) {\n    console.error(\"failed to fetch gas\", e);\n  }\n  return getDefaultGasFee(chainId);\n}\n\n// couldn't find this in barbones ethers export, but \"type\" should mean it does not increase bundle size either way\n\n/**\n * @internal\n */\n\n/**\n * eip712 sign typed data with different wallet handling including ledger live\n * @internal\n */\nasync function signTypedDataInternal(signer, domain, types, message) {\n  const provider = signer?.provider;\n  if (!provider) {\n    throw new Error(\"missing provider\");\n  }\n  const payload = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils._TypedDataEncoder.getPayload(domain, types, message);\n  let signature = \"\";\n\n  // an indirect way for accessing walletconnect's underlying provider\n  if (provider?.provider?.isWalletConnect) {\n    signature = await provider.send(\"eth_signTypedData\", [(await signer.getAddress()).toLowerCase(), JSON.stringify(payload)]);\n  } else {\n    try {\n      signature = await signer._signTypedData(domain, types, message);\n    } catch (err) {\n      if (err?.message?.includes(\"Method eth_signTypedData_v4 not supported\")) {\n        signature = await provider.send(\"eth_signTypedData\", [(await signer.getAddress()).toLowerCase(), JSON.stringify(payload)]);\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  // fix ledger live where signature result in v = 0, 1. ethers magically fix it in split/join.\n  return {\n    payload,\n    signature: ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.joinSignature(ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.splitSignature(signature))\n  };\n}\n\nconst NAME_ABI = [{\n  inputs: [],\n  name: \"name\",\n  outputs: [{\n    internalType: \"string\",\n    name: \"\",\n    type: \"string\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nconst DOMAIN_SEPARATOR_ABI = [{\n  constant: true,\n  inputs: [],\n  name: \"DOMAIN_SEPARATOR\",\n  outputs: [{\n    internalType: \"bytes32\",\n    name: \"\",\n    type: \"bytes32\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"getDomainSeperator\",\n  outputs: [{\n    internalType: \"bytes32\",\n    name: \"\",\n    type: \"bytes32\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nconst NONCES_ABI = [{\n  inputs: [{\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"nonces\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"user\",\n    type: \"address\"\n  }],\n  name: \"getNonce\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"nonce\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nasync function getSignerNonce(signer, contractAddress) {\n  const contract = new ethers__WEBPACK_IMPORTED_MODULE_58__.Contract(contractAddress, NONCES_ABI, signer);\n  try {\n    return await contract.nonces(await signer.getAddress());\n  } catch (err) {\n    return await contract.getNonce(await signer.getAddress());\n  }\n}\nasync function getDomainSeperator(signer, contractAddress) {\n  const contract = new ethers__WEBPACK_IMPORTED_MODULE_58__.Contract(contractAddress, DOMAIN_SEPARATOR_ABI, signer);\n  try {\n    return await contract.DOMAIN_SEPARATOR();\n  } catch (err) {\n    return await contract.getDomainSeperator();\n  }\n}\nasync function getTokenName(signer, contractAddress) {\n  return new ethers__WEBPACK_IMPORTED_MODULE_58__.Contract(contractAddress, NAME_ABI, signer).name();\n}\n\n/**\n * Polygon chain has different EIP712 domain separator for USDC, DAI compared to other chains and slightly different than EIP-2612.\n */\nasync function getChainDomainSeperator(signer, domain) {\n  const contractDomainSeparator = await getDomainSeperator(signer, domain.verifyingContract);\n  const polygonDomain = {\n    name: domain.name,\n    version: domain.version,\n    verifyingContract: domain.verifyingContract,\n    salt: ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.hexZeroPad(ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(domain.chainId).toHexString(), 32)\n  };\n  if (ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils._TypedDataEncoder.hashDomain(polygonDomain) === contractDomainSeparator) {\n    return polygonDomain;\n  }\n  return domain;\n}\n\n/**\n * @internal\n */\nasync function signEIP2612Permit(signer, currencyAddress, owner, spender, value, deadline, nonce) {\n  const domain = await getChainDomainSeperator(signer, {\n    name: await getTokenName(signer, currencyAddress),\n    version: \"1\",\n    chainId: await signer.getChainId(),\n    verifyingContract: currencyAddress\n  });\n  nonce = nonce || (await getSignerNonce(signer, currencyAddress)).toString();\n  deadline = deadline || ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.MaxUint256;\n  const message = {\n    owner,\n    spender,\n    value,\n    nonce,\n    deadline\n  };\n  const types = {\n    Permit: [{\n      name: \"owner\",\n      type: \"address\"\n    }, {\n      name: \"spender\",\n      type: \"address\"\n    }, {\n      name: \"value\",\n      type: \"uint256\"\n    }, {\n      name: \"nonce\",\n      type: \"uint256\"\n    }, {\n      name: \"deadline\",\n      type: \"uint256\"\n    }]\n  };\n  const {\n    signature\n  } = await signTypedDataInternal(signer, domain, types, message);\n  return {\n    message,\n    signature\n  };\n}\n\n/**\n * @internal\n */\n// @ts-expext-error window is not defined\nconst isBrowser = () => typeof window !== \"undefined\";\n\n/**\n * @internal\n */\nconst isNode = () => !isBrowser();\n\n/**\n * @internal\n */\nclass RPCConnectionHandler extends eventemitter3__WEBPACK_IMPORTED_MODULE_5__[\"default\"] {\n  constructor(network, options) {\n    super();\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"provider\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"signer\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"options\", void 0);\n    const [signer, provider] = getSignerAndProvider(network, options);\n    this.signer = signer;\n    this.provider = provider;\n    try {\n      this.options = SDKOptionsSchema.parse(options);\n    } catch (optionParseError) {\n      console.error(\"invalid sdk options object passed, falling back to default options\", optionParseError);\n      this.options = SDKOptionsSchema.parse({});\n    }\n  }\n  /**\n   * The function to call whenever the network changes, such as when the users connects their wallet, disconnects their wallet, the connected chain changes, etc.\n   *\n   * @param network - a network, signer or provider that ethers js can interpret\n   */\n  updateSignerOrProvider(network) {\n    const [signer, provider] = getSignerAndProvider(network, this.options);\n    this.signer = signer;\n    this.provider = provider;\n  }\n  /**\n   *\n   * @returns whether or not a signer is set, `true` if there is no signer so the class is in \"read only\" mode\n   */\n  isReadOnly() {\n    return !ethers__WEBPACK_IMPORTED_MODULE_58__.Signer.isSigner(this.signer);\n  }\n\n  /**\n   * Explicitly get the active signer.\n   * @returns the active signer, if there is one\n   */\n  getSigner() {\n    return this.signer;\n  }\n\n  /**\n   * Explicitly get the active provider.\n   * @returns the active provider\n   */\n  getProvider() {\n    return this.provider;\n  }\n\n  /**\n   *\n   * @returns the current signer if there is one, otherwise the active provider\n   */\n  getSignerOrProvider() {\n    return this.getSigner() || this.getProvider();\n  }\n}\n\n/**\n * @internal\n */\nfunction getSignerAndProvider(network, options) {\n  let signer;\n  let provider;\n  if (ethers__WEBPACK_IMPORTED_MODULE_58__.Signer.isSigner(network)) {\n    signer = network;\n    if (network.provider) {\n      provider = network.provider;\n    }\n  }\n  if (options?.readonlySettings) {\n    provider = getReadOnlyProvider(options.readonlySettings.rpcUrl, options.readonlySettings.chainId);\n  }\n  if (!provider) {\n    if (ethers__WEBPACK_IMPORTED_MODULE_58__.providers.Provider.isProvider(network)) {\n      provider = network;\n    } else if (!ethers__WEBPACK_IMPORTED_MODULE_58__.Signer.isSigner(network)) {\n      if (typeof network === \"string\") {\n        provider = getReadOnlyProvider(network, options?.readonlySettings?.chainId);\n      } else {\n        // no a signer, not a provider, not a string? try with default provider\n        provider = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.getDefaultProvider(network);\n      }\n    }\n  }\n  if (!provider) {\n    // we should really never hit this case!\n    provider = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.getDefaultProvider();\n    console.error(\"No provider found, using default provider on default chain!\");\n  }\n  return [signer, provider];\n}\n\n/**\n * @internal\n */\nclass ContractWrapper extends RPCConnectionHandler {\n  /**\n   * @internal\n   */\n\n  constructor(network, contractAddress, contractAbi, options) {\n    super(network, options);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"isValidContract\", false);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"customOverrides\", () => ({}));\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"writeContract\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"readContract\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"abi\", void 0);\n    this.abi = contractAbi;\n    // set up the contract\n    this.writeContract = new ethers__WEBPACK_IMPORTED_MODULE_58__.Contract(contractAddress, contractAbi, this.getSignerOrProvider());\n    // setup the read only contract\n    this.readContract = this.writeContract.connect(this.getProvider());\n  }\n  updateSignerOrProvider(network) {\n    // update the underlying base class\n    super.updateSignerOrProvider(network);\n    // re-connect the contract with the new signer / provider\n    this.writeContract = this.writeContract.connect(this.getSignerOrProvider());\n    // setup the read only contract\n    this.readContract = this.writeContract.connect(this.getProvider());\n  }\n\n  /**\n   * @internal\n   */\n  async getChainID() {\n    const provider = this.getProvider();\n    const {\n      chainId\n    } = await provider.getNetwork();\n    return chainId;\n  }\n  /**\n   * @internal\n   */\n  async getSignerAddress() {\n    const signer = this.getSigner();\n    if (!signer) {\n      throw new Error(\"This action requires a connected wallet to sign the transaction. Please pass a valid signer to the SDK.\");\n    }\n    return await signer.getAddress();\n  }\n\n  /**\n   * @internal\n   */\n  callStatic() {\n    return this.writeContract.callStatic;\n  }\n\n  /**\n   * @internal\n   */\n  async getCallOverrides() {\n    if (isBrowser()) {\n      // When running in the browser, let the wallet suggest gas estimates\n      // this means that the gas speed preferences set in the SDK options are ignored in a browser context\n      // but it also allows users to select their own gas speed prefs per tx from their wallet directly\n      return {};\n    }\n    const feeData = await this.getProvider().getFeeData();\n    const supports1559 = feeData.maxFeePerGas && feeData.maxPriorityFeePerGas;\n    if (supports1559) {\n      const chainId = await this.getChainID();\n      const block = await this.getProvider().getBlock(\"latest\");\n      const baseBlockFee = block && block.baseFeePerGas ? block.baseFeePerGas : ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.parseUnits(\"1\", \"gwei\");\n      let defaultPriorityFee;\n      if (chainId === ChainId.Mumbai || chainId === ChainId.Polygon) {\n        // for polygon, get fee data from gas station\n        defaultPriorityFee = await getPolygonGasPriorityFee(chainId);\n      } else {\n        // otherwise get it from ethers\n        defaultPriorityFee = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(feeData.maxPriorityFeePerGas);\n      }\n      // then add additional fee based on user preferences\n      const maxPriorityFeePerGas = this.getPreferredPriorityFee(defaultPriorityFee);\n      // See: https://eips.ethereum.org/EIPS/eip-1559 for formula\n      const baseMaxFeePerGas = baseBlockFee.mul(2);\n      const maxFeePerGas = baseMaxFeePerGas.add(maxPriorityFeePerGas);\n      return {\n        maxFeePerGas,\n        maxPriorityFeePerGas\n      };\n    } else {\n      return {\n        gasPrice: await this.getPreferredGasPrice()\n      };\n    }\n  }\n\n  /**\n   * Calculates the priority fee per gas according to user preferences\n   * @param defaultPriorityFeePerGas - the base priority fee\n   */\n  getPreferredPriorityFee(defaultPriorityFeePerGas) {\n    const speed = this.options.gasSettings.speed;\n    const maxGasPrice = this.options.gasSettings.maxPriceInGwei;\n    let extraTip;\n    switch (speed) {\n      case \"standard\":\n        extraTip = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(0); // default is 2.5 gwei for ETH, 31 gwei for polygon\n        break;\n      case \"fast\":\n        extraTip = defaultPriorityFeePerGas.div(100).mul(5); // + 5% - 2.625 gwei / 32.5 gwei\n        break;\n      case \"fastest\":\n        extraTip = defaultPriorityFeePerGas.div(100).mul(10); // + 10% - 2.75 gwei / 34.1 gwei\n        break;\n    }\n    let txGasPrice = defaultPriorityFeePerGas.add(extraTip);\n    const max = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.parseUnits(maxGasPrice.toString(), \"gwei\"); // no more than max gas setting\n    const min = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.parseUnits(\"2.5\", \"gwei\"); // no less than 2.5 gwei\n    if (txGasPrice.gt(max)) {\n      txGasPrice = max;\n    }\n    if (txGasPrice.lt(min)) {\n      txGasPrice = min;\n    }\n    return txGasPrice;\n  }\n\n  /**\n   * Calculates the gas price for transactions according to user preferences\n   */\n  async getPreferredGasPrice() {\n    const gasPrice = await this.getProvider().getGasPrice();\n    const speed = this.options.gasSettings.speed;\n    const maxGasPrice = this.options.gasSettings.maxPriceInGwei;\n    let txGasPrice = gasPrice;\n    let extraTip;\n    switch (speed) {\n      case \"standard\":\n        extraTip = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(1); // min 1 wei\n        break;\n      case \"fast\":\n        extraTip = gasPrice.div(100).mul(5); // + 5%\n        break;\n      case \"fastest\":\n        extraTip = gasPrice.div(100).mul(10); // + 10%\n        break;\n    }\n    txGasPrice = txGasPrice.add(extraTip);\n    const max = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.parseUnits(maxGasPrice.toString(), \"gwei\");\n    if (txGasPrice.gt(max)) {\n      txGasPrice = max;\n    }\n    return txGasPrice;\n  }\n\n  /**\n   * @internal\n   */\n  emitTransactionEvent(status, transactionHash) {\n    this.emit(EventType.Transaction, {\n      status,\n      transactionHash\n    });\n  }\n\n  /**\n   * @internal\n   */\n  async multiCall(encoded) {\n    return this.sendTransaction(\"multicall\", [encoded]);\n  }\n\n  /**\n   * @internal\n   */\n  async estimateGas(fn, args) {\n    return this.writeContract.estimateGas[fn](...args);\n  }\n\n  /**\n   * @internal\n   */\n  withTransactionOverride(hook) {\n    this.customOverrides = hook;\n  }\n\n  /**\n   * @internal\n   */\n  async call(functionName) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    // parse last arg as tx options if present\n    let txOptions;\n    try {\n      if (args.length > 0 && typeof args[args.length - 1] === \"object\") {\n        const last = args[args.length - 1];\n        txOptions = CallOverrideSchema.parse(last);\n        // if call overrides found, remove it from args array\n        args = args.slice(0, args.length - 1);\n      }\n    } catch (e) {\n      // no-op\n    }\n    const functions = extractFunctionsFromAbi(AbiSchema.parse(this.abi)).filter(f => f.name === functionName);\n    if (!functions.length) {\n      throw new Error(`Function \"${functionName}\" not found in contract. Check your dashboard for the list of functions available`);\n    }\n    const fn = functions.find(f => f.name === functionName && f.inputs.length === args.length);\n\n    // TODO extract this and re-use for deploy function to check constructor args\n    if (!fn) {\n      throw new Error(`Function \"${functionName}\" requires ${functions[0].inputs.length} arguments, but ${args.length} were provided.\\nExpected function signature: ${functions[0].signature}`);\n    }\n    const ethersFnName = `${functionName}(${fn.inputs.map(i => i.type).join()})`;\n\n    // check if the function exists on the contract, otherwise use the name passed in\n    const fnName = ethersFnName in this.readContract.functions ? ethersFnName : functionName;\n\n    // TODO validate each argument\n    if (fn.stateMutability === \"view\" || fn.stateMutability === \"pure\") {\n      // read function\n      return this.readContract[fnName](...args);\n    } else {\n      // write function\n      const receipt = await this.sendTransaction(fnName, args, txOptions);\n      return {\n        receipt\n      };\n    }\n  }\n\n  /**\n   * @internal\n   */\n  async sendTransaction(fn, args, callOverrides) {\n    if (!callOverrides) {\n      callOverrides = await this.getCallOverrides();\n    }\n    // if a custom override is set, merge our override with the custom one\n    callOverrides = {\n      ...callOverrides,\n      ...this.customOverrides()\n    };\n    // clear up the override (single use)\n    this.customOverrides = () => ({});\n    if (this.options?.gasless && (\"openzeppelin\" in this.options.gasless || \"biconomy\" in this.options.gasless)) {\n      if (fn === \"multicall\" && Array.isArray(args[0]) && args[0].length > 0) {\n        const from = await this.getSignerAddress();\n        args[0] = args[0].map(tx => ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.solidityPack([\"bytes\", \"address\"], [tx, from]));\n      }\n      const provider = this.getProvider();\n      const txHash = await this.sendGaslessTransaction(fn, args, callOverrides);\n      this.emitTransactionEvent(\"submitted\", txHash);\n      const receipt = await provider.waitForTransaction(txHash);\n      this.emitTransactionEvent(\"completed\", txHash);\n      return receipt;\n    } else {\n      // one time verification that this is a valid contract (to avoid sending funds to wrong addresses)\n      if (!this.isValidContract) {\n        const code = await this.getProvider().getCode(this.readContract.address);\n        this.isValidContract = code !== \"0x\";\n        if (!this.isValidContract) {\n          throw new Error(\"The address you're trying to send a transaction to is not a smart contract. Make sure you are on the correct network and the contract address is correct\");\n        }\n      }\n      const tx = await this.sendTransactionByFunction(fn, args, callOverrides);\n      this.emitTransactionEvent(\"submitted\", tx.hash);\n      const receipt = tx.wait();\n      this.emitTransactionEvent(\"completed\", tx.hash);\n      return receipt;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  async sendTransactionByFunction(fn, args, callOverrides) {\n    const func = this.writeContract.functions[fn];\n    if (!func) {\n      throw new Error(`invalid function: \"${fn.toString()}\"`);\n    }\n    try {\n      return await func(...args, callOverrides);\n    } catch (e) {\n      const network = await this.getProvider().getNetwork();\n      const signerAddress = await this.getSignerAddress();\n      const contractAddress = await this.readContract.address;\n      throw await convertToTWError(e, network, signerAddress, contractAddress, this.readContract.interface);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  async sendGaslessTransaction(fn) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let callOverrides = arguments.length > 2 ? arguments[2] : undefined;\n    const signer = this.getSigner();\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(signer, \"Cannot execute gasless transaction without valid signer\");\n    const chainId = await this.getChainID();\n    const from = await this.getSignerAddress();\n    const to = this.writeContract.address;\n    const value = callOverrides?.value || 0;\n    if (ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(value).gt(0)) {\n      throw new Error(\"Cannot send native token value with gasless transaction\");\n    }\n    const data = this.writeContract.interface.encodeFunctionData(fn, args);\n    let gas = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(0);\n    try {\n      const gasEstimate = await this.readContract.estimateGas[fn](...args);\n      gas = gasEstimate.mul(2);\n    } catch (e) {\n      // ignore\n    }\n\n    // in some cases WalletConnect doesn't properly gives an estimate for how much gas it would actually use.\n    // as a fix, we're setting it to a high arbitrary number (500k) as the gas limit that should cover for most function calls.\n    if (gas.lt(100000)) {\n      gas = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(500000);\n    }\n\n    // check for gas override in callOverrides\n    if (callOverrides.gasLimit && ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(callOverrides.gasLimit).gt(gas)) {\n      gas = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(callOverrides.gasLimit);\n    }\n    const tx = {\n      from,\n      to,\n      data,\n      chainId,\n      gasLimit: gas,\n      functionName: fn.toString(),\n      functionArgs: args,\n      callOverrides\n    };\n    return await this.defaultGaslessSendFunction(tx);\n  }\n  async signTypedData(signer, domain, types, message) {\n    this.emit(EventType.Signature, {\n      status: \"submitted\",\n      message,\n      signature: \"\"\n    });\n    const {\n      signature: sig\n    } = await signTypedDataInternal(signer, domain, types, message);\n    this.emit(EventType.Signature, {\n      status: \"completed\",\n      message,\n      signature: sig\n    });\n    return sig;\n  }\n  parseLogs(eventName, logs) {\n    if (!logs || logs.length === 0) {\n      return [];\n    }\n    const topic = this.writeContract.interface.getEventTopic(eventName);\n    const parsedLogs = logs.filter(x => x.topics.indexOf(topic) >= 0);\n    return parsedLogs.map(l => this.writeContract.interface.parseLog(l));\n  }\n  async defaultGaslessSendFunction(transaction) {\n    if (this.options.gasless && \"biconomy\" in this.options.gasless) {\n      return this.biconomySendFunction(transaction);\n    }\n    return this.defenderSendFunction(transaction);\n  }\n  async biconomySendFunction(transaction) {\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.options.gasless && \"biconomy\" in this.options.gasless, \"calling biconomySendFunction without biconomy\");\n    const signer = this.getSigner();\n    const provider = this.getProvider();\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(signer && provider, \"signer and provider must be set\");\n    const forwarder = new ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.Contract(getContractAddressByChainId(transaction.chainId, \"biconomyForwarder\"), BiconomyForwarderAbi, provider);\n    const batchId = 0;\n    const batchNonce = await getAndIncrementNonce(forwarder, \"getNonce\", [transaction.from, batchId]);\n    const request = {\n      from: transaction.from,\n      to: transaction.to,\n      token: ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.AddressZero,\n      txGas: transaction.gasLimit.toNumber(),\n      tokenGasPrice: \"0\",\n      batchId,\n      batchNonce: batchNonce.toNumber(),\n      deadline: Math.floor(Date.now() / 1000 + (this.options?.gasless && \"biconomy\" in this.options.gasless && this.options.gasless.biconomy?.deadlineSeconds || 3600)),\n      data: transaction.data\n    };\n    const hashToSign = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.arrayify(ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.solidityKeccak256([\"address\", \"address\", \"address\", \"uint256\", \"uint256\", \"uint256\", \"uint256\", \"uint256\", \"bytes32\"], [request.from, request.to, request.token, request.txGas, request.tokenGasPrice, request.batchId, request.batchNonce, request.deadline, ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.keccak256(request.data)]));\n    this.emit(EventType.Signature, {\n      status: \"submitted\",\n      message: hashToSign,\n      signature: \"\"\n    });\n    const signature = await signer.signMessage(hashToSign);\n    this.emit(EventType.Signature, {\n      status: \"completed\",\n      message: hashToSign,\n      signature\n    });\n    const response = await cross_fetch__WEBPACK_IMPORTED_MODULE_6___default()(\"https://api.biconomy.io/api/v2/meta-tx/native\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        from: transaction.from,\n        apiId: this.options.gasless.biconomy.apiId,\n        params: [request, signature],\n        to: transaction.to,\n        gasLimit: transaction.gasLimit.toHexString()\n      }),\n      headers: {\n        \"x-api-key\": this.options.gasless.biconomy.apiKey,\n        \"Content-Type\": \"application/json;charset=utf-8\"\n      }\n    });\n    if (response.ok) {\n      const resp = await response.json();\n      if (!resp.txHash) {\n        throw new Error(`relay transaction failed: ${resp.log}`);\n      }\n      return resp.txHash;\n    }\n    throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);\n  }\n  async defenderSendFunction(transaction) {\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.options.gasless && \"openzeppelin\" in this.options.gasless, \"calling openzeppelin gasless transaction without openzeppelin config in the SDK options\");\n    const signer = this.getSigner();\n    const provider = this.getProvider();\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(signer, \"provider is not set\");\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(provider, \"provider is not set\");\n    const forwarderAddress = this.options.gasless.openzeppelin.relayerForwarderAddress || (this.options.gasless.openzeppelin.useEOAForwarder ? CONTRACT_ADDRESSES[transaction.chainId].openzeppelinForwarderEOA : CONTRACT_ADDRESSES[transaction.chainId].openzeppelinForwarder);\n    const forwarder = new ethers__WEBPACK_IMPORTED_MODULE_58__.Contract(forwarderAddress, _thirdweb_dev_contracts_js_dist_abis_Forwarder_json__WEBPACK_IMPORTED_MODULE_7__, provider);\n    const nonce = await getAndIncrementNonce(forwarder, \"getNonce\", [transaction.from]);\n    let domain;\n    let types;\n    let message;\n    if (this.options.gasless.experimentalChainlessSupport) {\n      domain = {\n        name: \"GSNv2 Forwarder\",\n        version: \"0.0.1\",\n        verifyingContract: forwarderAddress\n      };\n      types = {\n        ForwardRequest: ChainAwareForwardRequest\n      };\n      message = {\n        from: transaction.from,\n        to: transaction.to,\n        value: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(0).toString(),\n        gas: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(transaction.gasLimit).toString(),\n        nonce: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(nonce).toString(),\n        data: transaction.data,\n        chainid: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(transaction.chainId).toString()\n      };\n    } else {\n      domain = {\n        name: \"GSNv2 Forwarder\",\n        version: \"0.0.1\",\n        chainId: transaction.chainId,\n        verifyingContract: forwarderAddress\n      };\n      types = {\n        ForwardRequest\n      };\n      message = {\n        from: transaction.from,\n        to: transaction.to,\n        value: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(0).toString(),\n        gas: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(transaction.gasLimit).toString(),\n        nonce: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(nonce).toString(),\n        data: transaction.data\n      };\n    }\n    let signature;\n    this.emit(EventType.Signature, {\n      status: \"submitted\",\n      message,\n      signature: \"\"\n    });\n\n    // if the executing function is \"approve\" and matches with erc20 approve signature\n    // and if the token supports permit, then we use permit for gasless instead of approve.\n    if (transaction.functionName === \"approve\" && transaction.functionArgs.length === 2) {\n      const spender = transaction.functionArgs[0];\n      const amount = transaction.functionArgs[1];\n      // TODO: support DAI permit by signDAIPermit\n      const {\n        message: permit,\n        signature: sig\n      } = await signEIP2612Permit(signer, this.writeContract.address, transaction.from, spender, amount);\n      const {\n        r,\n        s,\n        v\n      } = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.splitSignature(sig);\n      message = {\n        to: this.readContract.address,\n        owner: permit.owner,\n        spender: permit.spender,\n        value: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(permit.value).toString(),\n        nonce: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(permit.nonce).toString(),\n        deadline: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(permit.deadline).toString(),\n        r,\n        s,\n        v\n      };\n      signature = sig;\n    } else {\n      const {\n        signature: sig\n      } = await signTypedDataInternal(signer, domain, types, message);\n      signature = sig;\n    }\n    let messageType = \"forward\";\n\n    // if has owner property then it's permit :)\n    if (message?.owner) {\n      messageType = \"permit\";\n    }\n    const body = JSON.stringify({\n      request: message,\n      signature,\n      forwarderAddress,\n      type: messageType\n    });\n    this.emit(EventType.Signature, {\n      status: \"completed\",\n      message,\n      signature\n    });\n    const response = await cross_fetch__WEBPACK_IMPORTED_MODULE_6___default()(this.options.gasless.openzeppelin.relayerUrl, {\n      method: \"POST\",\n      body\n    });\n    if (response.ok) {\n      const resp = await response.json();\n      if (!resp.result) {\n        throw new Error(`Relay transaction failed: ${resp.message}`);\n      }\n      const result = JSON.parse(resp.result);\n      return result.txHash;\n    }\n    throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);\n  }\n}\n\nfunction isNativeToken(tokenAddress) {\n  return tokenAddress.toLowerCase() === NATIVE_TOKEN_ADDRESS || tokenAddress.toLowerCase() === ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero;\n}\nfunction cleanCurrencyAddress(currencyAddress) {\n  if (isNativeToken(currencyAddress)) {\n    return NATIVE_TOKEN_ADDRESS;\n  }\n  return currencyAddress;\n}\n\n/**\n *\n * @param provider\n * @param inputPrice\n * @param currencyAddress\n * @returns\n * @internal\n */\nasync function normalizePriceValue(provider, inputPrice, currencyAddress) {\n  const metadata = await fetchCurrencyMetadata(provider, currencyAddress);\n  return ethers__WEBPACK_IMPORTED_MODULE_58__.utils.parseUnits(_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.A.parse(inputPrice), metadata.decimals);\n}\n\n/**\n *\n * @param provider\n * @param asset\n * @returns\n * @internal\n */\nasync function fetchCurrencyMetadata(provider, asset) {\n  if (isNativeToken(asset)) {\n    const network = await provider.getNetwork();\n    const nativeToken = getNativeTokenByChainId(network.chainId);\n    return {\n      name: nativeToken.name,\n      symbol: nativeToken.symbol,\n      decimals: nativeToken.decimals\n    };\n  } else {\n    const erc20 = new ethers__WEBPACK_IMPORTED_MODULE_58__.Contract(asset, _thirdweb_dev_contracts_js_dist_abis_IERC20Metadata_json__WEBPACK_IMPORTED_MODULE_38__, provider);\n    const [name, symbol, decimals] = await Promise.all([erc20.name(), erc20.symbol(), erc20.decimals()]);\n    return {\n      name,\n      symbol,\n      decimals\n    };\n  }\n}\n\n/**\n *\n * @param providerOrSigner\n * @param asset\n * @param price\n * @returns\n * @internal\n */\nasync function fetchCurrencyValue(providerOrSigner, asset, price) {\n  const metadata = await fetchCurrencyMetadata(providerOrSigner, asset);\n  return {\n    ...metadata,\n    value: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(price),\n    displayValue: ethers__WEBPACK_IMPORTED_MODULE_58__.utils.formatUnits(price, metadata.decimals)\n  };\n}\nasync function setErc20Allowance(contractToApprove, value, currencyAddress, overrides) {\n  if (isNativeToken(currencyAddress)) {\n    overrides[\"value\"] = value;\n  } else {\n    const signer = contractToApprove.getSigner();\n    const provider = contractToApprove.getProvider();\n    const erc20 = new ContractWrapper(signer || provider, currencyAddress, _thirdweb_dev_contracts_js_dist_abis_IERC20_json__WEBPACK_IMPORTED_MODULE_13__, {});\n    const owner = await contractToApprove.getSignerAddress();\n    const spender = contractToApprove.readContract.address;\n    const allowance = await erc20.readContract.allowance(owner, spender);\n    if (allowance.lt(value)) {\n      // approve overrides the previous allowance, set it to the minimum required for this tx\n      await erc20.sendTransaction(\"approve\", [spender, value]);\n    }\n    return overrides;\n  }\n}\nasync function approveErc20Allowance(contractToApprove, currencyAddress, price, quantity, tokenDecimals) {\n  const signer = contractToApprove.getSigner();\n  const provider = contractToApprove.getProvider();\n  const erc20 = new ContractWrapper(signer || provider, currencyAddress, _thirdweb_dev_contracts_js_dist_abis_IERC20_json__WEBPACK_IMPORTED_MODULE_13__, {});\n  const owner = await contractToApprove.getSignerAddress();\n  const spender = contractToApprove.readContract.address;\n  const allowance = await erc20.readContract.allowance(owner, spender);\n  const totalPrice = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(price).mul(ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(quantity)).div(ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.parseUnits(\"1\", tokenDecimals));\n  if (allowance.lt(totalPrice)) {\n    await erc20.sendTransaction(\"approve\", [spender, allowance.add(totalPrice)]);\n  }\n}\nasync function hasERC20Allowance(contractToApprove, currencyAddress, value) {\n  const provider = contractToApprove.getProvider();\n  const erc20 = new ContractWrapper(provider, currencyAddress, _thirdweb_dev_contracts_js_dist_abis_IERC20_json__WEBPACK_IMPORTED_MODULE_13__, {});\n  const owner = await contractToApprove.getSignerAddress();\n  const spender = contractToApprove.readContract.address;\n  const allowance = await erc20.readContract.allowance(owner, spender);\n  return allowance.gte(value);\n}\n\n/**\n * Returns proofs and the overrides required for the transaction.\n * @internal\n * @returns - `overrides` and `proofs` as an object.\n */\nasync function prepareClaim(addressToClaim, quantity, activeClaimCondition, merkleMetadataFetcher, tokenDecimals, contractWrapper, storage, checkERC20Allowance, snapshotFormatVersion) {\n  let maxClaimable = convertQuantityToBigNumber(activeClaimCondition.maxClaimablePerWallet, tokenDecimals);\n  let proofs = [ethers__WEBPACK_IMPORTED_MODULE_58__.utils.hexZeroPad([0], 32)];\n  let priceInProof = activeClaimCondition.price; // the price to send to the contract in claim proofs\n  let currencyAddressInProof = activeClaimCondition.currencyAddress;\n  try {\n    if (!activeClaimCondition.merkleRootHash.toString().startsWith(ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero)) {\n      const snapshotEntry = await fetchSnapshotEntryForAddress(addressToClaim, activeClaimCondition.merkleRootHash.toString(), await merkleMetadataFetcher(), contractWrapper.getProvider(), storage, snapshotFormatVersion);\n      if (snapshotEntry) {\n        proofs = snapshotEntry.proof;\n        // override only if not default values (unlimited for quantity, zero addr for currency)\n        maxClaimable = snapshotEntry.maxClaimable === \"unlimited\" ? ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.MaxUint256 : ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.parseUnits(snapshotEntry.maxClaimable, tokenDecimals);\n        priceInProof = snapshotEntry.price === undefined || snapshotEntry.price === \"unlimited\" ? ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.MaxUint256 : await normalizePriceValue(contractWrapper.getProvider(), snapshotEntry.price, snapshotEntry.currencyAddress || ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.AddressZero);\n        currencyAddressInProof = snapshotEntry.currencyAddress || ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.AddressZero;\n      } else {\n        // if no snapshot entry, and it's a v1 format (exclusive allowlist) then address can't claim\n        if (snapshotFormatVersion === SnapshotFormatVersion.V1) {\n          throw new Error(\"No claim found for this address\");\n        }\n        // but if its snapshot v2 (override list behavior) then address can still claim with default settings\n      }\n    }\n  } catch (e) {\n    // have to handle the valid error case that we *do* want to throw on\n    if (e?.message === \"No claim found for this address\") {\n      throw e;\n    }\n    // other errors we wanna ignore and try to continue\n    console.warn(\"failed to check claim condition merkle root hash, continuing anyways\", e);\n  }\n  const overrides = (await contractWrapper.getCallOverrides()) || {};\n  // the actual price to check allowance against\n  // if proof price is unlimited, then we use the price from the claim condition\n  // this mimics the contract behavior\n  const pricePerToken = priceInProof.toString() !== ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.MaxUint256.toString() ? priceInProof : activeClaimCondition.price;\n  // same for currency address\n  const currencyAddress = currencyAddressInProof !== ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.AddressZero ? currencyAddressInProof : activeClaimCondition.currencyAddress;\n  if (pricePerToken.gt(0)) {\n    if (isNativeToken(currencyAddress)) {\n      overrides[\"value\"] = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(pricePerToken).mul(quantity).div(ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.parseUnits(\"1\", tokenDecimals));\n    } else if (checkERC20Allowance) {\n      await approveErc20Allowance(contractWrapper, currencyAddress, pricePerToken, quantity, tokenDecimals);\n    }\n  }\n  return {\n    overrides,\n    proofs,\n    maxClaimable,\n    price: pricePerToken,\n    currencyAddress: currencyAddress,\n    priceInProof,\n    currencyAddressInProof\n  };\n}\n\n/**\n * @internal\n * @param merkleRoot\n * @param merkleMetadata\n * @param storage\n */\nasync function fetchSnapshot(merkleRoot, merkleMetadata, storage) {\n  if (!merkleMetadata) {\n    return null;\n  }\n  const snapshotUri = merkleMetadata[merkleRoot];\n  if (snapshotUri) {\n    const raw = await storage.downloadJSON(snapshotUri);\n    if (raw.isShardedMerkleTree && raw.merkleRoot === merkleRoot) {\n      const smt = await ShardedMerkleTree.fromUri(snapshotUri, storage);\n      return smt?.getAllEntries() || null;\n    } else {\n      const snapshotData = SnapshotSchema.parse(raw);\n      if (merkleRoot === snapshotData.merkleRoot) {\n        return snapshotData.claims.map(claim => ({\n          address: claim.address,\n          maxClaimable: claim.maxClaimable,\n          price: claim.price,\n          currencyAddress: claim.currencyAddress\n        }));\n      }\n    }\n  }\n  return null;\n}\nasync function fetchSnapshotEntryForAddress(address, merkleRoot, merkleMetadata, provider, storage, snapshotFormatVersion) {\n  if (!merkleMetadata) {\n    return null;\n  }\n  const snapshotUri = merkleMetadata[merkleRoot];\n  if (snapshotUri) {\n    const raw = await storage.downloadJSON(snapshotUri);\n    if (raw.isShardedMerkleTree && raw.merkleRoot === merkleRoot) {\n      const merkleTree = await ShardedMerkleTree.fromShardedMerkleTreeInfo(raw, storage);\n      return await merkleTree.getProof(address, provider, snapshotFormatVersion);\n    }\n    // legacy non-sharded, just fetch it all and filter out\n    const snapshotData = SnapshotSchema.parse(raw);\n    if (merkleRoot === snapshotData.merkleRoot) {\n      return snapshotData.claims.find(c => c.address.toLowerCase() === address.toLowerCase()) || null;\n    }\n  }\n  return null;\n}\n\n/**\n * @internal\n * @param index\n * @param claimConditionInput\n * @param existingConditions\n */\nasync function updateExistingClaimConditions(index, claimConditionInput, existingConditions) {\n  if (index >= existingConditions.length) {\n    throw Error(`Index out of bounds - got index: ${index} with ${existingConditions.length} conditions`);\n  }\n  // merge input with existing claim condition\n  const priceDecimals = existingConditions[index].currencyMetadata.decimals;\n  const priceInWei = existingConditions[index].price;\n  const priceInTokens = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.formatUnits(priceInWei, priceDecimals);\n\n  // merge existing (output format) with incoming (input format)\n  const newConditionParsed = ClaimConditionInputSchema.parse({\n    ...existingConditions[index],\n    price: priceInTokens,\n    ...claimConditionInput\n  });\n\n  // convert to output claim condition\n  const mergedConditionOutput = ClaimConditionOutputSchema.parse({\n    ...newConditionParsed,\n    price: priceInWei\n  });\n  return existingConditions.map((existingOutput, i) => {\n    let newConditionAtIndex;\n    if (i === index) {\n      newConditionAtIndex = mergedConditionOutput;\n    } else {\n      newConditionAtIndex = existingOutput;\n    }\n    const formattedPrice = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.formatUnits(newConditionAtIndex.price, priceDecimals);\n    return {\n      ...newConditionAtIndex,\n      price: formattedPrice // manually transform back to input price type\n    };\n  });\n}\n\n/**\n * @internal\n * Decorates claim conditions with merkle roots from snapshots if present\n * @param claimConditionInputs\n * @param tokenDecimals\n * @param provider\n * @param storage\n * @param snapshotFormatVersion\n */\nasync function processSnapshotData(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion) {\n  const snapshotInfos = [];\n  const inputsWithSnapshots = await Promise.all(claimConditionInputs.map(async conditionInput => {\n    // check snapshots and upload if provided\n    if (conditionInput.snapshot && conditionInput.snapshot.length > 0) {\n      const snapshotInfo = await createSnapshot(conditionInput.snapshot, tokenDecimals, provider, storage, snapshotFormatVersion);\n      snapshotInfos.push(snapshotInfo);\n      conditionInput.merkleRootHash = snapshotInfo.merkleRoot;\n    } else {\n      // if no snapshot is passed or empty, reset the merkle root\n      conditionInput.merkleRootHash = ethers__WEBPACK_IMPORTED_MODULE_58__.utils.hexZeroPad([0], 32);\n    }\n    // fill condition with defaults values if not provided\n    return conditionInput;\n  }));\n  return {\n    inputsWithSnapshots,\n    snapshotInfos\n  };\n}\nfunction compare(a, b) {\n  const left = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(a);\n  const right = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(b);\n  if (left.eq(right)) {\n    return 0;\n  } else if (left.gt(right)) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n\n/**\n * Create and uploads snapshots + converts claim conditions to contract format\n * @param claimConditionInputs\n * @param tokenDecimals\n * @param provider\n * @param storage\n * @param snapshotFormatVersion\n * @internal\n */\nasync function processClaimConditionInputs(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion) {\n  const {\n    inputsWithSnapshots,\n    snapshotInfos\n  } = await processSnapshotData(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion);\n  const parsedInputs = ClaimConditionInputArray.parse(inputsWithSnapshots);\n  // Convert processed inputs to the format the contract expects, and sort by timestamp\n  const sortedConditions = (await Promise.all(parsedInputs.map(c => convertToContractModel(c, tokenDecimals, provider, storage)))).sort((a, b) => {\n    return compare(a.startTimestamp, b.startTimestamp);\n  });\n  return {\n    snapshotInfos,\n    sortedConditions\n  };\n}\n\n/**\n * Converts a local SDK model to contract model\n * @param c\n * @param tokenDecimals\n * @param provider\n * @param storage\n * @internal\n */\nasync function convertToContractModel(c, tokenDecimals, provider, storage) {\n  const currency = c.currencyAddress === ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero ? NATIVE_TOKEN_ADDRESS : c.currencyAddress;\n  const maxClaimableSupply = convertQuantityToBigNumber(c.maxClaimableSupply, tokenDecimals);\n  const maxClaimablePerWallet = convertQuantityToBigNumber(c.maxClaimablePerWallet, tokenDecimals);\n  let metadataOrUri;\n  if (c.metadata) {\n    if (typeof c.metadata === \"string\") {\n      metadataOrUri = c.metadata;\n    } else {\n      metadataOrUri = await storage.upload(c.metadata);\n    }\n  }\n  return {\n    startTimestamp: c.startTime,\n    maxClaimableSupply,\n    supplyClaimed: 0,\n    maxClaimablePerWallet,\n    pricePerToken: await normalizePriceValue(provider, c.price, currency),\n    currency,\n    merkleRoot: c.merkleRootHash.toString(),\n    waitTimeInSecondsBetweenClaims: c.waitInSeconds || 0,\n    metadata: metadataOrUri\n  };\n}\nfunction abstractContractModelToLegacy(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot,\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    quantityLimitPerTransaction: model.maxClaimablePerWallet,\n    waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims || 0\n  };\n}\nfunction abstractContractModelToNew(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot,\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    quantityLimitPerWallet: model.maxClaimablePerWallet,\n    metadata: model.metadata || \"\"\n  };\n}\nfunction legacyContractModelToAbstract(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot.toString(),\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    maxClaimablePerWallet: model.quantityLimitPerTransaction,\n    waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims\n  };\n}\nfunction newContractModelToAbstract(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot.toString(),\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    maxClaimablePerWallet: model.quantityLimitPerWallet,\n    waitTimeInSecondsBetweenClaims: 0,\n    metadata: model.metadata\n  };\n}\n\n/**\n * Transforms a contract model to local model\n * @param pm\n * @param tokenDecimals\n * @param provider\n * @param merkleMetadata\n * @param storage\n * @param shouldDownloadSnapshot\n * @internal\n */\nasync function transformResultToClaimCondition(pm, tokenDecimals, provider, merkleMetadata, storage, shouldDownloadSnapshot) {\n  const cv = await fetchCurrencyValue(provider, pm.currency, pm.pricePerToken);\n  const maxClaimableSupply = convertToReadableQuantity(pm.maxClaimableSupply, tokenDecimals);\n  const maxClaimablePerWallet = convertToReadableQuantity(pm.maxClaimablePerWallet, tokenDecimals);\n  const availableSupply = convertToReadableQuantity(ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(pm.maxClaimableSupply).sub(pm.supplyClaimed), tokenDecimals);\n  const currentMintSupply = convertToReadableQuantity(pm.supplyClaimed, tokenDecimals);\n  let resolvedMetadata;\n  if (pm.metadata) {\n    resolvedMetadata = await storage.downloadJSON(pm.metadata);\n  }\n  return ClaimConditionOutputSchema.parse({\n    startTime: pm.startTimestamp,\n    maxClaimableSupply,\n    maxClaimablePerWallet,\n    currentMintSupply,\n    availableSupply,\n    waitInSeconds: pm.waitTimeInSecondsBetweenClaims?.toString(),\n    price: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(pm.pricePerToken),\n    currency: pm.currency,\n    currencyAddress: pm.currency,\n    currencyMetadata: cv,\n    merkleRootHash: pm.merkleRoot,\n    snapshot: shouldDownloadSnapshot ? await fetchSnapshot(pm.merkleRoot, merkleMetadata, storage) : undefined,\n    metadata: resolvedMetadata\n  });\n}\n\n/**\n * @internal\n * @param bn\n * @param tokenDecimals\n */\nfunction convertToReadableQuantity(bn, tokenDecimals) {\n  if (bn.toString() === ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.MaxUint256.toString()) {\n    return \"unlimited\";\n  } else {\n    return ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.formatUnits(bn, tokenDecimals);\n  }\n}\n\n/**\n * @internal\n * @param quantity\n * @param tokenDecimals\n */\nfunction convertQuantityToBigNumber(quantity, tokenDecimals) {\n  if (quantity === \"unlimited\") {\n    return ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.MaxUint256;\n  } else {\n    return ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.parseUnits(quantity, tokenDecimals);\n  }\n}\nasync function calculateClaimCost(contractWrapper, pricePerToken, quantity, currencyAddress, checkERC20Allowance) {\n  let overrides = {};\n  const currency = currencyAddress || NATIVE_TOKEN_ADDRESS;\n  const normalizedPrice = await normalizePriceValue(contractWrapper.getProvider(), pricePerToken, currency);\n  const totalCost = normalizedPrice.mul(quantity);\n  if (totalCost.gt(0)) {\n    if (currency === NATIVE_TOKEN_ADDRESS) {\n      overrides = {\n        value: totalCost\n      };\n    } else if (currency !== NATIVE_TOKEN_ADDRESS && checkERC20Allowance) {\n      await approveErc20Allowance(contractWrapper, currency, totalCost, quantity, 0);\n    }\n  }\n  return overrides;\n}\n\n// shard using the first 2 hex character of the address\n// this splits the merkle tree into 256 shards\n// shard files will be 00.json, 01.json, 02.json, ..., ff.json\nconst SHARD_NYBBLES = 2;\nlet SnapshotFormatVersion; // address, maxClaimable, price, currencyAddress\n(function (SnapshotFormatVersion) {\n  SnapshotFormatVersion[SnapshotFormatVersion[\"V1\"] = 1] = \"V1\";\n  SnapshotFormatVersion[SnapshotFormatVersion[\"V2\"] = 2] = \"V2\";\n})(SnapshotFormatVersion || (SnapshotFormatVersion = {}));\nclass ShardedMerkleTree {\n  constructor(storage, baseUri, originalEntriesUri, shardNybbles, tokenDecimals) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"shardNybbles\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"shards\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"trees\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"baseUri\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"originalEntriesUri\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"tokenDecimals\", void 0);\n    this.storage = storage;\n    this.shardNybbles = shardNybbles;\n    this.baseUri = baseUri;\n    this.originalEntriesUri = originalEntriesUri;\n    this.tokenDecimals = tokenDecimals;\n    this.shards = {};\n    this.trees = {};\n  }\n  static async fromUri(uri, storage) {\n    try {\n      const shardedMerkleTreeInfo = await storage.downloadJSON(uri);\n      if (shardedMerkleTreeInfo.isShardedMerkleTree) {\n        return ShardedMerkleTree.fromShardedMerkleTreeInfo(shardedMerkleTreeInfo, storage);\n      }\n    } catch (e) {\n      return undefined;\n    }\n  }\n  static async fromShardedMerkleTreeInfo(info, storage) {\n    return new ShardedMerkleTree(storage, info.baseUri, info.originalEntriesUri, info.shardNybbles, info.tokenDecimals);\n  }\n  static hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion) {\n    switch (snapshotFormatVersion) {\n      case SnapshotFormatVersion.V1:\n        return ethers__WEBPACK_IMPORTED_MODULE_58__.utils.solidityKeccak256([\"address\", \"uint256\"], [entry.address, convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals)]);\n      case SnapshotFormatVersion.V2:\n        return ethers__WEBPACK_IMPORTED_MODULE_58__.utils.solidityKeccak256([\"address\", \"uint256\", \"uint256\", \"address\"], [entry.address, convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals), convertQuantityToBigNumber(entry.price || \"unlimited\", currencyDecimals), entry.currencyAddress || ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.AddressZero]);\n    }\n  }\n  static async fetchAndCacheDecimals(cache, provider, currencyAddress) {\n    if (!currencyAddress) {\n      return 18;\n    }\n    // cache decimals for each currency to avoid refetching for every address\n    let currencyDecimals = cache[currencyAddress];\n    if (currencyDecimals === undefined) {\n      const currencyMetadata = await fetchCurrencyMetadata(provider, currencyAddress);\n      currencyDecimals = currencyMetadata.decimals;\n      cache[currencyAddress] = currencyDecimals;\n    }\n    return currencyDecimals;\n  }\n  static async buildAndUpload(snapshotInput, tokenDecimals, provider, storage, snapshotFormatVersion) {\n    let shardNybbles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : SHARD_NYBBLES;\n    const inputs = SnapshotInputSchema.parse(snapshotInput);\n    // TODO Could also derive shardNybbles from input size\n    const shards = {};\n    for (const snapshotEntry of inputs) {\n      const shard = snapshotEntry.address.slice(2, 2 + shardNybbles).toLowerCase();\n      if (shards[shard] === undefined) {\n        shards[shard] = [];\n      }\n      shards[shard].push(snapshotEntry);\n    }\n    const currencyDecimalMap = {};\n    // create shard => subtree root map\n    const subTrees = await Promise.all(Object.entries(shards).map(async _ref => {\n      let [shard, entries] = _ref;\n      return [shard, new merkletreejs__WEBPACK_IMPORTED_MODULE_39__.MerkleTree(await Promise.all(entries.map(async entry => {\n        // cache decimals for each currency to avoid refetching for every address\n        const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);\n        return ShardedMerkleTree.hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion);\n      })), ethers__WEBPACK_IMPORTED_MODULE_58__.utils.keccak256, {\n        sort: true\n      }).getHexRoot()];\n    }));\n    const roots = Object.fromEntries(subTrees);\n    // create master tree from shard => subtree root map\n    const tree = new merkletreejs__WEBPACK_IMPORTED_MODULE_39__.MerkleTree(Object.values(roots), ethers__WEBPACK_IMPORTED_MODULE_58__.utils.keccak256, {\n      sort: true\n    });\n    const shardsToUpload = [];\n    for (const [shardId, entries] of Object.entries(shards)) {\n      const data = {\n        proofs: tree.getProof(roots[shardId]).map(value => \"0x\" + value.data.toString(\"hex\")),\n        entries\n      };\n      shardsToUpload.push({\n        data: JSON.stringify(data),\n        name: `${shardId}.json`\n      });\n    }\n    const uris = await storage.uploadBatch(shardsToUpload);\n    const baseUri = uris[0].slice(0, uris[0].lastIndexOf(\"/\"));\n    const originalEntriesUri = await storage.upload(inputs);\n    const shardedMerkleInfo = {\n      merkleRoot: tree.getHexRoot(),\n      baseUri,\n      originalEntriesUri,\n      shardNybbles,\n      tokenDecimals,\n      isShardedMerkleTree: true\n    };\n    const masterUri = await storage.upload(shardedMerkleInfo);\n    return {\n      shardedMerkleInfo,\n      uri: masterUri\n    };\n  }\n  async getProof(address, provider, snapshotFormatVersion) {\n    const shardId = address.slice(2, 2 + this.shardNybbles).toLowerCase();\n    let shard = this.shards[shardId];\n    const currencyDecimalMap = {};\n    if (shard === undefined) {\n      try {\n        shard = this.shards[shardId] = await this.storage.downloadJSON(`${this.baseUri}/${shardId}.json`);\n        const hashedEntries = await Promise.all(shard.entries.map(async entry => {\n          // cache decimals for each currency to avoid refetching for every address\n          const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);\n          return ShardedMerkleTree.hashEntry(entry, this.tokenDecimals, currencyDecimals, snapshotFormatVersion);\n        }));\n        this.trees[shardId] = new merkletreejs__WEBPACK_IMPORTED_MODULE_39__.MerkleTree(hashedEntries, ethers__WEBPACK_IMPORTED_MODULE_58__.utils.keccak256, {\n          sort: true\n        });\n      } catch (e) {\n        console.warn(\"No merkle entry found for address\", address);\n        return null;\n      }\n    }\n    const entry = shard.entries.find(i => i.address.toLowerCase() === address.toLowerCase());\n    if (!entry) {\n      return null;\n    }\n    const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);\n    const leaf = ShardedMerkleTree.hashEntry(entry, this.tokenDecimals, currencyDecimals, snapshotFormatVersion);\n    const proof = this.trees[shardId].getProof(leaf).map(i => \"0x\" + i.data.toString(\"hex\"));\n    return SnapshotEntryWithProofSchema.parse({\n      ...entry,\n      proof: proof.concat(shard.proofs)\n    });\n  }\n  async getAllEntries() {\n    try {\n      return await this.storage.downloadJSON(this.originalEntriesUri);\n    } catch (e) {\n      console.warn(\"Could not fetch original snapshot entries\", e);\n      return [];\n    }\n  }\n}\n\n/**\n * Create a snapshot (merkle tree) from a list of addresses and uploads it to IPFS\n * @param snapshotInput - the list of addresses to hash\n * @param tokenDecimals - the token decimals\n * @param provider\n * @param storage - the storage to upload to\n * @param snapshotFormatVersion\n * @returns the generated snapshot and URI\n * @internal\n */\nasync function createSnapshot(snapshotInput, tokenDecimals, provider, storage, snapshotFormatVersion) {\n  const input = SnapshotInputSchema.parse(snapshotInput);\n  const addresses = input.map(i => i.address);\n  const hasDuplicates = new Set(addresses).size < addresses.length;\n  if (hasDuplicates) {\n    throw new DuplicateLeafsError();\n  }\n  const tree = await ShardedMerkleTree.buildAndUpload(input, tokenDecimals, provider, storage, snapshotFormatVersion);\n  return {\n    merkleRoot: tree.shardedMerkleInfo.merkleRoot,\n    snapshotUri: tree.uri\n  };\n}\n\n/**\n *\n * @internal\n */\nconst roleMap = {\n  admin: \"\",\n  transfer: \"TRANSFER_ROLE\",\n  minter: \"MINTER_ROLE\",\n  pauser: \"PAUSER_ROLE\",\n  lister: \"LISTER_ROLE\",\n  asset: \"ASSET_ROLE\",\n  unwrap: \"UNWRAP_ROLE\",\n  factory: \"FACTORY_ROLE\"\n};\n\n/**\n * @public\n */\n\n/**\n * @public\n */\nconst ALL_ROLES = Object.keys(roleMap);\n\n/**\n * @internal\n */\nfunction getRoleHash(role) {\n  if (role === \"admin\") {\n    return ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.hexZeroPad([0], 32);\n  }\n  return ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.id(roleMap[role]);\n}\n\nconst FEATURE_TOKEN_CLAIM_CONDITIONS_V1 = {\n  name: \"ERC20ClaimConditionsV1\",\n  namespace: \"token.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc20dclaimable\",\n    contracts: \"DropSinglePhase_V1\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC20_json__WEBPACK_IMPORTED_MODULE_13__, _thirdweb_dev_contracts_js_dist_abis_IDropSinglePhase_V1_json__WEBPACK_IMPORTED_MODULE_12__],\n  features: {}\n};\nconst FEATURE_TOKEN_CLAIM_CONDITIONS_V2 = {\n  name: \"ERC20ClaimConditionsV2\",\n  namespace: \"token.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc20dclaimable\",\n    contracts: \"DropSinglePhase\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC20_json__WEBPACK_IMPORTED_MODULE_13__, _thirdweb_dev_contracts_js_dist_abis_IDropSinglePhase_json__WEBPACK_IMPORTED_MODULE_11__],\n  features: {}\n};\nconst FEATURE_TOKEN_CLAIM_PHASES_V2 = {\n  name: \"ERC20ClaimPhasesV2\",\n  namespace: \"token.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc20dclaimable\",\n    contracts: \"Drop\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC20_json__WEBPACK_IMPORTED_MODULE_13__, _thirdweb_dev_contracts_js_dist_abis_IDrop_json__WEBPACK_IMPORTED_MODULE_10__],\n  features: {}\n};\nconst FEATURE_TOKEN_CLAIM_PHASES_V1 = {\n  name: \"ERC20ClaimPhasesV1\",\n  namespace: \"token.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc20dclaimable\",\n    contracts: \"Drop\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_DropERC20_V2_json__WEBPACK_IMPORTED_MODULE_8__],\n  features: {}\n};\nconst FEATURE_TOKEN_BURNABLE = {\n  name: \"ERC20Burnable\",\n  namespace: \"token.burn\",\n  docLinks: {\n    sdk: \"sdk.erc20burnable\",\n    contracts: \"IBurnableERC20\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC20_json__WEBPACK_IMPORTED_MODULE_13__, _thirdweb_dev_contracts_js_dist_abis_IBurnableERC20_json__WEBPACK_IMPORTED_MODULE_9__],\n  features: {}\n};\nconst FEATURE_TOKEN_SIGNATURE_MINTABLE = {\n  name: \"ERC20SignatureMintable\",\n  namespace: \"token.signature\",\n  docLinks: {\n    sdk: \"sdk.erc20signaturemintable\",\n    contracts: \"ISignatureMintERC20\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC20_json__WEBPACK_IMPORTED_MODULE_13__, _thirdweb_dev_contracts_js_dist_abis_ISignatureMintERC20_json__WEBPACK_IMPORTED_MODULE_16__],\n  features: {}\n};\nconst FEATURE_TOKEN_BATCH_MINTABLE = {\n  name: \"ERC20BatchMintable\",\n  namespace: \"token.mint.batch\",\n  docLinks: {\n    sdk: \"sdk.erc20batchmintable\",\n    contracts: \"IMulticall\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC20_json__WEBPACK_IMPORTED_MODULE_13__, _thirdweb_dev_contracts_js_dist_abis_IMintableERC20_json__WEBPACK_IMPORTED_MODULE_14__, _thirdweb_dev_contracts_js_dist_abis_IMulticall_json__WEBPACK_IMPORTED_MODULE_15__],\n  features: {}\n};\nconst FEATURE_TOKEN_MINTABLE = {\n  name: \"ERC20Mintable\",\n  namespace: \"token.mint\",\n  docLinks: {\n    sdk: \"sdk.erc20mintable\",\n    contracts: \"IMintableERC20\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC20_json__WEBPACK_IMPORTED_MODULE_13__, _thirdweb_dev_contracts_js_dist_abis_IMintableERC20_json__WEBPACK_IMPORTED_MODULE_14__],\n  features: {\n    [FEATURE_TOKEN_BATCH_MINTABLE.name]: FEATURE_TOKEN_BATCH_MINTABLE\n  }\n};\nconst FEATURE_TOKEN = {\n  name: \"ERC20\",\n  namespace: \"token\",\n  docLinks: {\n    sdk: \"sdk.erc20\",\n    contracts: \"IERC20\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC20_json__WEBPACK_IMPORTED_MODULE_13__],\n  features: {\n    [FEATURE_TOKEN_BURNABLE.name]: FEATURE_TOKEN_BURNABLE,\n    [FEATURE_TOKEN_MINTABLE.name]: FEATURE_TOKEN_MINTABLE,\n    [FEATURE_TOKEN_CLAIM_CONDITIONS_V1.name]: FEATURE_TOKEN_CLAIM_CONDITIONS_V1,\n    [FEATURE_TOKEN_CLAIM_CONDITIONS_V2.name]: FEATURE_TOKEN_CLAIM_CONDITIONS_V2,\n    [FEATURE_TOKEN_CLAIM_PHASES_V1.name]: FEATURE_TOKEN_CLAIM_PHASES_V1,\n    [FEATURE_TOKEN_CLAIM_PHASES_V2.name]: FEATURE_TOKEN_CLAIM_PHASES_V2,\n    [FEATURE_TOKEN_SIGNATURE_MINTABLE.name]: FEATURE_TOKEN_SIGNATURE_MINTABLE\n  }\n};\n\nconst FEATURE_NFT_BURNABLE = {\n  name: \"ERC721Burnable\",\n  namespace: \"nft.burn\",\n  docLinks: {\n    sdk: \"sdk.erc721burnable\",\n    contracts: \"IBurnableERC721\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC721_json__WEBPACK_IMPORTED_MODULE_1__, _thirdweb_dev_contracts_js_dist_abis_IBurnableERC721_json__WEBPACK_IMPORTED_MODULE_18__],\n  features: {}\n};\nconst FEATURE_NFT_REVEALABLE = {\n  name: \"ERC721Revealable\",\n  namespace: \"nft.drop.revealer\",\n  docLinks: {\n    sdk: \"sdk.delayedreveal\",\n    contracts: \"DelayedReveal\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC721_json__WEBPACK_IMPORTED_MODULE_1__, _thirdweb_dev_contracts_js_dist_abis_ILazyMint_json__WEBPACK_IMPORTED_MODULE_23__, _thirdweb_dev_contracts_js_dist_abis_IDelayedReveal_json__WEBPACK_IMPORTED_MODULE_20__],\n  features: {}\n};\nconst FEATURE_NFT_TIERED_DROP = {\n  name: \"ERC721TieredDrop\",\n  namespace: \"nft.tieredDrop\",\n  docLinks: {\n    sdk: \"sdk.erc721tiereddrop\",\n    contracts: \"TieredDrop\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC721_json__WEBPACK_IMPORTED_MODULE_1__, _thirdweb_dev_contracts_js_dist_abis_LazyMintWithTier_json__WEBPACK_IMPORTED_MODULE_27__],\n  features: {}\n};\nconst FEATURE_NFT_CLAIM_CONDITIONS_V1 = {\n  name: \"ERC721ClaimConditionsV1\",\n  namespace: \"nft.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc721claimable\",\n    contracts: \"DropSinglePhase_V1\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC721_json__WEBPACK_IMPORTED_MODULE_1__, _thirdweb_dev_contracts_js_dist_abis_ILazyMint_json__WEBPACK_IMPORTED_MODULE_23__, _thirdweb_dev_contracts_js_dist_abis_IDropSinglePhase_V1_json__WEBPACK_IMPORTED_MODULE_12__],\n  features: {}\n};\nconst FEATURE_NFT_CLAIM_CONDITIONS_V2 = {\n  name: \"ERC721ClaimConditionsV2\",\n  namespace: \"nft.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc721claimable\",\n    contracts: \"DropSinglePhase\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC721_json__WEBPACK_IMPORTED_MODULE_1__, _thirdweb_dev_contracts_js_dist_abis_ILazyMint_json__WEBPACK_IMPORTED_MODULE_23__, _thirdweb_dev_contracts_js_dist_abis_IDropSinglePhase_json__WEBPACK_IMPORTED_MODULE_11__],\n  features: {}\n};\nconst FEATURE_NFT_CLAIM_PHASES_V1 = {\n  name: \"ERC721ClaimPhasesV1\",\n  namespace: \"nft.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc721claimable\",\n    contracts: \"Drop\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_DropERC721_V3_json__WEBPACK_IMPORTED_MODULE_17__],\n  features: {}\n};\nconst FEATURE_NFT_CLAIM_PHASES_V2 = {\n  name: \"ERC721ClaimPhasesV2\",\n  namespace: \"nft.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc721claimable\",\n    contracts: \"Drop\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC721_json__WEBPACK_IMPORTED_MODULE_1__, _thirdweb_dev_contracts_js_dist_abis_ILazyMint_json__WEBPACK_IMPORTED_MODULE_23__, _thirdweb_dev_contracts_js_dist_abis_IDrop_json__WEBPACK_IMPORTED_MODULE_10__],\n  features: {}\n};\nconst FEATURE_NFT_CLAIM_CUSTOM = {\n  name: \"ERC721ClaimCustom\",\n  namespace: \"nft.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc721claimable\",\n    contracts: \"IClaimableERC721\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC721_json__WEBPACK_IMPORTED_MODULE_1__, _thirdweb_dev_contracts_js_dist_abis_ILazyMint_json__WEBPACK_IMPORTED_MODULE_23__, _thirdweb_dev_contracts_js_dist_abis_IClaimableERC721_json__WEBPACK_IMPORTED_MODULE_19__],\n  features: {}\n};\nconst FEATURE_NFT_LAZY_MINTABLE = {\n  name: \"ERC721LazyMintable\",\n  namespace: \"nft.drop\",\n  docLinks: {\n    sdk: \"sdk.erc721lazymintable\",\n    contracts: \"LazyMint\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC721_json__WEBPACK_IMPORTED_MODULE_1__, _thirdweb_dev_contracts_js_dist_abis_ILazyMint_json__WEBPACK_IMPORTED_MODULE_23__],\n  features: {\n    [FEATURE_NFT_REVEALABLE.name]: FEATURE_NFT_REVEALABLE,\n    [FEATURE_NFT_CLAIM_CUSTOM.name]: FEATURE_NFT_CLAIM_CUSTOM,\n    [FEATURE_NFT_CLAIM_CONDITIONS_V1.name]: FEATURE_NFT_CLAIM_CONDITIONS_V1,\n    [FEATURE_NFT_CLAIM_CONDITIONS_V2.name]: FEATURE_NFT_CLAIM_CONDITIONS_V2,\n    [FEATURE_NFT_CLAIM_PHASES_V1.name]: FEATURE_NFT_CLAIM_PHASES_V1,\n    [FEATURE_NFT_CLAIM_PHASES_V2.name]: FEATURE_NFT_CLAIM_PHASES_V2\n  }\n};\nconst FEATURE_NFT_BATCH_MINTABLE = {\n  name: \"ERC721BatchMintable\",\n  namespace: \"nft.mint.batch\",\n  docLinks: {\n    sdk: \"sdk.erc721batchmintable\",\n    contracts: \"IMulticall\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC721_json__WEBPACK_IMPORTED_MODULE_1__, _thirdweb_dev_contracts_js_dist_abis_IMintableERC721_json__WEBPACK_IMPORTED_MODULE_24__, _thirdweb_dev_contracts_js_dist_abis_IMulticall_json__WEBPACK_IMPORTED_MODULE_15__],\n  features: {}\n};\nconst FEATURE_NFT_MINTABLE = {\n  name: \"ERC721Mintable\",\n  namespace: \"nft.mint\",\n  docLinks: {\n    sdk: \"sdk.erc721mintable\",\n    contracts: \"IMintableERC721\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC721_json__WEBPACK_IMPORTED_MODULE_1__, _thirdweb_dev_contracts_js_dist_abis_IMintableERC721_json__WEBPACK_IMPORTED_MODULE_24__],\n  features: {\n    [FEATURE_NFT_BATCH_MINTABLE.name]: FEATURE_NFT_BATCH_MINTABLE\n  }\n};\nconst FEATURE_NFT_SIGNATURE_MINTABLE_V2 = {\n  name: \"ERC721SignatureMintV2\",\n  namespace: \"nft.signature\",\n  docLinks: {\n    sdk: \"sdk.erc721signaturemint\",\n    contracts: \"ISignatureMintERC721\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC721_json__WEBPACK_IMPORTED_MODULE_1__, _thirdweb_dev_contracts_js_dist_abis_ISignatureMintERC721_json__WEBPACK_IMPORTED_MODULE_25__],\n  features: {}\n};\nconst FEATURE_NFT_SIGNATURE_MINTABLE_V1 = {\n  name: \"ERC721SignatureMintV1\",\n  namespace: \"nft.signature\",\n  docLinks: {\n    sdk: \"sdk.erc721signaturemint\",\n    contracts: \"ISignatureMintERC721\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_ISignatureMintERC721_V1_json__WEBPACK_IMPORTED_MODULE_26__],\n  features: {}\n};\nconst FEATURE_NFT_ENUMERABLE = {\n  name: \"ERC721Enumerable\",\n  namespace: \"nft.query.owned\",\n  docLinks: {\n    sdk: \"sdk.erc721enumerable\",\n    contracts: \"IERC721Enumerable\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC721_json__WEBPACK_IMPORTED_MODULE_1__, _thirdweb_dev_contracts_js_dist_abis_IERC721Enumerable_json__WEBPACK_IMPORTED_MODULE_21__],\n  features: {}\n};\nconst FEATURE_NFT_SUPPLY = {\n  name: \"ERC721Supply\",\n  namespace: \"nft.query\",\n  docLinks: {\n    sdk: \"sdk.erc721supply\",\n    contracts: \"IERC721Supply\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC721_json__WEBPACK_IMPORTED_MODULE_1__, _thirdweb_dev_contracts_js_dist_abis_IERC721Supply_json__WEBPACK_IMPORTED_MODULE_22__],\n  features: {\n    [FEATURE_NFT_ENUMERABLE.name]: FEATURE_NFT_ENUMERABLE\n  }\n};\nconst FEATURE_NFT = {\n  name: \"ERC721\",\n  namespace: \"nft\",\n  docLinks: {\n    sdk: \"sdk.erc721\",\n    contracts: \"IERC721\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC721_json__WEBPACK_IMPORTED_MODULE_1__],\n  features: {\n    [FEATURE_NFT_BURNABLE.name]: FEATURE_NFT_BURNABLE,\n    [FEATURE_NFT_SUPPLY.name]: FEATURE_NFT_SUPPLY,\n    [FEATURE_NFT_MINTABLE.name]: FEATURE_NFT_MINTABLE,\n    [FEATURE_NFT_LAZY_MINTABLE.name]: FEATURE_NFT_LAZY_MINTABLE,\n    [FEATURE_NFT_SIGNATURE_MINTABLE_V1.name]: FEATURE_NFT_SIGNATURE_MINTABLE_V1,\n    [FEATURE_NFT_SIGNATURE_MINTABLE_V2.name]: FEATURE_NFT_SIGNATURE_MINTABLE_V2,\n    [FEATURE_NFT_TIERED_DROP.name]: FEATURE_NFT_TIERED_DROP\n  }\n};\n\nconst FEATURE_EDITION_BURNABLE = {\n  name: \"ERC1155Burnable\",\n  namespace: \"edition.burn\",\n  docLinks: {\n    sdk: \"sdk.erc1155burnable\",\n    contracts: \"IBurnableERC1155\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC1155_json__WEBPACK_IMPORTED_MODULE_2__, _thirdweb_dev_contracts_js_dist_abis_IBurnableERC1155_json__WEBPACK_IMPORTED_MODULE_29__],\n  features: {}\n};\nconst FEATURE_EDITION_CLAIM_CONDITIONS_V1 = {\n  name: \"ERC1155ClaimConditionsV1\",\n  namespace: \"edition.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc1155claimable\",\n    contracts: \"DropSinglePhase1155\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC1155_json__WEBPACK_IMPORTED_MODULE_2__, _thirdweb_dev_contracts_js_dist_abis_ILazyMint_json__WEBPACK_IMPORTED_MODULE_23__, _thirdweb_dev_contracts_js_dist_abis_IDropSinglePhase1155_V1_json__WEBPACK_IMPORTED_MODULE_33__],\n  features: {}\n};\nconst FEATURE_EDITION_CLAIM_CONDITIONS_V2 = {\n  name: \"ERC1155ClaimConditionsV2\",\n  namespace: \"edition.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc1155claimable\",\n    contracts: \"DropSinglePhase1155\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC1155_json__WEBPACK_IMPORTED_MODULE_2__, _thirdweb_dev_contracts_js_dist_abis_ILazyMint_json__WEBPACK_IMPORTED_MODULE_23__, _thirdweb_dev_contracts_js_dist_abis_IDropSinglePhase1155_json__WEBPACK_IMPORTED_MODULE_32__],\n  features: {}\n};\nconst FEATURE_EDITION_CLAIM_PHASES_V2 = {\n  name: \"ERC1155ClaimPhasesV2\",\n  namespace: \"edition.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc1155claimable\",\n    contracts: \"Drop1155\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC1155_json__WEBPACK_IMPORTED_MODULE_2__, _thirdweb_dev_contracts_js_dist_abis_ILazyMint_json__WEBPACK_IMPORTED_MODULE_23__, _thirdweb_dev_contracts_js_dist_abis_IDrop1155_json__WEBPACK_IMPORTED_MODULE_31__],\n  features: {}\n};\nconst FEATURE_EDITION_CLAIM_PHASES_V1 = {\n  name: \"ERC1155ClaimPhasesV1\",\n  namespace: \"edition.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc1155claimable\",\n    contracts: \"Drop1155\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_DropERC1155_V2_json__WEBPACK_IMPORTED_MODULE_28__],\n  features: {}\n};\nconst FEATURE_EDITION_CLAIM_CUSTOM = {\n  name: \"ERC1155ClaimCustom\",\n  namespace: \"edition.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc1155claimable\",\n    contracts: \"IClaimableERC1155\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC1155_json__WEBPACK_IMPORTED_MODULE_2__, _thirdweb_dev_contracts_js_dist_abis_ILazyMint_json__WEBPACK_IMPORTED_MODULE_23__, _thirdweb_dev_contracts_js_dist_abis_IClaimableERC1155_json__WEBPACK_IMPORTED_MODULE_30__],\n  features: {}\n};\nconst FEATURE_EDITION_REVEALABLE = {\n  name: \"ERC1155Revealable\",\n  namespace: \"edition.drop.revealer\",\n  docLinks: {\n    sdk: \"sdk.drop.delayedreveal\",\n    contracts: \"DelayedReveal\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC1155_json__WEBPACK_IMPORTED_MODULE_2__, _thirdweb_dev_contracts_js_dist_abis_ILazyMint_json__WEBPACK_IMPORTED_MODULE_23__, _thirdweb_dev_contracts_js_dist_abis_IDelayedReveal_json__WEBPACK_IMPORTED_MODULE_20__],\n  features: {}\n};\nconst FEATURE_EDITION_LAZY_MINTABLE_V2 = {\n  name: \"ERC1155LazyMintableV2\",\n  namespace: \"edition.drop\",\n  docLinks: {\n    sdk: \"sdk.erc1155droppable\",\n    contracts: \"LazyMint\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC1155_json__WEBPACK_IMPORTED_MODULE_2__, _thirdweb_dev_contracts_js_dist_abis_ILazyMint_json__WEBPACK_IMPORTED_MODULE_23__],\n  features: {\n    [FEATURE_EDITION_REVEALABLE.name]: FEATURE_EDITION_REVEALABLE,\n    [FEATURE_EDITION_CLAIM_CUSTOM.name]: FEATURE_EDITION_CLAIM_CUSTOM,\n    [FEATURE_EDITION_CLAIM_CONDITIONS_V1.name]: FEATURE_EDITION_CLAIM_CONDITIONS_V1,\n    [FEATURE_EDITION_CLAIM_CONDITIONS_V2.name]: FEATURE_EDITION_CLAIM_CONDITIONS_V2,\n    [FEATURE_EDITION_CLAIM_PHASES_V2.name]: FEATURE_EDITION_CLAIM_PHASES_V2\n  }\n};\nconst FEATURE_EDITION_LAZY_MINTABLE_V1 = {\n  name: \"ERC1155LazyMintableV1\",\n  namespace: \"edition.drop\",\n  docLinks: {\n    sdk: \"sdk.erc1155droppable\",\n    contracts: \"LazyMint\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_DropERC1155_V2_json__WEBPACK_IMPORTED_MODULE_28__],\n  features: {\n    [FEATURE_EDITION_CLAIM_PHASES_V1.name]: FEATURE_EDITION_CLAIM_PHASES_V1\n  }\n};\nconst FEATURE_EDITION_SIGNATURE_MINTABLE = {\n  name: \"ERC1155SignatureMintable\",\n  namespace: \"edition.signature\",\n  docLinks: {\n    sdk: \"sdk.erc1155signaturemintable\",\n    contracts: \"ISignatureMintERC1155\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC1155_json__WEBPACK_IMPORTED_MODULE_2__, _thirdweb_dev_contracts_js_dist_abis_ISignatureMintERC1155_json__WEBPACK_IMPORTED_MODULE_36__],\n  features: {}\n};\nconst FEATURE_EDITION_BATCH_MINTABLE = {\n  name: \"ERC1155BatchMintable\",\n  namespace: \"edition.mint.batch\",\n  docLinks: {\n    sdk: \"sdk.erc1155batchmintable\",\n    contracts: \"IMulticall\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC1155_json__WEBPACK_IMPORTED_MODULE_2__, _thirdweb_dev_contracts_js_dist_abis_IMintableERC1155_json__WEBPACK_IMPORTED_MODULE_35__, _thirdweb_dev_contracts_js_dist_abis_IMulticall_json__WEBPACK_IMPORTED_MODULE_15__],\n  features: {}\n};\nconst FEATURE_EDITION_MINTABLE = {\n  name: \"ERC1155Mintable\",\n  namespace: \"edition.mint\",\n  docLinks: {\n    sdk: \"sdk.erc1155mintable\",\n    contracts: \"IMintableERC1155\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC1155_json__WEBPACK_IMPORTED_MODULE_2__, _thirdweb_dev_contracts_js_dist_abis_IMintableERC1155_json__WEBPACK_IMPORTED_MODULE_35__],\n  features: {\n    [FEATURE_EDITION_BATCH_MINTABLE.name]: FEATURE_EDITION_BATCH_MINTABLE\n  }\n};\nconst FEATURE_EDITION_ENUMERABLE = {\n  name: \"ERC1155Enumerable\",\n  namespace: \"edition.query\",\n  docLinks: {\n    sdk: \"sdk.erc1155\",\n    contracts: \"IERC1155\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC1155_json__WEBPACK_IMPORTED_MODULE_2__, _thirdweb_dev_contracts_js_dist_abis_IERC1155Enumerable_json__WEBPACK_IMPORTED_MODULE_34__],\n  features: {}\n};\nconst FEATURE_EDITION = {\n  name: \"ERC1155\",\n  namespace: \"edition\",\n  docLinks: {\n    sdk: \"sdk.erc1155enumerable\",\n    contracts: \"IERC1155Enumerable\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IERC1155_json__WEBPACK_IMPORTED_MODULE_2__],\n  features: {\n    [FEATURE_EDITION_BURNABLE.name]: FEATURE_EDITION_BURNABLE,\n    [FEATURE_EDITION_ENUMERABLE.name]: FEATURE_EDITION_ENUMERABLE,\n    [FEATURE_EDITION_MINTABLE.name]: FEATURE_EDITION_MINTABLE,\n    [FEATURE_EDITION_LAZY_MINTABLE_V1.name]: FEATURE_EDITION_LAZY_MINTABLE_V1,\n    [FEATURE_EDITION_LAZY_MINTABLE_V2.name]: FEATURE_EDITION_LAZY_MINTABLE_V2,\n    [FEATURE_EDITION_REVEALABLE.name]: FEATURE_EDITION_REVEALABLE,\n    [FEATURE_EDITION_SIGNATURE_MINTABLE.name]: FEATURE_EDITION_SIGNATURE_MINTABLE\n  }\n};\n\nconst FEATURE_ROYALTY = {\n  name: \"Royalty\",\n  namespace: \"royalty\",\n  docLinks: {\n    sdk: \"sdk.contractroyalty\",\n    contracts: \"Royalty\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IRoyalty_json__WEBPACK_IMPORTED_MODULE_55__],\n  features: {}\n};\nconst FEATURE_PRIMARY_SALE = {\n  name: \"PrimarySale\",\n  namespace: \"sales\",\n  docLinks: {\n    sdk: \"sdk.contractprimarysale\",\n    contracts: \"PrimarySale\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IPrimarySale_json__WEBPACK_IMPORTED_MODULE_54__],\n  features: {}\n};\nconst FEATURE_PLATFORM_FEE = {\n  name: \"PlatformFee\",\n  namespace: \"platformFee\",\n  docLinks: {\n    sdk: \"sdk.platformfee\",\n    contracts: \"PlatformFee\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IPlatformFee_json__WEBPACK_IMPORTED_MODULE_53__],\n  features: {}\n};\nconst FEATURE_PERMISSIONS_ENUMERABLE = {\n  name: \"PermissionsEnumerable\",\n  namespace: \"roles\",\n  docLinks: {\n    sdk: \"sdk.contractroles\",\n    contracts: \"PermissionsEnumerable\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IPermissionsEnumerable_json__WEBPACK_IMPORTED_MODULE_52__],\n  features: {}\n};\nconst FEATURE_PERMISSIONS = {\n  name: \"Permissions\",\n  namespace: \"roles\",\n  docLinks: {\n    sdk: \"sdk.contractroles\",\n    contracts: \"Permissions\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IPermissions_json__WEBPACK_IMPORTED_MODULE_51__],\n  features: {\n    [FEATURE_PERMISSIONS_ENUMERABLE.name]: FEATURE_PERMISSIONS_ENUMERABLE\n  }\n};\nconst FEATURE_METADATA = {\n  name: \"ContractMetadata\",\n  namespace: \"metadata\",\n  docLinks: {\n    sdk: \"sdk.contractmetadata\",\n    contracts: \"ContractMetadata\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IContractMetadata_json__WEBPACK_IMPORTED_MODULE_50__],\n  features: {}\n};\nconst FEATURE_APPURI = {\n  name: \"AppURI\",\n  namespace: \"appURI\",\n  docLinks: {\n    sdk: \"sdk.appURI\",\n    contracts: \"AppURI\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_IAppURI_json__WEBPACK_IMPORTED_MODULE_49__],\n  features: {}\n};\nconst FEATURE_OWNER = {\n  name: \"Ownable\",\n  namespace: \"owner\",\n  docLinks: {\n    sdk: \"sdk.owner\",\n    contracts: \"Ownable\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_Ownable_json__WEBPACK_IMPORTED_MODULE_56__],\n  features: {}\n};\nconst FEATURE_GASLESS = {\n  name: \"Gasless\",\n  namespace: \"gasless\",\n  docLinks: {\n    sdk: \"sdk.gaslesstransaction\",\n    // TODO add the correct name for this once it's added to portal\n    contracts: \"\"\n  },\n  abis: [_thirdweb_dev_contracts_js_dist_abis_ERC2771Context_json__WEBPACK_IMPORTED_MODULE_48__],\n  features: {}\n};\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\nconst SUPPORTED_FEATURES = {\n  [FEATURE_TOKEN.name]: FEATURE_TOKEN,\n  [FEATURE_NFT.name]: FEATURE_NFT,\n  [FEATURE_EDITION.name]: FEATURE_EDITION,\n  [FEATURE_ROYALTY.name]: FEATURE_ROYALTY,\n  [FEATURE_PLATFORM_FEE.name]: FEATURE_PLATFORM_FEE,\n  [FEATURE_PRIMARY_SALE.name]: FEATURE_PRIMARY_SALE,\n  [FEATURE_PERMISSIONS.name]: FEATURE_PERMISSIONS,\n  [FEATURE_METADATA.name]: FEATURE_METADATA,\n  [FEATURE_APPURI.name]: FEATURE_APPURI,\n  [FEATURE_OWNER.name]: FEATURE_OWNER,\n  [FEATURE_GASLESS.name]: FEATURE_GASLESS\n};\n\n/* eslint-disable eqeqeq */\nlet decoder;\ntry {\n  decoder = new TextDecoder();\n} catch (error) {}\nlet src;\nlet srcEnd;\nlet position = 0;\nconst LEGACY_RECORD_INLINE_ID = 105;\nconst RECORD_DEFINITIONS_ID = 0xdffe;\nconst RECORD_INLINE_ID = 0xdfff; // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'\nconst BUNDLED_STRINGS_ID = 0xdff9;\nconst PACKED_REFERENCE_TAG_ID = 6;\nconst STOP_CODE = {};\nlet currentDecoder = {};\nlet currentStructures;\nlet srcString;\nlet srcStringStart = 0;\nlet srcStringEnd = 0;\nlet bundledStrings;\nlet referenceMap;\nlet currentExtensions = [];\nlet currentExtensionRanges = [];\nlet packedValues;\nlet dataView;\nlet restoreMapsAsObject;\nlet defaultOptions = {\n  useRecords: false,\n  mapsAsObjects: true\n};\nlet sequentialMode = false;\nclass Decoder {\n  constructor(options) {\n    if (options) {\n      if ((options.keyMap || options._keyMap) && !options.useRecords) {\n        options.useRecords = false;\n        options.mapsAsObjects = true;\n      }\n      if (options.useRecords === false && options.mapsAsObjects === undefined) {\n        options.mapsAsObjects = true;\n      }\n      if (options.getStructures) {\n        options.getShared = options.getStructures;\n      }\n      if (options.getShared && !options.structures) {\n        (options.structures = []).uninitialized = true;\n      } // this is what we use to denote an uninitialized structures\n      if (options.keyMap) {\n        this.mapKey = new Map();\n        for (let [k, v] of Object.entries(options.keyMap)) {\n          this.mapKey.set(v, k);\n        }\n      }\n    }\n    Object.assign(this, options);\n  }\n  decodeKey(key) {\n    return this.keyMap ? this.mapKey.get(key) || key : key;\n  }\n  decode(source, end) {\n    if (src) {\n      // re-entrant execution, save the state and restore it after we do this decode\n      return saveState(() => {\n        clearSource();\n        return this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end);\n      });\n    }\n    srcEnd = end > -1 ? end : source.length;\n    position = 0;\n    srcStringEnd = 0;\n    srcString = null;\n    bundledStrings = null;\n    src = source;\n    // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n    // technique for getting data from a database where it can be copied into an existing buffer instead of creating\n    // new ones\n    try {\n      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));\n    } catch (error) {\n      // if it doesn't have a buffer, maybe it is the wrong type of object\n      src = null;\n      if (source instanceof Uint8Array) {\n        throw error;\n      }\n      throw new Error(\"Source must be a Uint8Array or Buffer but was a \" + (source && typeof source === \"object\" ? source.constructor.name : typeof source));\n    }\n    if (this instanceof Decoder) {\n      currentDecoder = this;\n      packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);\n      if (this.structures) {\n        currentStructures = this.structures;\n        return checkedRead();\n      } else if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n    } else {\n      currentDecoder = defaultOptions;\n      if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n      packedValues = null;\n    }\n    return checkedRead();\n  }\n}\nfunction checkedRead() {\n  try {\n    let result = read();\n    if (bundledStrings) {\n      if (position >= bundledStrings.postBundlePosition) {\n        let error = new Error(\"Unexpected bundle position\");\n        error.incomplete = true;\n        throw error;\n      }\n      // bundled strings to skip past\n      position = bundledStrings.postBundlePosition;\n      bundledStrings = null;\n    }\n    if (position == srcEnd) {\n      // finished reading this source, cleanup references\n      currentStructures = null;\n      src = null;\n      if (referenceMap) {\n        referenceMap = null;\n      }\n    } else if (position > srcEnd) {\n      // over read\n      let error = new Error(\"Unexpected end of CBOR data\");\n      error.incomplete = true;\n      throw error;\n    } else if (!sequentialMode) {\n      throw new Error(\"Data read, but end of buffer not reached\");\n    }\n    // else more to read, but we are reading sequentially, so don't clear source yet\n    return result;\n  } catch (error) {\n    clearSource();\n    if (error instanceof RangeError || error.message.startsWith(\"Unexpected end of buffer\")) {\n      error.incomplete = true;\n    }\n    throw error;\n  }\n}\nfunction read() {\n  let token = src[position++];\n  let majorType = token >> 5;\n  token = token & 0x1f;\n  if (token > 0x17) {\n    switch (token) {\n      case 0x18:\n        token = src[position++];\n        break;\n      case 0x19:\n        if (majorType == 7) {\n          return getFloat16();\n        }\n        token = dataView.getUint16(position);\n        position += 2;\n        break;\n      case 0x1a:\n        if (majorType == 7) {\n          let value = dataView.getFloat32(position);\n          if (currentDecoder.useFloat32 > 2) {\n            // this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n            let multiplier = mult10[(src[position] & 0x7f) << 1 | src[position + 1] >> 7];\n            position += 4;\n            return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;\n          }\n          position += 4;\n          return value;\n        }\n        token = dataView.getUint32(position);\n        position += 4;\n        break;\n      case 0x1b:\n        if (majorType == 7) {\n          let value = dataView.getFloat64(position);\n          position += 8;\n          return value;\n        }\n        if (majorType > 1) {\n          if (dataView.getUint32(position) > 0) {\n            throw new Error(\"JavaScript does not support arrays, maps, or strings with length over 4294967295\");\n          }\n          token = dataView.getUint32(position + 4);\n        } else if (currentDecoder.int64AsNumber) {\n          token = dataView.getUint32(position) * 0x100000000;\n          token += dataView.getUint32(position + 4);\n        } else {\n          token = dataView.getBigUint64(position);\n        }\n        position += 8;\n        break;\n      case 0x1f:\n        // indefinite length\n        switch (majorType) {\n          case 2: // byte string\n          case 3:\n            // text string\n            throw new Error(\"Indefinite length not supported for byte or text strings\");\n          case 4:\n            // array\n            let array = [];\n            let value,\n              i = 0;\n            while ((value = read()) != STOP_CODE) {\n              array[i++] = value;\n            }\n            return majorType == 4 ? array : majorType == 3 ? array.join(\"\") : Buffer.concat(array);\n          case 5:\n            // map\n            let key;\n            if (currentDecoder.mapsAsObjects) {\n              let object = {};\n              if (currentDecoder.keyMap) {\n                while ((key = read()) != STOP_CODE) {\n                  object[safeKey(currentDecoder.decodeKey(key))] = read();\n                }\n              } else {\n                while ((key = read()) != STOP_CODE) {\n                  object[safeKey(key)] = read();\n                }\n              }\n              return object;\n            } else {\n              if (restoreMapsAsObject) {\n                currentDecoder.mapsAsObjects = true;\n                restoreMapsAsObject = false;\n              }\n              let map = new Map();\n              if (currentDecoder.keyMap) {\n                while ((key = read()) != STOP_CODE) {\n                  map.set(currentDecoder.decodeKey(key), read());\n                }\n              } else {\n                while ((key = read()) != STOP_CODE) {\n                  map.set(key, read());\n                }\n              }\n              return map;\n            }\n          case 7:\n            return STOP_CODE;\n          default:\n            throw new Error(\"Invalid major type for indefinite length \" + majorType);\n        }\n      default:\n        throw new Error(\"Unknown token \" + token);\n    }\n  }\n  switch (majorType) {\n    case 0:\n      // positive int\n      return token;\n    case 1:\n      // negative int\n      return ~token;\n    case 2:\n      // buffer\n      return readBin(token);\n    case 3:\n      // string\n      if (srcStringEnd >= position) {\n        return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);\n      }\n      if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {\n        // for small blocks, avoiding the overhead of the extract call is helpful\n        let string = token < 16 ? shortStringInJS(token) : longStringInJS(token);\n        if (string != null) {\n          return string;\n        }\n      }\n      return readFixedString(token);\n    case 4:\n      // array\n      let array = new Array(token);\n      //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())\n      //else\n      for (let i = 0; i < token; i++) {\n        array[i] = read();\n      }\n      return array;\n    case 5:\n      // map\n      if (currentDecoder.mapsAsObjects) {\n        let object = {};\n        if (currentDecoder.keyMap) {\n          for (let i = 0; i < token; i++) {\n            object[safeKey(currentDecoder.decodeKey(read()))] = read();\n          }\n        } else {\n          for (let i = 0; i < token; i++) {\n            object[safeKey(read())] = read();\n          }\n        }\n        return object;\n      } else {\n        if (restoreMapsAsObject) {\n          currentDecoder.mapsAsObjects = true;\n          restoreMapsAsObject = false;\n        }\n        let map = new Map();\n        if (currentDecoder.keyMap) {\n          for (let i = 0; i < token; i++) {\n            map.set(currentDecoder.decodeKey(read()), read());\n          }\n        } else {\n          for (let i = 0; i < token; i++) {\n            map.set(read(), read());\n          }\n        }\n        return map;\n      }\n    case 6:\n      // extension\n      if (token >= BUNDLED_STRINGS_ID) {\n        let structure = currentStructures[token & 0x1fff]; // check record structures first\n        // At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))\n        if (structure) {\n          if (!structure.read) {\n            structure.read = createStructureReader(structure);\n          }\n          return structure.read();\n        }\n        if (token < 0x10000) {\n          if (token == RECORD_INLINE_ID) {\n            // we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n            return recordDefinition(read());\n          } else if (token == RECORD_DEFINITIONS_ID) {\n            let length = readJustLength();\n            let id = read();\n            for (let i = 2; i < length; i++) {\n              recordDefinition([id++, read()]);\n            }\n            return read();\n          } else if (token == BUNDLED_STRINGS_ID) {\n            return readBundleExt();\n          }\n          if (currentDecoder.getShared) {\n            loadShared();\n            structure = currentStructures[token & 0x1fff];\n            if (structure) {\n              if (!structure.read) {\n                structure.read = createStructureReader(structure);\n              }\n              return structure.read();\n            }\n          }\n        }\n      }\n      let extension = currentExtensions[token];\n      if (extension) {\n        if (extension.handlesRead) {\n          return extension(read);\n        } else {\n          return extension(read());\n        }\n      } else {\n        let input = read();\n        for (let i = 0; i < currentExtensionRanges.length; i++) {\n          let value = currentExtensionRanges[i](token, input);\n          if (value !== undefined) {\n            return value;\n          }\n        }\n        return new Tag(input, token);\n      }\n    case 7:\n      // fixed value\n      switch (token) {\n        case 0x14:\n          return false;\n        case 0x15:\n          return true;\n        case 0x16:\n          return null;\n        case 0x17:\n          return;\n        // undefined\n        case 0x1f:\n        default:\n          let packedValue = (packedValues || getPackedValues())[token];\n          if (packedValue !== undefined) {\n            return packedValue;\n          }\n          throw new Error(\"Unknown token \" + token);\n      }\n    default:\n      // negative int\n      if (isNaN(token)) {\n        let error = new Error(\"Unexpected end of CBOR data\");\n        error.incomplete = true;\n        throw error;\n      }\n      throw new Error(\"Unknown CBOR token \" + token);\n  }\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/;\nfunction createStructureReader(structure) {\n  function readObject() {\n    // get the array size from the header\n    let length = src[position++];\n    //let majorType = token >> 5\n    length = length & 0x1f;\n    if (length > 0x17) {\n      switch (length) {\n        case 0x18:\n          length = src[position++];\n          break;\n        case 0x19:\n          length = dataView.getUint16(position);\n          position += 2;\n          break;\n        case 0x1a:\n          length = dataView.getUint32(position);\n          position += 4;\n          break;\n        default:\n          throw new Error(\"Expected array header, but got \" + src[position - 1]);\n      }\n    }\n    // This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n    let compiledReader = this.compiledReader; // first look to see if we have the fast compiled function\n    while (compiledReader) {\n      // we have a fast compiled object literal reader\n      if (compiledReader.propertyCount === length) {\n        return compiledReader(read);\n      } // with the right length, so we use it\n      compiledReader = compiledReader.next; // see if there is another reader with the right length\n    }\n\n    if (this.slowReads++ >= 3) {\n      // create a fast compiled reader\n      let array = this.length == length ? this : this.slice(0, length);\n      compiledReader = currentDecoder.keyMap ? new Function(\"r\", \"return {\" + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + \":r()\" : \"[\" + JSON.stringify(k) + \"]:r()\").join(\",\") + \"}\") : new Function(\"r\", \"return {\" + array.map(key => validName.test(key) ? safeKey(key) + \":r()\" : \"[\" + JSON.stringify(key) + \"]:r()\").join(\",\") + \"}\");\n      if (this.compiledReader) {\n        compiledReader.next = this.compiledReader;\n      } // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure\n      compiledReader.propertyCount = length;\n      this.compiledReader = compiledReader;\n      return compiledReader(read);\n    }\n    let object = {};\n    if (currentDecoder.keyMap) {\n      for (let i = 0; i < length; i++) {\n        object[safeKey(currentDecoder.decodeKey(this[i]))] = read();\n      }\n    } else {\n      for (let i = 0; i < length; i++) {\n        object[safeKey(this[i])] = read();\n      }\n    }\n    return object;\n  }\n  structure.slowReads = 0;\n  return readObject;\n}\nfunction safeKey(key) {\n  return key === \"__proto__\" ? \"__proto_\" : key;\n}\nlet readFixedString = readStringJS;\nfunction readStringJS(length) {\n  let result;\n  if (length < 16) {\n    if (result = shortStringInJS(length)) {\n      return result;\n    }\n  }\n  if (length > 64 && decoder) {\n    return decoder.decode(src.subarray(position, position += length));\n  }\n  const end = position + length;\n  const units = [];\n  result = \"\";\n  while (position < end) {\n    const byte1 = src[position++];\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      const byte2 = src[position++] & 0x3f;\n      units.push((byte1 & 0x1f) << 6 | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      const byte2 = src[position++] & 0x3f;\n      const byte3 = src[position++] & 0x3f;\n      units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      const byte2 = src[position++] & 0x3f;\n      const byte3 = src[position++] & 0x3f;\n      const byte4 = src[position++] & 0x3f;\n      let unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(unit >>> 10 & 0x3ff | 0xd800);\n        unit = 0xdc00 | unit & 0x3ff;\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n    if (units.length >= 0x1000) {\n      result += fromCharCode.apply(String, units);\n      units.length = 0;\n    }\n  }\n  if (units.length > 0) {\n    result += fromCharCode.apply(String, units);\n  }\n  return result;\n}\nlet fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n  let start = position;\n  let bytes = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const byte = src[position++];\n    if ((byte & 0x80) > 0) {\n      position = start;\n      return;\n    }\n    bytes[i] = byte;\n  }\n  return fromCharCode.apply(String, bytes);\n}\nfunction shortStringInJS(length) {\n  if (length < 4) {\n    if (length < 2) {\n      if (length === 0) {\n        return \"\";\n      } else {\n        let a = src[position++];\n        if ((a & 0x80) > 1) {\n          position -= 1;\n          return;\n        }\n        return fromCharCode(a);\n      }\n    } else {\n      let a = src[position++];\n      let b = src[position++];\n      if ((a & 0x80) > 0 || (b & 0x80) > 0) {\n        position -= 2;\n        return;\n      }\n      if (length < 3) {\n        return fromCharCode(a, b);\n      }\n      let c = src[position++];\n      if ((c & 0x80) > 0) {\n        position -= 3;\n        return;\n      }\n      return fromCharCode(a, b, c);\n    }\n  } else {\n    let a = src[position++];\n    let b = src[position++];\n    let c = src[position++];\n    let d = src[position++];\n    if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n      position -= 4;\n      return;\n    }\n    if (length < 6) {\n      if (length === 4) {\n        return fromCharCode(a, b, c, d);\n      } else {\n        let e = src[position++];\n        if ((e & 0x80) > 0) {\n          position -= 5;\n          return;\n        }\n        return fromCharCode(a, b, c, d, e);\n      }\n    } else if (length < 8) {\n      let e = src[position++];\n      let f = src[position++];\n      if ((e & 0x80) > 0 || (f & 0x80) > 0) {\n        position -= 6;\n        return;\n      }\n      if (length < 7) {\n        return fromCharCode(a, b, c, d, e, f);\n      }\n      let g = src[position++];\n      if ((g & 0x80) > 0) {\n        position -= 7;\n        return;\n      }\n      return fromCharCode(a, b, c, d, e, f, g);\n    } else {\n      let e = src[position++];\n      let f = src[position++];\n      let g = src[position++];\n      let h = src[position++];\n      if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n        position -= 8;\n        return;\n      }\n      if (length < 10) {\n        if (length === 8) {\n          return fromCharCode(a, b, c, d, e, f, g, h);\n        } else {\n          let i = src[position++];\n          if ((i & 0x80) > 0) {\n            position -= 9;\n            return;\n          }\n          return fromCharCode(a, b, c, d, e, f, g, h, i);\n        }\n      } else if (length < 12) {\n        let i = src[position++];\n        let j = src[position++];\n        if ((i & 0x80) > 0 || (j & 0x80) > 0) {\n          position -= 10;\n          return;\n        }\n        if (length < 11) {\n          return fromCharCode(a, b, c, d, e, f, g, h, i, j);\n        }\n        let k = src[position++];\n        if ((k & 0x80) > 0) {\n          position -= 11;\n          return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n      } else {\n        let i = src[position++];\n        let j = src[position++];\n        let k = src[position++];\n        let l = src[position++];\n        if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n          position -= 12;\n          return;\n        }\n        if (length < 14) {\n          if (length === 12) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);\n          } else {\n            let m = src[position++];\n            if ((m & 0x80) > 0) {\n              position -= 13;\n              return;\n            }\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n          }\n        } else {\n          let m = src[position++];\n          let n = src[position++];\n          if ((m & 0x80) > 0 || (n & 0x80) > 0) {\n            position -= 14;\n            return;\n          }\n          if (length < 15) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n          }\n          let o = src[position++];\n          if ((o & 0x80) > 0) {\n            position -= 15;\n            return;\n          }\n          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n        }\n      }\n    }\n  }\n}\nfunction readBin(length) {\n  return currentDecoder.copyBuffers ?\n  // specifically use the copying slice (not the node one)\n  Uint8Array.prototype.slice.call(src, position, position += length) : src.subarray(position, position += length);\n}\nlet f32Array = new Float32Array(1);\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4);\nfunction getFloat16() {\n  let byte0 = src[position++];\n  let byte1 = src[position++];\n  let exponent = (byte0 & 0x7f) >> 2;\n  if (exponent === 0x1f) {\n    // specials\n    if (byte1 || byte0 & 3) {\n      return NaN;\n    }\n    return byte0 & 0x80 ? -Infinity : Infinity;\n  }\n  if (exponent === 0) {\n    // sub-normals\n    // significand with 10 fractional bits and divided by 2^14\n    let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);\n    return byte0 & 0x80 ? -abs : abs;\n  }\n  u8Array[3] = byte0 & 0x80 |\n  // sign bit\n  (exponent >> 1) + 56; // 4 of 5 of the exponent bits, re-offset-ed\n  u8Array[2] = (byte0 & 7) << 5 |\n  // last exponent bit and first two mantissa bits\n  byte1 >> 3; // next 5 bits of mantissa\n  u8Array[1] = byte1 << 5; // last three bits of mantissa\n  u8Array[0] = 0;\n  return f32Array[0];\n}\nclass Tag {\n  constructor(value, tag) {\n    this.value = value;\n    this.tag = tag;\n  }\n}\ncurrentExtensions[0] = dateString => {\n  // string date extension\n  return new Date(dateString);\n};\ncurrentExtensions[1] = epochSec => {\n  // numeric date extension\n  return new Date(Math.round(epochSec * 1000));\n};\ncurrentExtensions[2] = buffer => {\n  // bigint extension\n  let value = BigInt(0);\n  for (let i = 0, l = buffer.byteLength; i < l; i++) {\n    value = BigInt(buffer[i]) + value << BigInt(8);\n  }\n  return value;\n};\ncurrentExtensions[3] = buffer => {\n  // negative bigint extension\n  return BigInt(-1) - currentExtensions[2](buffer);\n};\ncurrentExtensions[4] = fraction => {\n  // best to reparse to maintain accuracy\n  return Number(fraction[1] + \"e\" + fraction[0]);\n};\ncurrentExtensions[5] = fraction => {\n  // probably not sufficiently accurate\n  return fraction[1] * Math.exp(fraction[0] * Math.log(2));\n};\n\n// the registration of the record definition extension\nconst recordDefinition = definition => {\n  let id = definition[0] - 0xe000;\n  let structure = definition[1];\n  let existingStructure = currentStructures[id];\n  if (existingStructure && existingStructure.isShared) {\n    (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;\n  }\n  currentStructures[id] = structure;\n  structure.read = createStructureReader(structure);\n  let object = {};\n  if (currentDecoder.keyMap) {\n    for (let i = 2, l = definition.length; i < l; i++) {\n      let key = currentDecoder.decodeKey(structure[i - 2]);\n      object[safeKey(key)] = definition[i];\n    }\n  } else {\n    for (let i = 2, l = definition.length; i < l; i++) {\n      let key = structure[i - 2];\n      object[safeKey(key)] = definition[i];\n    }\n  }\n  return object;\n};\ncurrentExtensions[LEGACY_RECORD_INLINE_ID] = recordDefinition;\ncurrentExtensions[14] = value => {\n  if (bundledStrings) {\n    return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value);\n  }\n  return new Tag(value, 14);\n};\ncurrentExtensions[15] = value => {\n  if (bundledStrings) {\n    return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);\n  }\n  return new Tag(value, 15);\n};\nlet glbl = {\n  Error,\n  RegExp\n};\ncurrentExtensions[27] = data => {\n  // http://cbor.schmorp.de/generic-object\n  return (glbl[data[0]] || Error)(data[1], data[2]);\n};\nconst packedTable = _read => {\n  if (src[position++] != 0x84) {\n    throw new Error(\"Packed values structure must be followed by a 4 element array\");\n  }\n  let newPackedValues = _read(); // packed values\n  packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;\n  packedValues.prefixes = _read();\n  packedValues.suffixes = _read();\n  return _read(); // read the rump\n};\n\npackedTable.handlesRead = true;\ncurrentExtensions[51] = packedTable;\ncurrentExtensions[PACKED_REFERENCE_TAG_ID] = data => {\n  // packed reference\n  if (!packedValues) {\n    if (currentDecoder.getShared) {\n      loadShared();\n    } else {\n      return new Tag(data, PACKED_REFERENCE_TAG_ID);\n    }\n  }\n  if (typeof data === \"number\") {\n    return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];\n  }\n  throw new Error(\"No support for non-integer packed references yet\");\n};\ncurrentExtensions[25] = id => {\n  return stringRefs[id];\n};\ncurrentExtensions[256] = _read => {\n  stringRefs = [];\n  try {\n    return _read();\n  } finally {\n    stringRefs = null;\n  }\n};\ncurrentExtensions[256].handlesRead = true;\ncurrentExtensions[28] = _read => {\n  // shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n  if (!referenceMap) {\n    referenceMap = new Map();\n    referenceMap.id = 0;\n  }\n  let id = referenceMap.id++;\n  let token = src[position];\n  let target;\n  // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n  // ahead past references to record structure definitions\n  if (token >> 5 == 4) {\n    target = [];\n  } else {\n    target = {};\n  }\n  let refEntry = {\n    target\n  }; // a placeholder object\n  referenceMap.set(id, refEntry);\n  let targetProperties = _read(); // read the next value as the target object to id\n  if (refEntry.used) {\n    // there is a cycle, so we have to assign properties to original target\n    return Object.assign(target, targetProperties);\n  }\n  refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one\n  return targetProperties; // no cycle, can just use the returned read object\n};\n\ncurrentExtensions[28].handlesRead = true;\ncurrentExtensions[29] = id => {\n  // sharedref http://cbor.schmorp.de/value-sharing (for structured clones)\n  let refEntry = referenceMap.get(id);\n  refEntry.used = true;\n  return refEntry.target;\n};\ncurrentExtensions[258] = array => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n(currentExtensions[259] = _read => {\n  // https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec\n  // for decoding as a standard Map\n  if (currentDecoder.mapsAsObjects) {\n    currentDecoder.mapsAsObjects = false;\n    restoreMapsAsObject = true;\n  }\n  return _read();\n}).handlesRead = true;\nfunction combine(a, b) {\n  if (typeof a === \"string\") {\n    return a + b;\n  }\n  if (a instanceof Array) {\n    return a.concat(b);\n  }\n  return Object.assign({}, a, b);\n}\nfunction getPackedValues() {\n  if (!packedValues) {\n    if (currentDecoder.getShared) {\n      loadShared();\n    } else {\n      throw new Error(\"No packed values available\");\n    }\n  }\n  return packedValues;\n}\nconst SHARED_DATA_TAG_ID = 0x53687264; // ascii 'Shrd'\ncurrentExtensionRanges.push((tag, input) => {\n  if (tag >= 225 && tag <= 255) {\n    return combine(getPackedValues().prefixes[tag - 224], input);\n  }\n  if (tag >= 28704 && tag <= 32767) {\n    return combine(getPackedValues().prefixes[tag - 28672], input);\n  }\n  if (tag >= 1879052288 && tag <= 2147483647) {\n    return combine(getPackedValues().prefixes[tag - 1879048192], input);\n  }\n  if (tag >= 216 && tag <= 223) {\n    return combine(input, getPackedValues().suffixes[tag - 216]);\n  }\n  if (tag >= 27647 && tag <= 28671) {\n    return combine(input, getPackedValues().suffixes[tag - 27639]);\n  }\n  if (tag >= 1811940352 && tag <= 1879048191) {\n    return combine(input, getPackedValues().suffixes[tag - 1811939328]);\n  }\n  if (tag == SHARED_DATA_TAG_ID) {\n    // we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n    return {\n      packedValues: packedValues,\n      structures: currentStructures.slice(0),\n      version: input\n    };\n  }\n  if (tag == 55799) {\n    // self-descriptive CBOR tag, just return input value\n    return input;\n  }\n});\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;\nconst typedArrays = [Uint8Array];\nconst typedArrayTags = [64];\nfor (let i = 0; i < typedArrays.length; i++) {\n  registerTypedArray(typedArrays[i], typedArrayTags[i]);\n}\nfunction registerTypedArray(TypedArray, tag) {\n  let dvMethod = \"get\" + TypedArray.name.slice(0, -5);\n  if (typeof TypedArray !== \"function\") {\n    TypedArray = null;\n  }\n  let bytesPerElement = TypedArray.BYTES_PER_ELEMENT;\n  for (let littleEndian = 0; littleEndian < 2; littleEndian++) {\n    if (!littleEndian && bytesPerElement == 1) {\n      continue;\n    }\n    let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3;\n    currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine ? buffer => {\n      if (!TypedArray) {\n        throw new Error(\"Could not find typed array for code \" + tag);\n      }\n      // we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n      return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer);\n    } : buffer => {\n      if (!TypedArray) {\n        throw new Error(\"Could not find typed array for code \" + tag);\n      }\n      let dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n      let elements = buffer.length >> sizeShift;\n      let ta = new TypedArray(elements);\n      let method = dv[dvMethod];\n      for (let i = 0; i < elements; i++) {\n        ta[i] = method.call(dv, i << sizeShift, littleEndian);\n      }\n      return ta;\n    };\n  }\n}\nfunction readBundleExt() {\n  let length = readJustLength();\n  let bundlePosition = position + read();\n  for (let i = 2; i < length; i++) {\n    // skip past bundles that were already read\n    let bundleLength = readJustLength(); // this will increment position, so must add to position afterwards\n    position += bundleLength;\n  }\n  let dataPosition = position;\n  position = bundlePosition;\n  bundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())];\n  bundledStrings.position0 = 0;\n  bundledStrings.position1 = 0;\n  bundledStrings.postBundlePosition = position;\n  position = dataPosition;\n  return read();\n}\nfunction readJustLength() {\n  let token = src[position++] & 0x1f;\n  if (token > 0x17) {\n    switch (token) {\n      case 0x18:\n        token = src[position++];\n        break;\n      case 0x19:\n        token = dataView.getUint16(position);\n        position += 2;\n        break;\n      case 0x1a:\n        token = dataView.getUint32(position);\n        position += 4;\n        break;\n    }\n  }\n  return token;\n}\nfunction loadShared() {\n  if (currentDecoder.getShared) {\n    let sharedData = saveState(() => {\n      // save the state in case getShared modifies our buffer\n      src = null;\n      return currentDecoder.getShared();\n    }) || {};\n    let updatedStructures = sharedData.structures || [];\n    currentDecoder.sharedVersion = sharedData.version;\n    packedValues = currentDecoder.sharedValues = sharedData.packedValues;\n    if (currentStructures === true) {\n      currentDecoder.structures = currentStructures = updatedStructures;\n    } else {\n      currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));\n    }\n  }\n}\nfunction saveState(callback) {\n  let savedSrcEnd = srcEnd;\n  let savedPosition = position;\n  let savedSrcStringStart = srcStringStart;\n  let savedSrcStringEnd = srcStringEnd;\n  let savedSrcString = srcString;\n  let savedReferenceMap = referenceMap;\n  let savedBundledStrings = bundledStrings;\n\n  // TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n  let savedSrc = new Uint8Array(src.slice(0, srcEnd)); // we copy the data in case it changes while external data is processed\n  let savedStructures = currentStructures;\n  let savedDecoder = currentDecoder;\n  let savedSequentialMode = sequentialMode;\n  let value = callback();\n  srcEnd = savedSrcEnd;\n  position = savedPosition;\n  srcStringStart = savedSrcStringStart;\n  srcStringEnd = savedSrcStringEnd;\n  srcString = savedSrcString;\n  referenceMap = savedReferenceMap;\n  bundledStrings = savedBundledStrings;\n  src = savedSrc;\n  sequentialMode = savedSequentialMode;\n  currentStructures = savedStructures;\n  currentDecoder = savedDecoder;\n  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);\n  return value;\n}\nfunction clearSource() {\n  src = null;\n  referenceMap = null;\n  currentStructures = null;\n}\nconst mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n  mult10[i] = Number(\"1e\" + Math.floor(45.15 - i * 0.30103));\n}\nconst defaultDecoder = new Decoder({\n  useRecords: false\n});\nconst decode = defaultDecoder.decode;\n\n/**\n * @internal\n * @param abi\n * @param feature\n */\nfunction matchesAbiInterface(abi, feature) {\n  // returns true if all the functions in `interfaceToMatch` are found in `contract` (removing any duplicates)\n  return hasMatchingAbi(abi, feature.abis);\n}\n\n/**\n * @internal\n * @param contractWrapper\n * @param abi\n * @returns\n */\nfunction matchesPrebuiltAbi(contractWrapper, abi) {\n  return hasMatchingAbi(contractWrapper.abi, [abi]);\n}\n\n/**\n * @internal\n * @param contractAbi\n * @param featureAbis\n * @returns\n */\nfunction hasMatchingAbi(contractAbi, featureAbis) {\n  const contractFn = extractFunctionsFromAbi(contractAbi);\n  const interfaceFn = featureAbis.flatMap(i => extractFunctionsFromAbi(i));\n  // match every function and their arguments\n  const intersection = contractFn.filter(fn => {\n    const match = interfaceFn.find(iFn => iFn.name === fn.name && iFn.inputs.length === fn.inputs.length && iFn.inputs.every((i, index) => {\n      if (i.type === \"tuple\" || i.type === \"tuple[]\") {\n        // check that all properties in the tuple are the same type\n        return i.type === fn.inputs[index].type && i.components?.every((c, cIndex) => {\n          return c.type === fn.inputs[index].components?.[cIndex]?.type;\n        });\n      }\n      return i.type === fn.inputs[index].type;\n    }));\n    return match !== undefined;\n  });\n  return intersection.length === interfaceFn.length;\n}\n\n/**\n * @internal\n */\nasync function extractConstructorParams(predeployMetadataUri, storage) {\n  const meta = await fetchPreDeployMetadata(predeployMetadataUri, storage);\n  return extractConstructorParamsFromAbi(meta.abi);\n}\n\n/**\n * @internal\n * @param predeployMetadataUri\n * @param storage\n */\nasync function extractFunctions(predeployMetadataUri, storage) {\n  const metadata = await fetchPreDeployMetadata(predeployMetadataUri, storage);\n  return extractFunctionsFromAbi(metadata.abi, metadata.metadata);\n}\n\n/**\n * @internal\n * @param name\n * @param metadata\n * @param type\n */\nfunction extractCommentFromMetadata(name, metadata, type) {\n  return metadata?.output?.userdoc?.[type]?.[Object.keys(metadata?.output?.userdoc[type] || {}).find(fn => fn.includes(name || \"unknown\")) || \"\"]?.notice || metadata?.output?.devdoc?.[type]?.[Object.keys(metadata?.output?.devdoc[type] || {}).find(fn => fn.includes(name || \"unknown\")) || \"\"]?.details;\n}\n\n/**\n *\n * @param abi\n * @returns\n * @internal\n */\nfunction extractConstructorParamsFromAbi(abi) {\n  for (const input of abi) {\n    if (input.type === \"constructor\") {\n      return input.inputs || [];\n    }\n  }\n  return [];\n}\n\n/**\n *\n * @param abi\n * @param functionName\n * @returns\n * @internal\n */\nfunction extractFunctionParamsFromAbi(abi, functionName) {\n  for (const input of abi) {\n    if (input.type === \"function\" && input.name === functionName) {\n      return input.inputs || [];\n    }\n  }\n  return [];\n}\n\n/**\n * @internal\n * @param abi\n * @param metadata\n */\nfunction extractFunctionsFromAbi(abi, metadata) {\n  const functions = (abi || []).filter(el => el.type === \"function\");\n  const parsed = [];\n  for (const f of functions) {\n    const doc = extractCommentFromMetadata(f.name, metadata, \"methods\");\n    const args = f.inputs?.map(i => `${i.name || \"key\"}: ${toJSType(i)}`)?.join(\", \") || \"\";\n    const fargs = args ? `, ${args}` : \"\";\n    const out = f.outputs?.map(o => toJSType(o, true))?.join(\", \");\n    const promise = out ? `: Promise<${out}>` : `: Promise<TransactionResult>`;\n    const signature = `contract.call(\"${f.name}\"${fargs})${promise}`;\n    parsed.push({\n      inputs: f.inputs || [],\n      outputs: f.outputs || [],\n      name: f.name || \"unknown\",\n      signature,\n      stateMutability: f.stateMutability || \"\",\n      comment: doc\n    });\n  }\n  return parsed;\n}\n\n/**\n * @internal\n * @param abi\n * @param metadata\n */\nfunction extractEventsFromAbi(abi, metadata) {\n  const events = (abi || []).filter(el => el.type === \"event\");\n  const parsed = [];\n  for (const e of events) {\n    const doc = extractCommentFromMetadata(e.name, metadata, \"events\");\n    parsed.push({\n      inputs: e.inputs || [],\n      outputs: e.outputs || [],\n      name: e.name || \"unknown\",\n      comment: doc\n    });\n  }\n  return parsed;\n}\nfunction toJSType(contractType) {\n  let isReturnType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let withName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let jsType = contractType.type;\n  let isArray = false;\n  if (jsType.endsWith(\"[]\")) {\n    isArray = true;\n    jsType = jsType.slice(0, -2);\n  }\n  if (jsType.startsWith(\"bytes\")) {\n    jsType = \"BytesLike\";\n  }\n  if (jsType.startsWith(\"uint\") || jsType.startsWith(\"int\")) {\n    jsType = isReturnType ? \"BigNumber\" : \"BigNumberish\";\n  }\n  if (jsType.startsWith(\"bool\")) {\n    jsType = \"boolean\";\n  }\n  if (jsType === \"address\") {\n    jsType = \"string\";\n  }\n  if (jsType === \"tuple\") {\n    if (contractType.components) {\n      jsType = `{ ${contractType.components.map(a => toJSType(a, false, true)).join(\", \")} }`;\n    }\n  }\n  if (isArray) {\n    jsType += \"[]\";\n  }\n  if (withName) {\n    jsType = `${contractType.name}: ${jsType}`;\n  }\n  return jsType;\n}\n\n/**\n * @internal\n * @param bytecode\n */\nfunction extractMinimalProxyImplementationAddress(bytecode) {\n  // EIP-1167 clone minimal proxy - https://eips.ethereum.org/EIPS/eip-1167\n  if (bytecode.startsWith(\"0x363d3d373d3d3d363d73\")) {\n    const implementationAddress = bytecode.slice(22, 62);\n    return `0x${implementationAddress}`;\n  }\n\n  // Minimal Proxy with receive() from 0xSplits - https://github.com/0xSplits/splits-contracts/blob/c7b741926ec9746182d0d1e2c4c2046102e5d337/contracts/libraries/Clones.sol\n  if (bytecode.startsWith(\"0x36603057343d5230\")) {\n    // +40 = size of addr\n    const implementationAddress = bytecode.slice(122, 122 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  // 0age's minimal proxy - https://medium.com/coinmonks/the-more-minimal-proxy-5756ae08ee48\n  if (bytecode.startsWith(\"0x3d3d3d3d363d3d37363d73\")) {\n    // +40 = size of addr\n    const implementationAddress = bytecode.slice(24, 24 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  // vyper's minimal proxy (uniswap v1) - https://etherscan.io/address/0x09cabec1ead1c0ba254b09efb3ee13841712be14#code\n  if (bytecode.startsWith(\"0x366000600037611000600036600073\")) {\n    const implementationAddress = bytecode.slice(32, 32 + 40);\n    return `0x${implementationAddress}`;\n  }\n  return undefined;\n}\n\n/**\n * @internal\n * @param address\n * @param provider\n */\nasync function resolveContractUriFromAddress(address, provider) {\n  const bytecode = await provider.getCode(address);\n  if (bytecode === \"0x\") {\n    const chain = await provider.getNetwork();\n    throw new Error(`Contract at ${address} does not exist on chain '${chain.name}' (chainId: ${chain.chainId})`);\n  }\n  try {\n    const implementationAddress = extractMinimalProxyImplementationAddress(bytecode);\n    if (implementationAddress) {\n      return await resolveContractUriFromAddress(implementationAddress, provider);\n    }\n  } catch (e) {\n    // ignore\n  }\n\n  // EIP-1967 proxy storage slots - https://eips.ethereum.org/EIPS/eip-1967\n  try {\n    const proxyStorage = await provider.getStorageAt(address, ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(\"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\"));\n    const implementationAddress = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.hexStripZeros(proxyStorage);\n    if (implementationAddress !== \"0x\") {\n      return await resolveContractUriFromAddress(implementationAddress, provider);\n    }\n  } catch (e) {\n    // ignore\n  }\n  // TODO support other types of proxies\n  return await extractIPFSHashFromBytecode(bytecode);\n}\n\n/**\n * @internal\n * @param bytecode\n */\nfunction extractIPFSHashFromBytecode(bytecode) {\n  const numericBytecode = hexToBytes(bytecode);\n  const cborLength = numericBytecode[numericBytecode.length - 2] * 0x100 + numericBytecode[numericBytecode.length - 1];\n  const bytecodeBuffer = Uint8Array.from(numericBytecode.slice(numericBytecode.length - 2 - cborLength, -2));\n  const cborData = decode(bytecodeBuffer);\n  if (\"ipfs\" in cborData && cborData[\"ipfs\"]) {\n    try {\n      return `ipfs://${bs58__WEBPACK_IMPORTED_MODULE_37___default().encode(cborData[\"ipfs\"])}`;\n    } catch (e) {\n      console.warn(\"feature-detection ipfs cbor failed\", e);\n    }\n  }\n  return undefined;\n}\n\n/**\n * @internal\n * @param hex\n */\nfunction hexToBytes(hex) {\n  hex = hex.toString(16);\n  if (!hex.startsWith(\"0x\")) {\n    hex = `0x${hex}`;\n  }\n  if (!isHexStrict(hex)) {\n    throw new Error(`Given value \"${hex}\" is not a valid hex string.`);\n  }\n  hex = hex.replace(/^0x/i, \"\");\n  const bytes = [];\n  for (let c = 0; c < hex.length; c += 2) {\n    bytes.push(parseInt(hex.slice(c, c + 2), 16));\n  }\n  return bytes;\n}\n\n/**\n * @internal\n * @param hex\n */\nfunction isHexStrict(hex) {\n  return (typeof hex === \"string\" || typeof hex === \"number\") && /^(-)?0x[0-9a-f]*$/i.test(hex.toString());\n}\n\n/**\n * @internal\n * @param address\n * @param provider\n * @param storage\n */\nasync function fetchContractMetadataFromAddress(address, provider, storage) {\n  const compilerMetadataUri = await resolveContractUriFromAddress(address, provider);\n  if (!compilerMetadataUri) {\n    throw new Error(`Could not resolve metadata for contract at ${address}`);\n  }\n  return await fetchContractMetadata(compilerMetadataUri, storage);\n}\n\n/**\n * @internal\n * @param compilerMetadataUri\n * @param storage\n */\nasync function fetchContractMetadata(compilerMetadataUri, storage) {\n  const metadata = await storage.downloadJSON(compilerMetadataUri);\n  const abi = AbiSchema.parse(metadata.output.abi);\n  const compilationTarget = metadata.settings.compilationTarget;\n  const targets = Object.keys(compilationTarget);\n  const name = compilationTarget[targets[0]];\n  const info = ContractInfoSchema.parse({\n    title: metadata.output.devdoc.title,\n    author: metadata.output.devdoc.author,\n    details: metadata.output.devdoc.detail,\n    notice: metadata.output.userdoc.notice\n  });\n  const licenses = [...new Set(Object.entries(metadata.sources).map(_ref => {\n    let [, src] = _ref;\n    return src.license;\n  }))];\n  return {\n    name,\n    abi,\n    metadata,\n    info,\n    licenses\n  };\n}\n\n/**\n * @internal\n * @param publishedMetadata\n * @param storage\n */\nasync function fetchSourceFilesFromMetadata(publishedMetadata, storage) {\n  return await Promise.all(Object.entries(publishedMetadata.metadata.sources).map(async _ref2 => {\n    let [path, info] = _ref2;\n    const urls = info.urls;\n    const ipfsLink = urls ? urls.find(url => url.includes(\"ipfs\")) : undefined;\n    if (ipfsLink) {\n      const ipfsHash = ipfsLink.split(\"ipfs/\")[1];\n      // 5 sec timeout for sources that haven't been uploaded to ipfs\n      const timeout = new Promise((_r, rej) => setTimeout(() => rej(\"timeout\"), 5000));\n      const source = await Promise.race([(await storage.download(`ipfs://${ipfsHash}`)).text(), timeout]);\n      return {\n        filename: path,\n        source\n      };\n    } else {\n      return {\n        filename: path,\n        source: info.content || \"Could not find source for this contract\"\n      };\n    }\n  }));\n}\n\n/**\n * @internal\n * @param publishMetadataUri\n * @param storage\n */\nasync function fetchRawPredeployMetadata(publishMetadataUri, storage) {\n  return PreDeployMetadata.parse(JSON.parse(await (await storage.download(publishMetadataUri)).text()));\n}\n\n/**\n * Fetch the metadata coming from CLI, this is before deploying or releasing the contract.\n * @internal\n * @param publishMetadataUri\n * @param storage\n */\nasync function fetchPreDeployMetadata(publishMetadataUri, storage) {\n  const rawMeta = await fetchRawPredeployMetadata(publishMetadataUri, storage);\n  const deployBytecode = await (await storage.download(rawMeta.bytecodeUri)).text();\n  const parsedMeta = await fetchContractMetadata(rawMeta.metadataUri, storage);\n  return PreDeployMetadataFetchedSchema.parse({\n    ...rawMeta,\n    ...parsedMeta,\n    bytecode: deployBytecode\n  });\n}\n\n/**\n * Fetch and parse the full metadata AFTER creating a release, with all the extra information (version, readme, etc)\n * @internal\n * @param publishMetadataUri\n * @param storage\n */\nasync function fetchExtendedReleaseMetadata(publishMetadataUri, storage) {\n  const meta = await (await storage.download(publishMetadataUri)).text();\n  return FullPublishMetadataSchemaOutput.parse(JSON.parse(meta));\n}\n\n/**\n * Processes ALL supported features and sets whether the passed in abi supports each individual feature\n * @internal\n * @param abi\n * @param features\n * @returns the nested struct of all features and whether they're detected in the abi\n */\nfunction detectFeatures(abi) {\n  let features = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SUPPORTED_FEATURES;\n  const results = {};\n  for (const featureKey in features) {\n    const feature = features[featureKey];\n    const enabled = matchesAbiInterface(abi, feature);\n    const childResults = detectFeatures(abi, feature.features);\n    results[featureKey] = {\n      ...feature,\n      features: childResults,\n      enabled\n    };\n  }\n  return results;\n}\nfunction extractFeatures(input, enabledExtensions) {\n  if (!input) {\n    return;\n  }\n  for (const extensionKey in input) {\n    const extension = input[extensionKey];\n    // if extension is enabled, then add it to enabledFeatures\n    if (extension.enabled) {\n      enabledExtensions.push(extension);\n    }\n    // recurse\n    extractFeatures(extension.features, enabledExtensions);\n  }\n}\n\n/**\n * Return all the detected features in the abi\n * @param abi - parsed array of abi entries\n * @returns array of all detected extensions with full information on each feature\n * @public\n */\nfunction getAllDetectedFeatures(abi) {\n  const features = [];\n  extractFeatures(detectFeatures(abi), features);\n  return features;\n}\n\n/**\n * Return all the detected features names in the abi\n * @param abi - parsed array of abi entries\n * @returns array of all detected features names\n * @public\n */\nfunction getAllDetectedFeatureNames(abi) {\n  const features = [];\n  extractFeatures(detectFeatures(abi), features);\n  return features.map(f => f.name);\n}\n\n/**\n * Checks whether the given ABI supports a given feature\n * @internal\n * @param abi\n * @param featureName\n */\nfunction isFeatureEnabled(abi, featureName) {\n  const features = detectFeatures(abi);\n  return _featureEnabled(features, featureName);\n}\n\n/**\n * Checks whether the given DetectableFeature is defined\n * @internal\n * @param namespace The namespace to check\n * @param feature The corresponding feature\n */\nfunction assertEnabled(namespace, feature) {\n  if (!namespace) {\n    throw new ExtensionNotImplementedError(feature);\n  }\n  return namespace;\n}\n\n/**\n * Type guard for contractWrappers depending on passed feature name\n * @internal\n * @param contractWrapper\n * @param featureName\n */\nfunction detectContractFeature(contractWrapper, featureName) {\n  return isFeatureEnabled(AbiSchema.parse(contractWrapper.abi), featureName);\n}\n\n/**\n * Searches the feature map for featureName and returns whether its enabled\n * @internal\n * @param features\n * @param featureName\n */\nfunction _featureEnabled(features, featureName) {\n  const keys = Object.keys(features);\n  if (!keys.includes(featureName)) {\n    let found = false;\n    for (const key of keys) {\n      const f = features[key];\n      found = _featureEnabled(f.features, featureName);\n      if (found) {\n        break;\n      }\n    }\n    return found;\n  }\n  const feature = features[featureName];\n  return feature.enabled;\n}\n\n/**\n * @internal\n * @param contractWrapper\n * @param functionName\n */\nfunction hasFunction(functionName, contractWrapper) {\n  return functionName in contractWrapper.readContract.functions;\n}\n\nconst MAX_LENGTH = 256;\nconst NUMERIC_IDENTIFIER = \"0|[1-9]\\\\d*\";\nconst MAIN_VERSION_IDENTIFIER = `(${NUMERIC_IDENTIFIER})\\\\.(${NUMERIC_IDENTIFIER})\\\\.(${NUMERIC_IDENTIFIER})`;\nconst REGEX_MAIN_VERSION = new RegExp(MAIN_VERSION_IDENTIFIER);\n\n/**\n * @internal\n */\n\n/**\n * @internal\n * @param version\n */\nfunction toSemver(version) {\n  if (version.length > MAX_LENGTH) {\n    throw new Error(`version is longer than ${MAX_LENGTH} characters`);\n  }\n  const matches = version.trim().match(REGEX_MAIN_VERSION);\n  if (!matches || matches?.length !== 4) {\n    throw new Error(`${version} is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`);\n  }\n  const major = Number(matches[1]);\n  const minor = Number(matches[2]);\n  const patch = Number(matches[3]);\n  const versionString = [major, minor, patch].join(\".\");\n  return {\n    major,\n    minor,\n    patch,\n    versionString\n  };\n}\n\n/**\n * @internal\n * @param current\n * @param next\n */\nfunction isIncrementalVersion(current, next) {\n  const currentSemver = toSemver(current);\n  const nextSemver = toSemver(next);\n  if (nextSemver.major > currentSemver.major) {\n    return true;\n  }\n  const eqMajor = nextSemver.major === currentSemver.major;\n  if (eqMajor && nextSemver.minor > currentSemver.minor) {\n    return true;\n  }\n  const eqMinor = nextSemver.minor === currentSemver.minor;\n  return eqMajor && eqMinor && nextSemver.patch > currentSemver.patch;\n}\nfunction isDowngradeVersion(current, next) {\n  const currentSemver = toSemver(current);\n  const nextSemver = toSemver(next);\n  if (nextSemver.major < currentSemver.major) {\n    return true;\n  }\n  const eqMajor = nextSemver.major === currentSemver.major;\n  if (eqMajor && nextSemver.minor < currentSemver.minor) {\n    return true;\n  }\n  const eqMinor = nextSemver.minor === currentSemver.minor;\n  return eqMajor && eqMinor && nextSemver.patch < currentSemver.patch;\n}\n\n/**\n * @internal\n */\nconst BYOCContractMetadataSchema = CommonContractSchema.catchall(zod__WEBPACK_IMPORTED_MODULE_57__.z.union([BigNumberTransformSchema, zod__WEBPACK_IMPORTED_MODULE_57__.z.unknown()]));\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\nconst CustomContractInput = BYOCContractMetadataSchema.merge(CommonRoyaltySchema.merge(MerkleSchema).merge(CommonSymbolSchema).partial());\n\n/**\n * @internal\n */\nconst CustomContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema.merge(MerkleSchema).merge(CommonSymbolSchema).partial());\n\n/**\n * @internal\n */\nconst CustomContractDeploy = CustomContractInput.merge(CommonPlatformFeeSchema.merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema).partial());\n\n/**\n * @internal\n */\nconst CustomContractSchema = {\n  deploy: CustomContractDeploy,\n  output: CustomContractOutput,\n  input: CustomContractInput\n};\n\n/**\n * @internal\n */\nconst AbiTypeBaseSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n  name: zod__WEBPACK_IMPORTED_MODULE_57__.z.string()\n}).catchall(zod__WEBPACK_IMPORTED_MODULE_57__.z.any());\n\n/**\n * @internal\n */\nconst AbiTypeSchema = AbiTypeBaseSchema.extend({\n  stateMutability: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  components: zod__WEBPACK_IMPORTED_MODULE_57__.z.array(AbiTypeBaseSchema).optional()\n}).catchall(zod__WEBPACK_IMPORTED_MODULE_57__.z.any());\n\n/**\n * @internal\n */\nconst AbiObjectSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n  name: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().default(\"\"),\n  inputs: zod__WEBPACK_IMPORTED_MODULE_57__.z.array(AbiTypeSchema).default([]),\n  outputs: zod__WEBPACK_IMPORTED_MODULE_57__.z.array(AbiTypeSchema).default([])\n}).catchall(zod__WEBPACK_IMPORTED_MODULE_57__.z.any());\n\n/**\n * @internal\n */\nconst AbiSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.array(AbiObjectSchema);\n/**\n * @internal\n */\nconst PreDeployMetadata = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  name: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n  metadataUri: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n  bytecodeUri: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n  analytics: zod__WEBPACK_IMPORTED_MODULE_57__.z.any().optional()\n}).catchall(zod__WEBPACK_IMPORTED_MODULE_57__.z.any());\n\n/**\n * @internal\n */\nconst ChainIdToAddressSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.record(zod__WEBPACK_IMPORTED_MODULE_57__.z.string(), zod__WEBPACK_IMPORTED_MODULE_57__.z.string());\n\n/**\n * @internal\n */\nconst FactoryDeploymentSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  implementationAddresses: ChainIdToAddressSchema,\n  implementationInitializerFunction: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().default(\"initialize\"),\n  factoryAddresses: ChainIdToAddressSchema.optional()\n});\n\n/**\n * @internal\n */\nconst ExtraPublishMetadataSchemaInput = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  version: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().refine(v => {\n    try {\n      toSemver(v);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }, out => {\n    return {\n      message: `'${out}' is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`\n    };\n  }),\n  displayName: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  description: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  readme: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  license: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  changelog: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  tags: zod__WEBPACK_IMPORTED_MODULE_57__.z.array(zod__WEBPACK_IMPORTED_MODULE_57__.z.string()).optional(),\n  audit: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.F.nullable().optional(),\n  logo: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.F.nullable().optional(),\n  isDeployableViaFactory: zod__WEBPACK_IMPORTED_MODULE_57__.z.boolean().optional(),\n  isDeployableViaProxy: zod__WEBPACK_IMPORTED_MODULE_57__.z.boolean().optional(),\n  factoryDeploymentData: FactoryDeploymentSchema.optional(),\n  constructorParams: zod__WEBPACK_IMPORTED_MODULE_57__.z.record(zod__WEBPACK_IMPORTED_MODULE_57__.z.string(), zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n    displayName: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n    description: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n    defaultValue: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional()\n  }).catchall(zod__WEBPACK_IMPORTED_MODULE_57__.z.any())).optional()\n}).catchall(zod__WEBPACK_IMPORTED_MODULE_57__.z.any());\n\n/**\n * @internal\n */\nconst ExtraPublishMetadataSchemaOutput = ExtraPublishMetadataSchemaInput.extend({\n  audit: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().nullable().optional(),\n  logo: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().nullable().optional()\n});\n/**\n * @internal\n */\nconst FullPublishMetadataSchemaInput = PreDeployMetadata.merge(ExtraPublishMetadataSchemaInput).extend({\n  publisher: AddressSchema.optional()\n});\n/**\n * @internal\n */\nconst FullPublishMetadataSchemaOutput = PreDeployMetadata.merge(ExtraPublishMetadataSchemaOutput).extend({\n  publisher: AddressSchema.optional()\n});\n/**\n * @internal\n */\nconst ProfileSchemaInput = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  name: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  bio: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  avatar: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.F.nullable().optional(),\n  website: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  twitter: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  telegram: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  facebook: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  github: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  medium: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  linkedin: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  reddit: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  discord: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional()\n});\nconst ProfileSchemaOutput = ProfileSchemaInput.extend({\n  avatar: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().nullable().optional()\n});\n/**\n * @internal\n */\nconst PublishedContractSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  id: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n  timestamp: BigNumberishSchema,\n  metadataUri: zod__WEBPACK_IMPORTED_MODULE_57__.z.string()\n});\n\n/**\n * @internal\n * Follows https://docs.soliditylang.org/en/v0.8.15/natspec-format.html\n */\nconst ContractInfoSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  title: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  author: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  details: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional(),\n  notice: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional()\n});\n\n/**\n * @internal\n */\nconst CompilerMetadataFetchedSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  name: zod__WEBPACK_IMPORTED_MODULE_57__.z.string(),\n  abi: AbiSchema,\n  metadata: zod__WEBPACK_IMPORTED_MODULE_57__.z.record(zod__WEBPACK_IMPORTED_MODULE_57__.z.string(), zod__WEBPACK_IMPORTED_MODULE_57__.z.any()),\n  info: ContractInfoSchema,\n  licenses: zod__WEBPACK_IMPORTED_MODULE_57__.z.array(zod__WEBPACK_IMPORTED_MODULE_57__.z.string().optional()).default([]).transform(v => {\n    return v.filter(license => license !== undefined);\n  })\n});\n\n/**\n * @internal\n */\nconst PreDeployMetadataFetchedSchema = PreDeployMetadata.merge(CompilerMetadataFetchedSchema).extend({\n  bytecode: zod__WEBPACK_IMPORTED_MODULE_57__.z.string()\n});\n\n/**\n * Wallet Authenticator\n * @remarks The wallet authenticator enables server-side applications to securely identify the\n * connected wallet address of users on the client-side, and also enables users to authenticate\n * to any backend using just their wallet. It implements the JSON Web Token (JWT) authentication\n * standard.\n *\n * @example\n * ```javascript\n * // We specify the domain of the application to authenticate to\n * const domain = \"example.com\"\n *\n * // On the client side, we can generate a payload for the connected wallet to login\n * const loginPayload = await sdk.auth.login(domain);\n *\n * // Then on the server side, we can securely verify the connected client-side address\n * const address = sdk.auth.verify(domain, loginPayload);\n *\n * // And we can also generate an authentication token to send to the client\n * const token = sdk.auth.generate(domain, loginPayload);\n *\n * // Finally, the token can be send from the client to the server to make authenticated requests\n * // And the server can use the following function to authenticate a token and verify the associated address\n * const address = sdk.auth.authenticate(domain, token);\n * ```\n * @public\n */\nclass WalletAuthenticator extends RPCConnectionHandler {\n  constructor(network, wallet, options) {\n    super(network, options);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"wallet\", void 0);\n    this.wallet = wallet;\n  }\n\n  /**\n   * Login With Connected Wallet\n   * @remarks Client-side function that allows the connected wallet to login to a server-side application.\n   * Generates a login payload that can be sent to the server-side for verification or authentication.\n   *\n   * @param domain - The domain of the server-side application to login to\n   * @param options - Optional configuration options for the login request\n   * @returns Login payload that can be used on the server-side to verify the login request or authenticate\n   *\n   * @example\n   * ```javascript\n   * // Add the domain of the application users will login to, this will be used throughout the login process\n   * const domain = \"example.com\";\n   * // Generate a signed login payload for the connected wallet to authenticate with\n   * const loginPayload = await sdk.auth.login(domain);\n   * ```\n   */\n  async login(domain, options) {\n    const parsedOptions = LoginOptionsSchema.parse(options);\n    const signerAddress = await this.wallet.getAddress();\n    const expirationTime = parsedOptions?.expirationTime || new Date(Date.now() + 1000 * 60 * 5);\n    const payloadData = LoginPayloadDataSchema.parse({\n      domain,\n      address: signerAddress,\n      nonce: parsedOptions?.nonce,\n      expiration_time: expirationTime,\n      chain_id: parsedOptions?.chainId\n    });\n    const message = this.generateMessage(payloadData);\n    const signature = await this.wallet.sign(message);\n    return {\n      payload: payloadData,\n      signature\n    };\n  }\n\n  /**\n   * Verify Logged In Address\n   * @remarks Server-side function to securely verify the address of the logged in client-side wallet\n   * by validating the provided client-side login request.\n   *\n   * @param domain - The domain of the server-side application to verify the login request for\n   * @param payload - The login payload to verify\n   * @returns Address of the logged in wallet\n   *\n   * @example\n   * ```javascript\n   * const domain = \"example.com\";\n   * const loginPayload = await sdk.auth.login(domain);\n   *\n   * // Verify the login request\n   * const address = sdk.auth.verify(domain, loginPayload);\n   * ```\n   */\n  verify(domain, payload, options) {\n    const parsedOptions = VerifyOptionsSchema.parse(options);\n\n    // Check that the intended domain matches the domain of the payload\n    if (payload.payload.domain !== domain) {\n      throw new Error(`Expected domain '${domain}' does not match domain on payload '${payload.payload.domain}'`);\n    }\n\n    // Check that the payload hasn't expired\n    const currentTime = new Date();\n    if (currentTime > new Date(payload.payload.expiration_time)) {\n      throw new Error(`Login request has expired`);\n    }\n\n    // If chain ID is specified, check that it matches the chain ID of the signature\n    if (parsedOptions?.chainId !== undefined && parsedOptions.chainId !== payload.payload.chain_id) {\n      throw new Error(`Chain ID '${parsedOptions.chainId}' does not match payload chain ID '${payload.payload.chain_id}'`);\n    }\n\n    // Check that the signing address is the claimed wallet address\n    const message = this.generateMessage(payload.payload);\n    const userAddress = this.wallet.recoverAddress(message, payload.signature);\n    if (userAddress.toLowerCase() !== payload.payload.address.toLowerCase()) {\n      throw new Error(`Signer address '${userAddress.toLowerCase()}' does not match payload address '${payload.payload.address.toLowerCase()}'`);\n    }\n    return userAddress;\n  }\n\n  /**\n   * Generate Authentication Token\n   * @remarks Server-side function that generates a JWT token from the provided login request that the\n   * client-side wallet can use to authenticate to the server-side application.\n   *\n   * @param domain - The domain of the server-side application to authenticate to\n   * @param payload - The login payload to authenticate with\n   * @param options - Optional configuration options for the authentication request\n   * @returns A authentication token that can be used by the client to make authenticated requests\n   *\n   * @example\n   * ```javascript\n   * const domain = \"example.com\";\n   * const loginPayload = await sdk.auth.login(domain);\n   *\n   * // Generate a JWT token that can be sent to the client-side wallet and used for authentication\n   * const token = await sdk.auth.generateAuthToken(domain, loginPayload);\n   * ```\n   */\n  async generateAuthToken(domain, payload, options) {\n    if (isBrowser()) {\n      throw new Error(\"Authentication tokens should not be generated in the browser, as they must be signed by a server-side admin wallet.\");\n    }\n    const parsedOptions = AuthenticationOptionsSchema.parse(options);\n    const userAddress = this.verify(domain, payload);\n    const adminAddress = await this.wallet.getAddress();\n    const payloadData = AuthenticationPayloadDataSchema.parse({\n      iss: adminAddress,\n      sub: userAddress,\n      aud: domain,\n      nbf: parsedOptions?.invalidBefore || new Date(),\n      exp: parsedOptions?.expirationTime || new Date(Date.now() + 1000 * 60 * 60 * 5),\n      iat: new Date()\n    });\n    const message = JSON.stringify(payloadData);\n    const signature = await this.wallet.sign(message);\n\n    // Header used for JWT token specifying hash algorithm\n    const header = {\n      // Specify ECDSA with SHA-256 for hashing algorithm\n      alg: \"ES256\",\n      typ: \"JWT\"\n    };\n    const encodedHeader = Buffer.from(JSON.stringify(header)).toString(\"base64\");\n    const encodedData = Buffer.from(JSON.stringify(payloadData)).toString(\"base64\").replace(/=/g, \"\");\n    const encodedSignature = Buffer.from(signature).toString(\"base64\");\n\n    // Generate a JWT token with base64 encoded header, payload, and signature\n    const token = `${encodedHeader}.${encodedData}.${encodedSignature}`;\n    return token;\n  }\n\n  /**\n   * Authenticate With Token\n   * @remarks Server-side function that authenticates the provided JWT token. This function verifies that\n   * the provided authentication token is valid and returns the address of the authenticated wallet.\n   *\n   * @param domain - The domain of the server-side application doing authentication\n   * @param token - The authentication token being used\n   * @returns The address of the authenticated wallet\n   *\n   * @example\n   * ```javascript\n   * const domain = \"example.com\";\n   * const loginPayload = await sdk.auth.login(domain);\n   * const token = await sdk.auth.generateAuthToken(domain, loginPayload);\n   *\n   * // Authenticate the token and get the address of authenticating users wallet\n   * const address = sdk.auth.authenticate(domain, token);\n   * ```\n   */\n  async authenticate(domain, token) {\n    if (isBrowser()) {\n      throw new Error(\"Should not authenticate tokens in the browser, as they must be verified by the server-side admin wallet.\");\n    }\n    const encodedPayload = token.split(\".\")[1];\n    const encodedSignature = token.split(\".\")[2];\n    const payload = JSON.parse(Buffer.from(encodedPayload, \"base64\").toString());\n    const signature = Buffer.from(encodedSignature, \"base64\").toString();\n\n    // Check that the token audience matches the domain\n    if (payload.aud !== domain) {\n      throw new Error(`Expected token to be for the domain '${domain}', but found token with domain '${payload.aud}'`);\n    }\n\n    // Check that the token is past the invalid before time\n    const currentTime = Math.floor(new Date().getTime() / 1000);\n    if (currentTime < payload.nbf) {\n      throw new Error(`This token is invalid before epoch time '${payload.nbf}', current epoch time is '${currentTime}'`);\n    }\n\n    // Check that the token hasn't expired\n    if (currentTime > payload.exp) {\n      throw new Error(`This token expired at epoch time '${payload.exp}', current epoch time is '${currentTime}'`);\n    }\n\n    // Check that the connected wallet matches the token issuer\n    const connectedAddress = await this.wallet.getAddress();\n    if (connectedAddress.toLowerCase() !== payload.iss.toLowerCase()) {\n      throw new Error(`Expected the connected wallet address '${connectedAddress}' to match the token issuer address '${payload.iss}'`);\n    }\n\n    // Check that the connected wallet signed the token\n    const adminAddress = this.wallet.recoverAddress(JSON.stringify(payload), signature);\n    if (connectedAddress.toLowerCase() !== adminAddress.toLowerCase()) {\n      throw new Error(`The connected wallet address '${connectedAddress}' did not sign the token`);\n    }\n    return payload.sub;\n  }\n\n  /**\n   * Generates a EIP-4361 compliant message to sign based on the login payload\n   */\n  generateMessage(payload) {\n    let message = ``;\n\n    // Add the domain and login address for transparency\n    message += `${payload.domain} wants you to sign in with your account:\\n${payload.address}\\n\\n`;\n\n    // Prompt user to make sure domain is correct to prevent phishing attacks\n    message += `Make sure that the requesting domain above matches the URL of the current website.\\n\\n`;\n\n    // Add data fields in compliance with the EIP-4361 standard\n    if (payload.chain_id) {\n      message += `Chain ID: ${payload.chain_id}\\n`;\n    }\n    message += `Nonce: ${payload.nonce}\\n`;\n    message += `Expiration Time: ${payload.expiration_time}\\n`;\n    return message;\n  }\n}\n\n/**\n * Encodes and decodes Contract functions\n * @public\n */\nclass ContractEncoder {\n  constructor(contractWrapper) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Encodes the given contract function with argument\n   * @returns the encoded data\n   */\n  encode(fn, args) {\n    return this.contractWrapper.readContract.interface.encodeFunctionData(fn, args);\n  }\n\n  /**\n   * Decode encoded call data for a given function\n   * @param fn - the function to decode\n   * @param encodedArgs - the encoded arguments\n   */\n  decode(fn, encodedArgs) {\n    return this.contractWrapper.readContract.interface.decodeFunctionData(fn, encodedArgs);\n  }\n}\n\n/**\n * Handles metadata for a Contract\n * @remarks Read and update metadata for this contract\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const metadata = await contract.metadata.get();\n * await contract.metadata.set({\n *   name: \"My Contract\",\n *   description: \"My contract description\"\n * })\n * ```\n * @public\n */\nclass ContractMetadata {\n  constructor(contractWrapper, schema, storage) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_METADATA.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"schema\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    this.contractWrapper = contractWrapper;\n    this.schema = schema;\n    this.storage = storage;\n  }\n  /**\n   * @internal\n   */\n  parseOutputMetadata(metadata) {\n    return this.schema.output.parse(metadata);\n  }\n\n  /**\n   * @internal\n   */\n  parseInputMetadata(metadata) {\n    return this.schema.input.parse(metadata);\n  }\n  /**\n   * Get the metadata of a contract\n   * @remarks Get the metadata of a contract\n   * @example\n   * ```javascript\n   * const metadata = await contract.metadata.get();\n   * ```\n   * @public\n   * @returns the metadata of the given contract\n   * @twfeature ContractMetadata\n   */\n  async get() {\n    let data;\n    if (this.supportsContractMetadata(this.contractWrapper)) {\n      const uri = await this.contractWrapper.readContract.contractURI();\n      if (uri && uri.includes(\"://\")) {\n        data = await this.storage.downloadJSON(uri);\n      }\n    }\n    if (!data) {\n      try {\n        // try fetching metadata from bytecode and / or contract itself\n        let contractName;\n        try {\n          if (hasFunction(\"name\", this.contractWrapper)) {\n            contractName = await this.contractWrapper.readContract.name();\n          }\n        } catch (err) {\n          // no-op\n        }\n        const publishedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.readContract.address, this.contractWrapper.getProvider(), this.storage);\n        data = {\n          name: contractName || publishedMetadata.name,\n          description: publishedMetadata.info.title\n        };\n      } catch (e) {\n        throw new Error(\"Could not fetch contract metadata\");\n      }\n    }\n    return this.parseOutputMetadata(data);\n  }\n  /**\n   * Set the metadata of a contract\n   * @remarks OVERWRITE the metadata of a contract\n   * @example\n   * ```javascript\n   * await contract.metadata.set({\n   *  name: \"My Contract\",\n   *  description: \"My contract description\"\n   * })\n   * ```\n   * @public\n   * @param metadata - the metadata to set\n   * @twfeature ContractMetadata\n   */\n  async set(metadata) {\n    const uri = await this._parseAndUploadMetadata(metadata);\n    const wrapper = this.contractWrapper;\n    if (this.supportsContractMetadata(wrapper)) {\n      const receipt = await wrapper.sendTransaction(\"setContractURI\", [uri]);\n      return {\n        receipt,\n        data: this.get\n      };\n    } else {\n      throw new ExtensionNotImplementedError(FEATURE_METADATA);\n    }\n  }\n\n  /**\n   * Update the metadata of a contract\n   * @remarks Update the metadata of a contract\n   * @example\n   * ```javascript\n   * await contract.metadata.update({\n   *   name: \"My Contract\",\n   *   description: \"My contract description\"\n   * })\n   * ```\n   * @public\n   * @param metadata - the metadata to update\n   * @twfeature ContractMetadata\n   * */\n  async update(metadata) {\n    return await this.set({\n      ...(await this.get()),\n      ...metadata\n    });\n  }\n\n  /**\n   *\n   * @internal\n   * @param metadata - the metadata to set\n   * @returns\n   */\n  async _parseAndUploadMetadata(metadata) {\n    const parsedMetadata = this.parseInputMetadata(metadata);\n    return this.storage.upload(parsedMetadata);\n  }\n  supportsContractMetadata(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ContractMetadata\");\n  }\n}\n\n/**\n * Handle contract permissions\n * @remarks Configure roles and permissions for a contract, to restrict certain actions.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const rolesAndMembers = await contract.roles.getAll();\n * await contract.roles.grantRole(\"admin\", \"0x...\");\n * ```\n * @public\n */\nclass ContractRoles {\n  /**\n   * @internal\n   * @remarks This is used for typing inside react hooks which is why it has to be public.\n   */\n\n  constructor(contractWrapper, roles) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_PERMISSIONS.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"roles\", void 0);\n    this.contractWrapper = contractWrapper;\n    this.roles = roles;\n  }\n\n  /** **************************\n   * READ FUNCTIONS\n   ****************************/\n\n  /**\n   * Call this to get get a list of addresses for all supported roles on the contract.\n   * @remarks See {@link ContractRoles.get} to get a list of addresses that are members of a specific role.\n   * @example\n   * ```javascript\n   * const rolesAndMembers = await contract.roles.getAll();\n   * ```\n   * @returns A record of {@link Role}s to lists of addresses that are members of the given role.\n   * @throws If the contract does not support roles this will throw an error.\n   *\n   * @public\n   * @twfeature Permissions\n   */\n  async getAll() {\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.roles.length, \"this contract has no support for roles\");\n    const roles = {};\n    for (const role of this.roles) {\n      roles[role] = await this.get(role);\n    }\n    return roles;\n  }\n\n  /**\n   * Call this to get a list of addresses that are members of a specific role.\n   * @remarks See {@link ContractRoles.getAll} to get get a list of addresses for all supported roles on the contract.\n   * @param role - The Role to to get a memberlist for.\n   * @returns The list of addresses that are members of the specific role.\n   * @throws If you are requestiong a role that does not exist on the contract this will throw an error.\n   *\n   * @example Say you want to get the list of addresses that are members of the minter role.\n   * ```javascript\n   * const minterAddresses = await contract.roles.get(\"minter\");\n   * ```\n   *\n   * @public\n   * @twfeature Permissions\n   */\n  async get(role) {\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.roles.includes(role), `this contract does not support the \"${role}\" role`);\n    const wrapper = this.contractWrapper;\n    if (hasFunction(\"getRoleMemberCount\", wrapper) && hasFunction(\"getRoleMember\", wrapper)) {\n      const roleHash = getRoleHash(role);\n      const count = (await wrapper.readContract.getRoleMemberCount(roleHash)).toNumber();\n      return await Promise.all(Array.from(Array(count).keys()).map(i => wrapper.readContract.getRoleMember(roleHash, i)));\n    }\n    throw new Error(\"Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.\");\n  }\n\n  /**\n   * Call this to OVERWRITE the list of addresses that are members of specific roles.\n   *\n   * Every role in the list will be overwritten with the new list of addresses provided with them.\n   * If you want to add or remove addresses for a single address use {@link ContractRoles.grant} and {@link ContractRoles.revoke} respectively instead.\n   * @param rolesWithAddresses - A record of {@link Role}s to lists of addresses that should be members of the given role.\n   * @throws If you are requestiong a role that does not exist on the contract this will throw an error.\n   * @example Say you want to overwrite the list of addresses that are members of the minter role.\n   * ```javascript\n   * const minterAddresses = await contract.roles.get(\"minter\");\n   * await contract.roles.setAll({\n   *  minter: []\n   * });\n   * console.log(await contract.roles.get(\"minter\")); // No matter what members had the role before, the new list will be set to []\n   * ```\n   * @public\n   * @twfeature Permissions\n   *\n   * */\n  async setAll(rolesWithAddresses) {\n    const roles = Object.keys(rolesWithAddresses);\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(roles.length, \"you must provide at least one role to set\");\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(roles.every(role => this.roles.includes(role)), \"this contract does not support the given role\");\n    const currentRoles = await this.getAll();\n    const encoded = [];\n    // add / remove admin role at the end so we don't revoke admin then grant\n    const sortedRoles = roles.sort(role => role === \"admin\" ? 1 : -1);\n    for (let i = 0; i < sortedRoles.length; i++) {\n      const role = sortedRoles[i];\n      const addresses = rolesWithAddresses[role] || [];\n      const currentAddresses = currentRoles[role] || [];\n      const toAdd = addresses.filter(address => !currentAddresses.includes(address));\n      const toRemove = currentAddresses.filter(address => !addresses.includes(address));\n      if (toAdd.length) {\n        toAdd.forEach(address => {\n          encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData(\"grantRole\", [getRoleHash(role), address]));\n        });\n      }\n      if (toRemove.length) {\n        for (let j = 0; j < toRemove.length; j++) {\n          const address = toRemove[j];\n          const revokeFunctionName = await this.getRevokeRoleFunctionName(address);\n          encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData(revokeFunctionName, [getRoleHash(role), address]));\n        }\n      }\n    }\n    return {\n      receipt: await this.contractWrapper.multiCall(encoded)\n    };\n  }\n\n  /**\n   * Throws an error if an address is missing the roles specified.\n   *\n   * @param roles - The roles to check\n   * @param address - The address to check\n   *\n   * @internal\n   */\n  async verify(roles, address) {\n    await Promise.all(roles.map(async role => {\n      const members = await this.get(role);\n      if (!members.map(a => a.toLowerCase()).includes(address.toLowerCase())) {\n        throw new MissingRoleError(address, role);\n      }\n    }));\n  }\n\n  /** **************************\n   * WRITE FUNCTIONS\n   ****************************/\n\n  /**\n   * Call this to grant a role to a specific address.\n   *\n   * @remarks Make sure you are sure you want to grant the role to the address.\n   *\n   * @example\n   * ```javascript\n   * await contract.roles.grant(\"minter\", \"0x1234567890123456789012345678901234567890\");\n   * ```\n   *\n   * @param role - The {@link Role} to grant to the address\n   * @param address - The address to grant the role to\n   * @returns The transaction receipt\n   * @throws If you are trying to grant does not exist on the contract this will throw an error.\n   *\n   * @public\n   * @twfeature Permissions\n   */\n  async grant(role, address) {\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.roles.includes(role), `this contract does not support the \"${role}\" role`);\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"grantRole\", [getRoleHash(role), address])\n    };\n  }\n\n  /**\n   * Call this to revoke a role from a specific address.\n   *\n   * @remarks\n   *\n   * -- Caution --\n   *\n   * This will let you remove yourself from the role, too.\n   * If you remove yourself from the admin role, you will no longer be able to administer the contract.\n   * There is no way to recover from this.\n   *\n   * @example\n   * ```javascript\n   * await contract.roles.revoke(\"minter\", \"0x1234567890123456789012345678901234567890\");\n   * ```\n   *\n   * @param role - The {@link Role} to revoke\n   * @param address - The address to revoke the role from\n   * @returns The transaction receipt\n   * @throws If you are trying to revoke does not exist on the module this will throw an error.\n   *\n   * @public\n   * @twfeature Permissions\n   */\n  async revoke(role, address) {\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.roles.includes(role), `this contract does not support the \"${role}\" role`);\n    const revokeFunctionName = await this.getRevokeRoleFunctionName(address);\n    return {\n      receipt: await this.contractWrapper.sendTransaction(revokeFunctionName, [getRoleHash(role), address])\n    };\n  }\n\n  /** **************************\n   * PRIVATE FUNCTIONS\n   ****************************/\n\n  async getRevokeRoleFunctionName(address) {\n    const signerAddress = await this.contractWrapper.getSignerAddress();\n    if (signerAddress.toLowerCase() === address.toLowerCase()) {\n      return \"renounceRole\";\n    }\n    return \"revokeRole\";\n  }\n}\n\n/**\n * Handle contract royalties\n * @remarks Configure royalties for an entire contract or a particular token.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n * await contract.roles.setTokenRoyaltyInfo(tokenId, {\n *   seller_fee_basis_points: 100, // 1% royalty fee\n *   fee_recipient: \"0x...\", // the fee recipient\n * });\n * ```\n * @public\n */\nclass ContractRoyalty {\n  constructor(contractWrapper, metadata) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_ROYALTY.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"metadata\", void 0);\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n  }\n\n  /**\n   * Gets the royalty recipient and BPS (basis points) of the contract\n   * @returns - The royalty recipient and BPS\n   * @example\n   * ```javascript\n   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  async getDefaultRoyaltyInfo() {\n    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.readContract.getDefaultRoyaltyInfo();\n    // parse it on the way out to make sure we default things if they are not set\n    return CommonRoyaltySchema.parse({\n      fee_recipient: royaltyRecipient,\n      seller_fee_basis_points: royaltyBps\n    });\n  }\n\n  /**\n   * Gets the royalty recipient and BPS (basis points) of a particular token\n   * @returns - The royalty recipient and BPS\n   * @example\n   * ```javascript\n   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  async getTokenRoyaltyInfo(tokenId) {\n    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.readContract.getRoyaltyInfoForToken(tokenId);\n    return CommonRoyaltySchema.parse({\n      fee_recipient: royaltyRecipient,\n      seller_fee_basis_points: royaltyBps\n    });\n  }\n\n  /**\n   * Set the royalty recipient and fee for a contract\n   * @param royaltyData - the royalty recipient and fee\n   *  @example\n   * ```javascript\n   * await contract.roles.setDefaultRoyaltyInfo({\n   *   seller_fee_basis_points: 100, // 1% royalty fee\n   *   fee_recipient: \"0x...\", // the fee recipient\n   * });\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  async setDefaultRoyaltyInfo(royaltyData) {\n    // read the metadata from the contract\n    const oldMetadata = await this.metadata.get();\n\n    // update the metadata with the new royalty data\n    // if one of the keys is \"undefined\" it will be ignored (which is the desired behavior)\n    const mergedMetadata = this.metadata.parseInputMetadata({\n      ...oldMetadata,\n      ...royaltyData\n    });\n\n    // why not use this.metadata.set()? - because that would end up sending it's own separate transaction to `setContractURI`\n    // but we want to send both the `setRoyaltyInfo` and `setContractURI` in one transaction!\n    const contractURI = await this.metadata._parseAndUploadMetadata(mergedMetadata);\n    if (hasFunction(\"setContractURI\", this.contractWrapper)) {\n      // encode both the functions we want to send\n      const encoded = [this.contractWrapper.readContract.interface.encodeFunctionData(\"setDefaultRoyaltyInfo\", [mergedMetadata.fee_recipient, mergedMetadata.seller_fee_basis_points]), this.contractWrapper.readContract.interface.encodeFunctionData(\"setContractURI\", [contractURI])];\n      // actually send the transaction and return the receipt + a way to get the new royalty info\n      return {\n        receipt: await this.contractWrapper.multiCall(encoded),\n        data: () => this.getDefaultRoyaltyInfo()\n      };\n    } else {\n      throw new Error(\"Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.\");\n    }\n  }\n\n  /**\n   * Set the royalty recipient and fee for a particular token\n   * @param tokenId - the token id\n   * @param royaltyData - the royalty recipient and fee\n   * @example\n   * ```javascript\n   * await contract.roles.setTokenRoyaltyInfo(tokenId, {\n   *   seller_fee_basis_points: 100, // 1% royalty fee\n   *   fee_recipient: \"0x...\", // the fee recipient\n   * });\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  async setTokenRoyaltyInfo(tokenId, royaltyData) {\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"setRoyaltyInfoForToken\", [tokenId, royaltyData.fee_recipient, royaltyData.seller_fee_basis_points]),\n      data: () => this.getDefaultRoyaltyInfo()\n    };\n  }\n}\n\n/**\n * Handle primary sales recipients\n * @remarks Configure primary sale recipients for an entire contract.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const salesRecipient = await contract.sales.getRecipient();\n * await contract.sales.setRecipient(recipientWalletAddress);\n * ```\n * @public\n */\nclass ContractPrimarySale {\n  constructor(contractWrapper) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_PRIMARY_SALE.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get the primary sale recipient.\n   * @returns the wallet address.\n   * @example\n   * ```javascript\n   * const salesRecipient = await contract.sales.getRecipient();\n   * ```\n   * @public\n   * @twfeature PrimarySale\n   */\n  async getRecipient() {\n    return await this.contractWrapper.readContract.primarySaleRecipient();\n  }\n\n  /**\n   * Set the primary sale recipient\n   * @param recipient - the wallet address\n   * @example\n   * ```javascript\n   * await contract.sales.setRecipient(recipientWalletAddress);\n   * ```\n   * @public\n   * @twfeature PrimarySale\n   */\n  async setRecipient(recipient) {\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"setPrimarySaleRecipient\", [recipient])\n    };\n  }\n}\n\nconst FALLBACK_METADATA = {\n  name: \"Failed to load NFT metadata\"\n};\n\n/**\n * fetches the token metadata\n * @param tokenId - the id (to get it back in the output)\n * @param tokenUri - the uri to fetch\n * @param storage - which storage to fetch from\n *\n * @internal\n */\nasync function fetchTokenMetadata(tokenId, tokenUri, storage) {\n  const parsedUri = tokenUri.replace(\"{id}\", ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.hexZeroPad(ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(tokenId).toHexString(), 32).slice(2));\n  let jsonMetadata;\n  try {\n    jsonMetadata = await storage.downloadJSON(parsedUri);\n  } catch (err) {\n    const unparsedTokenIdUri = tokenUri.replace(\"{id}\", ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(tokenId).toString());\n    try {\n      jsonMetadata = await storage.downloadJSON(unparsedTokenIdUri);\n    } catch (e) {\n      console.warn(`failed to get token metadata: ${JSON.stringify({\n        tokenId: tokenId.toString(),\n        tokenUri\n      })} -- falling back to default metadata`);\n      jsonMetadata = FALLBACK_METADATA;\n    }\n  }\n  return _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.C.parse({\n    ...jsonMetadata,\n    id: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(tokenId).toString(),\n    uri: tokenUri\n  });\n}\n\n// Used for marketplace to fetch NFT metadata from contract address + tokenId\n/**\n * @internal\n * @param contractAddress\n * @param provider\n * @param tokenId\n * @param storage\n */\nasync function fetchTokenMetadataForContract(contractAddress, provider, tokenId, storage) {\n  let uri;\n  const erc165 = new ethers__WEBPACK_IMPORTED_MODULE_58__.Contract(contractAddress, _thirdweb_dev_contracts_js_dist_abis_IERC165_json__WEBPACK_IMPORTED_MODULE_0__, provider);\n  const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);\n  const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);\n  if (isERC721) {\n    const erc721 = new ethers__WEBPACK_IMPORTED_MODULE_58__.Contract(contractAddress, _thirdweb_dev_contracts_js_dist_abis_IERC721Metadata_json__WEBPACK_IMPORTED_MODULE_41__, provider);\n    uri = await erc721.tokenURI(tokenId);\n  } else if (isERC1155) {\n    const erc1155 = new ethers__WEBPACK_IMPORTED_MODULE_58__.Contract(contractAddress, _thirdweb_dev_contracts_js_dist_abis_IERC1155Metadata_json__WEBPACK_IMPORTED_MODULE_42__, provider);\n    uri = await erc1155.uri(tokenId);\n  } else {\n    throw Error(\"Contract must implement ERC 1155 or ERC 721.\");\n  }\n  if (!uri) {\n    throw new NotFoundError();\n  }\n  return fetchTokenMetadata(tokenId, uri, storage);\n}\n\n/**\n * @internal\n * @param metadata\n * @param storage\n */\nasync function uploadOrExtractURI(metadata, storage) {\n  if (typeof metadata === \"string\") {\n    return metadata;\n  } else {\n    return await storage.upload(_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.b.parse(metadata));\n  }\n}\n\n/**\n * @internal\n * @param metadatas\n * @param storage\n * @param startNumber\n * @param contractAddress\n * @param signerAddress\n * @param options\n */\nasync function uploadOrExtractURIs(metadatas, storage, startNumber, options) {\n  if (isUriList(metadatas)) {\n    return metadatas;\n  } else if (isMetadataList(metadatas)) {\n    const uris = await storage.uploadBatch(metadatas.map(m => _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.b.parse(m)), {\n      rewriteFileNames: {\n        fileStartNumber: startNumber || 0\n      },\n      onProgress: options?.onProgress\n    });\n    return uris;\n  } else {\n    throw new Error(\"NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)\");\n  }\n}\nfunction getBaseUriFromBatch(uris) {\n  const baseUri = uris[0].substring(0, uris[0].lastIndexOf(\"/\"));\n  for (let i = 0; i < uris.length; i++) {\n    const uri = uris[i].substring(0, uris[i].lastIndexOf(\"/\"));\n    if (baseUri !== uri) {\n      throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);\n    }\n  }\n\n  // Ensure that baseUri ends with trailing slash\n  return baseUri.replace(/\\/$/, \"\") + \"/\";\n}\nfunction isUriList(metadatas) {\n  return metadatas.find(m => typeof m !== \"string\") === undefined;\n}\nfunction isMetadataList(metadatas) {\n  return metadatas.find(m => typeof m !== \"object\") === undefined;\n}\n\n/**\n * Handles delayed reveal logic\n * @public\n */\nclass DelayedReveal {\n  constructor(contractWrapper, storage, fetureName, nextTokenIdToMintFn) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"nextTokenIdToMintFn\", void 0);\n    this.featureName = fetureName;\n    this.nextTokenIdToMintFn = nextTokenIdToMintFn;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until your reveal them!\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, until the reveal happens!\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * ```\n   * @public\n   * @param placeholder - the placeholder NFT to show before the reveal\n   * @param metadatas - the final NFTs that will be hidden\n   * @param password - the password that will be used to reveal these NFTs\n   * @param options - additional options like upload progress\n   */\n  async createDelayedRevealBatch(placeholder, metadatas, password, options) {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const placeholderUris = await this.storage.uploadBatch([_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.b.parse(placeholder)], {\n      rewriteFileNames: {\n        fileStartNumber: 0\n      }\n    });\n    const placeholderUri = getBaseUriFromBatch(placeholderUris);\n    const startFileNumber = await this.nextTokenIdToMintFn();\n    const uris = await this.storage.uploadBatch(metadatas.map(m => _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.b.parse(m)), {\n      onProgress: options?.onProgress,\n      rewriteFileNames: {\n        fileStartNumber: startFileNumber.toNumber()\n      }\n    });\n    const baseUri = getBaseUriFromBatch(uris);\n    const baseUriId = await this.contractWrapper.readContract.getBaseURICount();\n    const hashedPassword = await this.hashDelayRevealPasword(baseUriId, password);\n    const encryptedBaseUri = await this.contractWrapper.readContract.encryptDecrypt(ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.toUtf8Bytes(baseUri), hashedPassword);\n    let data;\n    const legacyContract = await this.isLegacyContract();\n    if (legacyContract) {\n      data = encryptedBaseUri;\n    } else {\n      const chainId = await this.contractWrapper.getChainID();\n      const provenanceHash = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.solidityKeccak256([\"bytes\", \"bytes\", \"uint256\"], [ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.toUtf8Bytes(baseUri), hashedPassword, chainId]);\n      data = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.defaultAbiCoder.encode([\"bytes\", \"bytes32\"], [encryptedBaseUri, provenanceHash]);\n    }\n    const receipt = await this.contractWrapper.sendTransaction(\"lazyMint\", [uris.length, placeholderUri.endsWith(\"/\") ? placeholderUri : `${placeholderUri}/`, data]);\n    const events = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n    const startingIndex = events[0].args.startTokenId;\n    const endingIndex = events[0].args.endTokenId;\n    const results = [];\n    for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n      results.push({\n        id,\n        receipt\n      });\n    }\n    return results;\n  }\n\n  /**\n   * Reveal a batch of hidden NFTs\n   * @remarks Reveal the NFTs of a batch using the password.\n   * @example\n   * ```javascript\n   * // the batch to reveal\n   * const batchId = 0;\n   * // reveal the batch\n   * await contract.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   * @public\n   * @param batchId - the id of the batch to reveal\n   * @param password - the password\n   */\n  async reveal(batchId, password) {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const key = await this.hashDelayRevealPasword(batchId, password);\n    // performing the reveal locally to make sure it'd succeed before sending the transaction\n    try {\n      const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);\n      // basic sanity check for making sure decryptedUri is valid\n      // this is optional because invalid decryption key would result in non-utf8 bytes and\n      // ethers would throw when trying to decode it\n      if (!decryptedUri.includes(\"://\") || !decryptedUri.endsWith(\"/\")) {\n        throw new Error(\"invalid password\");\n      }\n    } catch (e) {\n      throw new Error(\"invalid password\");\n    }\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"reveal\", [batchId, key])\n    };\n  }\n\n  /**\n   * Gets the list of unrevealed NFT batches.\n   * @remarks Gets the list of unrevealed NFT batches.\n   * @example\n   * ```javascript\n   * const batches = await contract.revealer.getBatchesToReveal();\n   * ```\n   * @public\n   */\n  async getBatchesToReveal() {\n    const count = await this.contractWrapper.readContract.getBaseURICount();\n    if (count.isZero()) {\n      return [];\n    }\n    const countRangeArray = Array.from(Array(count.toNumber()).keys());\n    // map over to get the base uri indices, which should be the end token id of every batch\n    const uriIndices = await Promise.all(countRangeArray.map(i => {\n      if (hasFunction(\"getBatchIdAtIndex\", this.contractWrapper)) {\n        return this.contractWrapper.readContract.getBatchIdAtIndex(i);\n      }\n      if (hasFunction(\"baseURIIndices\", this.contractWrapper)) {\n        return this.contractWrapper.readContract.baseURIIndices(i);\n      }\n      throw new Error(\"Contract does not have getBatchIdAtIndex or baseURIIndices.\");\n    }));\n\n    // first batch always start from 0. don't need to fetch the last batch so pop it from the range array\n    const uriIndicesWithZeroStart = uriIndices.slice(0, uriIndices.length - 1);\n\n    // returns the token uri for each batches. first batch always starts from token id 0.\n    const tokenMetadatas = await Promise.all(Array.from([0, ...uriIndicesWithZeroStart]).map(i => this.getNftMetadata(i.toString())));\n\n    // index is the uri indices, which is end token id. different from uris\n    const legacyContract = await this.isLegacyContract();\n    const encryptedUriData = await Promise.all(Array.from([...uriIndices]).map(i => legacyContract ? this.getLegacyEncryptedData(i) : this.contractWrapper.readContract.encryptedData(i)));\n    const encryptedBaseUris = encryptedUriData.map(data => {\n      if (ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.hexDataLength(data) > 0) {\n        if (legacyContract) {\n          return data;\n        }\n        const result = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.defaultAbiCoder.decode([\"bytes\", \"bytes32\"], data);\n        return result[0];\n      } else {\n        return data;\n      }\n    });\n    return tokenMetadatas.map((meta, index) => ({\n      batchId: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(index),\n      batchUri: meta.uri,\n      placeholderMetadata: meta\n    })).filter((_, index) => ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.hexDataLength(encryptedBaseUris[index]) > 0);\n  }\n\n  /**\n   * Algorithm to hash delay reveal password, so we don't broadcast the input password on-chain.\n   *\n   * @internal\n   */\n  async hashDelayRevealPasword(batchTokenIndex, password) {\n    const chainId = await this.contractWrapper.getChainID();\n    const contractAddress = this.contractWrapper.readContract.address;\n    return ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.solidityKeccak256([\"string\", \"uint256\", \"uint256\", \"address\"], [password, chainId, batchTokenIndex, contractAddress]);\n  }\n  async getNftMetadata(tokenId) {\n    return fetchTokenMetadataForContract(this.contractWrapper.readContract.address, this.contractWrapper.getProvider(), tokenId, this.storage);\n  }\n  async isLegacyContract() {\n    if (hasFunction(\"contractVersion\", this.contractWrapper)) {\n      try {\n        const version = await this.contractWrapper.readContract.contractVersion();\n        return version <= 2;\n      } catch (e) {\n        return false;\n      }\n    }\n    return false;\n  }\n  async getLegacyEncryptedData(index) {\n    const legacy = new ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.Contract(this.contractWrapper.readContract.address, _thirdweb_dev_contracts_js_dist_abis_IDelayedRevealDeprecated_json__WEBPACK_IMPORTED_MODULE_43__, this.contractWrapper.getProvider());\n    const result = await legacy.functions[\"encryptedBaseURI\"](index);\n    if (result.length > 0) {\n      return result[0];\n    } else {\n      return \"0x\";\n    }\n  }\n}\n\nlet ListingType;\n(function (ListingType) {\n  ListingType[ListingType[\"Direct\"] = 0] = \"Direct\";\n  ListingType[ListingType[\"Auction\"] = 1] = \"Auction\";\n})(ListingType || (ListingType = {}));\n\nlet ProposalState;\n(function (ProposalState) {\n  ProposalState[ProposalState[\"Pending\"] = 0] = \"Pending\";\n  ProposalState[ProposalState[\"Active\"] = 1] = \"Active\";\n  ProposalState[ProposalState[\"Canceled\"] = 2] = \"Canceled\";\n  ProposalState[ProposalState[\"Defeated\"] = 3] = \"Defeated\";\n  ProposalState[ProposalState[\"Succeeded\"] = 4] = \"Succeeded\";\n  ProposalState[ProposalState[\"Queued\"] = 5] = \"Queued\";\n  ProposalState[ProposalState[\"Expired\"] = 6] = \"Expired\";\n  ProposalState[ProposalState[\"Executed\"] = 7] = \"Executed\";\n})(ProposalState || (ProposalState = {}));\n\nlet VoteType;\n(function (VoteType) {\n  VoteType[VoteType[\"Against\"] = 0] = \"Against\";\n  VoteType[VoteType[\"For\"] = 1] = \"For\";\n  VoteType[VoteType[\"Abstain\"] = 2] = \"Abstain\";\n})(VoteType || (VoteType = {}));\n\nlet ClaimEligibility;\n(function (ClaimEligibility) {\n  ClaimEligibility[\"NotEnoughSupply\"] = \"There is not enough supply to claim.\";\n  ClaimEligibility[\"AddressNotAllowed\"] = \"This address is not on the allowlist.\";\n  ClaimEligibility[\"WaitBeforeNextClaimTransaction\"] = \"Not enough time since last claim transaction. Please wait.\";\n  ClaimEligibility[\"AlreadyClaimed\"] = \"You have already claimed the token.\";\n  ClaimEligibility[\"NotEnoughTokens\"] = \"There are not enough tokens in the wallet to pay for the claim.\";\n  ClaimEligibility[\"NoActiveClaimPhase\"] = \"There is no active claim phase at the moment. Please check back in later.\";\n  ClaimEligibility[\"NoClaimConditionSet\"] = \"There is no claim condition set.\";\n  ClaimEligibility[\"NoWallet\"] = \"No wallet connected.\";\n  ClaimEligibility[\"Unknown\"] = \"No claim conditions found.\";\n})(ClaimEligibility || (ClaimEligibility = {}));\n\n/**\n * Estimates the gas cost of Contract calls\n * @public\n */\nclass GasCostEstimator {\n  constructor(contractWrapper) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Estimates the cost of gas in native token of the current chain\n   * Pass in the same parameters as the contract's function.\n   * @remarks Estimate the cost of gas in native token of the current chain\n   * @example\n   * ```javascript\n   * const costOfClaim = await nftDrop?.estimator.gasCostOf(\"claim\", [\n   *   \"0x...\", // receiver\n   *   1, // quantity\n   *   \"0x...\", // currency\n   *   1, // price per token\n   *   [], // proofs\n   *   1, // proof max quantity per transaction\n   * ]);\n   * ```\n   * @returns the estimated price in native currency (ETH, MATIC, etc) of calling this function\n   * @public\n   */\n  async gasCostOf(fn, args) {\n    const price = await this.contractWrapper.getPreferredGasPrice();\n    const gasUnits = await this.contractWrapper.estimateGas(fn, args);\n    return ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.formatEther(gasUnits.mul(price));\n  }\n\n  /**\n   * Estimates the gas limit of a transaction\n   * Pass in the same parameters as the contract's function.\n   * @remarks Estimates the gas limit of a transaction\n   * @example\n   * ```javascript\n   * const gasLimitOfClaim = await nftDrop?.estimator.gasLimitOf(\"claim\", [\n   *   \"0x...\", // receiver\n   *   1, // quantity\n   *   \"0x...\", // currency\n   *   1, // price per token\n   *   [], // proofs\n   *   1, // proof max quantity per transaction\n   * ]);\n   * ```\n   * @returns the estimated gas limit of the transaction\n   * @public\n   */\n  async gasLimitOf(fn, args) {\n    return this.contractWrapper.estimateGas(fn, args);\n  }\n\n  /**\n   * Returns the current gas price in gwei\n   * @remarks Get the current gas price in gwei\n   * @example\n   * ```javascript\n   * const gasCostInGwei = await contract.estimator.currentGasPriceInGwei();\n   * ```\n   * @returns the current gas price in gwei\n   * @public\n   */\n  async currentGasPriceInGwei() {\n    const price = await this.contractWrapper.getProvider().getGasPrice();\n    return ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.formatUnits(price, \"gwei\");\n  }\n}\n\n/**\n * @internal\n * Represents a transaction to be executed and can be customized.\n */\nclass TransactionTask {\n  static make(taskArgs) {\n    return new TransactionTask(taskArgs);\n  }\n  constructor(taskArgs) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"functionName\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"args\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"overrides\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"encoder\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"estimator\", void 0);\n    this.contractWrapper = taskArgs.contractWrapper;\n    this.functionName = taskArgs.functionName;\n    this.args = taskArgs.args || [];\n    this.overrides = taskArgs.overrides;\n    this.encoder = new ContractEncoder(this.contractWrapper);\n    this.estimator = new GasCostEstimator(this.contractWrapper);\n  }\n\n  // ////////////// Overrides ////////////////\n\n  /**\n   * Override the gas limit for this transaction.\n   * @param gasLimit\n   */\n  overrideGasLimit(gasLimit) {\n    this.overrides = {\n      ...this.overrides,\n      gasLimit\n    };\n    return this;\n  }\n\n  /**\n   * Override the gas price for this transaction.\n   * @param gasPrice\n   */\n  overrideGasPrice(gasPrice) {\n    this.overrides = {\n      ...this.overrides,\n      gasPrice\n    };\n    return this;\n  }\n\n  /**\n   * Override the nonce for this transaction.\n   * @param nonce\n   */\n  overrideNonce(nonce) {\n    this.overrides = {\n      ...this.overrides,\n      nonce\n    };\n    return this;\n  }\n\n  /**\n   * Override the value sent with this transaction.\n   * @param value\n   */\n  overrideValue(value) {\n    this.overrides = {\n      ...this.overrides,\n      value\n    };\n    return this;\n  }\n\n  // ////////////// Estimates ////////////////\n\n  /**\n   * Returns the gas limit that this transaction would consume if executed.\n   * @returns the gas limit in gas units\n   */\n  async estimateGasLimit() {\n    return await this.estimator.gasLimitOf(this.functionName, this.args);\n  }\n\n  /**\n   * Returns the total gas cost of this transaction if executed.\n   * @returns the gas cost in ether\n   */\n  async estimateGasCostInEther() {\n    return await this.estimator.gasCostOf(this.functionName, this.args);\n  }\n\n  // ////////////// Actions ////////////////\n\n  /**\n   * Returns the encoded function data of this transaction if executed.\n   */\n  async encodeFunctionData() {\n    return this.encoder.encode(this.functionName, this.args);\n  }\n\n  /**\n   * Submits this transaction to the network. Does not wait for the transaction to be mined.\n   * To wait for the transaction to be mined, you can call `.wait()` on the result of this function.\n   */\n  async submit() {\n    return await this.contractWrapper.sendTransactionByFunction(this.functionName, this.args, this.overrides || {});\n  }\n\n  /**\n   * Submits this transaction to the network and waits for it to be mined.\n   */\n  async execute() {\n    const receipt = await this.contractWrapper.sendTransaction(this.functionName, this.args, this.overrides || {});\n    return {\n      receipt\n    };\n  }\n}\n\n/**\n * Manages claim conditions for NFT Drop contracts\n * @public\n */\nclass DropClaimConditions {\n  constructor(contractWrapper, metadata, storage) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"metadata\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    this.storage = storage;\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n  }\n\n  /** ***************************************\n   * READ FUNCTIONS\n   *****************************************/\n\n  /**\n   * Get the currently active claim condition\n   *\n   * @returns the claim condition metadata\n   */\n  async getActive(options) {\n    const cc = await this.get();\n    const metadata = await this.metadata.get();\n    return await transformResultToClaimCondition(cc, await this.getTokenDecimals(), this.contractWrapper.getProvider(), metadata.merkle || {}, this.storage, options?.withAllowList || false);\n  }\n  async get(conditionId) {\n    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      const contractModel = await this.contractWrapper.readContract.claimCondition();\n      return legacyContractModelToAbstract(contractModel);\n    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.readContract.getActiveClaimConditionId();\n      const contractModel = await this.contractWrapper.readContract.getClaimConditionById(id);\n      return legacyContractModelToAbstract(contractModel);\n    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n      const contractModel = await this.contractWrapper.readContract.claimCondition();\n      return newContractModelToAbstract(contractModel);\n    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.readContract.getActiveClaimConditionId();\n      const contractModel = await this.contractWrapper.readContract.getClaimConditionById(id);\n      return newContractModelToAbstract(contractModel);\n    } else {\n      throw new Error(\"Contract does not support claim conditions\");\n    }\n  }\n\n  /**\n   * Get all the claim conditions\n   *\n   * @returns the claim conditions metadata\n   */\n  async getAll(options) {\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const claimCondition = await this.contractWrapper.readContract.claimCondition();\n      const startId = claimCondition.currentStartId.toNumber();\n      const count = claimCondition.count.toNumber();\n      const conditions = [];\n      for (let i = startId; i < startId + count; i++) {\n        conditions.push(await this.get(i));\n      }\n      const metadata = await this.metadata.get();\n      const decimals = await this.getTokenDecimals();\n      return Promise.all(conditions.map(c => transformResultToClaimCondition(c, decimals, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options?.withAllowList || false)));\n    } else {\n      return [await this.getActive(options)];\n    }\n  }\n\n  /**\n   * Can Claim\n   *\n   * @remarks Check if the drop can currently be claimed.\n   *\n   * @example\n   * ```javascript\n   * // Quantity of tokens to check claimability of\n   * const quantity = 1;\n   * const canClaim = await contract.canClaim(quantity);\n   * ```\n   */\n  async canClaim(quantity, addressToCheck) {\n    // TODO switch to use verifyClaim\n    return (await this.getClaimIneligibilityReasons(quantity, addressToCheck)).length === 0;\n  }\n\n  /**\n   * For any claim conditions that a particular wallet is violating,\n   * this function returns human readable information about the\n   * breaks in the condition that can be used to inform the user.\n   *\n   * @param quantity - The desired quantity that would be claimed.\n   * @param addressToCheck - The wallet address, defaults to the connected wallet.\n   *\n   */\n  async getClaimIneligibilityReasons(quantity, addressToCheck) {\n    const reasons = [];\n    let activeConditionIndex;\n    let claimCondition;\n    const decimals = await this.getTokenDecimals();\n    const quantityWithDecimals = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.parseUnits(_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.A.parse(quantity), decimals);\n    if (addressToCheck === undefined) {\n      try {\n        addressToCheck = await this.contractWrapper.getSignerAddress();\n      } catch (err) {\n        console.warn(\"failed to get signer address\", err);\n      }\n    }\n\n    // if we have been unable to get a signer address, we can't check eligibility, so return a NoWallet error reason\n    if (!addressToCheck) {\n      return [ClaimEligibility.NoWallet];\n    }\n    try {\n      claimCondition = await this.getActive();\n    } catch (err) {\n      if (includesErrorMessage(err, \"!CONDITION\") || includesErrorMessage(err, \"no active mint condition\")) {\n        reasons.push(ClaimEligibility.NoClaimConditionSet);\n        return reasons;\n      }\n      console.warn(\"failed to get active claim condition\", err);\n      reasons.push(ClaimEligibility.Unknown);\n      return reasons;\n    }\n    if (claimCondition.availableSupply !== \"unlimited\") {\n      const supplyWithDecimals = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.parseUnits(claimCondition.availableSupply, decimals);\n      if (supplyWithDecimals.lt(quantityWithDecimals)) {\n        reasons.push(ClaimEligibility.NotEnoughSupply);\n      }\n    }\n\n    // check for merkle root inclusion\n    const merkleRootArray = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.stripZeros(claimCondition.merkleRootHash);\n    const hasAllowList = merkleRootArray.length > 0;\n    let allowListEntry = null;\n    if (hasAllowList) {\n      allowListEntry = await this.getClaimerProofs(addressToCheck);\n      if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {\n        // exclusive allowlist behavior\n        reasons.push(ClaimEligibility.AddressNotAllowed);\n        return reasons;\n      }\n      if (allowListEntry) {\n        try {\n          const claimVerification = await this.prepareClaim(quantity, false, decimals, addressToCheck);\n          let validMerkleProof;\n          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n            activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId();\n            // legacy verifyClaimerMerkleProofs function\n            [validMerkleProof] = await this.contractWrapper.readContract.verifyClaimMerkleProof(activeConditionIndex, addressToCheck, quantity, claimVerification.proofs, claimVerification.maxClaimable);\n            if (!validMerkleProof) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n            [validMerkleProof] = await this.contractWrapper.readContract.verifyClaimMerkleProof(addressToCheck, quantity, {\n              proof: claimVerification.proofs,\n              maxQuantityInAllowlist: claimVerification.maxClaimable\n            });\n            if (!validMerkleProof) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n            await this.contractWrapper.readContract.verifyClaim(addressToCheck, quantity, claimVerification.currencyAddress, claimVerification.price, {\n              proof: claimVerification.proofs,\n              quantityLimitPerWallet: claimVerification.maxClaimable,\n              currency: claimVerification.currencyAddressInProof,\n              pricePerToken: claimVerification.priceInProof\n            });\n            if (convertQuantityToBigNumber(claimCondition.maxClaimablePerWallet, decimals).eq(0) && claimVerification.maxClaimable === ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.MaxUint256 || claimVerification.maxClaimable === ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(0)) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n            activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId();\n            await this.contractWrapper.readContract.verifyClaim(activeConditionIndex, addressToCheck, quantity, claimVerification.currencyAddress, claimVerification.price, {\n              proof: claimVerification.proofs,\n              quantityLimitPerWallet: claimVerification.maxClaimable,\n              currency: claimVerification.currencyAddressInProof,\n              pricePerToken: claimVerification.priceInProof\n            });\n            if (convertQuantityToBigNumber(claimCondition.maxClaimablePerWallet, decimals).eq(0) && claimVerification.maxClaimable === ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.MaxUint256 || claimVerification.maxClaimable === ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(0)) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          }\n        } catch (e) {\n          console.warn(\"Merkle proof verification failed:\", \"reason\" in e ? e.reason : e);\n          reasons.push(ClaimEligibility.AddressNotAllowed);\n          return reasons;\n        }\n      }\n    }\n\n    // TODO (cc) check for max claimable per wallet and how much each wallet has claimed\n    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      if (!hasAllowList || hasAllowList && !allowListEntry) {\n        if (convertQuantityToBigNumber(claimCondition.maxClaimablePerWallet, decimals).eq(0)) {\n          reasons.push(ClaimEligibility.AddressNotAllowed);\n          return reasons;\n        }\n      }\n    }\n\n    // check for claim timestamp between claims (ONLY FOR LEGACY)\n    if (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      let [lastClaimedTimestamp, timestampForNextClaim] = [ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(0), ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(0)];\n      if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n        activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId();\n        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.readContract.getClaimTimestamp(activeConditionIndex, addressToCheck);\n      } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n        // check for claim timestamp between claims\n        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.readContract.getClaimTimestamp(addressToCheck);\n      }\n      const now = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(Date.now()).div(1000);\n      if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {\n        // contract will return MaxUint256 if user has already claimed and cannot claim again\n        if (timestampForNextClaim.eq(ethers__WEBPACK_IMPORTED_MODULE_58__.constants.MaxUint256)) {\n          reasons.push(ClaimEligibility.AlreadyClaimed);\n        } else {\n          reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);\n        }\n      }\n    }\n\n    // if not within a browser conetext, check for wallet balance.\n    // In browser context, let the wallet do that job\n    if (claimCondition.price.gt(0) && isNode()) {\n      const totalPrice = claimCondition.price.mul(ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(quantity));\n      const provider = this.contractWrapper.getProvider();\n      if (isNativeToken(claimCondition.currencyAddress)) {\n        const balance = await provider.getBalance(addressToCheck);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      } else {\n        const erc20 = new ContractWrapper(provider, claimCondition.currencyAddress, _thirdweb_dev_contracts_js_dist_abis_IERC20_json__WEBPACK_IMPORTED_MODULE_13__, {});\n        const balance = await erc20.readContract.balanceOf(addressToCheck);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      }\n    }\n    return reasons;\n  }\n\n  /**\n   * Returns allow list information and merkle proofs for the given address.\n   * @param claimerAddress - the claimer address\n   * @param claimConditionId - optional the claim condition id to get the proofs for\n   */\n  async getClaimerProofs(claimerAddress, claimConditionId) {\n    const claimCondition = await this.get(claimConditionId);\n    const merkleRoot = claimCondition.merkleRoot;\n    const merkleRootArray = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.stripZeros(merkleRoot);\n    if (merkleRootArray.length > 0) {\n      const metadata = await this.metadata.get();\n      return await fetchSnapshotEntryForAddress(claimerAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());\n    } else {\n      return null;\n    }\n  }\n\n  /** ***************************************\n   * WRITE FUNCTIONS\n   *****************************************/\n\n  /**\n   * Set public mint conditions\n   *\n   * @remarks Sets the public mint conditions that need to be fullfiled by users to claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   *\n   * // Optionally specify addresses that can claim\n   * const snapshots = ['0x...', '0x...']\n   *\n   * // Or alternatively, you can pass snapshots with the max number of NFTs each address can claim\n   * // const snapshots = [{ address: '0x...', maxClaimable: 1 }, { address: '0x...', maxClaimable: 2 }]\n   *\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxQuantity: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: snapshots, // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   *\n   * await dropContract.claimConditions.set(claimConditions);\n   * ```\n   *\n   * @param claimConditionInputs - The claim conditions\n   * @param resetClaimEligibilityForAll - Whether to reset the state of who already claimed NFTs previously\n   */\n  async set(claimConditionInputs) {\n    let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let claimConditionsProcessed = claimConditionInputs;\n    if (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isNewSinglePhaseDrop(this.contractWrapper)) {\n      resetClaimEligibilityForAll = true;\n      if (claimConditionInputs.length === 0) {\n        claimConditionsProcessed = [{\n          startTime: new Date(0),\n          currencyAddress: ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.AddressZero,\n          price: 0,\n          maxClaimableSupply: 0,\n          maxClaimablePerWallet: 0,\n          waitInSeconds: 0,\n          merkleRootHash: ethers__WEBPACK_IMPORTED_MODULE_58__.utils.hexZeroPad([0], 32),\n          snapshot: []\n        }];\n      } else if (claimConditionInputs.length > 1) {\n        throw new Error(\"Single phase drop contract cannot have multiple claim conditions, only one is allowed\");\n      }\n    }\n\n    // if using new snapshot format, make sure that maxClaimablePerWallet is set if allowlist is set as well\n    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      claimConditionsProcessed.forEach(cc => {\n        if (cc.snapshot && cc.snapshot.length > 0 && (cc.maxClaimablePerWallet === undefined || cc.maxClaimablePerWallet === \"unlimited\")) {\n          throw new Error(\"maxClaimablePerWallet must be set to a specific value when an allowlist is set.\\n\" + \"Example: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\\n\" + \"contract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])\");\n        }\n        if (cc.snapshot && cc.snapshot.length > 0 && cc.maxClaimablePerWallet?.toString() === \"0\" && cc.snapshot.map(s => {\n          if (typeof s === \"string\") {\n            return 0;\n          } else {\n            return Number(s.maxClaimable?.toString() || 0);\n          }\n        }).reduce((acc, current) => {\n          return acc + current;\n        }, 0) === 0) {\n          throw new Error(\"maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.\");\n        }\n      });\n    }\n\n    // process inputs\n    const {\n      snapshotInfos,\n      sortedConditions\n    } = await processClaimConditionInputs(claimConditionsProcessed, await this.getTokenDecimals(), this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());\n    const merkleInfo = {};\n    snapshotInfos.forEach(s => {\n      merkleInfo[s.merkleRoot] = s.snapshotUri;\n    });\n    const metadata = await this.metadata.get();\n    const encoded = [];\n\n    // upload new merkle roots to snapshot URIs if updated\n    if (!fast_deep_equal__WEBPACK_IMPORTED_MODULE_40___default()(metadata.merkle, merkleInfo)) {\n      const mergedMetadata = this.metadata.parseInputMetadata({\n        ...metadata,\n        merkle: merkleInfo\n      });\n      // using internal method to just upload, avoids one contract call\n      const contractURI = await this.metadata._parseAndUploadMetadata(mergedMetadata);\n\n      // TODO (cc) we could write the merkle tree info on the claim condition metadata instead\n      // TODO (cc) but we still need to maintain the behavior here for older contracts\n      if (hasFunction(\"setContractURI\", this.contractWrapper)) {\n        encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData(\"setContractURI\", [contractURI]));\n      } else {\n        throw new Error(\"Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.\");\n      }\n    }\n    const cw = this.contractWrapper;\n    if (this.isLegacySinglePhaseDrop(cw)) {\n      encoded.push(cw.readContract.interface.encodeFunctionData(\"setClaimConditions\", [abstractContractModelToLegacy(sortedConditions[0]), resetClaimEligibilityForAll]));\n    } else if (this.isLegacyMultiPhaseDrop(cw)) {\n      encoded.push(cw.readContract.interface.encodeFunctionData(\"setClaimConditions\", [sortedConditions.map(abstractContractModelToLegacy), resetClaimEligibilityForAll]));\n    } else if (this.isNewSinglePhaseDrop(cw)) {\n      encoded.push(cw.readContract.interface.encodeFunctionData(\"setClaimConditions\", [abstractContractModelToNew(sortedConditions[0]), resetClaimEligibilityForAll]));\n    } else if (this.isNewMultiphaseDrop(cw)) {\n      encoded.push(cw.readContract.interface.encodeFunctionData(\"setClaimConditions\", [sortedConditions.map(abstractContractModelToNew), resetClaimEligibilityForAll]));\n    } else {\n      throw new Error(\"Contract does not support claim conditions\");\n    }\n    return {\n      receipt: await this.contractWrapper.multiCall(encoded)\n    };\n  }\n\n  /**\n   * Update a single claim condition with new data.\n   *\n   * @param index - the index of the claim condition to update, as given by the index from the result of `getAll()`\n   * @param claimConditionInput - the new data to update, previous data will be retained\n   */\n  async update(index, claimConditionInput) {\n    const existingConditions = await this.getAll();\n    const newConditionInputs = await updateExistingClaimConditions(index, claimConditionInput, existingConditions);\n    return await this.set(newConditionInputs);\n  }\n\n  /** ***************************************\n   * PRIVATE FUNCTIONS\n   *****************************************/\n\n  async getTokenDecimals() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20\")) {\n      return this.contractWrapper.readContract.decimals();\n    } else {\n      return Promise.resolve(0);\n    }\n  }\n\n  /**\n   * Returns proofs and the overrides required for the transaction.\n   *\n   * @returns - `overrides` and `proofs` as an object.\n   * @internal\n   */\n  async prepareClaim(quantity, checkERC20Allowance) {\n    let decimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let address = arguments.length > 3 ? arguments[3] : undefined;\n    const addressToClaim = address ? address : await this.contractWrapper.getSignerAddress();\n    return prepareClaim(addressToClaim, quantity, await this.getActive(), async () => (await this.metadata.get()).merkle, decimals, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());\n  }\n  async getClaimArguments(destinationAddress, quantity, claimVerification) {\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      return [destinationAddress, quantity, claimVerification.currencyAddress, claimVerification.price, claimVerification.proofs, claimVerification.maxClaimable];\n    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      return [destinationAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n        proof: claimVerification.proofs,\n        maxQuantityInAllowlist: claimVerification.maxClaimable\n      }, ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.toUtf8Bytes(\"\")];\n    }\n    return [destinationAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n      proof: claimVerification.proofs,\n      quantityLimitPerWallet: claimVerification.maxClaimable,\n      pricePerToken: claimVerification.priceInProof,\n      currency: claimVerification.currencyAddressInProof\n    }, ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.toUtf8Bytes(\"\")];\n  }\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress\n   * @param quantity\n   * @param options\n   */\n  async getClaimTransaction(destinationAddress, quantity, options) {\n    if (options?.pricePerToken) {\n      throw new Error(\"Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`\");\n    }\n    const claimVerification = await this.prepareClaim(quantity, options?.checkERC20Allowance === undefined ? true : options.checkERC20Allowance, await this.getTokenDecimals());\n    return TransactionTask.make({\n      contractWrapper: this.contractWrapper,\n      functionName: \"claim\",\n      args: await this.getClaimArguments(destinationAddress, quantity, claimVerification),\n      overrides: claimVerification.overrides\n    });\n  }\n  isNewSinglePhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimConditionsV2\") || detectContractFeature(contractWrapper, \"ERC20ClaimConditionsV2\");\n  }\n  isNewMultiphaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimPhasesV2\") || detectContractFeature(contractWrapper, \"ERC20ClaimPhasesV2\");\n  }\n  isLegacySinglePhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimConditionsV1\") || detectContractFeature(contractWrapper, \"ERC20ClaimConditionsV1\");\n  }\n  isLegacyMultiPhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimPhasesV1\") || detectContractFeature(contractWrapper, \"ERC20ClaimPhasesV1\");\n  }\n  getSnapshotFormatVersion() {\n    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? SnapshotFormatVersion.V1 : SnapshotFormatVersion.V2;\n  }\n}\n\n/**\n * Manages claim conditions for Edition Drop contracts\n * @public\n */\nclass DropErc1155ClaimConditions {\n  constructor(contractWrapper, metadata, storage) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"metadata\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    this.storage = storage;\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n  }\n\n  /** ***************************************\n   * READ FUNCTIONS\n   *****************************************/\n\n  /**\n   * Get the currently active claim condition\n   *\n   * @returns the claim condition metadata\n   */\n  async getActive(tokenId, options) {\n    const mc = await this.get(tokenId);\n    const metadata = await this.metadata.get();\n    return await transformResultToClaimCondition(mc, 0, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options?.withAllowList || false);\n  }\n  async get(tokenId, conditionId) {\n    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      const contractModel = await this.contractWrapper.readContract.claimCondition(tokenId);\n      return legacyContractModelToAbstract(contractModel);\n    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.readContract.getActiveClaimConditionId(tokenId);\n      const contractModel = await this.contractWrapper.readContract.getClaimConditionById(tokenId, id);\n      return legacyContractModelToAbstract(contractModel);\n    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n      const contractModel = await this.contractWrapper.readContract.claimCondition(tokenId);\n      return newContractModelToAbstract(contractModel);\n    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.readContract.getActiveClaimConditionId(tokenId);\n      const contractModel = await this.contractWrapper.readContract.getClaimConditionById(tokenId, id);\n      return newContractModelToAbstract(contractModel);\n    } else {\n      throw new Error(\"Contract does not support claim conditions\");\n    }\n  }\n\n  /**\n   * Get all the claim conditions\n   *\n   * @returns the claim conditions metadata\n   */\n  async getAll(tokenId, options) {\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const claimCondition = await this.contractWrapper.readContract.claimCondition(tokenId);\n      const startId = claimCondition.currentStartId.toNumber();\n      const count = claimCondition.count.toNumber();\n      const conditions = [];\n      for (let i = startId; i < startId + count; i++) {\n        conditions.push(await this.get(tokenId, i));\n      }\n      const metadata = await this.metadata.get();\n      return Promise.all(conditions.map(c => transformResultToClaimCondition(c, 0, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options?.withAllowList || false)));\n    } else {\n      return [await this.getActive(tokenId, options)];\n    }\n  }\n\n  /**\n   * Can Claim\n   *\n   * @remarks Check if a particular NFT can currently be claimed by a given user.\n   *\n   * @example\n   * ```javascript\n   * // Quantity of tokens to check claimability of\n   * const quantity = 1;\n   * const canClaim = await contract.canClaim(quantity);\n   * ```\n   */\n  async canClaim(tokenId, quantity, addressToCheck) {\n    // TODO switch to use verifyClaim\n    return (await this.getClaimIneligibilityReasons(tokenId, quantity, addressToCheck)).length === 0;\n  }\n\n  /**\n   * For any claim conditions that a particular wallet is violating,\n   * this function returns human-readable information about the\n   * breaks in the condition that can be used to inform the user.\n   *\n   * @param tokenId - the token id to check\n   * @param quantity - The desired quantity that would be claimed.\n   * @param addressToCheck - The wallet address, defaults to the connected wallet.\n   *\n   */\n  async getClaimIneligibilityReasons(tokenId, quantity, addressToCheck) {\n    const reasons = [];\n    let activeConditionIndex;\n    let claimCondition;\n    if (addressToCheck === undefined) {\n      try {\n        addressToCheck = await this.contractWrapper.getSignerAddress();\n      } catch (err) {\n        console.warn(\"failed to get signer address\", err);\n      }\n    }\n\n    // if we have been unable to get a signer address, we can't check eligibility, so return a NoWallet error reason\n    if (!addressToCheck) {\n      return [ClaimEligibility.NoWallet];\n    }\n    try {\n      claimCondition = await this.getActive(tokenId);\n    } catch (err) {\n      if (includesErrorMessage(err, \"!CONDITION\") || includesErrorMessage(err, \"no active mint condition\")) {\n        reasons.push(ClaimEligibility.NoClaimConditionSet);\n        return reasons;\n      }\n      reasons.push(ClaimEligibility.Unknown);\n      return reasons;\n    }\n    if (claimCondition.availableSupply !== \"unlimited\") {\n      if (ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(claimCondition.availableSupply).lt(quantity)) {\n        reasons.push(ClaimEligibility.NotEnoughSupply);\n      }\n    }\n\n    // check for merkle root inclusion\n    const merkleRootArray = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.stripZeros(claimCondition.merkleRootHash);\n    const hasAllowList = merkleRootArray.length > 0;\n    let allowListEntry = null;\n    if (hasAllowList) {\n      allowListEntry = await this.getClaimerProofs(tokenId, addressToCheck);\n      if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {\n        // exclusive allowlist behavior\n        reasons.push(ClaimEligibility.AddressNotAllowed);\n        return reasons;\n      }\n      if (allowListEntry) {\n        try {\n          const claimVerification = await this.prepareClaim(tokenId, quantity, false, addressToCheck);\n          let validMerkleProof;\n          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n            activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId(tokenId);\n            // legacy verifyClaimerMerkleProofs function\n            [validMerkleProof] = await this.contractWrapper.readContract.verifyClaimMerkleProof(activeConditionIndex, addressToCheck, tokenId, quantity, claimVerification.proofs, claimVerification.maxClaimable);\n            if (!validMerkleProof) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n            [validMerkleProof] = await this.contractWrapper.readContract.verifyClaimMerkleProof(tokenId, addressToCheck, quantity, {\n              proof: claimVerification.proofs,\n              maxQuantityInAllowlist: claimVerification.maxClaimable\n            });\n            if (!validMerkleProof) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n            await this.contractWrapper.readContract.verifyClaim(tokenId, addressToCheck, quantity, claimVerification.currencyAddress, claimVerification.price, {\n              proof: claimVerification.proofs,\n              quantityLimitPerWallet: claimVerification.maxClaimable,\n              currency: claimVerification.currencyAddressInProof,\n              pricePerToken: claimVerification.priceInProof\n            });\n            // TODO (cc) in new override format, anyone can claim (no allow list restriction)\n            // TODO (cc) instead check if maxClaimablePerWallet is 0 and this address has no overrides\n            // TODO (cc) meaning this address is not allowed to claim\n            if (claimCondition.maxClaimablePerWallet === \"0\" && claimVerification.maxClaimable === ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.MaxUint256 || claimVerification.maxClaimable === ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(0)) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n            activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId(tokenId);\n            await this.contractWrapper.readContract.verifyClaim(activeConditionIndex, addressToCheck, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {\n              proof: claimVerification.proofs,\n              quantityLimitPerWallet: claimVerification.maxClaimable,\n              currency: claimVerification.currencyAddressInProof,\n              pricePerToken: claimVerification.priceInProof\n            });\n            if (claimCondition.maxClaimablePerWallet === \"0\" && claimVerification.maxClaimable === ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.MaxUint256 || claimVerification.maxClaimable === ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(0)) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          }\n        } catch (e) {\n          console.warn(\"Merkle proof verification failed:\", \"reason\" in e ? e.reason : e);\n          reasons.push(ClaimEligibility.AddressNotAllowed);\n          return reasons;\n        }\n      }\n    }\n\n    // TODO (cc) check for max claimable per wallet and how much each wallet has claimed\n    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      if (!hasAllowList || hasAllowList && !allowListEntry) {\n        if (claimCondition.maxClaimablePerWallet === \"0\") {\n          reasons.push(ClaimEligibility.AddressNotAllowed);\n          return reasons;\n        }\n      }\n    }\n\n    // check for claim timestamp between claims\n    let [lastClaimedTimestamp, timestampForNextClaim] = [ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(0), ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(0)];\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId(tokenId);\n      [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.readContract.getClaimTimestamp(tokenId, activeConditionIndex, addressToCheck);\n    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.readContract.getClaimTimestamp(tokenId, addressToCheck);\n    }\n    const now = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(Date.now()).div(1000);\n    if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {\n      // contract will return MaxUint256 if user has already claimed and cannot claim again\n      if (timestampForNextClaim.eq(ethers__WEBPACK_IMPORTED_MODULE_58__.constants.MaxUint256)) {\n        reasons.push(ClaimEligibility.AlreadyClaimed);\n      } else {\n        reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);\n      }\n    }\n\n    // if not within a browser conetext, check for wallet balance.\n    // In browser context, let the wallet do that job\n    if (claimCondition.price.gt(0) && isNode()) {\n      const totalPrice = claimCondition.price.mul(quantity);\n      const provider = this.contractWrapper.getProvider();\n      if (isNativeToken(claimCondition.currencyAddress)) {\n        const balance = await provider.getBalance(addressToCheck);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      } else {\n        const erc20 = new ContractWrapper(provider, claimCondition.currencyAddress, _thirdweb_dev_contracts_js_dist_abis_IERC20_json__WEBPACK_IMPORTED_MODULE_13__, {});\n        const balance = await erc20.readContract.balanceOf(addressToCheck);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      }\n    }\n    return reasons;\n  }\n\n  /**\n   * Returns allow list information and merkle proofs for the given address.\n   * @param tokenId - the token ID to check\n   * @param claimerAddress - the claimer address\n   * @param claimConditionId - optional the claim condition id to get the proofs for\n   */\n  async getClaimerProofs(tokenId, claimerAddress, claimConditionId) {\n    const claimCondition = await this.get(tokenId, claimConditionId);\n    const merkleRoot = claimCondition.merkleRoot;\n    const merkleRootArray = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.stripZeros(merkleRoot);\n    if (merkleRootArray.length > 0) {\n      const metadata = await this.metadata.get();\n      return await fetchSnapshotEntryForAddress(claimerAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());\n    } else {\n      return null;\n    }\n  }\n\n  /** ***************************************\n   * WRITE FUNCTIONS\n   *****************************************/\n\n  /**\n   * Set claim conditions on a single NFT\n   *\n   * @remarks Sets the public mint conditions that need to be fulfilled by users to claim a particular NFT in this contract.\n   *\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   *\n   * // Optionally specify addresses that can claim\n   * const snapshots = ['0x...', '0x...']\n   *\n   * // Or alternatively, you can pass snapshots with the max number of NFTs each address can claim\n   * // const snapshots = [{ address: '0x...', maxClaimable: 1 }, { address: '0x...', maxClaimable: 2 }]\n   *\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxQuantity: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: snapshots, // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   *\n   * const tokenId = 0; // the id of the NFT to set claim conditions on\n   * await dropContract.claimConditions.set(tokenId, claimConditions);\n   * ```\n   *\n   * @param tokenId - The id of the NFT to set the claim conditions on\n   * @param claimConditionInputs - The claim conditions\n   * @param resetClaimEligibilityForAll - Whether to reset the state of who already claimed NFTs previously\n   */\n  async set(tokenId, claimConditionInputs) {\n    let resetClaimEligibilityForAll = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return this.setBatch([{\n      tokenId,\n      claimConditions: claimConditionInputs\n    }], resetClaimEligibilityForAll);\n  }\n\n  /**\n   * Set claim conditions on multiple NFTs at once\n   *\n   * @remarks Sets the claim conditions that need to be fulfilled by users to claim the given NFTs in this contract.\n   *\n   * @example\n   * ```javascript\n   * const claimConditionsForTokens = [\n   *   {\n   *     tokenId: 0,\n   *     claimConditions: [{\n   *       startTime: new Date(), // start the claim phase now\n   *       maxQuantity: 2, // limit how many mints for this tokenId\n   *       price: 0.01, // price for this tokenId\n   *       snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *     }]\n   *   },\n   *   {\n   *     tokenId: 1,\n   *     claimConditions: [{\n   *       startTime: new Date(),\n   *       price: 0.08, // different price for this tokenId\n   *     }]\n   *   },\n   * ];\n   *\n   * await dropContract.claimConditions.setBatch(claimConditionsForTokens);\n   * ```\n   *\n   * @param claimConditionsForToken - The claim conditions for each NFT\n   * @param resetClaimEligibilityForAll - Whether to reset the state of who already claimed NFTs previously\n   */\n  async setBatch(claimConditionsForToken) {\n    let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const merkleInfo = {};\n    const processedClaimConditions = await Promise.all(claimConditionsForToken.map(async _ref => {\n      let {\n        tokenId,\n        claimConditions\n      } = _ref;\n      // sanitize for single phase deletions\n      let claimConditionsProcessed = claimConditions;\n      if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n        resetClaimEligibilityForAll = true;\n        if (claimConditions.length === 0) {\n          claimConditionsProcessed = [{\n            startTime: new Date(0),\n            currencyAddress: ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.AddressZero,\n            price: 0,\n            maxClaimableSupply: 0,\n            maxClaimablePerWallet: 0,\n            waitInSeconds: 0,\n            merkleRootHash: ethers__WEBPACK_IMPORTED_MODULE_58__.utils.hexZeroPad([0], 32),\n            snapshot: []\n          }];\n        } else if (claimConditions.length > 1) {\n          throw new Error(\"Single phase drop contract cannot have multiple claim conditions, only one is allowed\");\n        }\n      }\n      // if using new snapshot format, make sure that maxClaimablePerWallet is set if allowlist is set as well\n      if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n        claimConditionsProcessed.forEach(cc => {\n          if (cc.snapshot && cc.snapshot.length > 0 && (cc.maxClaimablePerWallet === undefined || cc.maxClaimablePerWallet === \"unlimited\")) {\n            throw new Error(\"maxClaimablePerWallet must be set to a specific value when an allowlist is set.\\n\" + \"Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\" + \"\\n\\nex:\\n\" + \"contract.claimConditions.set(tokenId, [{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])\");\n          }\n          if (cc.snapshot && cc.snapshot.length > 0 && cc.maxClaimablePerWallet?.toString() === \"0\" && cc.snapshot.map(s => {\n            if (typeof s === \"string\") {\n              return 0;\n            } else {\n              return Number(s.maxClaimable?.toString() || 0);\n            }\n          }).reduce((acc, current) => {\n            return acc + current;\n          }, 0) === 0) {\n            throw new Error(\"maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.\");\n          }\n        });\n      }\n      // process inputs\n      const {\n        snapshotInfos,\n        sortedConditions\n      } = await processClaimConditionInputs(claimConditionsProcessed, 0, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());\n      snapshotInfos.forEach(s => {\n        merkleInfo[s.merkleRoot] = s.snapshotUri;\n      });\n      return {\n        tokenId,\n        sortedConditions\n      };\n    }));\n    const metadata = await this.metadata.get();\n    const encoded = [];\n\n    // keep the old merkle roots from other tokenIds\n    for (const key of Object.keys(metadata.merkle || {})) {\n      merkleInfo[key] = metadata.merkle[key];\n    }\n\n    // upload new merkle roots to snapshot URIs if updated\n    if (!fast_deep_equal__WEBPACK_IMPORTED_MODULE_40___default()(metadata.merkle, merkleInfo)) {\n      const mergedMetadata = this.metadata.parseInputMetadata({\n        ...metadata,\n        merkle: merkleInfo\n      });\n      // using internal method to just upload, avoids one contract call\n      const contractURI = await this.metadata._parseAndUploadMetadata(mergedMetadata);\n      if (hasFunction(\"setContractURI\", this.contractWrapper)) {\n        encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData(\"setContractURI\", [contractURI]));\n      } else {\n        throw new Error(\"Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.\");\n      }\n    }\n    processedClaimConditions.forEach(_ref2 => {\n      let {\n        tokenId,\n        sortedConditions\n      } = _ref2;\n      if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n        encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData(\"setClaimConditions\", [tokenId, abstractContractModelToLegacy(sortedConditions[0]), resetClaimEligibilityForAll]));\n      } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n        encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData(\"setClaimConditions\", [tokenId, sortedConditions.map(abstractContractModelToLegacy), resetClaimEligibilityForAll]));\n      } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n        encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData(\"setClaimConditions\", [tokenId, abstractContractModelToNew(sortedConditions[0]), resetClaimEligibilityForAll]));\n      } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n        encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData(\"setClaimConditions\", [tokenId, sortedConditions.map(abstractContractModelToNew), resetClaimEligibilityForAll]));\n      } else {\n        throw new Error(\"Contract does not support claim conditions\");\n      }\n    });\n    return {\n      receipt: await this.contractWrapper.multiCall(encoded)\n    };\n  }\n\n  /**\n   * Update a single claim condition with new data.\n   * @param tokenId - the token id to update\n   * @param index - the index of the claim condition to update, as given by the index from the result of `getAll()`\n   * @param claimConditionInput - the new data to update, previous data will be retained\n   */\n  async update(tokenId, index, claimConditionInput) {\n    const existingConditions = await this.getAll(tokenId);\n    const newConditionInputs = await updateExistingClaimConditions(index, claimConditionInput, existingConditions);\n    return await this.set(tokenId, newConditionInputs);\n  }\n\n  /**\n   * Returns proofs and the overrides required for the transaction.\n   *\n   * @returns - `overrides` and `proofs` as an object.\n   */\n  async prepareClaim(tokenId, quantity, checkERC20Allowance, address) {\n    const addressToClaim = address ? address : await this.contractWrapper.getSignerAddress();\n    return prepareClaim(addressToClaim, quantity, await this.getActive(tokenId), async () => (await this.metadata.get()).merkle, 0, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());\n  }\n  async getClaimArguments(tokenId, destinationAddress, quantity, claimVerification) {\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      return [destinationAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, claimVerification.proofs, claimVerification.maxClaimable];\n    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      return [destinationAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {\n        proof: claimVerification.proofs,\n        maxQuantityInAllowlist: claimVerification.maxClaimable\n      }, ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.toUtf8Bytes(\"\")];\n    }\n    return [destinationAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {\n      proof: claimVerification.proofs,\n      quantityLimitPerWallet: claimVerification.maxClaimable,\n      pricePerToken: claimVerification.priceInProof,\n      currency: claimVerification.currencyAddressInProof\n    }, ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.toUtf8Bytes(\"\")];\n  }\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   */\n  async getClaimTransaction(destinationAddress, tokenId, quantity, options) {\n    if (options?.pricePerToken) {\n      throw new Error(\"Price per token should be set via claim conditions by calling `contract.erc1155.claimConditions.set()`\");\n    }\n    const claimVerification = await this.prepareClaim(tokenId, quantity, options?.checkERC20Allowance || true);\n    return TransactionTask.make({\n      contractWrapper: this.contractWrapper,\n      functionName: \"claim\",\n      args: await this.getClaimArguments(tokenId, destinationAddress, quantity, claimVerification),\n      overrides: claimVerification.overrides\n    });\n  }\n  isNewSinglePhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC1155ClaimConditionsV2\");\n  }\n  isNewMultiphaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC1155ClaimPhasesV2\");\n  }\n  isLegacySinglePhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC1155ClaimConditionsV1\");\n  }\n  isLegacyMultiPhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC1155ClaimPhasesV1\");\n  }\n  getSnapshotFormatVersion() {\n    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? SnapshotFormatVersion.V1 : SnapshotFormatVersion.V2;\n  }\n}\n\n/**\n * Manages history for Edition Drop contracts\n * @public\n */\nclass DropErc1155History {\n  constructor(events) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"events\", void 0);\n    this.events = events;\n  }\n\n  /**\n   * Get all claimer addresses\n   *\n   * @remarks Get a list of all the addresses that have claimed a token\n   * @param tokenId - the tokenId of the NFT to get the addresses of*\n   * @returns - A unique list of addresses that claimed the token\n   * @example\n   * ```javascript\n   * const tokenId = \"0\";\n   * const allClaimerAddresses = await contract.history.getAllClaimerAddresses(tokenId);\n   * ```\n   */\n  async getAllClaimerAddresses(tokenId) {\n    const a = (await this.events.getEvents(\"TokensClaimed\")).filter(e => e.data && ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.isBigNumber(e.data.tokenId) ? e.data.tokenId.eq(tokenId) : false);\n    return Array.from(new Set(a.filter(b => typeof b.data?.claimer === \"string\").map(b => b.data.claimer)));\n  }\n}\n\nclass Erc20Burnable {\n  constructor(erc20, contractWrapper) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_TOKEN_BURNABLE.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"erc20\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    this.erc20 = erc20;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Burn Tokens\n   *\n   * @remarks Burn tokens held by the connected wallet\n   *\n   * @example\n   * ```javascript\n   * // The amount of this token you want to burn\n   * const amount = 1.2;\n   *\n   * await contract.token.burn.tokens(amount);\n   * ```\n   */\n  async tokens(amount) {\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"burn\", [await this.erc20.normalizeAmount(amount)])\n    };\n  }\n\n  /**\n   * Burn Tokens\n   *\n   * @remarks Burn tokens held by the specified wallet\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet sending the tokens\n   * const holderAddress = \"{{wallet_address}}\";\n   *\n   * // The amount of this token you want to burn\n   * const amount = 1.2;\n   *\n   * await contract.token.burn.from(holderAddress, amount);\n   * ```\n   */\n  async from(holder, amount) {\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"burnFrom\", [holder, await this.erc20.normalizeAmount(amount)])\n    };\n  }\n}\n\n/**\n * Configure and claim ERC20 tokens\n * @remarks Manage claim phases and claim ERC20 tokens that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.token.drop.claim.to(\"0x...\", quantity);\n * ```\n */\nclass Erc20ClaimableWithConditions {\n  /**\n   * Configure claim conditions\n   * @remarks Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxQuantity: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   * await contract.token.drop.claim.conditions.set(claimConditions);\n   * ```\n   */\n\n  constructor(erc20, contractWrapper, storage) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_TOKEN_CLAIM_CONDITIONS_V2.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"conditions\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"erc20\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    this.erc20 = erc20;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);\n    this.conditions = new DropClaimConditions(this.contractWrapper, metadata, this.storage);\n  }\n\n  /**\n   * Claim a certain amount of tokens to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim Tokens.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 42.69; // how many tokens you want to claim\n   *\n   * const tx = await contract.token.drop.claim.to(address, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param amount - Quantity of the tokens you want to claim\n   * @param checkERC20Allowance - Optional, check if the wallet has enough ERC20 allowance to claim the tokens, and if not, approve the transfer\n   * @param claimData\n   * @returns - The transaction receipt\n   */\n  async to(destinationAddress, amount, options) {\n    const quantity = await this.erc20.normalizeAmount(amount);\n    const task = await this.conditions.getClaimTransaction(destinationAddress, quantity, options);\n    return await task.execute();\n  }\n}\n\n/**\n * Configure and claim ERC20 tokens\n * @remarks Manage claim phases and claim ERC20 tokens that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.token.drop.claim.to(\"0x...\", quantity);\n * ```\n */\nclass Erc20Droppable {\n  /**\n   * Configure claim conditions\n   * @remarks Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxQuantity: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   * await contract.nft.drop.claim.conditions.set(claimConditions);\n   * ```\n   */\n\n  constructor(erc20, contractWrapper, storage) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"claim\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"erc20\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    this.erc20 = erc20;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.claim = new Erc20ClaimableWithConditions(this.erc20, this.contractWrapper, this.storage);\n  }\n}\n\n/**\n * Mint Many ERC20 Tokens at once\n * @remarks Token batch minting functionality that handles unit parsing for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.token.mint.batch.to(walletAddress, [nftMetadata1, nftMetadata2, ...]);\n * ```\n * @public\n */\nclass Erc20BatchMintable {\n  constructor(erc20, contractWrapper) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_TOKEN_BATCH_MINTABLE.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"erc20\", void 0);\n    this.erc20 = erc20;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Mint Tokens To Many Wallets\n   *\n   * @remarks Mint tokens to many wallets in one transaction.\n   *\n   * @example\n   * ```javascript\n   * // Data of the tokens you want to mint\n   * const data = [\n   *   {\n   *     toAddress: \"{{wallet_address}}\", // Address to mint tokens to\n   *     amount: 0.2, // How many tokens to mint to specified address\n   *   },\n   *  {\n   *    toAddress: \"0x...\",\n   *    amount: 1.4,\n   *  }\n   * ]\n   *\n   * await contract.token.mint.batch(data);\n   * ```\n   */\n  async to(args) {\n    const encoded = [];\n    for (const arg of args) {\n      encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData(\"mintTo\", [arg.toAddress, await this.erc20.normalizeAmount(arg.amount)]));\n    }\n    return {\n      receipt: await this.contractWrapper.multiCall(encoded)\n    };\n  }\n}\n\n/**\n * Mint ERC20 Tokens\n * @remarks Token minting functionality that handles unit parsing for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.nft.mint.to(walletAddress, nftMetadata);\n * ```\n * @public\n */\nclass Erc20Mintable {\n  /**\n   * Batch mint Tokens to many addresses\n   */\n\n  constructor(erc20, contractWrapper) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_TOKEN_MINTABLE.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"erc20\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"batch\", void 0);\n    this.erc20 = erc20;\n    this.contractWrapper = contractWrapper;\n    this.batch = this.detectErc20BatchMintable();\n  }\n\n  /**\n   * Mint Tokens\n   *\n   * @remarks Mint tokens to a specified address.\n   *\n   * @example\n   * ```javascript\n   * const toAddress = \"{{wallet_address}}\"; // Address of the wallet you want to mint the tokens to\n   * const amount = \"1.5\"; // The amount of this token you want to mint\n   * await contract.token.mint.to(toAddress, amount);\n   * ```\n   */\n  async to(to, amount) {\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"mintTo\", [to, await this.erc20.normalizeAmount(amount)])\n    };\n  }\n  detectErc20BatchMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20BatchMintable\")) {\n      return new Erc20BatchMintable(this.erc20, this.contractWrapper);\n    }\n    return undefined;\n  }\n}\n\n/**\n * Enables generating ERC20 Tokens with rules and an associated signature, which can then be minted by anyone securely\n * @public\n */\n// TODO consolidate into a single class\nclass Erc20SignatureMintable {\n  constructor(contractWrapper, roles) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_TOKEN_SIGNATURE_MINTABLE.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"roles\", void 0);\n    this.contractWrapper = contractWrapper;\n    this.roles = roles;\n  }\n\n  /**\n   * Mint tokens from a signature\n   *\n   * @remarks Mint a certain amount of tokens from a previously generated signature.\n   *\n   * @example\n   * ```javascript\n   * // see how to craft a payload to sign in the `generate()` documentation\n   * const signedPayload = contract.erc20.signature.generate(payload);\n   *\n   * // Use the signed payload to mint the tokens\n   * const tx = contract.erc20.signature.mint(signedPayload);\n   * ```\n   * @param signedPayload - the previously generated payload and signature with {@link Erc20SignatureMintable.generate}\n   * @twfeature ERC20SignatureMintable\n   */\n  async mint(signedPayload) {\n    const mintRequest = signedPayload.payload;\n    const signature = signedPayload.signature;\n    const message = await this.mapPayloadToContractStruct(mintRequest);\n    const overrides = await this.contractWrapper.getCallOverrides();\n    await setErc20Allowance(this.contractWrapper, ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(message.price), mintRequest.currencyAddress, overrides);\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"mintWithSignature\", [message, signature], overrides)\n    };\n  }\n\n  /**\n   * Mint any number of generated tokens signatures at once\n   * @remarks Mint multiple token signatures in one transaction. Note that this is only possible for free mints (cannot batch mints with a price attached to it for security reasons)\n   * @param signedPayloads - the array of signed payloads to mint\n   * @twfeature ERC20SignatureMintable\n   */\n  async mintBatch(signedPayloads) {\n    const contractPayloads = await Promise.all(signedPayloads.map(async s => {\n      const message = await this.mapPayloadToContractStruct(s.payload);\n      const signature = s.signature;\n      const price = s.payload.price;\n      if (ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(price).gt(0)) {\n        throw new Error(\"Can only batch free mints. For mints with a price, use regular mint()\");\n      }\n      return {\n        message,\n        signature\n      };\n    }));\n    const encoded = contractPayloads.map(p => {\n      return this.contractWrapper.readContract.interface.encodeFunctionData(\"mintWithSignature\", [p.message, p.signature]);\n    });\n    return {\n      receipt: await this.contractWrapper.multiCall(encoded)\n    };\n  }\n\n  /**\n   * Verify that a payload is correctly signed\n   * @param signedPayload - the payload to verify\n   * @twfeature ERC20SignatureMintable\n   *\n   * ```javascript\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   quantity: 4.2, // The quantity of tokens to be minted\n   *   to: {{wallet_address}}, // Who will receive the tokens\n   *   price: 0.5, // the price to pay for minting those tokens\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now,\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this token mint\n   * };\n   *\n   * const signedPayload = await contract.erc20.signature.generate(payload);\n   * // Now you can verify if the signed payload is valid\n   * const isValid = await contract.erc20.signature.verify(signedPayload);\n   * ```\n   */\n  async verify(signedPayload) {\n    const mintRequest = signedPayload.payload;\n    const signature = signedPayload.signature;\n    const message = await this.mapPayloadToContractStruct(mintRequest);\n    const verification = await this.contractWrapper.readContract.verify(message, signature);\n    return verification[0];\n  }\n\n  /**\n   * Generate a signature that can be used to mint a certain amount of tokens\n   *\n   * @remarks Takes in a quantity of tokens, some conditions for how it can be minted and signs it with your private key. The generated signature can then be used to mint those tokens using the exact payload and signature generated.\n   *\n   * @example\n   * ```javascript\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   quantity: 4.2, // The quantity of tokens to be minted\n   *   to: {{wallet_address}}, // Who will receive the tokens\n   *   price: 0.5, // the price to pay for minting those tokens\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now,\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this token mint\n   * };\n   *\n   * const signedPayload = await contract.erc20.signature.generate(payload);\n   * // now anyone can use these to mint the NFT using `contract.erc20.signature.mint(signedPayload)`\n   * ```\n   * @param mintRequest - the payload to sign\n   * @returns the signed payload and the corresponding signature\n   * @twfeature ERC20SignatureMintable\n   */\n  async generate(mintRequest) {\n    return (await this.generateBatch([mintRequest]))[0];\n  }\n\n  /**\n   * Generate a batch of signatures that can be used to mint many token signatures.\n   *\n   * @remarks See {@link Erc20SignatureMintable.generate}\n   *\n   * @param payloadsToSign - the payloads to sign\n   * @returns an array of payloads and signatures\n   * @twfeature ERC20SignatureMintable\n   */\n  async generateBatch(payloadsToSign) {\n    await this.roles?.verify([\"minter\"], await this.contractWrapper.getSignerAddress());\n    const parsedRequests = payloadsToSign.map(m => Signature20PayloadInput.parse(m));\n    const chainId = await this.contractWrapper.getChainID();\n    const signer = this.contractWrapper.getSigner();\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(signer, \"No signer available\");\n\n    // ERC20Permit (EIP-712) spec differs from signature mint 721, 1155.\n    const name = await this.contractWrapper.readContract.name();\n    return await Promise.all(parsedRequests.map(async m => {\n      const finalPayload = Signature20PayloadOutput.parse(m);\n      const signature = await this.contractWrapper.signTypedData(signer, {\n        name,\n        version: \"1\",\n        chainId,\n        verifyingContract: this.contractWrapper.readContract.address\n      }, {\n        MintRequest: MintRequest20\n      }, await this.mapPayloadToContractStruct(finalPayload));\n      return {\n        payload: finalPayload,\n        signature: signature.toString()\n      };\n    }));\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Maps a payload to the format expected by the contract\n   *\n   * @internal\n   *\n   * @param mintRequest - The payload to map.\n   * @returns - The mapped payload.\n   */\n  async mapPayloadToContractStruct(mintRequest) {\n    const normalizedPrice = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);\n    const amountWithDecimals = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.parseUnits(mintRequest.quantity, await this.contractWrapper.readContract.decimals());\n    return {\n      to: mintRequest.to,\n      primarySaleRecipient: mintRequest.primarySaleRecipient,\n      quantity: amountWithDecimals,\n      price: normalizedPrice,\n      currency: mintRequest.currencyAddress,\n      validityEndTimestamp: mintRequest.mintEndTime,\n      validityStartTimestamp: mintRequest.mintStartTime,\n      uid: mintRequest.uid\n    };\n  }\n}\n\n/**\n * Standard ERC20 Token functions\n * @remarks Basic functionality for a ERC20 contract that handles all unit transformation for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc20.transfer(walletAddress, amount);\n * ```\n * @public\n */\nclass Erc20 {\n  /**\n   * Mint tokens\n   */\n\n  get chainId() {\n    return this._chainId;\n  }\n  constructor(contractWrapper, storage, chainId) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_TOKEN.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"mintable\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"burnable\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"droppable\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"signatureMintable\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"_chainId\", void 0);\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.mintable = this.detectErc20Mintable();\n    this.burnable = this.detectErc20Burnable();\n    this.droppable = this.detectErc20Droppable();\n    this.signatureMintable = this.detectErc20SignatureMintable();\n    this._chainId = chainId;\n  }\n\n  /**\n   * @internal\n   */\n  onNetworkUpdated(network) {\n    this.contractWrapper.updateSignerOrProvider(network);\n  }\n\n  /**\n   * @internal\n   */\n  getAddress() {\n    return this.contractWrapper.readContract.address;\n  }\n\n  ////// Standard ERC20 Extension //////\n\n  /**\n   * Get the token Metadata (name, symbol, etc...)\n   *\n   * @example\n   * ```javascript\n   * const token = await contract.erc20.get();\n   * ```\n   * @returns The token metadata\n   * @twfeature ERC20\n   */\n  async get() {\n    return await fetchCurrencyMetadata(this.contractWrapper.getProvider(), this.getAddress());\n  }\n\n  /**\n   * Get Token Balance for the currently connected wallet\n   *\n   * @remarks Get a wallets token balance.\n   *\n   * @example\n   * ```javascript\n   * const balance = await contract.erc20.balance();\n   * ```\n   *\n   * @returns The balance of a specific wallet.\n   * @twfeature ERC20\n   */\n  async balance() {\n    return await this.balanceOf(await this.contractWrapper.getSignerAddress());\n  }\n\n  /**\n   * Get Token Balance\n   *\n   * @remarks Get a wallets token balance.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to check token balance\n   * const walletAddress = \"{{wallet_address}}\";\n   * const balance = await contract.erc20.balanceOf(walletAddress);\n   * ```\n   *\n   * @returns The balance of a specific wallet.\n   * @twfeature ERC20\n   */\n  async balanceOf(address) {\n    return this.getValue(await this.contractWrapper.readContract.balanceOf(address));\n  }\n\n  /**\n   * The total supply for this Token\n   * @remarks Get how much supply has been minted\n   * @example\n   * ```javascript\n   * const balance = await contract.erc20.totalSupply();\n   * ```\n   * @twfeature ERC20\n   */\n  async totalSupply() {\n    return await this.getValue(await this.contractWrapper.readContract.totalSupply());\n  }\n\n  /**\n   * Get Token Allowance\n   *\n   * @remarks Get the allowance of a 'spender' wallet over the connected wallet's funds - the allowance of a different address for a token is the amount of tokens that the `spender` wallet is allowed to spend on behalf of the connected wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to check token allowance\n   * const spenderAddress = \"0x...\";\n   * const allowance = await contract.erc20.allowance(spenderAddress);\n   * ```\n   *\n   * @returns The allowance of one wallet over anothers funds.\n   * @twfeature ERC20\n   */\n  async allowance(spender) {\n    return await this.allowanceOf(await this.contractWrapper.getSignerAddress(), spender);\n  }\n\n  /**\n   * Get Token Allowance\n   *\n   * @remarks Get the allowance of one wallet over another wallet's funds - the allowance of a different address for a token is the amount of tokens that the wallet is allowed to spend on behalf of the specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet who owns the funds\n   * const owner = \"{{wallet_address}}\";\n   * // Address of the wallet to check token allowance\n   * const spender = \"0x...\";\n   * const allowance = await contract.erc20.allowanceOf(owner, spender);\n   * ```\n   *\n   * @returns The allowance of one wallet over anothers funds.\n   * @twfeature ERC20\n   */\n  async allowanceOf(owner, spender) {\n    return await this.getValue(await this.contractWrapper.readContract.allowance(owner, spender));\n  }\n\n  /**\n   * Transfer Tokens\n   *\n   * @remarks Transfer tokens from the connected wallet to another wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to send the tokens to\n   * const toAddress = \"0x...\";\n   * // The amount of tokens you want to send\n   * const amount = 0.1;\n   * await contract.erc20.transfer(toAddress, amount);\n   * ```\n   * @twfeature ERC20\n   */\n  async transfer(to, amount) {\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"transfer\", [to, await this.normalizeAmount(amount)])\n    };\n  }\n\n  /**\n   * Transfer Tokens From Address\n   *\n   * @remarks Transfer tokens from one wallet to another\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet sending the tokens\n   * const fromAddress = \"{{wallet_address}}\";\n   * // Address of the wallet you want to send the tokens to\n   * const toAddress = \"0x...\";\n   * // The number of tokens you want to send\n   * const amount = 1.2\n   * // Note that the connected wallet must have approval to transfer the tokens of the fromAddress\n   * await contract.erc20.transferFrom(fromAddress, toAddress, amount);\n   * ```\n   * @twfeature ERC20\n   */\n  async transferFrom(from, to, amount) {\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"transferFrom\", [from, to, await this.normalizeAmount(amount)])\n    };\n  }\n\n  /**\n   * Allows the specified `spender` wallet to transfer the given `amount` of tokens to another wallet\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to allow transfers from\n   * const spenderAddress = \"0x...\";\n   * // The number of tokens to give as allowance\n   * const amount = 100\n   * await contract.erc20.setAllowance(spenderAddress, amount);\n   * ```\n   * @twfeature ERC20\n   */\n  async setAllowance(spender, amount) {\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"approve\", [spender, await this.normalizeAmount(amount)])\n    };\n  }\n\n  /**\n   * Transfer Tokens To Many Wallets\n   *\n   * @remarks Mint tokens from the connected wallet to many wallets\n   *\n   * @example\n   * ```javascript\n   * // Data of the tokens you want to mint\n   * const data = [\n   *   {\n   *     toAddress: \"{{wallet_address}}\", // Address to mint tokens to\n   *     amount: 100, // How many tokens to mint to specified address\n   *   },\n   *  {\n   *    toAddress: \"0x...\",\n   *    amount: 100,\n   *  }\n   * ]\n   *\n   * await contract.erc20.transferBatch(data);\n   * ```\n   */\n  async transferBatch(args) {\n    const encoded = await Promise.all(args.map(async arg => {\n      const amountWithDecimals = await this.normalizeAmount(arg.amount);\n      return this.contractWrapper.readContract.interface.encodeFunctionData(\"transfer\", [arg.toAddress, amountWithDecimals]);\n    }));\n    await this.contractWrapper.multiCall(encoded);\n  }\n\n  ////// ERC20 Mintable Extension //////\n\n  /**\n   * Mint Tokens\n   *\n   * @remarks Mint tokens to the connected wallet.\n   *\n   * @example\n   * ```javascript\n   * const amount = \"1.5\"; // The amount of this token you want to mint\n   * await contract.erc20.mint(toAddress, amount);\n   * ```\n   * @twfeature ERC20Mintable\n   */\n  async mint(amount) {\n    return this.mintTo(await this.contractWrapper.getSignerAddress(), amount);\n  }\n\n  /**\n   * Mint Tokens\n   *\n   * @remarks Mint tokens to a specified address.\n   *\n   * @example\n   * ```javascript\n   * const toAddress = \"{{wallet_address}}\"; // Address of the wallet you want to mint the tokens to\n   * const amount = \"1.5\"; // The amount of this token you want to mint\n   * await contract.erc20.mintTo(toAddress, amount);\n   * ```\n   * @twfeature ERC20Mintable\n   */\n  async mintTo(receiver, amount) {\n    return assertEnabled(this.mintable, FEATURE_TOKEN_MINTABLE).to(receiver, amount);\n  }\n\n  ////// ERC20 BatchMintable Extension //////\n\n  /**\n   * Mint Tokens To Many Wallets\n   *\n   * @remarks Mint tokens to many wallets in one transaction.\n   *\n   * @example\n   * ```javascript\n   * // Data of the tokens you want to mint\n   * const data = [\n   *   {\n   *     toAddress: \"{{wallet_address}}\", // Address to mint tokens to\n   *     amount: 0.2, // How many tokens to mint to specified address\n   *   },\n   *  {\n   *    toAddress: \"0x...\",\n   *    amount: 1.4,\n   *  }\n   * ]\n   *\n   * await contract.mintBatchTo(data);\n   * ```\n   * @twfeature ERC20BatchMintable\n   */\n  async mintBatchTo(args) {\n    return assertEnabled(this.mintable?.batch, FEATURE_TOKEN_BATCH_MINTABLE).to(args);\n  }\n\n  ////// ERC20 Burnable Extension //////\n\n  /**\n   * Burn Tokens\n   *\n   * @remarks Burn tokens held by the connected wallet\n   *\n   * @example\n   * ```javascript\n   * // The amount of this token you want to burn\n   * const amount = 1.2;\n   *\n   * await contract.erc20.burn(amount);\n   * ```\n   * @twfeature ERC20Burnable\n   */\n  async burn(amount) {\n    return assertEnabled(this.burnable, FEATURE_TOKEN_BURNABLE).tokens(amount);\n  }\n\n  /**\n   * Burn Tokens\n   *\n   * @remarks Burn tokens held by the specified wallet\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet sending the tokens\n   * const holderAddress = \"{{wallet_address}}\";\n   *\n   * // The amount of this token you want to burn\n   * const amount = 1.2;\n   *\n   * await contract.erc20.burnFrom(holderAddress, amount);\n   * ```\n   * @twfeature ERC20Burnable\n   */\n  async burnFrom(holder, amount) {\n    return assertEnabled(this.burnable, FEATURE_TOKEN_BURNABLE).from(holder, amount);\n  }\n\n  ////// ERC20 Claimable Extension //////\n\n  /**\n   * Claim a certain amount of tokens to the connected Wallet\n   *\n   * @remarks Let the specified wallet claim Tokens.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 42.69; // how many tokens you want to claim\n   *\n   * const tx = await contract.erc20.claim(address, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param amount - Quantity of the tokens you want to claim\n   * @param checkERC20Allowance - Optional, check if the wallet has enough ERC20 allowance to claim the tokens, and if not, approve the transfer\n   * @param claimData\n   * @returns - The transaction receipt\n   * @twfeature ERC20ClaimableWithConditions\n   */\n  async claim(amount, options) {\n    return this.claimTo(await this.contractWrapper.getSignerAddress(), amount, options);\n  }\n\n  /**\n   * Claim a certain amount of tokens to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim Tokens.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 42.69; // how many tokens you want to claim\n   *\n   * const tx = await contract.erc20.claim(address, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param amount - Quantity of the tokens you want to claim\n   * @param checkERC20Allowance - Optional, check if the wallet has enough ERC20 allowance to claim the tokens, and if not, approve the transfer\n   * @param claimData\n   * @returns - The transaction receipt\n   * @twfeature ERC20ClaimableWithConditions\n   */\n  async claimTo(destinationAddress, amount, options) {\n    return assertEnabled(this.droppable?.claim, FEATURE_TOKEN_CLAIM_CONDITIONS_V2).to(destinationAddress, amount, options);\n  }\n\n  /**\n   * Configure claim conditions\n   * @remarks Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxQuantity: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   * await contract.erc20.claimConditions.set(claimConditions);\n   * ```\n   * @twfeature ERC20ClaimableWithConditions\n   */\n  get claimConditions() {\n    return assertEnabled(this.droppable?.claim, FEATURE_TOKEN_CLAIM_CONDITIONS_V2).conditions;\n  }\n\n  ////// ERC20 SignatureMint Extension //////\n\n  /**\n   * Signature Minting\n   * @remarks Generate dynamic tokens with your own signature, and let others mint them using that signature.\n   * @example\n   * ```javascript\n   * // see how to craft a payload to sign in the `contract.erc20.signature.generate()` documentation\n   * const signedPayload = contract.erc20.signature().generate(payload);\n   *\n   * // now the payload can be used to mint tokens\n   * const tx = contract.erc20.signature.mint(signedPayload);\n   * ```\n   * @twfeature ERC20SignatureMintable\n   */\n  get signature() {\n    return assertEnabled(this.signatureMintable, FEATURE_TOKEN_SIGNATURE_MINTABLE);\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * returns the wei amount from a token amount\n   * @internal\n   * @param amount\n   */\n  async normalizeAmount(amount) {\n    const decimals = await this.contractWrapper.readContract.decimals();\n    return ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.parseUnits(_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.A.parse(amount), decimals);\n  }\n\n  /**\n   * @internal\n   */\n  async getValue(value) {\n    return await fetchCurrencyValue(this.contractWrapper.getProvider(), this.getAddress(), ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(value));\n  }\n  detectErc20Mintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20\")) {\n      return new Erc20Mintable(this, this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc20Burnable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20Burnable\")) {\n      return new Erc20Burnable(this, this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc20Droppable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20ClaimConditionsV1\") || detectContractFeature(this.contractWrapper, \"ERC20ClaimConditionsV2\") || detectContractFeature(this.contractWrapper, \"ERC20ClaimPhasesV1\") || detectContractFeature(this.contractWrapper, \"ERC20ClaimPhasesV2\")) {\n      return new Erc20Droppable(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc20SignatureMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20SignatureMintable\")) {\n      return new Erc20SignatureMintable(this.contractWrapper);\n    }\n    return undefined;\n  }\n}\n\n/**\n * Manages history for Token contracts\n * @public\n */\nclass TokenERC20History {\n  constructor(contractWrapper, events) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"events\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    this.contractWrapper = contractWrapper;\n    this.events = events;\n  }\n\n  /**\n   * Get all holder balances\n   *\n   * @remarks Lets you get all token holders and their corresponding balances\n   * @returns - A JSON object of all token holders and their corresponding balances\n   * @example\n   * ```javascript\n   * const allHolderBalances = await contract.history.getAllHolderBalances();\n   * ```\n   */\n  async getAllHolderBalances() {\n    const a = await this.events.getEvents(\"Transfer\");\n    const txns = a.map(b => b.data);\n    const balances = {};\n    txns.forEach(item => {\n      const from = item?.from;\n      const to = item?.to;\n      const amount = item?.value;\n      if (!(from === ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero)) {\n        if (!(from in balances)) {\n          balances[from] = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(0);\n        }\n        balances[from] = balances[from].sub(amount);\n      }\n      if (!(to === ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero)) {\n        if (!(to in balances)) {\n          balances[to] = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(0);\n        }\n        balances[to] = balances[to].add(amount);\n      }\n    });\n    return Promise.all(Object.keys(balances).map(async addr => ({\n      holder: addr,\n      balance: await fetchCurrencyValue(this.contractWrapper.getProvider(), this.contractWrapper.readContract.address, balances[addr])\n    })));\n  }\n}\n\n/**\n * Standard ERC20 Token functions\n * @remarks Basic functionality for a ERC20 contract that handles all unit transformation for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.token.transfer(walletAddress, amount);\n * ```\n * @public\n */\nclass StandardErc20 {\n  get chainId() {\n    return this._chainId;\n  }\n  constructor(contractWrapper, storage, chainId) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"erc20\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"_chainId\", void 0);\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.erc20 = new Erc20(this.contractWrapper, this.storage, chainId);\n    this._chainId = chainId;\n  }\n\n  /**\n   * @internal\n   */\n  onNetworkUpdated(network) {\n    this.contractWrapper.updateSignerOrProvider(network);\n  }\n\n  /**\n   * @internal\n   */\n  getAddress() {\n    return this.contractWrapper.readContract.address;\n  }\n\n  /** ******************************\n   * READ FUNCTIONS\n   *******************************/\n\n  /**\n   * Get the token Metadata (name, symbol, etc...)\n   *\n   * @example\n   * ```javascript\n   * const token = await contract.get();\n   * ```\n   * @returns The token metadata\n   */\n  async get() {\n    return this.erc20.get();\n  }\n\n  /**\n   * Get Token Balance for the currently connected wallet\n   *\n   * @remarks Get a wallets token balance.\n   *\n   * @example\n   * ```javascript\n   * const balance = await contract.balance();\n   * ```\n   *\n   * @returns The balance of a specific wallet.\n   */\n  async balance() {\n    return await this.erc20.balance();\n  }\n\n  /**\n   * Get Token Balance\n   *\n   * @remarks Get a wallets token balance.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to check token balance\n   * const walletAddress = \"{{wallet_address}}\";\n   * const balance = await contract.balanceOf(walletAddress);\n   * ```\n   *\n   * @returns The balance of a specific wallet.\n   */\n  async balanceOf(address) {\n    return this.erc20.balanceOf(address);\n  }\n\n  /**\n   * The total supply for this Token\n   * @remarks Get how much supply has been minted\n   * @example\n   * ```javascript\n   * const balance = await contract.totalSupply();\n   * ```\n   */\n  async totalSupply() {\n    return await this.erc20.totalSupply();\n  }\n\n  /**\n   * Get Token Allowance\n   *\n   * @remarks Get the allowance of a 'spender' wallet over the connected wallet's funds - the allowance of a different address for a token is the amount of tokens that the `spender` wallet is allowed to spend on behalf of the connected wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to check token allowance\n   * const spenderAddress = \"0x...\";\n   * const allowance = await contract.allowance(spenderAddress);\n   * ```\n   *\n   * @returns The allowance of one wallet over anothers funds.\n   */\n  async allowance(spender) {\n    return await this.erc20.allowance(spender);\n  }\n\n  /**\n   * Get Token Allowance\n   *\n   * @remarks Get the allowance of one wallet over another wallet's funds - the allowance of a different address for a token is the amount of tokens that the wallet is allowed to spend on behalf of the specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet who owns the funds\n   * const owner = \"{{wallet_address}}\";\n   * // Address of the wallet to check token allowance\n   * const spender = \"0x...\";\n   * const allowance = await contract.allowanceOf(owner, spender);\n   * ```\n   *\n   * @returns The allowance of one wallet over anothers funds.\n   */\n  async allowanceOf(owner, spender) {\n    return await this.erc20.allowanceOf(owner, spender);\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Transfer Tokens\n   *\n   * @remarks Transfer tokens from the connected wallet to another wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to send the tokens to\n   * const toAddress = \"0x...\";\n   * // The amount of tokens you want to send\n   * const amount = 0.1;\n   * await contract.transfer(toAddress, amount);\n   * ```\n   */\n  async transfer(to, amount) {\n    return this.erc20.transfer(to, amount);\n  }\n\n  /**\n   * Transfer Tokens From Address\n   *\n   * @remarks Transfer tokens from one wallet to another\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet sending the tokens\n   * const fromAddress = \"{{wallet_address}}\";\n   * // Address of the wallet you want to send the tokens to\n   * const toAddress = \"0x...\";\n   * // The number of tokens you want to send\n   * const amount = 1.2\n   * // Note that the connected wallet must have approval to transfer the tokens of the fromAddress\n   * await contract.transferFrom(fromAddress, toAddress, amount);\n   * ```\n   */\n  async transferFrom(from, to, amount) {\n    return this.erc20.transferFrom(from, to, amount);\n  }\n\n  /**\n   * Allows the specified `spender` wallet to transfer the given `amount` of tokens to another wallet\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to allow transfers from\n   * const spenderAddress = \"0x...\";\n   * // The number of tokens to give as allowance\n   * const amount = 100\n   * await contract.setAllowance(spenderAddress, amount);\n   * ```\n   */\n  async setAllowance(spender, amount) {\n    return this.erc20.setAllowance(spender, amount);\n  }\n\n  /**\n   * Transfer Tokens To Many Wallets\n   *\n   * @remarks Mint tokens from the connected wallet to many wallets\n   *\n   * @example\n   * ```javascript\n   * // Data of the tokens you want to mint\n   * const data = [\n   *   {\n   *     toAddress: \"{{wallet_address}}\", // Address to mint tokens to\n   *     amount: 100, // How many tokens to mint to specified address\n   *   },\n   *  {\n   *    toAddress: \"0x...\",\n   *    amount: 100,\n   *  }\n   * ]\n   *\n   * await contract.transferBatch(data);\n   * ```\n   */\n  async transferBatch(args) {\n    return this.erc20.transferBatch(args);\n  }\n}\n\nclass Erc721Burnable {\n  constructor(contractWrapper) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_NFT_BURNABLE.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Burn NFTs\n   *\n   * @remarks Burn NFTs held by the connected wallet\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the NFT you want to burn\n   * const tokenId = 0;\n   *\n   * await contract.nft.burn.token(tokenId);\n   * ```\n   */\n  async token(tokenId) {\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"burn\", [tokenId])\n    };\n  }\n}\n\n/**\n * Configure and claim ERC721 NFTs\n * @remarks Manage claim phases and claim ERC721 NFTs that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc721.claim(tokenId, quantity);\n * ```\n */\nclass Erc721Claimable {\n  constructor(erc721, contractWrapper) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_NFT_CLAIM_CUSTOM.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"erc721\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Options for claiming the NFTs\n   */\n  async getClaimTransaction(destinationAddress, quantity, options) {\n    let overrides = {};\n    if (options && options.pricePerToken) {\n      overrides = await calculateClaimCost(this.contractWrapper, options.pricePerToken, quantity, options.currencyAddress, options.checkERC20Allowance);\n    }\n    return TransactionTask.make({\n      contractWrapper: this.contractWrapper,\n      functionName: \"claim\",\n      args: [destinationAddress, quantity],\n      overrides\n    });\n  }\n\n  /**\n   * Claim NFTs to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const tokenId = 0; // the id of the NFT you want to claim\n   * const quantity = 1; // how many NFTs you want to claim\n   *\n   * const tx = await contract.erc721.claimTo(address, tokenId, quantity);\n   * const receipt = tx[0].receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Options for claiming the NFTs\n   *\n   * @returns - Receipt for the transaction\n   */\n  async to(destinationAddress, quantity, options) {\n    const task = await this.getClaimTransaction(destinationAddress, quantity, options);\n    const {\n      receipt\n    } = await task.execute();\n    const event = this.contractWrapper.parseLogs(\"TokensClaimed\", receipt?.logs);\n    const startingIndex = event[0].args.startTokenId;\n    const endingIndex = startingIndex.add(quantity);\n    const results = [];\n    for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {\n      results.push({\n        id,\n        receipt,\n        data: () => this.erc721.get(id)\n      });\n    }\n    return results;\n  }\n}\n\n/**\n * Configure and claim ERC721 NFTs\n * @remarks Manage claim phases and claim ERC721 NFTs that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc721.claim(quantity);\n * await contract.erc721.claimConditions.getActive();\n * ```\n */\nclass Erc721ClaimableWithConditions {\n  /**\n   * Configure claim conditions\n   * @remarks Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxQuantity: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   * await contract.erc721.claimConditions.set(claimConditions);\n   * ```\n   */\n\n  constructor(erc721, contractWrapper, storage) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_NFT_CLAIM_CONDITIONS_V2.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"conditions\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"erc721\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);\n    this.conditions = new DropClaimConditions(this.contractWrapper, metadata, this.storage);\n  }\n\n  /**\n   * Claim unique NFTs to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 1; // how many unique NFTs you want to claim\n   *\n   * const tx = await contract.erc721.claimTo(address, quantity);\n   * const receipt = tx[0].receipt; // the transaction receipt\n   * const claimedTokenId = tx[0].id; // the id of the first NFT claimed\n   * const claimedNFT = await tx[0].data(); // (optional) get the first claimed NFT metadata\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options\n   * @returns - an array of results containing the id of the token claimed, the transaction receipt and a promise to optionally fetch the nft metadata\n   */\n  async to(destinationAddress, quantity, options) {\n    const task = await this.conditions.getClaimTransaction(destinationAddress, quantity, options);\n    const {\n      receipt\n    } = await task.execute();\n    const event = this.contractWrapper.parseLogs(\"TokensClaimed\", receipt?.logs);\n    const startingIndex = event[0].args.startTokenId;\n    const endingIndex = startingIndex.add(quantity);\n    const results = [];\n    for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {\n      results.push({\n        id,\n        receipt,\n        data: () => this.erc721.get(id)\n      });\n    }\n    return results;\n  }\n}\n\n/**\n * Lazily mint and claim ERC721 NFTs\n * @remarks Manage claim phases and claim ERC721 NFTs that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.drop.claim(quantity);\n * ```\n */\nclass Erc721LazyMintable {\n  /**\n   * Delayed reveal\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until you reveal them\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.nft.drop.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * // Whenever you're ready, reveal your NFTs at any time\n   * const batchId = 0; // the batch to reveal\n   * await contract.erc721.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   */\n\n  /**\n   * Claim tokens and configure claim conditions\n   * @remarks Let users claim NFTs. Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const quantity = 10;\n   * await contract.erc721.claim(quantity);\n   * ```\n   */\n\n  constructor(erc721, contractWrapper, storage) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_NFT_LAZY_MINTABLE.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"revealer\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"claimWithConditions\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"claim\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"erc721\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.revealer = this.detectErc721Revealable();\n    this.claimWithConditions = this.detectErc721ClaimableWithConditions();\n    this.claim = this.detectErc721Claimable();\n  }\n\n  /**\n   * Create a batch of unique NFTs to be claimed in the future\n   *\n   * @remarks Create batch allows you to create a batch of many unique NFTs in one transaction.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata of the NFTs to create\n   * const metadatas = [{\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   *\n   * const results = await contract.erc721.lazyMint(metadatas); // uploads and creates the NFTs on chain\n   * const firstTokenId = results[0].id; // token id of the first created NFT\n   * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT\n   * ```\n   *\n   * @param metadatas - The metadata to include in the batch.\n   * @param options - optional upload progress callback\n   */\n  async lazyMint(metadatas, options) {\n    const startFileNumber = await this.erc721.nextTokenIdToMint();\n    const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options);\n    // ensure baseUri is the same for the entire batch\n    const baseUri = getBaseUriFromBatch(batch);\n    const receipt = await this.contractWrapper.sendTransaction(\"lazyMint\", [batch.length, baseUri.endsWith(\"/\") ? baseUri : `${baseUri}/`, ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.toUtf8Bytes(\"\")]);\n    const event = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n    const startingIndex = event[0].args.startTokenId;\n    const endingIndex = event[0].args.endTokenId;\n    const results = [];\n    for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n      results.push({\n        id,\n        receipt,\n        data: () => this.erc721.getTokenMetadata(id)\n      });\n    }\n    return results;\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  detectErc721Revealable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721Revealable\")) {\n      return new DelayedReveal(this.contractWrapper, this.storage, FEATURE_NFT_REVEALABLE.name, () => this.erc721.nextTokenIdToMint());\n    }\n    return undefined;\n  }\n  detectErc721ClaimableWithConditions() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721ClaimConditionsV1\") || detectContractFeature(this.contractWrapper, \"ERC721ClaimConditionsV2\") || detectContractFeature(this.contractWrapper, \"ERC721ClaimPhasesV1\") || detectContractFeature(this.contractWrapper, \"ERC721ClaimPhasesV2\")) {\n      return new Erc721ClaimableWithConditions(this.erc721, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721Claimable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721ClaimCustom\")) {\n      return new Erc721Claimable(this.erc721, this.contractWrapper);\n    }\n    return undefined;\n  }\n}\n\n/**\n * Mint Many ERC721 NFTs at once\n * @remarks NFT batch minting functionality that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.nft.mint.batch.to(walletAddress, [nftMetadata1, nftMetadata2, ...]);\n * ```\n * @public\n */\nclass Erc721BatchMintable {\n  constructor(erc721, contractWrapper, storage) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_NFT_BATCH_MINTABLE.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"erc721\", void 0);\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Mint Many unique NFTs\n   *\n   * @remarks Mint many unique NFTs at once to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const walletAddress = \"{{wallet_address}}\";\n   *\n   * // Custom metadata of the NFTs you want to mint.\n   * const metadatas = [{\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT #2\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/other/image.png\"),\n   * }];\n   *\n   * const tx = await contract.mint.batch.to(walletAddress, metadatas);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   */\n  async to(to, metadatas) {\n    const uris = await uploadOrExtractURIs(metadatas, this.storage);\n    const encoded = uris.map(uri => this.contractWrapper.readContract.interface.encodeFunctionData(\"mintTo\", [to, uri]));\n    const receipt = await this.contractWrapper.multiCall(encoded);\n    const events = this.contractWrapper.parseLogs(\"TokensMinted\", receipt.logs);\n    if (events.length === 0 || events.length < metadatas.length) {\n      throw new Error(\"TokenMinted event not found, minting failed\");\n    }\n    return events.map(e => {\n      const id = e.args.tokenIdMinted;\n      return {\n        id,\n        receipt,\n        data: () => this.erc721.get(id)\n      };\n    });\n  }\n}\n\n/**\n * Mint ERC721 NFTs\n * @remarks NFT minting functionality that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.nft.mint.to(walletAddress, nftMetadata);\n * ```\n * @public\n */\nclass Erc721Mintable {\n  constructor(erc721, contractWrapper, storage) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_NFT_MINTABLE.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"erc721\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"batch\", void 0);\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.batch = this.detectErc721BatchMintable();\n  }\n\n  /**\n   * Mint a unique NFT\n   *\n   * @remarks Mint a unique NFT to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const walletAddress = \"{{wallet_address}}\";\n   *\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const tx = await contract.nft.mint.to(walletAddress, metadata);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   */\n  async to(to, metadata) {\n    const uri = await uploadOrExtractURI(metadata, this.storage);\n    const receipt = await this.contractWrapper.sendTransaction(\"mintTo\", [to, uri]);\n    const event = this.contractWrapper.parseLogs(\"Transfer\", receipt?.logs);\n    if (event.length === 0) {\n      throw new Error(\"TransferEvent event not found\");\n    }\n    const id = event[0].args.tokenId;\n    return {\n      id,\n      receipt,\n      data: () => this.erc721.get(id)\n    };\n  }\n  detectErc721BatchMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721BatchMintable\")) {\n      return new Erc721BatchMintable(this.erc721, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n}\n\n/**\n * List owned ERC721 NFTs\n * @remarks Easily list all the NFTs from a ERC721 contract, owned by a certain wallet.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const walletAddress = \"0x...\";\n * const ownedNFTs = await contract.nft.query.owned.all(walletAddress);\n * ```\n * @public\n */\nclass Erc721Enumerable {\n  constructor(erc721, contractWrapper) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_NFT_ENUMERABLE.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"erc721\", void 0);\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get Owned NFTs\n   *\n   * @remarks Get all the data associated with the NFTs owned by a specific wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to get the NFTs of\n   * const address = \"{{wallet_address}}\";\n   * const nfts = await contract.nft.query.owned.all(address);\n   * ```\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   * @returns The NFT metadata for all NFTs in the contract.\n   */\n  async all(walletAddress) {\n    const tokenIds = await this.tokenIds(walletAddress);\n    return await Promise.all(tokenIds.map(tokenId => this.erc721.get(tokenId.toString())));\n  }\n\n  /**\n   * Get all token ids of NFTs owned by a specific wallet.\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   */\n  async tokenIds(walletAddress) {\n    const address = walletAddress || (await this.contractWrapper.getSignerAddress());\n    const balance = await this.contractWrapper.readContract.balanceOf(address);\n    const indices = Array.from(Array(balance.toNumber()).keys());\n    return await Promise.all(indices.map(i => this.contractWrapper.readContract.tokenOfOwnerByIndex(address, i)));\n  }\n}\n\n/**\n * List ERC721 NFTs\n * @remarks Easily list all the NFTs in a ERC721 contract.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const nfts = await contract.nft.query.all();\n * ```\n * @public\n */\nclass Erc721Supply {\n  constructor(erc721, contractWrapper) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_NFT_SUPPLY.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"erc721\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"owned\", void 0);\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.owned = this.detectErc721Owned();\n  }\n\n  /**\n   * Get All Minted NFTs\n   *\n   * @remarks Get all the data associated with every NFT in this contract.\n   *\n   * By default, returns the first 100 NFTs, use queryParams to fetch more.\n   *\n   * @example\n   * ```javascript\n   * const nfts = await contract.nft.query.all();\n   * ```\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs queried.\n   */\n  async all(queryParams) {\n    const start = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(queryParams?.start || 0).toNumber();\n    const count = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(queryParams?.count || _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.D).toNumber();\n    const maxSupply = await this.erc721.nextTokenIdToMint();\n    const maxId = Math.min(maxSupply.toNumber(), start + count);\n    return await Promise.all([...Array(maxId - start).keys()].map(i => this.erc721.get((start + i).toString())));\n  }\n\n  /**\n   * Return all the owners of each token id in this contract\n   * @returns\n   */\n  async allOwners() {\n    return Promise.all([...new Array((await this.totalCount()).toNumber()).keys()].map(async i => ({\n      tokenId: i,\n      owner: await this.erc721.ownerOf(i).catch(() => ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero)\n    })));\n  }\n\n  /**\n   * Get the number of NFTs minted\n   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.\n   *\n   * @returns the total number of NFTs minted in this contract\n   * @public\n   */\n  async totalCount() {\n    return await this.erc721.nextTokenIdToMint();\n  }\n\n  /**\n   * Get the number of NFTs of this contract currently owned by end users\n   * @returns the total number of NFTs of this contract in circulation (minted & not burned)\n   * @public\n   */\n  async totalCirculatingSupply() {\n    return await this.contractWrapper.readContract.totalSupply();\n  }\n  detectErc721Owned() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721Enumerable\")) {\n      return new Erc721Enumerable(this.erc721, this.contractWrapper);\n    }\n    return undefined;\n  }\n}\n\n/**\n * @internal\n */\nconst TieredDropPayloadSchema = BaseSignaturePayloadInput.extend({\n  tierPriority: zod__WEBPACK_IMPORTED_MODULE_57__.z.array(zod__WEBPACK_IMPORTED_MODULE_57__.z.string()),\n  royaltyRecipient: zod__WEBPACK_IMPORTED_MODULE_57__.z.string().default(ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero),\n  royaltyBps: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.a[\"default\"](0),\n  quantity: BigNumberSchema.default(1)\n});\n\nclass Erc721TieredDrop {\n  constructor(erc721, contractWrapper, storage) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_NFT_TIERED_DROP.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"erc721\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n  async getMetadataInTier(tier) {\n    const tiers = await this.contractWrapper.readContract.getMetadataForAllTiers();\n    const batches = tiers.find(t => t.tier === tier);\n    if (!batches) {\n      throw new Error(\"Tier not found in contract.\");\n    }\n    const nfts = await Promise.all(batches.ranges.map((range, i) => {\n      const nftsInRange = [];\n      const baseUri = batches.baseURIs[i];\n      for (let j = range.startIdInclusive.toNumber(); j < range.endIdNonInclusive.toNumber(); j++) {\n        const uri = `${baseUri}/${j}`;\n        const metadata = this.storage.downloadJSON(uri);\n        nftsInRange.push(metadata);\n      }\n      return nftsInRange;\n    }).flat());\n    return nfts;\n  }\n  async getTokensInTier(tier) {\n    const endIndex = await this.contractWrapper.readContract.getTokensInTierLen();\n    if (endIndex.eq(0)) {\n      return [];\n    }\n    const ranges = await this.contractWrapper.readContract.getTokensInTier(tier, 0, endIndex);\n    const nfts = await Promise.all(ranges.map(range => {\n      const nftsInRange = [];\n      for (let i = range.startIdInclusive.toNumber(); i < range.endIdNonInclusive.toNumber(); i++) {\n        nftsInRange.push(this.erc721.get(i));\n      }\n      return nftsInRange;\n    }).flat());\n    return nfts;\n  }\n  async createBatchWithTier(metadatas, tier, options) {\n    // TODO: Change this to on extension\n    const startFileNumber = await this.erc721.nextTokenIdToMint();\n    const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options);\n    const baseUri = getBaseUriFromBatch(batch);\n    const receipt = await this.contractWrapper.sendTransaction(\"lazyMint\", [batch.length, baseUri.endsWith(\"/\") ? baseUri : `${baseUri}/`, tier, ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.toUtf8Bytes(\"\")]);\n    const event = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n    const startingIndex = event[0].args[1];\n    const endingIndex = event[0].args[2];\n    const results = [];\n    for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n      results.push({\n        id,\n        receipt,\n        data: () => this.erc721.getTokenMetadata(id)\n      });\n    }\n    return results;\n  }\n  async createDelayedRevealBatchWithTier(placeholder, metadatas, password, tier, options) {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const placeholderUris = await this.storage.uploadBatch([_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.b.parse(placeholder)], {\n      rewriteFileNames: {\n        fileStartNumber: 0\n      }\n    });\n    const placeholderUri = getBaseUriFromBatch(placeholderUris);\n    const startFileNumber = await this.erc721.nextTokenIdToMint();\n    const uris = await this.storage.uploadBatch(metadatas.map(m => _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.b.parse(m)), {\n      onProgress: options?.onProgress,\n      rewriteFileNames: {\n        fileStartNumber: startFileNumber.toNumber()\n      }\n    });\n    const baseUri = getBaseUriFromBatch(uris);\n    const baseUriId = await this.contractWrapper.readContract.getBaseURICount();\n    const chainId = await this.contractWrapper.getChainID();\n    const hashedPassword = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.solidityKeccak256([\"string\", \"uint256\", \"uint256\", \"address\"], [password, chainId, baseUriId, this.contractWrapper.readContract.address]);\n    const encryptedBaseUri = await this.contractWrapper.readContract.encryptDecrypt(ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.toUtf8Bytes(baseUri), hashedPassword);\n    let data;\n    const provenanceHash = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.solidityKeccak256([\"bytes\", \"bytes\", \"uint256\"], [ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.toUtf8Bytes(baseUri), hashedPassword, chainId]);\n    data = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.defaultAbiCoder.encode([\"bytes\", \"bytes32\"], [encryptedBaseUri, provenanceHash]);\n    const receipt = await this.contractWrapper.sendTransaction(\"lazyMint\", [uris.length, placeholderUri.endsWith(\"/\") ? placeholderUri : `${placeholderUri}/`, tier, data]);\n    const event = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n    const startingIndex = event[0].args[1];\n    const endingIndex = event[0].args[2];\n    const results = [];\n    for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n      results.push({\n        id,\n        receipt,\n        data: () => this.erc721.getTokenMetadata(id)\n      });\n    }\n    return results;\n  }\n  async reveal(batchId, password) {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const chainId = await this.contractWrapper.getChainID();\n    const key = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.solidityKeccak256([\"string\", \"uint256\", \"uint256\", \"address\"], [password, chainId, batchId, this.contractWrapper.readContract.address]);\n    // performing the reveal locally to make sure it'd succeed before sending the transaction\n    try {\n      const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);\n      // basic sanity check for making sure decryptedUri is valid\n      // this is optional because invalid decryption key would result in non-utf8 bytes and\n      // ethers would throw when trying to decode it\n      if (!decryptedUri.includes(\"://\") || !decryptedUri.endsWith(\"/\")) {\n        throw new Error(\"invalid password\");\n      }\n    } catch (e) {\n      throw new Error(\"invalid password\");\n    }\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"reveal\", [batchId, key])\n    };\n  }\n  async generate(payloadToSign) {\n    const [payload] = await this.generateBatch([payloadToSign]);\n    return payload;\n  }\n  async generateBatch(payloadsToSign) {\n    const parsedPayloads = payloadsToSign.map(payload => TieredDropPayloadSchema.parse(payload));\n    const chainId = await this.contractWrapper.getChainID();\n    const signer = this.contractWrapper.getSigner();\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(signer, \"No signer available\");\n    return await Promise.all(parsedPayloads.map(async payload => {\n      const signature = await this.contractWrapper.signTypedData(signer, {\n        name: \"SignatureAction\",\n        version: \"1\",\n        chainId,\n        verifyingContract: this.contractWrapper.readContract.address\n      }, {\n        GenericRequest: GenericRequest\n      }, await this.mapPayloadToContractStruct(payload));\n      return {\n        payload,\n        signature: signature.toString()\n      };\n    }));\n  }\n  async verify(signedPayload) {\n    const message = await this.mapPayloadToContractStruct(signedPayload.payload);\n    const verification = await this.contractWrapper.readContract.verify(message, signedPayload.signature);\n    return verification[0];\n  }\n  async claimWithSignature(signedPayload) {\n    const message = await this.mapPayloadToContractStruct(signedPayload.payload);\n    const pricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), signedPayload.payload.price, signedPayload.payload.currencyAddress);\n    const price = pricePerToken.mul(signedPayload.payload.quantity);\n    const overrides = await this.contractWrapper.getCallOverrides();\n    await setErc20Allowance(this.contractWrapper, price, signedPayload.payload.currencyAddress, overrides);\n    const receipt = await this.contractWrapper.sendTransaction(\"claimWithSignature\", [message, signedPayload.signature], overrides);\n    const event = this.contractWrapper.parseLogs(\"TokensClaimed\", receipt?.logs);\n    const startingIndex = event[0].args.startTokenId;\n    const endingIndex = startingIndex.add(event[0].args.quantityClaimed);\n    const results = [];\n    for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {\n      results.push({\n        id,\n        receipt,\n        data: () => this.erc721.get(id)\n      });\n    }\n    return results;\n  }\n  async mapPayloadToContractStruct(payload) {\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), payload.price, payload.currencyAddress);\n    const data = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.defaultAbiCoder.encode([\"string[]\", \"address\", \"address\", \"uint256\", \"address\", \"uint256\", \"uint256\", \"address\"], [payload.tierPriority, payload.to, payload.royaltyRecipient, payload.royaltyBps, payload.primarySaleRecipient, payload.quantity, normalizedPricePerToken, payload.currencyAddress]);\n    return {\n      uid: payload.uid,\n      validityStartTimestamp: payload.mintStartTime,\n      validityEndTimestamp: payload.mintEndTime,\n      data\n    };\n  }\n}\n\n/**\n * Enables generating dynamic ERC721 NFTs with rules and an associated signature, which can then be minted by anyone securely\n * @public\n */\nclass Erc721WithQuantitySignatureMintable {\n  constructor(contractWrapper, storage) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_NFT_SIGNATURE_MINTABLE_V2.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Mint a dynamically generated NFT\n   *\n   * @remarks Mint a dynamic NFT with a previously generated signature.\n   *\n   * @example\n   * ```javascript\n   * // see how to craft a payload to sign in the `generate()` documentation\n   * const signedPayload = contract.erc721.signature.generate(payload);\n   *\n   * // now anyone can mint the NFT\n   * const tx = contract.erc721.signature.mint(signedPayload);\n   * const receipt = tx.receipt; // the mint transaction receipt\n   * const mintedId = tx.id; // the id of the NFT minted\n   * ```\n   * @param signedPayload - the previously generated payload and signature with {@link Erc721WithQuantitySignatureMintable.generate}\n   * @twfeature ERC721SignatureMint\n   */\n  async mint(signedPayload) {\n    const mintRequest = signedPayload.payload;\n    const signature = signedPayload.signature;\n    const isLegacyNFTContract = await this.isLegacyNFTContract();\n    let message;\n    let price;\n    if (isLegacyNFTContract) {\n      message = await this.mapLegacyPayloadToContractStruct(mintRequest);\n      price = message.price;\n    } else {\n      message = await this.mapPayloadToContractStruct(mintRequest);\n      price = message.pricePerToken.mul(message.quantity);\n    }\n    const overrides = await this.contractWrapper.getCallOverrides();\n    await setErc20Allowance(this.contractWrapper, price, mintRequest.currencyAddress, overrides);\n    const receipt = await this.contractWrapper.sendTransaction(\"mintWithSignature\", [message, signature], overrides);\n    const t = this.contractWrapper.parseLogs(\"TokensMintedWithSignature\", receipt.logs);\n    if (t.length === 0) {\n      throw new Error(\"No MintWithSignature event found\");\n    }\n    const id = t[0].args.tokenIdMinted;\n    return {\n      id,\n      receipt\n    };\n  }\n\n  /**\n   * Mint any number of dynamically generated NFT at once\n   * @remarks Mint multiple dynamic NFTs in one transaction. Note that this is only possible for free mints (cannot batch mints with a price attached to it for security reasons)\n   * @param signedPayloads - the array of signed payloads to mint\n   * @twfeature ERC721SignatureMint\n   */\n  async mintBatch(signedPayloads) {\n    const isLegacyNFTContract = await this.isLegacyNFTContract();\n    const contractPayloads = await Promise.all(signedPayloads.map(async s => {\n      let message;\n      if (isLegacyNFTContract) {\n        message = await this.mapLegacyPayloadToContractStruct(s.payload);\n      } else {\n        message = await this.mapPayloadToContractStruct(s.payload);\n      }\n      const signature = s.signature;\n      const price = s.payload.price;\n      if (ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(price).gt(0)) {\n        throw new Error(\"Can only batch free mints. For mints with a price, use regular mint()\");\n      }\n      return {\n        message,\n        signature\n      };\n    }));\n    const encoded = contractPayloads.map(p => {\n      if (isLegacyNFTContract) {\n        const contract = this.contractWrapper.readContract;\n        return contract.interface.encodeFunctionData(\"mintWithSignature\", [p.message, p.signature]);\n      } else {\n        const contract = this.contractWrapper.readContract;\n        return contract.interface.encodeFunctionData(\"mintWithSignature\", [p.message, p.signature]);\n      }\n    });\n    const receipt = await this.contractWrapper.multiCall(encoded);\n    const events = this.contractWrapper.parseLogs(\"TokensMintedWithSignature\", receipt.logs);\n    if (events.length === 0) {\n      throw new Error(\"No MintWithSignature event found\");\n    }\n    return events.map(log => ({\n      id: log.args.tokenIdMinted,\n      receipt\n    }));\n  }\n\n  /**\n   * Verify that a payload is correctly signed\n   * @param signedPayload - the payload to verify\n   * @twfeature ERC721SignatureMint\n   *\n   * @example\n   * ```javascript\n   * const nftMetadata = {\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   metadata: nftMetadata, // The NFT to mint\n   *   to: {{wallet_address}}, // Who will receive the NFT\n   *   quantity: 2, // the quantity of NFTs to mint\n   *   price: 0.5, // the price per NFT\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now\n   *   royaltyRecipient: \"0x...\", // custom royalty recipient for this NFT\n   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this NFT\n   * };\n   *\n   * const signedPayload = await contract.erc721.signature.generate(payload);\n   * // Now you can verify if the signed payload is valid\n   * const isValid = await contract.erc721.signature.verify(signedPayload);\n   * ```\n   */\n  async verify(signedPayload) {\n    const isLegacyNFTContract = await this.isLegacyNFTContract();\n    const mintRequest = signedPayload.payload;\n    const signature = signedPayload.signature;\n    let message;\n    let verification;\n    if (isLegacyNFTContract) {\n      const contract = this.contractWrapper.readContract;\n      message = await this.mapLegacyPayloadToContractStruct(mintRequest);\n      verification = await contract.verify(message, signature);\n    } else {\n      const contract = this.contractWrapper.readContract;\n      message = await this.mapPayloadToContractStruct(mintRequest);\n      verification = await contract.verify(message, signature);\n    }\n    return verification[0];\n  }\n\n  /**\n   * Generate a signature that can be used to mint a dynamic NFT\n   *\n   * @remarks Takes in an NFT and some information about how it can be minted, uploads the metadata and signs it with your private key. The generated signature can then be used to mint an NFT using the exact payload and signature generated.\n   *\n   * @example\n   * ```javascript\n   * const nftMetadata = {\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   metadata: nftMetadata, // The NFT to mint\n   *   to: {{wallet_address}}, // Who will receive the NFT\n   *   quantity: 2, // the quantity of NFTs to mint\n   *   price: 0.5, // the price per NFT\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now\n   *   royaltyRecipient: \"0x...\", // custom royalty recipient for this NFT\n   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this NFT\n   * };\n   *\n   * const signedPayload = await contract.erc721.signature.generate(payload);\n   * // now anyone can use these to mint the NFT using `contract.erc721.signature.mint(signedPayload)`\n   * ```\n   * @param mintRequest - the payload to sign\n   * @returns the signed payload and the corresponding signature\n   * @twfeature ERC721SignatureMint\n   */\n  async generate(mintRequest) {\n    return (await this.generateBatch([mintRequest]))[0];\n  }\n\n  /**\n   * Genrate a batch of signatures that can be used to mint many dynamic NFTs.\n   *\n   * @remarks See {@link Erc721WithQuantitySignatureMintable.generate}\n   *\n   * @param payloadsToSign - the payloads to sign\n   * @returns an array of payloads and signatures\n   * @twfeature ERC721SignatureMint\n   */\n  async generateBatch(payloadsToSign) {\n    const isLegacyNFTContract = await this.isLegacyNFTContract();\n    const parsedRequests = payloadsToSign.map(m => Signature721WithQuantityInput.parse(m));\n    const metadatas = parsedRequests.map(r => r.metadata);\n    const uris = await uploadOrExtractURIs(metadatas, this.storage);\n    const chainId = await this.contractWrapper.getChainID();\n    const signer = this.contractWrapper.getSigner();\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(signer, \"No signer available\");\n    return await Promise.all(parsedRequests.map(async (m, i) => {\n      const uri = uris[i];\n      const finalPayload = Signature721WithQuantityOutput.parse({\n        ...m,\n        uri\n      });\n      let signature;\n      if (isLegacyNFTContract) {\n        signature = await this.contractWrapper.signTypedData(signer, {\n          name: \"TokenERC721\",\n          version: \"1\",\n          chainId,\n          verifyingContract: this.contractWrapper.readContract.address\n        }, {\n          MintRequest: MintRequest721\n        }, await this.mapLegacyPayloadToContractStruct(finalPayload));\n      } else {\n        signature = await this.contractWrapper.signTypedData(signer, {\n          name: \"SignatureMintERC721\",\n          version: \"1\",\n          chainId,\n          verifyingContract: await this.contractWrapper.readContract.address\n        }, {\n          MintRequest: MintRequest721withQuantity\n        },\n        // TYPEHASH\n        await this.mapPayloadToContractStruct(finalPayload));\n      }\n      return {\n        payload: finalPayload,\n        signature: signature.toString()\n      };\n    }));\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Maps a payload to the format expected by the contract\n   *\n   * @internal\n   *\n   * @param mintRequest - The payload to map.\n   * @returns - The mapped payload.\n   */\n  async mapPayloadToContractStruct(mintRequest) {\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);\n    return {\n      to: mintRequest.to,\n      royaltyRecipient: mintRequest.royaltyRecipient,\n      royaltyBps: mintRequest.royaltyBps,\n      primarySaleRecipient: mintRequest.primarySaleRecipient,\n      uri: mintRequest.uri,\n      quantity: mintRequest.quantity,\n      pricePerToken: normalizedPricePerToken,\n      currency: mintRequest.currencyAddress,\n      validityStartTimestamp: mintRequest.mintStartTime,\n      validityEndTimestamp: mintRequest.mintEndTime,\n      uid: mintRequest.uid\n    };\n  }\n  async mapLegacyPayloadToContractStruct(mintRequest) {\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);\n    return {\n      to: mintRequest.to,\n      price: normalizedPricePerToken,\n      uri: mintRequest.uri,\n      currency: mintRequest.currencyAddress,\n      validityEndTimestamp: mintRequest.mintEndTime,\n      validityStartTimestamp: mintRequest.mintStartTime,\n      uid: mintRequest.uid,\n      royaltyRecipient: mintRequest.royaltyRecipient,\n      royaltyBps: mintRequest.royaltyBps,\n      primarySaleRecipient: mintRequest.primarySaleRecipient\n    };\n  }\n  async isLegacyNFTContract() {\n    if (hasFunction(\"contractType\", this.contractWrapper)) {\n      try {\n        const contractType = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.toUtf8String(await this.contractWrapper.readContract.contractType());\n        return contractType.includes(\"TokenERC721\");\n      } catch (e) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n}\n\n/**\n * Standard ERC721 NFT functions\n * @remarks Basic functionality for a ERC721 contract that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc721.transfer(walletAddress, tokenId);\n * ```\n * @public\n */\nclass Erc721 {\n  get chainId() {\n    return this._chainId;\n  }\n  constructor(contractWrapper, storage, chainId) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_NFT.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"query\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"mintable\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"burnable\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"lazyMintable\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"tieredDropable\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"signatureMintable\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"_chainId\", void 0);\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.query = this.detectErc721Enumerable();\n    this.mintable = this.detectErc721Mintable();\n    this.burnable = this.detectErc721Burnable();\n    this.lazyMintable = this.detectErc721LazyMintable();\n    this.tieredDropable = this.detectErc721TieredDrop();\n    this.signatureMintable = this.detectErc721SignatureMintable();\n    this._chainId = chainId;\n  }\n\n  /**\n   * @internal\n   */\n  onNetworkUpdated(network) {\n    this.contractWrapper.updateSignerOrProvider(network);\n  }\n  getAddress() {\n    return this.contractWrapper.readContract.address;\n  }\n\n  ////// Standard ERC721 Extension //////\n\n  /**\n   * Get a single NFT Metadata\n   *\n   * @example\n   * ```javascript\n   * const tokenId = 0;\n   * const nft = await contract.erc721.get(tokenId);\n   * ```\n   * @param tokenId - the tokenId of the NFT to retrieve\n   * @returns The NFT metadata\n   * @twfeature ERC721\n   */\n  async get(tokenId) {\n    const [owner, metadata] = await Promise.all([this.ownerOf(tokenId).catch(() => ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero), this.getTokenMetadata(tokenId).catch(() => ({\n      id: tokenId.toString(),\n      uri: \"\",\n      ...FALLBACK_METADATA\n    }))]);\n    return {\n      owner,\n      metadata,\n      type: \"ERC721\",\n      supply: 1\n    };\n  }\n\n  /**\n   * Get the current owner of a given NFT within this Contract\n   *\n   * @param tokenId - the tokenId of the NFT\n   * @returns the address of the owner\n   * @twfeature ERC721\n   */\n  async ownerOf(tokenId) {\n    return await this.contractWrapper.readContract.ownerOf(tokenId);\n  }\n\n  /**\n   * Get NFT Balance\n   *\n   * @remarks Get a wallets NFT balance (number of NFTs in this contract owned by the wallet).\n   *\n   * @example\n   * ```javascript\n   * const walletAddress = \"{{wallet_address}}\";\n   * const balance = await contract.erc721.balanceOf(walletAddress);\n   * console.log(balance);\n   * ```\n   * @twfeature ERC721\n   */\n  async balanceOf(address) {\n    return await this.contractWrapper.readContract.balanceOf(address);\n  }\n\n  /**\n   * Get NFT Balance for the currently connected wallet\n   */\n  async balance() {\n    return await this.balanceOf(await this.contractWrapper.getSignerAddress());\n  }\n\n  /**\n   * Get whether this wallet has approved transfers from the given operator\n   * @param address - the wallet address\n   * @param operator - the operator address\n   */\n  async isApproved(address, operator) {\n    return await this.contractWrapper.readContract.isApprovedForAll(address, operator);\n  }\n\n  /**\n   * Transfer a single NFT\n   *\n   * @remarks Transfer an NFT from the connected wallet to another wallet.\n   *\n   * @example\n   * ```javascript\n   * const walletAddress = \"{{wallet_address}}\";\n   * const tokenId = 0;\n   * await contract.erc721.transfer(walletAddress, tokenId);\n   * ```\n   * @twfeature ERC721\n   */\n  async transfer(to, tokenId) {\n    const from = await this.contractWrapper.getSignerAddress();\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"safeTransferFrom(address,address,uint256)\", [from, to, tokenId])\n    };\n  }\n\n  /**\n   * Approve or remove operator as an operator for the caller. Operators can call transferFrom or safeTransferFrom for any token owned by the caller.\n   * @param operator - the operator's address\n   * @param approved - whether to approve or remove\n   *\n   * @internal\n   */\n  async setApprovalForAll(operator, approved) {\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"setApprovalForAll\", [operator, approved])\n    };\n  }\n\n  /**\n   * Approve an operator for the NFT owner. Operators can call transferFrom or safeTransferFrom for the specified token.\n   * @param operator - the operator's address\n   * @param tokenId - the tokenId to give approval for\n   *\n   * @internal\n   */\n  async setApprovalForToken(operator, tokenId) {\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"approve\", [operator, tokenId])\n    };\n  }\n\n  ////// ERC721 Supply Extension //////\n\n  /**\n   * Get All Minted NFTs\n   *\n   * @remarks Get all the data associated with every NFT in this contract.\n   *\n   * By default, returns the first 100 NFTs, use queryParams to fetch more.\n   *\n   * @example\n   * ```javascript\n   * const nfts = await contract.erc721.getAll();\n   * console.log(nfts);\n   * ```\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs queried.\n   * @twfeature ERC721Supply\n   */\n  async getAll(queryParams) {\n    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).all(queryParams);\n  }\n\n  /**\n   * Get All owners of minted NFTs on this contract\n   * @returns an array of token ids and owners\n   * @twfeature ERC721Supply\n   */\n  async getAllOwners() {\n    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).allOwners();\n  }\n\n  /**\n   * Get the number of NFTs minted\n   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.\n   *\n   * @returns the total number of NFTs minted in this contract\n   * @public\n   */\n  async totalCount() {\n    return this.nextTokenIdToMint();\n  }\n\n  /**\n   * Get the total count NFTs minted in this contract\n   */\n  async totalCirculatingSupply() {\n    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).totalCirculatingSupply();\n  }\n\n  ////// ERC721 Enumerable Extension //////\n\n  /**\n   * Get Owned NFTs\n   *\n   * @remarks Get all the data associated with the NFTs owned by a specific wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to get the NFTs of\n   * const address = \"{{wallet_address}}\";\n   * const nfts = await contract.erc721.getOwned(address);\n   * console.log(nfts);\n   * ```\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   * @returns The NFT metadata for all NFTs in the contract.\n   * @twfeature ERC721Enumerable\n   */\n  async getOwned(walletAddress) {\n    if (this.query?.owned) {\n      return this.query.owned.all(walletAddress);\n    } else {\n      const address = walletAddress || (await this.contractWrapper.getSignerAddress());\n      const allOwners = await this.getAllOwners();\n      return Promise.all((allOwners || []).filter(i => address?.toLowerCase() === i.owner?.toLowerCase()).map(async i => await this.get(i.tokenId)));\n    }\n  }\n\n  /**\n   * Get all token ids of NFTs owned by a specific wallet.\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   */\n  async getOwnedTokenIds(walletAddress) {\n    if (this.query?.owned) {\n      return this.query.owned.tokenIds(walletAddress);\n    } else {\n      const address = walletAddress || (await this.contractWrapper.getSignerAddress());\n      const allOwners = await this.getAllOwners();\n      return (allOwners || []).filter(i => address?.toLowerCase() === i.owner?.toLowerCase()).map(i => ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(i.tokenId));\n    }\n  }\n\n  ////// ERC721 Mintable Extension //////\n\n  /**\n   * Mint a unique NFT\n   *\n   * @remarks Mint a unique NFT to the connected wallet.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const tx = await contract.erc721.mint(metadata);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   * @twfeature ERC721Mintable\n   */\n  async mint(metadata) {\n    return this.mintTo(await this.contractWrapper.getSignerAddress(), metadata);\n  }\n\n  /**\n   * Mint a unique NFT\n   *\n   * @remarks Mint a unique NFT to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const walletAddress = \"{{wallet_address}}\";\n   *\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const tx = await contract.erc721.mintTo(walletAddress, metadata);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   * @twfeature ERC721Mintable\n   */\n  async mintTo(receiver, metadata) {\n    return assertEnabled(this.mintable, FEATURE_NFT_MINTABLE).to(receiver, metadata);\n  }\n\n  ////// ERC721 Batch Mintable Extension //////\n\n  /**\n   * Mint Many unique NFTs\n   *\n   * @remarks Mint many unique NFTs at once to the connected wallet\n   *\n   * @example\n   * ```javascript*\n   * // Custom metadata of the NFTs you want to mint.\n   * const metadatas = [{\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT #2\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/other/image.png\"),\n   * }];\n   *\n   * const tx = await contract.erc721.mintBatch(metadatas);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   * @twfeature ERC721BatchMintable\n   */\n  async mintBatch(metadatas) {\n    return this.mintBatchTo(await this.contractWrapper.getSignerAddress(), metadatas);\n  }\n\n  /**\n   * Mint Many unique NFTs\n   *\n   * @remarks Mint many unique NFTs at once to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const walletAddress = \"{{wallet_address}}\";\n   *\n   * // Custom metadata of the NFTs you want to mint.\n   * const metadatas = [{\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT #2\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/other/image.png\"),\n   * }];\n   *\n   * const tx = await contract.erc721.mintBatchTo(walletAddress, metadatas);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   * @twfeature ERC721BatchMintable\n   */\n  async mintBatchTo(receiver, metadatas) {\n    return assertEnabled(this.mintable?.batch, FEATURE_NFT_BATCH_MINTABLE).to(receiver, metadatas);\n  }\n\n  ////// ERC721 Burnable Extension //////\n\n  /**\n   * Burn a single NFT\n   * @param tokenId - the token Id to burn\n   *\n   * @example\n   * ```javascript\n   * const result = await contract.erc721.burn(tokenId);\n   * ```\n   * @twfeature ERC721Burnable\n   */\n  async burn(tokenId) {\n    return assertEnabled(this.burnable, FEATURE_NFT_BURNABLE).token(tokenId);\n  }\n\n  ////// ERC721 LazyMint Extension //////\n\n  /**\n   * Create a batch of unique NFTs to be claimed in the future\n   *\n   * @remarks Create batch allows you to create a batch of many unique NFTs in one transaction.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata of the NFTs to create\n   * const metadatas = [{\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   *\n   * const results = await contract.erc721.lazyMint(metadatas); // uploads and creates the NFTs on chain\n   * const firstTokenId = results[0].id; // token id of the first created NFT\n   * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT\n   * ```\n   *\n   * @param metadatas - The metadata to include in the batch.\n   * @param options - optional upload progress callback\n   * @twfeature ERC721LazyMintable\n   */\n  async lazyMint(metadatas, options) {\n    return assertEnabled(this.lazyMintable, FEATURE_NFT_LAZY_MINTABLE).lazyMint(metadatas, options);\n  }\n\n  ////// ERC721 Claimable Extension //////\n\n  /**\n   * Claim unique NFTs to the connected wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const quantity = 1; // how many unique NFTs you want to claim\n   *\n   * const tx = await contract.erc721.claim(quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const claimedTokenId = tx.id; // the id of the NFT claimed\n   * const claimedNFT = await tx.data(); // (optional) get the claimed NFT metadata\n   * ```\n   *\n   * @param quantity - Quantity of the tokens you want to claim\n   *\n   * @returns - an array of results containing the id of the token claimed, the transaction receipt and a promise to optionally fetch the nft metadata\n   * @twfeature ERC721Claimable\n   */\n  async claim(quantity, options) {\n    return this.claimTo(await this.contractWrapper.getSignerAddress(), quantity, options);\n  }\n\n  /**\n   * Claim unique NFTs to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 1; // how many unique NFTs you want to claim\n   *\n   * const tx = await contract.erc721.claimTo(address, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const claimedTokenId = tx.id; // the id of the NFT claimed\n   * const claimedNFT = await tx.data(); // (optional) get the claimed NFT metadata\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options\n   * @twfeature ERC721Claimable\n   * @returns - an array of results containing the id of the token claimed, the transaction receipt and a promise to optionally fetch the nft metadata\n   */\n  async claimTo(destinationAddress, quantity, options) {\n    const claimWithConditions = this.lazyMintable?.claimWithConditions;\n    const claim = this.lazyMintable?.claim;\n    if (claimWithConditions) {\n      return claimWithConditions.to(destinationAddress, quantity, options);\n    }\n    if (claim) {\n      return claim.to(destinationAddress, quantity, options);\n    }\n    throw new ExtensionNotImplementedError(FEATURE_NFT_CLAIM_CUSTOM);\n  }\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress\n   * @param quantity\n   * @param options\n   */\n  async getClaimTransaction(destinationAddress, quantity, options) {\n    const claimWithConditions = this.lazyMintable?.claimWithConditions;\n    const claim = this.lazyMintable?.claim;\n    if (claimWithConditions) {\n      return claimWithConditions.conditions.getClaimTransaction(destinationAddress, quantity, options);\n    }\n    if (claim) {\n      return claim.getClaimTransaction(destinationAddress, quantity, options);\n    }\n    throw new ExtensionNotImplementedError(FEATURE_NFT_CLAIM_CUSTOM);\n  }\n  async totalClaimedSupply() {\n    const contract = this.contractWrapper;\n    if (hasFunction(\"nextTokenIdToClaim\", contract)) {\n      return contract.readContract.nextTokenIdToClaim();\n    }\n    if (hasFunction(\"totalMinted\", contract)) {\n      return contract.readContract.totalMinted();\n    }\n    throw new Error(\"No function found on contract to get total claimed supply\");\n  }\n\n  /**\n   * Get the unclaimed supply\n   *\n   * @remarks Get the number of unclaimed NFTs in this Drop.\n   *\n   * * @example\n   * ```javascript\n   * const unclaimedNFTCount = await contract.totalUnclaimedSupply();\n   * console.log(`NFTs left to claim: ${unclaimedNFTCount}`);\n   * ```\n   * @returns the unclaimed supply\n   */\n  async totalUnclaimedSupply() {\n    return (await this.nextTokenIdToMint()).sub(await this.totalClaimedSupply());\n  }\n\n  /**\n   * Configure claim conditions\n   * @remarks Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxQuantity: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   * await contract.erc721.claimConditions.set(claimConditions);\n   * ```\n   * @twfeature ERC721ClaimableWithConditions\n   */\n  get claimConditions() {\n    return assertEnabled(this.lazyMintable?.claimWithConditions, FEATURE_NFT_CLAIM_CONDITIONS_V2).conditions;\n  }\n\n  ////// ERC721 Tiered Drop Extension //////\n\n  /**\n   * Tiered Drop\n   * @remarks Drop lazy minted NFTs using a tiered drop mechanism.\n   */\n  get tieredDrop() {\n    return assertEnabled(this.tieredDropable, FEATURE_NFT_TIERED_DROP);\n  }\n\n  ////// ERC721 SignatureMint Extension //////\n\n  /**\n   * Signature Minting\n   * @remarks Generate dynamic NFTs with your own signature, and let others mint them using that signature.\n   * @example\n   * ```javascript\n   * // see how to craft a payload to sign in the `contract.erc721.signature.generate()` documentation\n   * const signedPayload = contract.erc721.signature().generate(payload);\n   *\n   * // now anyone can mint the NFT\n   * const tx = contract.erc721.signature.mint(signedPayload);\n   * const receipt = tx.receipt; // the mint transaction receipt\n   * const mintedId = tx.id; // the id of the NFT minted\n   * ```\n   * @twfeature ERC721SignatureMint\n   */\n  get signature() {\n    return assertEnabled(this.signatureMintable, FEATURE_NFT_SIGNATURE_MINTABLE_V2);\n  }\n\n  ////// ERC721 DelayedReveal Extension //////\n\n  /**\n   * Delayed reveal\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until you reveal them\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.erc721.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * // Whenever you're ready, reveal your NFTs at any time\n   * const batchId = 0; // the batch to reveal\n   * await contract.erc721.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   * @twfeature ERC721Revealable\n   */\n  get revealer() {\n    return assertEnabled(this.lazyMintable?.revealer, FEATURE_NFT_REVEALABLE);\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * @internal\n   */\n  async getTokenMetadata(tokenId) {\n    const tokenUri = await this.contractWrapper.readContract.tokenURI(tokenId);\n    if (!tokenUri) {\n      throw new NotFoundError();\n    }\n    return fetchTokenMetadata(tokenId, tokenUri, this.storage);\n  }\n\n  /**\n   * Return the next available token ID to mint\n   * @internal\n   */\n  async nextTokenIdToMint() {\n    if (hasFunction(\"nextTokenIdToMint\", this.contractWrapper)) {\n      return await this.contractWrapper.readContract.nextTokenIdToMint();\n    } else if (hasFunction(\"totalSupply\", this.contractWrapper)) {\n      return await this.contractWrapper.readContract.totalSupply();\n    } else {\n      throw new Error(\"Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint\");\n    }\n  }\n  detectErc721Enumerable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721Supply\") || hasFunction(\"nextTokenIdToMint\", this.contractWrapper)) {\n      return new Erc721Supply(this, this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc721Mintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721Mintable\")) {\n      return new Erc721Mintable(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721Burnable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721Burnable\")) {\n      return new Erc721Burnable(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc721LazyMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721LazyMintable\")) {\n      return new Erc721LazyMintable(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721TieredDrop() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721TieredDrop\")) {\n      return new Erc721TieredDrop(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721SignatureMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721SignatureMintV1\") || detectContractFeature(this.contractWrapper, \"ERC721SignatureMintV2\")) {\n      return new Erc721WithQuantitySignatureMintable(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n}\n\n/**\n * Standard ERC721 NFT functions\n * @remarks Basic functionality for a ERC721 contract that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.nft.transfer(walletAddress, tokenId);\n * ```\n * @public\n */\nclass StandardErc721 {\n  get chainId() {\n    return this._chainId;\n  }\n  constructor(contractWrapper, storage, chainId) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"erc721\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"_chainId\", void 0);\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.erc721 = new Erc721(this.contractWrapper, this.storage, chainId);\n    this._chainId = chainId;\n  }\n\n  /**\n   * @internal\n   */\n  onNetworkUpdated(network) {\n    this.contractWrapper.updateSignerOrProvider(network);\n  }\n  getAddress() {\n    return this.contractWrapper.readContract.address;\n  }\n\n  /**\n   * Get All Minted NFTs\n   *\n   * @remarks Get all the data associated with every NFT in this contract.\n   *\n   * By default, returns the first 100 NFTs, use queryParams to fetch more.\n   *\n   * @example\n   * ```javascript\n   * const nfts = await contract.getAll();\n   * console.log(nfts);\n   * ```\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs queried.\n   */\n  async getAll(queryParams) {\n    return this.erc721.getAll(queryParams);\n  }\n\n  /**\n   * Get Owned NFTs\n   *\n   * @remarks Get all the data associated with the NFTs owned by a specific wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to get the NFTs of\n   * const address = \"{{wallet_address}}\";\n   * const nfts = await contract.getOwned(address);\n   * console.log(nfts);\n   * ```\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   * @returns The NFT metadata for all NFTs in the contract.\n   */\n  async getOwned(walletAddress) {\n    return this.erc721.getOwned(walletAddress);\n  }\n\n  /**\n   * Get Owned Token Ids\n   * @remarks Get all the token ids of NFTs owned by a specific wallet (no metadata)\n   */\n  async getOwnedTokenIds(walletAddress) {\n    return this.erc721.getOwnedTokenIds(walletAddress);\n  }\n\n  /**\n   * Get the total count NFTs minted in this contract\n   */\n  async totalSupply() {\n    return this.erc721.totalCirculatingSupply();\n  }\n\n  /**\n   * Get a single NFT Metadata\n   *\n   * @example\n   * ```javascript\n   * const tokenId = 0;\n   * const nft = await contract.get(tokenId);\n   * ```\n   * @param tokenId - the tokenId of the NFT to retrieve\n   * @returns The NFT metadata\n   */\n  async get(tokenId) {\n    return this.erc721.get(tokenId);\n  }\n\n  /**\n   * Get the current owner of a given NFT within this Contract\n   *\n   * @param tokenId - the tokenId of the NFT\n   * @returns the address of the owner\n   */\n  async ownerOf(tokenId) {\n    return this.erc721.ownerOf(tokenId);\n  }\n\n  /**\n   * Get NFT Balance\n   *\n   * @remarks Get a wallets NFT balance (number of NFTs in this contract owned by the wallet).\n   *\n   * @example\n   * ```javascript\n   * const walletAddress = \"{{wallet_address}}\";\n   * const balance = await contract.balanceOf(walletAddress);\n   * console.log(balance);\n   * ```\n   */\n  async balanceOf(address) {\n    return this.erc721.balanceOf(address);\n  }\n\n  /**\n   * Get NFT Balance for the currently connected wallet\n   */\n  async balance() {\n    return this.erc721.balance();\n  }\n\n  /**\n   * Get whether this wallet has approved transfers from the given operator\n   * @param address - the wallet address\n   * @param operator - the operator address\n   */\n  async isApproved(address, operator) {\n    return this.erc721.isApproved(address, operator);\n  }\n\n  /**\n   * Transfer a single NFT\n   *\n   * @remarks Transfer an NFT from the connected wallet to another wallet.\n   *\n   * @example\n   * ```javascript\n   * const walletAddress = \"{{wallet_address}}\";\n   * const tokenId = 0;\n   * await contract.transfer(walletAddress, tokenId);\n   * ```\n   */\n  async transfer(to, tokenId) {\n    return this.erc721.transfer(to, tokenId);\n  }\n\n  /**\n   * Approve or remove operator as an operator for the caller. Operators can call transferFrom or safeTransferFrom for any token owned by the caller.\n   * @param operator - the operator's address\n   * @param approved - whether to approve or remove\n   *\n   * @internal\n   */\n  async setApprovalForAll(operator, approved) {\n    return this.erc721.setApprovalForAll(operator, approved);\n  }\n\n  /**\n   * Approve an operator for the NFT owner. Operators can call transferFrom or safeTransferFrom for the specified token.\n   * @param operator - the operator's address\n   * @param tokenId - the tokenId to give approval for\n   *\n   * @internal\n   */\n  async setApprovalForToken(operator, tokenId) {\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"approve\", [operator, tokenId])\n    };\n  }\n}\n\n/**\n * @internal\n */\nconst AirdropAddressInput = zod__WEBPACK_IMPORTED_MODULE_57__.z.object({\n  address: AddressSchema,\n  quantity: _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.A[\"default\"](1)\n});\n\n/**\n * @internal\n */\nconst AirdropInputSchema = zod__WEBPACK_IMPORTED_MODULE_57__.z.union([zod__WEBPACK_IMPORTED_MODULE_57__.z.array(zod__WEBPACK_IMPORTED_MODULE_57__.z.string()).transform(strings => strings.map(address => AirdropAddressInput.parse({\n  address\n}))), zod__WEBPACK_IMPORTED_MODULE_57__.z.array(AirdropAddressInput)]);\n\nclass Erc1155Burnable {\n  constructor(contractWrapper) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_EDITION_BURNABLE.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Burn a specified amount of a NFTs\n   *\n   * @remarks Burn the specified NFTs from the connected wallet\n   *\n   * @param tokenId - the token Id to burn\n   * @param amount - amount to burn\n   *\n   * @example\n   * ```javascript\n   * // The token ID to burn NFTs of\n   * const tokenId = 0;\n   * // The amount of the NFT you want to burn\n   * const amount = 2;\n   *\n   * const result = await contract.edition.burn.tokens(tokenId, amount);\n   * ```\n   */\n  async tokens(tokenId, amount) {\n    const account = await this.contractWrapper.getSignerAddress();\n    return this.from(account, tokenId, amount);\n  }\n\n  /**\n   * Burn a specified amount of a NFTs\n   *\n   * @remarks Burn the specified NFTs from a specified wallet\n   *\n   * @param account - the address to burn NFTs from\n   * @param tokenId - the tokenId to burn\n   * @param amount - amount to burn\n   *\n   * @example\n   * ```javascript\n   * // The address of the wallet to burn NFTS from\n   * const account = \"0x...\";\n   * // The token ID to burn NFTs of\n   * const tokenId = 0;\n   * // The amount of this NFT you want to burn\n   * const amount = 2;\n   *\n   * const result = await contract.edition.burn.from(account, tokenId, amount);\n   * ```\n   */\n  async from(account, tokenId, amount) {\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"burn\", [account, tokenId, amount])\n    };\n  }\n\n  /**\n   * Burn a batch of NFTs\n   *\n   * @remarks Burn the batch NFTs from the connected wallet\n   *\n   * @param tokenIds - the tokenIds to burn\n   * @param amounts - amount of each token to burn\n   *\n   * @example\n   * ```javascript\n   * // The token IDs to burn NFTs of\n   * const tokenIds = [0, 1];\n   * // The amounts of each NFT you want to burn\n   * const amounts = [2, 2];\n   *\n   * const result = await contract.edition.burn.batch(tokenIds, amounts);\n   * ```\n   */\n  async batch(tokenIds, amounts) {\n    const account = await this.contractWrapper.getSignerAddress();\n    return this.batchFrom(account, tokenIds, amounts);\n  }\n\n  /**\n   * Burn a batch of NFTs\n   *\n   * @remarks Burn the batch NFTs from the specified wallet\n   *\n   * @param account - the address to burn NFTs from\n   * @param tokenIds - the tokenIds to burn\n   * @param amounts - amount of each token to burn\n   *\n   * @example\n   * ```javascript\n   * // The address of the wallet to burn NFTS from\n   * const account = \"0x...\";\n   * // The token IDs to burn NFTs of\n   * const tokenIds = [0, 1];\n   * // The amounts of each NFT you want to burn\n   * const amounts = [2, 2];\n   *\n   * const result = await contract.edition.burn.batchFrom(account, tokenIds, amounts);\n   * ```\n   */\n  async batchFrom(account, tokenIds, amounts) {\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"burnBatch\", [account, tokenIds, amounts])\n    };\n  }\n}\n\n/**\n * List ERC1155 NFTs\n * @remarks Easily list all the NFTs in a ERC1155 contract.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const nfts = await contract.edition.query.all();\n * ```\n * @public\n */\nclass Erc1155Enumerable {\n  constructor(erc1155, contractWrapper) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_EDITION_ENUMERABLE.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"erc1155\", void 0);\n    this.erc1155 = erc1155;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get All NFTs\n   *\n   * @remarks Get all the data associated with every NFT in this contract.\n   *\n   * By default, returns the first 100 NFTs, use queryParams to fetch more.\n   *\n   * @example\n   * ```javascript\n   * const nfts = await contract.edition.query.all();\n   * ```\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs queried.\n   */\n  async all(queryParams) {\n    const start = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(queryParams?.start || 0).toNumber();\n    const count = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(queryParams?.count || _QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.D).toNumber();\n    const maxId = Math.min((await this.totalCount()).toNumber(), start + count);\n    return await Promise.all([...Array(maxId - start).keys()].map(i => this.erc1155.get((start + i).toString())));\n  }\n\n  /**\n   * Get the number of NFTs minted\n   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.\n   *\n   * @returns the total number of NFTs minted in this contract\n   * @public\n   */\n  async totalCount() {\n    return await this.contractWrapper.readContract.nextTokenIdToMint();\n  }\n\n  /**\n   * Get the supply of token for a given tokenId.\n   * @remarks This is **not** the sum of supply of all NFTs in the contract.\n   *\n   * @returns the total number of NFTs minted in this contract\n   * @public\n   */\n  async totalCirculatingSupply(tokenId) {\n    return await this.contractWrapper.readContract.totalSupply(tokenId);\n  }\n\n  /**\n   * Get Owned NFTs\n   *\n   * @remarks Get all the data associated with the NFTs owned by a specific wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to get the NFTs of\n   * const address = \"{{wallet_address}}\";\n   * const nfts = await contract.edition.query.owned(address);\n   * ```\n   *\n   * @returns The NFT metadata for all NFTs in the contract.\n   */\n  async owned(walletAddress) {\n    const address = walletAddress || (await this.contractWrapper.getSignerAddress());\n    const maxId = await this.contractWrapper.readContract.nextTokenIdToMint();\n    const balances = await this.contractWrapper.readContract.balanceOfBatch(Array(maxId.toNumber()).fill(address), Array.from(Array(maxId.toNumber()).keys()));\n    const ownedBalances = balances.map((b, i) => {\n      return {\n        tokenId: i,\n        balance: b\n      };\n    }).filter(b => b.balance.gt(0));\n    return await Promise.all(ownedBalances.map(async b => {\n      const editionMetadata = await this.erc1155.get(b.tokenId.toString());\n      return {\n        ...editionMetadata,\n        owner: address,\n        quantityOwned: b.balance.toNumber()\n      };\n    }));\n  }\n}\n\nasync function getPrebuiltInfo(address, provider) {\n  try {\n    const contract = new ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.Contract(address, _thirdweb_dev_contracts_js_dist_abis_IThirdwebContract_json__WEBPACK_IMPORTED_MODULE_4__, provider);\n    const [type, version] = await Promise.all([ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.toUtf8String(await contract.contractType()) // eslint-disable-next-line no-control-regex\n    .replace(/\\x00/g, \"\"), await contract.contractVersion()]);\n    return {\n      type,\n      version\n    };\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\n * Configure and claim ERC1155 NFTs\n * @remarks Manage claim phases and claim ERC1155 NFTs that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.edition.drop.claim.to(\"0x...\", tokenId, quantity);\n * ```\n */\nclass ERC1155Claimable {\n  constructor(contractWrapper) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_EDITION_CLAIM_CUSTOM.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Options for claiming the NFTs\n   */\n  async getClaimTransaction(destinationAddress, tokenId, quantity, options) {\n    let overrides = {};\n    if (options && options.pricePerToken) {\n      overrides = await calculateClaimCost(this.contractWrapper, options.pricePerToken, quantity, options.currencyAddress, options.checkERC20Allowance);\n    }\n    return TransactionTask.make({\n      contractWrapper: this.contractWrapper,\n      functionName: \"claim\",\n      args: [destinationAddress, tokenId, quantity],\n      overrides\n    });\n  }\n\n  /**\n   * Claim NFTs to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const tokenId = 0; // the id of the NFT you want to claim\n   * const quantity = 1; // how many NFTs you want to claim\n   *\n   * const tx = await contract.erc1155.claimTo(address, tokenId, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Options for claiming the NFTs\n   *\n   * @returns - Receipt for the transaction\n   */\n  async to(destinationAddress, tokenId, quantity, options) {\n    const tx = await this.getClaimTransaction(destinationAddress, tokenId, quantity, options);\n    return await tx.execute();\n  }\n}\n\n/**\n * Configure and claim ERC1155 NFTs\n * @remarks Manage claim phases and claim ERC1155 NFTs that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc1155.claim(tokenId, quantity);\n * await contract.erc1155.claimConditions.getActive(tokenId);\n * ```\n */\nclass Erc1155ClaimableWithConditions {\n  constructor(contractWrapper, storage) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_EDITION_CLAIM_CONDITIONS_V2.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"conditions\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);\n    this.conditions = new DropErc1155ClaimConditions(contractWrapper, metadata, this.storage);\n  }\n\n  /**\n   * Claim NFTs to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const tokenId = 0; // the id of the NFT you want to claim\n   * const quantity = 1; // how many NFTs you want to claim\n   *\n   * const tx = await contract.erc1155.claimTo(address, tokenId, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   *\n   * @returns - Receipt for the transaction\n   */\n  async to(destinationAddress, tokenId, quantity, options) {\n    const tx = await this.conditions.getClaimTransaction(destinationAddress, tokenId, quantity, options);\n    return await tx.execute();\n  }\n}\n\nclass Erc1155LazyMintable {\n  /**\n   * Delayed reveal\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until you reveal them\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.edition.drop.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * // Whenever you're ready, reveal your NFTs at any time\n   * const batchId = 0; // the batch to reveal\n   * await contract.edition.drop.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   */\n\n  /**\n   * Claim tokens and configure claim conditions\n   * @remarks Let users claim NFTs. Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const quantity = 10;\n   * const tokenId = 0;\n   * await contract.erc1155.claimTo(\"0x...\", 0, quantity);\n   * ```\n   */\n\n  constructor(erc1155, contractWrapper, storage) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_EDITION_LAZY_MINTABLE_V2.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"revealer\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"claimWithConditions\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"claim\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"erc1155\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    this.erc1155 = erc1155;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.claim = this.detectErc1155Claimable();\n    this.claimWithConditions = this.detectErc1155ClaimableWithConditions();\n    this.revealer = this.detectErc1155Revealable();\n  }\n\n  /**\n   * Create a batch of NFTs to be claimed in the future\n   *\n   * @remarks Create batch allows you to create a batch of many NFTs in one transaction.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata of the NFTs to create\n   * const metadatas = [{\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   *\n   * const results = await contract.erc1155.lazyMint(metadatas); // uploads and creates the NFTs on chain\n   * const firstTokenId = results[0].id; // token id of the first created NFT\n   * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT\n   * ```\n   *\n   * @param metadatas - The metadata to include in the batch.\n   * @param options - optional upload progress callback\n   */\n  async lazyMint(metadatas, options) {\n    const startFileNumber = await this.erc1155.nextTokenIdToMint();\n    const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options);\n    // ensure baseUri is the same for the entire batch\n    const baseUri = batch[0].substring(0, batch[0].lastIndexOf(\"/\"));\n    for (let i = 0; i < batch.length; i++) {\n      const uri = batch[i].substring(0, batch[i].lastIndexOf(\"/\"));\n      if (baseUri !== uri) {\n        throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);\n      }\n    }\n    const isLegacyEditionDropContract = await this.isLegacyEditionDropContract();\n    let receipt;\n    if (isLegacyEditionDropContract) {\n      receipt = await this.contractWrapper.sendTransaction(\"lazyMint\", [batch.length, `${baseUri.endsWith(\"/\") ? baseUri : `${baseUri}/`}`]);\n    } else {\n      // new contracts/extensions have support for delayed reveal that adds an extra parameter to lazyMint\n      receipt = await this.contractWrapper.sendTransaction(\"lazyMint\", [batch.length, `${baseUri.endsWith(\"/\") ? baseUri : `${baseUri}/`}`, ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.toUtf8Bytes(\"\")]);\n    }\n    const event = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n    const startingIndex = event[0].args.startTokenId;\n    const endingIndex = event[0].args.endTokenId;\n    const results = [];\n    for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n      results.push({\n        id,\n        receipt,\n        data: () => this.erc1155.getTokenMetadata(id)\n      });\n    }\n    return results;\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  detectErc1155Claimable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155ClaimCustom\")) {\n      return new ERC1155Claimable(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc1155ClaimableWithConditions() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155ClaimConditionsV1\") || detectContractFeature(this.contractWrapper, \"ERC1155ClaimConditionsV2\") || detectContractFeature(this.contractWrapper, \"ERC1155ClaimPhasesV1\") || detectContractFeature(this.contractWrapper, \"ERC1155ClaimPhasesV2\")) {\n      return new Erc1155ClaimableWithConditions(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc1155Revealable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155Revealable\")) {\n      return new DelayedReveal(this.contractWrapper, this.storage, FEATURE_EDITION_REVEALABLE.name, () => this.erc1155.nextTokenIdToMint());\n    }\n    return undefined;\n  }\n  async isLegacyEditionDropContract() {\n    const info = await getPrebuiltInfo(this.contractWrapper.readContract.address, this.contractWrapper.getProvider());\n    return info && info.type === \"DropERC1155\" && info.version < 3;\n  }\n}\n\n/**\n * Mint Many ERC1155 NFTs at once\n * @remarks NFT batch minting functionality that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.edition.mint.batch.to(walletAddress, [nftMetadataWithSupply1, nftMetadataWithSupply2, ...]);\n * ```\n * @public\n */\nclass Erc1155BatchMintable {\n  constructor(erc1155, contractWrapper, storage) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_EDITION_BATCH_MINTABLE.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"erc1155\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    this.erc1155 = erc1155;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Mint Many NFTs with limited supplies\n   *\n   * @remarks Mint many different NFTs with limited supplies to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const toAddress = \"{{wallet_address}}\"\n   *\n   * // Custom metadata and supplies of your NFTs\n   * const metadataWithSupply = [{\n   *   supply: 50, // The number of this NFT you want to mint\n   *   metadata: {\n   *     name: \"Cool NFT #1\",\n   *     description: \"This is a cool NFT\",\n   *     image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   *   },\n   * }, {\n   *   supply: 100,\n   *   metadata: {\n   *     name: \"Cool NFT #2\",\n   *     description: \"This is a cool NFT\",\n   *     image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   *   },\n   * }];\n   *\n   * const tx = await contract.edition.mint.batch.to(toAddress, metadataWithSupply);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   */\n  async to(to, metadataWithSupply) {\n    const metadatas = metadataWithSupply.map(a => a.metadata);\n    const supplies = metadataWithSupply.map(a => a.supply);\n    const uris = await uploadOrExtractURIs(metadatas, this.storage);\n    const encoded = uris.map((uri, index) => this.contractWrapper.readContract.interface.encodeFunctionData(\"mintTo\", [to, ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.MaxUint256, uri, supplies[index]]));\n    const receipt = await this.contractWrapper.multiCall(encoded);\n    const events = this.contractWrapper.parseLogs(\"TokensMinted\", receipt.logs);\n    if (events.length === 0 || events.length < metadatas.length) {\n      throw new Error(\"TokenMinted event not found, minting failed\");\n    }\n    return events.map(e => {\n      const id = e.args.tokenIdMinted;\n      return {\n        id,\n        receipt,\n        data: () => this.erc1155.get(id)\n      };\n    });\n  }\n}\n\n/**\n * Mint ERC1155 NFTs\n * @remarks NFT minting functionality that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.edition.mint.to(walletAddress, nftMetadata);\n * ```\n * @public\n */\nclass Erc1155Mintable {\n  /**\n   * Batch mint Tokens to many addresses\n   */\n\n  constructor(erc1155, contractWrapper, storage) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_EDITION_MINTABLE.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"erc1155\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"batch\", void 0);\n    this.erc1155 = erc1155;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.batch = this.detectErc1155BatchMintable();\n  }\n\n  /**\n   * Mint an NFT with a limited supply\n   *\n   * @remarks Mint an NFT with a limited supply to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const toAddress = \"{{wallet_address}}\"\n   *\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }\n   *\n   * const metadataWithSupply = {\n   *   metadata,\n   *   supply: 1000, // The number of this NFT you want to mint\n   * }\n   *\n   * const tx = await contract.edition.mint.to(toAddress, metadataWithSupply);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   */\n  async to(to, metadataWithSupply) {\n    const uri = await uploadOrExtractURI(metadataWithSupply.metadata, this.storage);\n    const receipt = await this.contractWrapper.sendTransaction(\"mintTo\", [to, ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.MaxUint256, uri, metadataWithSupply.supply]);\n    const event = this.contractWrapper.parseLogs(\"TransferSingle\", receipt?.logs);\n    if (event.length === 0) {\n      throw new Error(\"TransferSingleEvent event not found\");\n    }\n    const id = event[0].args.id;\n    return {\n      id,\n      receipt,\n      data: () => this.erc1155.get(id.toString())\n    };\n  }\n\n  /**\n   * Increase the supply of an existing NFT and mint it to a given wallet address\n   *\n   * @param to - the address to mint to\n   * @param tokenId - the token id of the NFT to increase supply of\n   * @param additionalSupply - the additional amount to mint\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const toAddress = \"{{wallet_address}}\"\n   * const tokenId = 0;\n   * const additionalSupply = 1000;\n   *\n   * const tx = await contract.edition.mint.additionalSupplyTo(toAddress, tokenId, additionalSupply);\n   * ```\n   */\n  async additionalSupplyTo(to, tokenId, additionalSupply) {\n    const metadata = await this.erc1155.getTokenMetadata(tokenId);\n    const receipt = await this.contractWrapper.sendTransaction(\"mintTo\", [to, tokenId, metadata.uri, additionalSupply]);\n    return {\n      id: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(tokenId),\n      receipt,\n      data: () => this.erc1155.get(tokenId)\n    };\n  }\n  detectErc1155BatchMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155BatchMintable\")) {\n      return new Erc1155BatchMintable(this.erc1155, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n}\n\n/**\n * Enables generating dynamic ERC1155 NFTs with rules and an associated signature, which can then be minted by anyone securely\n * @public\n */\nclass Erc1155SignatureMintable {\n  constructor(contractWrapper, storage, roles) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_EDITION_SIGNATURE_MINTABLE.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"roles\", void 0);\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.roles = roles;\n  }\n\n  /**\n   * Mint a dynamically generated NFT\n   *\n   * @remarks Mint a dynamic NFT with a previously generated signature.\n   *\n   * @example\n   * ```javascript\n   * // see how to craft a payload to sign in the `generate()` documentation\n   * const signedPayload = contract.erc1155.signature.generate(payload);\n   *\n   * // now anyone can mint the NFT\n   * const tx = contract.erc1155.signature.mint(signedPayload);\n   * ```\n   * @param signedPayload - the previously generated payload and signature with {@link Erc1155SignatureMintable.generate}\n   * @twfeature ERC1155SignatureMintable\n   */\n  async mint(signedPayload) {\n    const mintRequest = signedPayload.payload;\n    const signature = signedPayload.signature;\n    const message = await this.mapPayloadToContractStruct(mintRequest);\n    const overrides = await this.contractWrapper.getCallOverrides();\n    await setErc20Allowance(this.contractWrapper, message.pricePerToken.mul(message.quantity), mintRequest.currencyAddress, overrides);\n    const receipt = await this.contractWrapper.sendTransaction(\"mintWithSignature\", [message, signature], overrides);\n    const t = this.contractWrapper.parseLogs(\"TokensMintedWithSignature\", receipt.logs);\n    if (t.length === 0) {\n      throw new Error(\"No MintWithSignature event found\");\n    }\n    const id = t[0].args.tokenIdMinted;\n    return {\n      id,\n      receipt\n    };\n  }\n\n  /**\n   * Mint any number of dynamically generated NFT at once\n   * @remarks Mint multiple dynamic NFTs in one transaction. Note that this is only possible for free mints (cannot batch mints with a price attached to it for security reasons)\n   *\n   * @example\n   * ```javascript\n   * // see how to craft a batch of payloads to sign in the `generateBatch()` documentation\n   * const signedPayloads = contract.erc1155.signature.generateBatch(payloads);\n   *\n   * // now anyone can mint the NFT\n   * const tx = contract.erc1155.signature.mintBatch(signedPayloads);\n   * ```\n   *\n   * @param signedPayloads - the array of signed payloads to mint\n   * @twfeature ERC1155SignatureMintable\n   */\n  async mintBatch(signedPayloads) {\n    const contractPayloads = await Promise.all(signedPayloads.map(async s => {\n      const message = await this.mapPayloadToContractStruct(s.payload);\n      const signature = s.signature;\n      const price = s.payload.price;\n      if (ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(price).gt(0)) {\n        throw new Error(\"Can only batch free mints. For mints with a price, use regular mint()\");\n      }\n      return {\n        message,\n        signature\n      };\n    }));\n    const encoded = contractPayloads.map(p => {\n      return this.contractWrapper.readContract.interface.encodeFunctionData(\"mintWithSignature\", [p.message, p.signature]);\n    });\n    const receipt = await this.contractWrapper.multiCall(encoded);\n    const events = this.contractWrapper.parseLogs(\"TokensMintedWithSignature\", receipt.logs);\n    if (events.length === 0) {\n      throw new Error(\"No MintWithSignature event found\");\n    }\n    return events.map(log => ({\n      id: log.args.tokenIdMinted,\n      receipt\n    }));\n  }\n\n  /**\n   * Verify that a payload is correctly signed\n   * @param signedPayload - the payload to verify\n   * @twfeature ERC1155SignatureMintable\n   *\n   * @example\n   * ```javascript\n   * const nftMetadata = {\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   metadata: nftMetadata, // The NFT to mint\n   *   to: {{wallet_address}}, // Who will receive the NFT\n   *   quantity: 2, // the quantity of NFTs to mint\n   *   price: 0.5, // the price per NFT\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now\n   *   royaltyRecipient: \"0x...\", // custom royalty recipient for this NFT\n   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this NFT\n   * };\n   *\n   * const signedPayload = contract.erc1155.signature.generate(payload);\n   * // Now you can verify that the payload is valid\n   * const isValid = await contract.erc1155.signature.verify(signedPayload);\n   * ```\n   */\n  async verify(signedPayload) {\n    const mintRequest = signedPayload.payload;\n    const signature = signedPayload.signature;\n    const message = await this.mapPayloadToContractStruct(mintRequest);\n    const verification = await this.contractWrapper.readContract.verify(message, signature);\n    return verification[0];\n  }\n\n  /**\n   * Generate a signature that can be used to mint an NFT dynamically.\n   *\n   * @remarks Takes in an NFT and some information about how it can be minted, uploads the metadata and signs it with your private key. The generated signature can then be used to mint an NFT using the exact payload and signature generated.\n   *\n   * @example\n   * ```javascript\n   * const nftMetadata = {\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   metadata: nftMetadata, // The NFT to mint\n   *   to: {{wallet_address}}, // Who will receive the NFT\n   *   quantity: 2, // the quantity of NFTs to mint\n   *   price: 0.5, // the price per NFT\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now\n   *   royaltyRecipient: \"0x...\", // custom royalty recipient for this NFT\n   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this NFT\n   * };\n   *\n   * const signedPayload = await contract.erc1155.signature.generate(payload);\n   * // now anyone can use these to mint the NFT using `contract.erc1155.signature.mint(signedPayload)`\n   * ```\n   * @param payloadToSign - the payload to sign\n   * @returns the signed payload and the corresponding signature\n   * @twfeature ERC1155SignatureMintable\n   */\n  async generate(payloadToSign) {\n    const payload = {\n      ...payloadToSign,\n      tokenId: ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.MaxUint256\n    };\n    return this.generateFromTokenId(payload);\n  }\n\n  /**\n   * Generate a signature that can be used to mint additionaly supply to an existing NFT.\n   *\n   * @remarks Takes in a payload with the token ID of an existing NFT, and signs it with your private key. The generated signature can then be used to mint additional supply to the NFT using the exact payload and signature generated.\n   *\n   * @example\n   * ```javascript\n   * const nftMetadata = {\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   tokenId: 0, // Instead of metadata, we specificy the token ID of the NFT to mint supply to\n   *   to: {{wallet_address}}, // Who will receive the NFT (or AddressZero for anyone)\n   *   quantity: 2, // the quantity of NFTs to mint\n   *   price: 0.5, // the price per NFT\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now\n   *   royaltyRecipient: \"0x...\", // custom royalty recipient for this NFT\n   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this NFT\n   * };\n   *\n   * const signedPayload = await contract.erc1155.signature.generateFromTokenId(payload);\n   * // now anyone can use these to mint the NFT using `contract.erc1155.signature.mint(signedPayload)`\n   * ```\n   * @param payloadToSign - the payload to sign\n   * @returns the signed payload and the corresponding signature\n   * @twfeature ERC1155SignatureMintable\n   */\n  async generateFromTokenId(payloadToSign) {\n    const payloads = await this.generateBatchFromTokenIds([payloadToSign]);\n    return payloads[0];\n  }\n\n  /**\n   * Generate a batch of signatures that can be used to mint many new NFTs dynamically.\n   *\n   * @remarks See {@link Erc1155SignatureMintable.generate}\n   *\n   * @param payloadsToSign - the payloads to sign\n   * @returns an array of payloads and signatures\n   * @twfeature ERC1155SignatureMintable\n   */\n  async generateBatch(payloadsToSign) {\n    const payloads = payloadsToSign.map(payload => ({\n      ...payload,\n      tokenId: ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.MaxUint256\n    }));\n    return this.generateBatchFromTokenIds(payloads);\n  }\n\n  /**\n   * Genrate a batch of signatures that can be used to mint new NFTs or additionaly supply to existing NFTs dynamically.\n   *\n   * @remarks See {@link Erc1155SignatureMintable.generateFromTokenId}\n   *\n   * @param payloadsToSign - the payloads to sign with tokenIds specified\n   * @returns an array of payloads and signatures\n   * @twfeature ERC1155SignatureMintable\n   */\n  async generateBatchFromTokenIds(payloadsToSign) {\n    await this.roles?.verify([\"minter\"], await this.contractWrapper.getSignerAddress());\n    const parsedRequests = payloadsToSign.map(m => Signature1155PayloadInputWithTokenId.parse(m));\n    const metadatas = parsedRequests.map(r => r.metadata);\n    const uris = await uploadOrExtractURIs(metadatas, this.storage);\n    const chainId = await this.contractWrapper.getChainID();\n    const signer = this.contractWrapper.getSigner();\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(signer, \"No signer available\");\n    const contractInfo = await getPrebuiltInfo(this.contractWrapper.readContract.address, this.contractWrapper.getProvider());\n    const isLegacyContract = contractInfo?.type === \"TokenERC1155\";\n    return await Promise.all(parsedRequests.map(async (m, i) => {\n      const uri = uris[i];\n      const finalPayload = Signature1155PayloadOutput.parse({\n        ...m,\n        uri\n      });\n      const signature = await this.contractWrapper.signTypedData(signer, {\n        name: isLegacyContract ? \"TokenERC1155\" : \"SignatureMintERC1155\",\n        version: \"1\",\n        chainId,\n        verifyingContract: this.contractWrapper.readContract.address\n      }, {\n        MintRequest: MintRequest1155\n      },\n      // TYPEHASH\n      await this.mapPayloadToContractStruct(finalPayload));\n      return {\n        payload: finalPayload,\n        signature: signature.toString()\n      };\n    }));\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Maps a payload to the format expected by the contract\n   *\n   * @internal\n   *\n   * @param mintRequest - The payload to map.\n   * @returns - The mapped payload.\n   */\n  async mapPayloadToContractStruct(mintRequest) {\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);\n    return {\n      to: mintRequest.to,\n      tokenId: mintRequest.tokenId,\n      uri: mintRequest.uri,\n      quantity: mintRequest.quantity,\n      pricePerToken: normalizedPricePerToken,\n      currency: mintRequest.currencyAddress,\n      validityStartTimestamp: mintRequest.mintStartTime,\n      validityEndTimestamp: mintRequest.mintEndTime,\n      uid: mintRequest.uid,\n      royaltyRecipient: mintRequest.royaltyRecipient,\n      royaltyBps: mintRequest.royaltyBps,\n      primarySaleRecipient: mintRequest.primarySaleRecipient\n    };\n  }\n}\n\n/**\n * Standard ERC1155 NFT functions\n * @remarks Basic functionality for a ERC1155 contract that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc1155.transfer(walletAddress, tokenId, quantity);\n * ```\n * @public\n */\nclass Erc1155 {\n  get chainId() {\n    return this._chainId;\n  }\n  constructor(contractWrapper, storage, chainId) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_EDITION.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"query\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"mintable\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"burnable\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"lazyMintable\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"signatureMintable\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"_chainId\", void 0);\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.query = this.detectErc1155Enumerable();\n    this.mintable = this.detectErc1155Mintable();\n    this.burnable = this.detectErc1155Burnable();\n    this.lazyMintable = this.detectErc1155LazyMintable();\n    this.signatureMintable = this.detectErc1155SignatureMintable();\n    this._chainId = chainId;\n  }\n\n  /**\n   * @internal\n   */\n  onNetworkUpdated(network) {\n    this.contractWrapper.updateSignerOrProvider(network);\n  }\n  getAddress() {\n    return this.contractWrapper.readContract.address;\n  }\n\n  ////// Standard ERC1155 functions //////\n\n  /**\n   * Get a single NFT Metadata\n   *\n   * @example\n   * ```javascript\n   * const nft = await contract.erc1155.get(0);\n   * ```\n   * @param tokenId - the tokenId of the NFT to retrieve\n   * @returns The NFT metadata\n   * @twfeature ERC1155\n   */\n  async get(tokenId) {\n    const [supply, metadata] = await Promise.all([this.contractWrapper.readContract.totalSupply(tokenId).catch(() => ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(0)), this.getTokenMetadata(tokenId).catch(() => ({\n      id: tokenId.toString(),\n      uri: \"\",\n      ...FALLBACK_METADATA\n    }))]);\n    return {\n      owner: ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.AddressZero,\n      metadata,\n      type: \"ERC1155\",\n      supply: supply.toNumber()\n    };\n  }\n\n  /**\n   * Returns the total supply of a specific token\n   * @param tokenId - The token ID to get the total supply of\n   * @returns the total supply\n   */\n  async totalSupply(tokenId) {\n    return await this.contractWrapper.readContract.totalSupply(tokenId);\n  }\n\n  /**\n   * Get NFT Balance\n   *\n   * @remarks Get a wallets NFT balance (number of NFTs in this contract owned by the wallet).\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to check NFT balance\n   * const walletAddress = \"{{wallet_address}}\";\n   * const tokenId = 0; // Id of the NFT to check\n   * const balance = await contract.erc1155.balanceOf(walletAddress, tokenId);\n   * ```\n   * @twfeature ERC1155\n   */\n  async balanceOf(address, tokenId) {\n    return await this.contractWrapper.readContract.balanceOf(address, tokenId);\n  }\n\n  /**\n   * Get NFT Balance for the currently connected wallet\n   */\n  async balance(tokenId) {\n    return await this.balanceOf(await this.contractWrapper.getSignerAddress(), tokenId);\n  }\n\n  /**\n   * Get whether this wallet has approved transfers from the given operator\n   * @param address - the wallet address\n   * @param operator - the operator address\n   */\n  async isApproved(address, operator) {\n    return await this.contractWrapper.readContract.isApprovedForAll(address, operator);\n  }\n\n  /**\n   * Transfer a single NFT\n   *\n   * @remarks Transfer an NFT from the connected wallet to another wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to send the NFT to\n   * const toAddress = \"{{wallet_address}}\";\n   * const tokenId = \"0\"; // The token ID of the NFT you want to send\n   * const amount = 3; // How many copies of the NFTs to transfer\n   * await contract.erc1155.transfer(toAddress, tokenId, amount);\n   * ```\n   * @twfeature ERC1155\n   */\n  async transfer(to, tokenId, amount) {\n    let data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0];\n    const from = await this.contractWrapper.getSignerAddress();\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"safeTransferFrom\", [from, to, tokenId, amount, data])\n    };\n  }\n\n  /**\n   * Approve or remove operator as an operator for the caller. Operators can call transferFrom or safeTransferFrom for any token owned by the caller.\n   * @param operator - the operator's address\n   * @param approved - whether to approve or remove\n   *\n   * @internal\n   */\n  async setApprovalForAll(operator, approved) {\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"setApprovalForAll\", [operator, approved])\n    };\n  }\n\n  /**\n   * Airdrop multiple NFTs\n   *\n   * @remarks Airdrop one or multiple NFTs to the provided wallet addresses.\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the NFT you want to airdrop\n   * const tokenId = \"0\";\n   * // Array of objects of addresses and quantities to airdrop NFTs to\n   * const addresses = [\n   *  {\n   *    address: \"0x...\",\n   *    quantity: 2,\n   *  },\n   *  {\n   *   address: \"0x...\",\n   *    quantity: 3,\n   *  },\n   * ];\n   * await contract.airdrop(tokenId, addresses);\n   *\n   * // You can also pass an array of addresses, it will airdrop 1 NFT per address\n   * const tokenId = \"0\";\n   * const addresses = [\n   *  \"0x...\", \"0x...\", \"0x...\",\n   * ]\n   * await contract.erc1155.airdrop(tokenId, addresses);\n   * ```\n   */\n  async airdrop(tokenId, addresses) {\n    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0];\n    const from = await this.contractWrapper.getSignerAddress();\n    const balanceOf = await this.balanceOf(from, tokenId);\n    const input = AirdropInputSchema.parse(addresses);\n    const totalToAirdrop = input.reduce((prev, curr) => {\n      return prev + Number(curr?.quantity || 1);\n    }, 0);\n    if (balanceOf.toNumber() < totalToAirdrop) {\n      throw new Error(`The caller owns ${balanceOf.toNumber()} NFTs, but wants to airdrop ${totalToAirdrop} NFTs.`);\n    }\n    const encoded = input.map(_ref => {\n      let {\n        address: to,\n        quantity\n      } = _ref;\n      return this.contractWrapper.readContract.interface.encodeFunctionData(\"safeTransferFrom\", [from, to, tokenId, quantity, data]);\n    });\n    return {\n      receipt: await this.contractWrapper.multiCall(encoded)\n    };\n  }\n\n  /**\n   * Return the next available token ID to mint\n   * @internal\n   */\n  async nextTokenIdToMint() {\n    if (hasFunction(\"nextTokenIdToMint\", this.contractWrapper)) {\n      return await this.contractWrapper.readContract.nextTokenIdToMint();\n    } else {\n      throw new Error(\"Contract requires the `nextTokenIdToMint` function available to determine the next token ID to mint\");\n    }\n  }\n\n  ////// ERC1155 Enumerable Extension //////\n\n  /**\n   * Get All NFTs\n   *\n   * @remarks Get all the data associated with every NFT in this contract.\n   *\n   * By default, returns the first 100 NFTs, use queryParams to fetch more.\n   *\n   * @example\n   * ```javascript\n   * const nfts = await contract.erc1155.getAll();\n   * ```\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs queried.\n   * @twfeature ERC1155Enumerable\n   */\n  async getAll(queryParams) {\n    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).all(queryParams);\n  }\n\n  /**\n   * Get the number of NFTs minted\n   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.\n   *\n   * @returns the total number of NFTs minted in this contract\n   * @public\n   */\n  async totalCount() {\n    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).totalCount();\n  }\n\n  /**\n   * Get the supply of token for a given tokenId.\n   * @remarks This is **not** the sum of supply of all NFTs in the contract.\n   *\n   * @returns the total number of NFTs minted in this contract\n   * @public\n   */\n  async totalCirculatingSupply(tokenId) {\n    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).totalCirculatingSupply(tokenId);\n  }\n\n  /**\n   * Get Owned NFTs\n   *\n   * @remarks Get all the data associated with the NFTs owned by a specific wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to get the NFTs of\n   * const address = \"{{wallet_address}}\";\n   * const nfts = await contract.erc1155.getOwned(address);\n   * ```\n   *\n   * @returns The NFT metadata for all NFTs in the contract.\n   * @twfeature ERC1155Enumerable\n   */\n  async getOwned(walletAddress) {\n    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).owned(walletAddress);\n  }\n\n  ////// ERC1155 Mintable Extension //////\n\n  /**\n   * Mint an NFT with a limited supply\n   *\n   * @remarks Mint an NFT with a limited supply to the connected wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const toAddress = \"{{wallet_address}}\"\n   *\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }\n   *\n   * const metadataWithSupply = {\n   *   metadata,\n   *   supply: 1000, // The number of this NFT you want to mint\n   * }\n   *\n   * const tx = await contract.erc1155.mint(toAddress, metadataWithSupply);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   * @twfeature ERC1155Mintable\n   */\n  async mint(metadataWithSupply) {\n    return this.mintTo(await this.contractWrapper.getSignerAddress(), metadataWithSupply);\n  }\n\n  /**\n   * Mint an NFT with a limited supply\n   *\n   * @remarks Mint an NFT with a limited supply to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const toAddress = \"{{wallet_address}}\"\n   *\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }\n   *\n   * const metadataWithSupply = {\n   *   metadata,\n   *   supply: 1000, // The number of this NFT you want to mint\n   * }\n   *\n   * const tx = await contract.erc1155.mintTo(toAddress, metadataWithSupply);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   * @twfeature ERC1155Mintable\n   */\n  async mintTo(receiver, metadataWithSupply) {\n    return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).to(receiver, metadataWithSupply);\n  }\n\n  /**\n   * Increase the supply of an existing NFT\n   * @remarks Increase the supply of an existing NFT and mint it to the connected wallet address\n   * @example\n   * ```javascript\n   * const tokenId = 0;\n   * const additionalSupply = 1000;\n   * await contract.erc1155.mintAdditionalSupply(tokenId, additionalSupply);\n   * ```\n   *\n   * @param tokenId - the token id of the NFT to increase supply of\n   * @param additionalSupply - the additional amount to mint\n   * @twfeature ERC1155Mintable\n   */\n  async mintAdditionalSupply(tokenId, additionalSupply) {\n    return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).additionalSupplyTo(await this.contractWrapper.getSignerAddress(), tokenId, additionalSupply);\n  }\n\n  /**\n   * Increase the supply of an existing NFT and mint it to a given wallet address\n   *\n   * @param to - the address to mint to\n   * @param tokenId - the token id of the NFT to increase supply of\n   * @param additionalSupply - the additional amount to mint\n   */\n  async mintAdditionalSupplyTo(receiver, tokenId, additionalSupply) {\n    return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).additionalSupplyTo(receiver, tokenId, additionalSupply);\n  }\n\n  ////// ERC1155 BatchMintable Extension //////\n\n  /**\n   * Mint Many NFTs with limited supplies\n   *\n   * @remarks Mint many different NFTs with limited supplies to the connected wallet.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata and supplies of your NFTs\n   * const metadataWithSupply = [{\n   *   supply: 50, // The number of this NFT you want to mint\n   *   metadata: {\n   *     name: \"Cool NFT #1\",\n   *     description: \"This is a cool NFT\",\n   *     image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   *   },\n   * }, {\n   *   supply: 100,\n   *   metadata: {\n   *     name: \"Cool NFT #2\",\n   *     description: \"This is a cool NFT\",\n   *     image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   *   },\n   * }];\n   *\n   * const tx = await contract.erc1155.mintBatch(metadataWithSupply);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   * @twfeature ERC1155BatchMintable\n   */\n  async mintBatch(metadataWithSupply) {\n    return this.mintBatchTo(await this.contractWrapper.getSignerAddress(), metadataWithSupply);\n  }\n\n  /**\n   * Mint Many NFTs with limited supplies\n   *\n   * @remarks Mint many different NFTs with limited supplies to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const toAddress = \"{{wallet_address}}\"\n   *\n   * // Custom metadata and supplies of your NFTs\n   * const metadataWithSupply = [{\n   *   supply: 50, // The number of this NFT you want to mint\n   *   metadata: {\n   *     name: \"Cool NFT #1\",\n   *     description: \"This is a cool NFT\",\n   *     image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   *   },\n   * }, {\n   *   supply: 100,\n   *   metadata: {\n   *     name: \"Cool NFT #2\",\n   *     description: \"This is a cool NFT\",\n   *     image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   *   },\n   * }];\n   *\n   * const tx = await contract.erc1155.mintBatchTo(toAddress, metadataWithSupply);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   * @twfeature ERC1155BatchMintable\n   */\n  async mintBatchTo(receiver, metadataWithSupply) {\n    return assertEnabled(this.mintable?.batch, FEATURE_EDITION_BATCH_MINTABLE).to(receiver, metadataWithSupply);\n  }\n\n  ////// ERC1155 Burnable Extension //////\n\n  /**\n   * Burn a specified amount of a NFTs\n   *\n   * @remarks Burn the specified NFTs from the connected wallet\n   *\n   * @param tokenId - the token Id to burn\n   * @param amount - amount to burn\n   *\n   * @example\n   * ```javascript\n   * // The token ID to burn NFTs of\n   * const tokenId = 0;\n   * // The amount of the NFT you want to burn\n   * const amount = 2;\n   *\n   * const result = await contract.erc1155.burn(tokenId, amount);\n   * ```\n   * @twfeature ERC1155Burnable\n   */\n  async burn(tokenId, amount) {\n    return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).tokens(tokenId, amount);\n  }\n\n  /**\n   * Burn a specified amount of a NFTs\n   *\n   * @remarks Burn the specified NFTs from a specified wallet\n   *\n   * @param account - the address to burn NFTs from\n   * @param tokenId - the tokenId to burn\n   * @param amount - amount to burn\n   *\n   * @example\n   * ```javascript\n   * // The address of the wallet to burn NFTS from\n   * const account = \"0x...\";\n   * // The token ID to burn NFTs of\n   * const tokenId = 0;\n   * // The amount of this NFT you want to burn\n   * const amount = 2;\n   *\n   * const result = await contract.erc1155.burnFrom(account, tokenId, amount);\n   * ```\n   * @twfeature ERC1155Burnable\n   */\n  async burnFrom(account, tokenId, amount) {\n    return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).from(account, tokenId, amount);\n  }\n\n  /**\n   * Burn a batch of NFTs\n   *\n   * @remarks Burn the batch NFTs from the connected wallet\n   *\n   * @param tokenIds - the tokenIds to burn\n   * @param amounts - amount of each token to burn\n   *\n   * @example\n   * ```javascript\n   * // The token IDs to burn NFTs of\n   * const tokenIds = [0, 1];\n   * // The amounts of each NFT you want to burn\n   * const amounts = [2, 2];\n   *\n   * const result = await contract.erc1155.burnBatch(tokenIds, amounts);\n   * ```\n   * @twfeature ERC1155Burnable\n   */\n  async burnBatch(tokenIds, amounts) {\n    return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).batch(tokenIds, amounts);\n  }\n\n  /**\n   * Burn a batch of NFTs\n   *\n   * @remarks Burn the batch NFTs from the specified wallet\n   *\n   * @param account - the address to burn NFTs from\n   * @param tokenIds - the tokenIds to burn\n   * @param amounts - amount of each token to burn\n   *\n   * @example\n   * ```javascript\n   * // The address of the wallet to burn NFTS from\n   * const account = \"0x...\";\n   * // The token IDs to burn NFTs of\n   * const tokenIds = [0, 1];\n   * // The amounts of each NFT you want to burn\n   * const amounts = [2, 2];\n   *\n   * const result = await contract.erc1155.burnBatchFrom(account, tokenIds, amounts);\n   * ```\n   * @twfeature ERC1155Burnable\n   */\n  async burnBatchFrom(account, tokenIds, amounts) {\n    return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).batchFrom(account, tokenIds, amounts);\n  }\n\n  ////// ERC721 LazyMint Extension //////\n\n  /**\n   * Create a batch of NFTs to be claimed in the future\n   *\n   * @remarks Create batch allows you to create a batch of many NFTs in one transaction.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata of the NFTs to create\n   * const metadatas = [{\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   *\n   * const results = await contract.erc1155.lazyMint(metadatas); // uploads and creates the NFTs on chain\n   * const firstTokenId = results[0].id; // token id of the first created NFT\n   * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT\n   * ```\n   *\n   * @param metadatas - The metadata to include in the batch.\n   * @param options - optional upload progress callback\n   * @twfeature ERC1155LazyMintable\n   */\n  async lazyMint(metadatas, options) {\n    return assertEnabled(this.lazyMintable, FEATURE_EDITION_LAZY_MINTABLE_V2).lazyMint(metadatas, options);\n  }\n\n  ////// ERC1155 Claimable Extension //////\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Optional claim verification data (e.g. price, currency, etc...)\n   */\n  async getClaimTransaction(destinationAddress, tokenId, quantity, options) {\n    const claimWithConditions = this.lazyMintable?.claimWithConditions;\n    const claim = this.lazyMintable?.claim;\n    if (claimWithConditions) {\n      return claimWithConditions.conditions.getClaimTransaction(destinationAddress, tokenId, quantity, options);\n    }\n    if (claim) {\n      return claim.getClaimTransaction(destinationAddress, tokenId, quantity, options);\n    }\n    throw new ExtensionNotImplementedError(FEATURE_EDITION_CLAIM_CUSTOM);\n  }\n\n  /**\n   * Claim NFTs\n   *\n   * @remarks Let the connected wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const tokenId = 0; // the id of the NFT you want to claim\n   * const quantity = 1; // how many NFTs you want to claim\n   *\n   * const tx = await contract.erc1155.claim(tokenId, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Optional claim verification data (e.g. price, currency, etc...)\n   *\n   * @returns - Receipt for the transaction\n   * @twfeature ERC1155Claimable\n   */\n  async claim(tokenId, quantity, options) {\n    return this.claimTo(await this.contractWrapper.getSignerAddress(), tokenId, quantity, options);\n  }\n\n  /**\n   * Claim NFTs to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const tokenId = 0; // the id of the NFT you want to claim\n   * const quantity = 1; // how many NFTs you want to claim\n   *\n   * const tx = await contract.erc1155.claimTo(address, tokenId, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Optional claim verification data (e.g. price, currency, etc...)\n   *\n   * @returns - Receipt for the transaction\n   * @twfeature ERC1155Claimable\n   */\n  async claimTo(destinationAddress, tokenId, quantity, options) {\n    const claimWithConditions = this.lazyMintable?.claimWithConditions;\n    const claim = this.lazyMintable?.claim;\n    if (claimWithConditions) {\n      return claimWithConditions.to(destinationAddress, tokenId, quantity, options);\n    }\n    if (claim) {\n      return claim.to(destinationAddress, tokenId, quantity, options);\n    }\n    throw new ExtensionNotImplementedError(FEATURE_EDITION_CLAIM_CUSTOM);\n  }\n\n  /**\n   * Configure claim conditions\n   * @remarks Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxQuantity: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   * await contract.erc1155.claimConditions.set(tokenId, claimConditions);\n   * ```\n   * @twfeature ERC1155ClaimableWithConditions\n   */\n  get claimConditions() {\n    return assertEnabled(this.lazyMintable?.claimWithConditions, FEATURE_EDITION_CLAIM_CONDITIONS_V2).conditions;\n  }\n\n  ////// ERC1155 SignatureMintable Extension //////\n\n  /**\n   * Signature Minting\n   * @remarks Generate dynamic NFTs with your own signature, and let others mint them using that signature.\n   * @example\n   * ```javascript\n   * // see how to craft a payload to sign in the `contract.erc1155.signature.generate()` documentation\n   * const signedPayload = contract.erc1155.signature().generate(payload);\n   *\n   * // now anyone can mint the NFT\n   * const tx = contract.erc1155.signature.mint(signedPayload);\n   * const receipt = tx.receipt; // the mint transaction receipt\n   * const mintedId = tx.id; // the id of the NFT minted\n   * ```\n   * @twfeature ERC1155SignatureMintable\n   */\n  get signature() {\n    return assertEnabled(this.signatureMintable, FEATURE_EDITION_SIGNATURE_MINTABLE);\n  }\n\n  ////// ERC1155 DelayedReveal Extension //////\n\n  /**\n   * Delayed reveal\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until you reveal them\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.erc1155.drop.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * // Whenever you're ready, reveal your NFTs at any time\n   * const batchId = 0; // the batch to reveal\n   * await contract.erc1155.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   * @twfeature ERC1155Revealable\n   */\n  get revealer() {\n    return assertEnabled(this.lazyMintable?.revealer, FEATURE_EDITION_REVEALABLE);\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * @internal\n   * @param tokenId - the token Id to fetch\n   */\n  async getTokenMetadata(tokenId) {\n    const tokenUri = await this.contractWrapper.readContract.uri(tokenId);\n    if (!tokenUri) {\n      throw new NotFoundError();\n    }\n    return fetchTokenMetadata(tokenId, tokenUri, this.storage);\n  }\n  detectErc1155Enumerable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155Enumerable\")) {\n      return new Erc1155Enumerable(this, this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc1155Mintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155Mintable\")) {\n      return new Erc1155Mintable(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc1155Burnable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155Burnable\")) {\n      return new Erc1155Burnable(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc1155LazyMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155LazyMintableV1\") || detectContractFeature(this.contractWrapper, \"ERC1155LazyMintableV2\")) {\n      return new Erc1155LazyMintable(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc1155SignatureMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155SignatureMintable\")) {\n      return new Erc1155SignatureMintable(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n}\n\n/**\n * Standard ERC1155 NFT functions\n * @remarks Basic functionality for a ERC1155 contract that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.edition.transfer(walletAddress, tokenId, quantity);\n * ```\n * @public\n */\nclass StandardErc1155 {\n  get chainId() {\n    return this._chainId;\n  }\n  constructor(contractWrapper, storage, chainId) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"erc1155\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"_chainId\", void 0);\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.erc1155 = new Erc1155(this.contractWrapper, this.storage, chainId);\n    this._chainId = chainId;\n  }\n\n  /**\n   * @internal\n   */\n  onNetworkUpdated(network) {\n    this.contractWrapper.updateSignerOrProvider(network);\n  }\n  getAddress() {\n    return this.contractWrapper.readContract.address;\n  }\n\n  ////// Standard ERC1155 functions //////\n\n  /**\n   * Get a single NFT Metadata\n   *\n   * @example\n   * ```javascript\n   * const nft = await contract.get(\"0\");\n   * ```\n   * @param tokenId - the tokenId of the NFT to retrieve\n   * @returns The NFT metadata\n   */\n  async get(tokenId) {\n    return this.erc1155.get(tokenId);\n  }\n\n  /**\n   * Returns the total supply of a specific token\n   * @param tokenId - The token ID to get the total supply of\n   * @returns the total supply\n   */\n  async totalSupply(tokenId) {\n    return this.erc1155.totalSupply(tokenId);\n  }\n\n  /**\n   * Get NFT Balance\n   *\n   * @remarks Get a wallets NFT balance (number of NFTs in this contract owned by the wallet).\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to check NFT balance\n   * const walletAddress = \"{{wallet_address}}\";\n   * const tokenId = 0; // Id of the NFT to check\n   * const balance = await contract.balanceOf(walletAddress, tokenId);\n   * ```\n   */\n  async balanceOf(address, tokenId) {\n    return this.erc1155.balanceOf(address, tokenId);\n  }\n\n  /**\n   * Get NFT Balance for the currently connected wallet\n   */\n  async balance(tokenId) {\n    return this.erc1155.balance(tokenId);\n  }\n\n  /**\n   * Get whether this wallet has approved transfers from the given operator\n   * @param address - the wallet address\n   * @param operator - the operator address\n   */\n  async isApproved(address, operator) {\n    return this.erc1155.isApproved(address, operator);\n  }\n\n  /**\n   * Transfer a single NFT\n   *\n   * @remarks Transfer an NFT from the connected wallet to another wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to send the NFT to\n   * const toAddress = \"{{wallet_address}}\";\n   * const tokenId = \"0\"; // The token ID of the NFT you want to send\n   * const amount = 3; // How many copies of the NFTs to transfer\n   * await contract.transfer(toAddress, tokenId, amount);\n   * ```\n   */\n  async transfer(to, tokenId, amount) {\n    let data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0];\n    return this.erc1155.transfer(to, tokenId, amount, data);\n  }\n\n  /**\n   * Approve or remove operator as an operator for the caller. Operators can call transferFrom or safeTransferFrom for any token owned by the caller.\n   * @param operator - the operator's address\n   * @param approved - whether to approve or remove\n   *\n   * @internal\n   */\n  async setApprovalForAll(operator, approved) {\n    return this.erc1155.setApprovalForAll(operator, approved);\n  }\n\n  /**\n   * Airdrop multiple NFTs\n   *\n   * @remarks Airdrop one or multiple NFTs to the provided wallet addresses.\n   * @twfeature ERC1155\n   * @example\n   * ```javascript\n   * // The token ID of the NFT you want to airdrop\n   * const tokenId = \"0\";\n   * // Array of objects of addresses and quantities to airdrop NFTs to\n   * const addresses = [\n   *  {\n   *    address: \"0x...\",\n   *    quantity: 2,\n   *  },\n   *  {\n   *   address: \"0x...\",\n   *    quantity: 3,\n   *  },\n   * ];\n   * await contract.airdrop(tokenId, addresses);\n   *\n   * // You can also pass an array of addresses, it will airdrop 1 NFT per address\n   * const tokenId = \"0\";\n   * const addresses = [\n   *  \"0x...\", \"0x...\", \"0x...\",\n   * ]\n   * await contract.airdrop(tokenId, addresses);\n   * ```\n   */\n  async airdrop(tokenId, addresses) {\n    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0];\n    return this.erc1155.airdrop(tokenId, addresses, data);\n  }\n}\n\n/**\n * This method checks if the given token is approved for the transferrerContractAddress contract.\n * This is particularly useful for contracts that need to transfer NFTs on the users' behalf\n *\n * @internal\n * @param provider - The connected provider\n * @param transferrerContractAddress - The address of the marketplace contract\n * @param assetContract - The address of the asset contract.\n * @param tokenId - The token id of the token.\n * @param owner - The address of the account that owns the token.\n * @returns - True if the transferrerContractAddress is approved on the token, false otherwise.\n */\nasync function isTokenApprovedForTransfer(provider, transferrerContractAddress, assetContract, tokenId, owner) {\n  try {\n    const erc165 = new ethers__WEBPACK_IMPORTED_MODULE_58__.Contract(assetContract, _thirdweb_dev_contracts_js_dist_abis_IERC165_json__WEBPACK_IMPORTED_MODULE_0__, provider);\n    const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);\n    const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);\n    if (isERC721) {\n      const asset = new ethers__WEBPACK_IMPORTED_MODULE_58__.Contract(assetContract, _thirdweb_dev_contracts_js_dist_abis_IERC721_json__WEBPACK_IMPORTED_MODULE_1__, provider);\n      const approved = await asset.isApprovedForAll(owner, transferrerContractAddress);\n      if (approved) {\n        return true;\n      }\n      return (await asset.getApproved(tokenId)).toLowerCase() === transferrerContractAddress.toLowerCase();\n    } else if (isERC1155) {\n      const asset = new ethers__WEBPACK_IMPORTED_MODULE_58__.Contract(assetContract, _thirdweb_dev_contracts_js_dist_abis_IERC1155_json__WEBPACK_IMPORTED_MODULE_2__, provider);\n      return await asset.isApprovedForAll(owner, transferrerContractAddress);\n    } else {\n      console.error(\"Contract does not implement ERC 1155 or ERC 721.\");\n      return false;\n    }\n  } catch (err) {\n    console.error(\"Failed to check if token is approved\", err);\n    return false;\n  }\n}\n\n/**\n * Checks if the marketplace is approved to make transfers on the assetContract\n * If not, it tries to set the approval.\n * @param signerOrProvider\n * @param marketplaceAddress\n * @param assetContract\n * @param tokenId\n * @param from\n */\nasync function handleTokenApproval(signerOrProvider, marketplaceAddress, assetContract, tokenId, from) {\n  const erc165 = new ethers__WEBPACK_IMPORTED_MODULE_58__.Contract(assetContract, _thirdweb_dev_contracts_js_dist_abis_IERC165_json__WEBPACK_IMPORTED_MODULE_0__, signerOrProvider);\n  const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);\n  const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);\n  // check for token approval\n  if (isERC721) {\n    const asset = new ContractWrapper(signerOrProvider, assetContract, _thirdweb_dev_contracts_js_dist_abis_IERC721_json__WEBPACK_IMPORTED_MODULE_1__, {});\n    const approved = await asset.readContract.isApprovedForAll(from, marketplaceAddress);\n    if (!approved) {\n      const isTokenApproved = (await asset.readContract.getApproved(tokenId)).toLowerCase() === marketplaceAddress.toLowerCase();\n      if (!isTokenApproved) {\n        await asset.sendTransaction(\"setApprovalForAll\", [marketplaceAddress, true]);\n      }\n    }\n  } else if (isERC1155) {\n    const asset = new ContractWrapper(signerOrProvider, assetContract, _thirdweb_dev_contracts_js_dist_abis_IERC1155_json__WEBPACK_IMPORTED_MODULE_2__, {});\n    const approved = await asset.readContract.isApprovedForAll(from, marketplaceAddress);\n    if (!approved) {\n      await asset.sendTransaction(\"setApprovalForAll\", [marketplaceAddress, true]);\n    }\n  } else {\n    throw Error(\"Contract must implement ERC 1155 or ERC 721.\");\n  }\n}\n\n/**\n * Used to verify fields in new listing.\n * @internal\n */\n// TODO this should be done in zod\nfunction validateNewListingParam(param) {\n  (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(param.assetContractAddress !== undefined && param.assetContractAddress !== null, \"Asset contract address is required\");\n  (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(param.buyoutPricePerToken !== undefined && param.buyoutPricePerToken !== null, \"Buyout price is required\");\n  (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(param.listingDurationInSeconds !== undefined && param.listingDurationInSeconds !== null, \"Listing duration is required\");\n  (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(param.startTimestamp !== undefined && param.startTimestamp !== null, \"Start time is required\");\n  (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(param.tokenId !== undefined && param.tokenId !== null, \"Token ID is required\");\n  (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(param.quantity !== undefined && param.quantity !== null, \"Quantity is required\");\n  switch (param.type) {\n    case \"NewAuctionListing\":\n      {\n        (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(param.reservePricePerToken !== undefined && param.reservePricePerToken !== null, \"Reserve price is required\");\n      }\n  }\n}\n\n/**\n * Maps a contract offer to the strict interface\n *\n * @internal\n * @param offer\n * @returns - An `Offer` object\n */\nasync function mapOffer(provider, listingId, offer) {\n  return {\n    quantity: offer.quantityDesired,\n    pricePerToken: offer.pricePerToken,\n    currencyContractAddress: offer.currency,\n    buyerAddress: offer.offeror,\n    quantityDesired: offer.quantityWanted,\n    currencyValue: await fetchCurrencyValue(provider, offer.currency, offer.quantityWanted.mul(offer.pricePerToken)),\n    listingId\n  };\n}\nfunction isWinningBid(winningPrice, newBidPrice, bidBuffer) {\n  bidBuffer = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(bidBuffer);\n  winningPrice = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(winningPrice);\n  newBidPrice = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(newBidPrice);\n  if (winningPrice.eq(ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(0))) {\n    return false;\n  }\n  const buffer = newBidPrice.sub(winningPrice).mul(_QueryParams_ac0149c6_esm_js__WEBPACK_IMPORTED_MODULE_59__.M).div(winningPrice);\n  return buffer.gte(bidBuffer);\n}\n\n/**\n * Handles direct listings\n * @public\n */\nclass MarketplaceDirect {\n  constructor(contractWrapper, storage) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n  getAddress() {\n    return this.contractWrapper.readContract.address;\n  }\n\n  /** ******************************\n   * READ FUNCTIONS\n   *******************************/\n\n  /**\n   * Get a direct listing by id\n   *\n   * @param listingId - the listing id\n   * @returns the Direct listing object\n   */\n  async getListing(listingId) {\n    const listing = await this.contractWrapper.readContract.listings(listingId);\n    if (listing.assetContract === ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero) {\n      throw new ListingNotFoundError(this.getAddress(), listingId.toString());\n    }\n    if (listing.listingType !== ListingType.Direct) {\n      throw new WrongListingTypeError(this.getAddress(), listingId.toString(), \"Auction\", \"Direct\");\n    }\n    return await this.mapListing(listing);\n  }\n\n  /**\n   * Get the active offer on a listing\n   * @param listingId - the listing id\n   * @param address - the address that made the offer\n   */\n  async getActiveOffer(listingId, address) {\n    await this.validateListing(ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listingId));\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(ethers__WEBPACK_IMPORTED_MODULE_58__.utils.isAddress(address), \"Address must be a valid address\");\n    const offers = await this.contractWrapper.readContract.offers(listingId, address);\n    if (offers.offeror === ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero) {\n      return undefined;\n    }\n    return await mapOffer(this.contractWrapper.getProvider(), ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listingId), offers);\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Create Direct Listing\n   *\n   * @remarks Create a new listing on the marketplace where people can buy an asset directly.\n   *\n   * @example\n   * ```javascript\n   * // Data of the listing you want to create\n   * const listing = {\n   *   // address of the contract the asset you want to list is on\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to list\n   *   tokenId: \"0\",\n   *   // when should the listing open up for offers\n   *   startTimestamp: new Date(),\n   *   // how long the listing will be open for\n   *   listingDurationInSeconds: 86400,\n   *   // how many of the asset you want to list\n   *   quantity: 1,\n   *   // address of the currency contract that will be used to pay for the listing\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // how much the asset will be sold for\n   *   buyoutPricePerToken: \"1.5\",\n   * }\n   *\n   * const tx = await contract.direct.createListing(listing);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created listing\n   * ```\n   */\n  async createListing(listing) {\n    validateNewListingParam(listing);\n    await handleTokenApproval(this.contractWrapper.getSignerOrProvider(), this.getAddress(), listing.assetContractAddress, listing.tokenId, await this.contractWrapper.getSignerAddress());\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), listing.buyoutPricePerToken, listing.currencyContractAddress);\n    let listingStartTime = Math.floor(listing.startTimestamp.getTime() / 1000);\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    if (listingStartTime < blockTime) {\n      listingStartTime = blockTime;\n    }\n    const receipt = await this.contractWrapper.sendTransaction(\"createListing\", [{\n      assetContract: listing.assetContractAddress,\n      tokenId: listing.tokenId,\n      buyoutPricePerToken: normalizedPricePerToken,\n      currencyToAccept: cleanCurrencyAddress(listing.currencyContractAddress),\n      listingType: ListingType.Direct,\n      quantityToList: listing.quantity,\n      reservePricePerToken: normalizedPricePerToken,\n      secondsUntilEndTime: listing.listingDurationInSeconds,\n      startTime: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listingStartTime)\n    }], {\n      // Higher gas limit for create listing\n      gasLimit: 500000\n    });\n    const event = this.contractWrapper.parseLogs(\"ListingAdded\", receipt?.logs);\n    return {\n      id: event[0].args.listingId,\n      receipt\n    };\n  }\n\n  /**\n   * Make an offer for a Direct Listing\n   *\n   * @remarks Make an offer on a direct listing\n   *\n   * @example\n   * ```javascript\n   * import { ChainId, NATIVE_TOKENS } from \"@thirdweb-dev/sdk\";\n   *\n   * // The listing ID of the asset you want to offer on\n   * const listingId = 0;\n   * // The price you are willing to offer per token\n   * const pricePerToken = 1;\n   * // The quantity of tokens you want to receive for this offer\n   * const quantity = 1;\n   * // The address of the currency you are making the offer in (must be ERC-20)\n   * const currencyContractAddress = NATIVE_TOKENS[ChainId.Rinkeby].wrapped.address\n   *\n   * await contract.direct.makeOffer(\n   *   listingId,\n   *   quantity,\n   *   currencyContractAddress,\n   *   pricePerToken\n   * );\n   * ```\n   */\n  async makeOffer(listingId, quantityDesired, currencyContractAddress, pricePerToken, expirationDate) {\n    if (isNativeToken(currencyContractAddress)) {\n      throw new Error(\"You must use the wrapped native token address when making an offer with a native token\");\n    }\n    const normalizedPrice = await normalizePriceValue(this.contractWrapper.getProvider(), pricePerToken, currencyContractAddress);\n    try {\n      await this.getListing(listingId);\n    } catch (err) {\n      console.error(\"Failed to get listing, err =\", err);\n      throw new Error(`Error getting the listing with id ${listingId}`);\n    }\n    const quantity = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(quantityDesired);\n    const value = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(normalizedPrice).mul(quantity);\n    const overrides = (await this.contractWrapper.getCallOverrides()) || {};\n    await setErc20Allowance(this.contractWrapper, value, currencyContractAddress, overrides);\n    let expirationTimestamp = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.MaxUint256;\n    if (expirationDate) {\n      expirationTimestamp = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(Math.floor(expirationDate.getTime() / 1000));\n    }\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"offer\", [listingId, quantityDesired, currencyContractAddress, normalizedPrice, expirationTimestamp], overrides)\n    };\n  }\n\n  /**\n   * Accept an offer on a direct listing\n   *\n   * @remarks Accept an offer on a direct listing\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the asset you want to bid on\n   * const listingId = 0;\n   * // The price you are willing to bid for a single token of the listing\n   * const offeror = \"0x...\";\n   *\n   * await contract.direct.acceptOffer(listingId, offeror);\n   * ```\n   */\n  async acceptOffer(listingId, addressOfOfferor) {\n    /**\n     * TODO:\n     * - Provide better error handling if offer is too low.\n     */\n    await this.validateListing(ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listingId));\n    const offer = await this.contractWrapper.readContract.offers(listingId, addressOfOfferor);\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"acceptOffer\", [listingId, addressOfOfferor, offer.currency, offer.pricePerToken])\n    };\n  }\n\n  /**\n   * Buy a Listing\n   *\n   * @remarks Buy a specific direct listing from the marketplace.\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the asset you want to buy\n   * const listingId = 0;\n   * // Quantity of the asset you want to buy\n   * const quantityDesired = 1;\n   *\n   * await contract.direct.buyoutListing(listingId, quantityDesired);\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param quantityDesired - the quantity to buy\n   * @param receiver - optional receiver of the bought listing if different from the connected wallet\n   */\n  async buyoutListing(listingId, quantityDesired, receiver) {\n    const listing = await this.validateListing(ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listingId));\n    const {\n      valid,\n      error\n    } = await this.isStillValidListing(listing, quantityDesired);\n    if (!valid) {\n      throw new Error(`Listing ${listingId} is no longer valid. ${error}`);\n    }\n    const buyFor = receiver ? receiver : await this.contractWrapper.getSignerAddress();\n    const quantity = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(quantityDesired);\n    const value = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listing.buyoutPrice).mul(quantity);\n    const overrides = (await this.contractWrapper.getCallOverrides()) || {};\n    await setErc20Allowance(this.contractWrapper, value, listing.currencyContractAddress, overrides);\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"buy\", [listingId, buyFor, quantity, listing.currencyContractAddress, value], overrides)\n    };\n  }\n\n  /**\n   * Update a Direct listing with new metadata.\n   *\n   * Note: cannot update a listing with a new quantity of 0. Use `cancelDirectListing` to remove a listing instead.\n   *\n   * @param listing - the new listing information\n   */\n  async updateListing(listing) {\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"updateListing\", [listing.id, listing.quantity, listing.buyoutPrice,\n      // reserve price, doesn't matter for direct listing\n      listing.buyoutPrice, listing.currencyContractAddress, listing.startTimeInSeconds, listing.secondsUntilEnd])\n    };\n  }\n\n  /**\n   * Cancel Direct Listing\n   *\n   * @remarks Cancel a direct listing on the marketplace\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to cancel\n   * const listingId = \"0\";\n   *\n   * await contract.direct.cancelListing(listingId);\n   * ```\n   */\n  async cancelListing(listingId) {\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"cancelDirectListing\", [listingId])\n    };\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Throws error if listing could not be found\n   *\n   * @param listingId - Listing to check for\n   */\n  async validateListing(listingId) {\n    try {\n      return await this.getListing(listingId);\n    } catch (err) {\n      console.error(`Error getting the listing with id ${listingId}`);\n      throw err;\n    }\n  }\n\n  /**\n   * Helper method maps the auction listing to the direct listing interface.\n   *\n   * @internal\n   * @param listing - The listing to map, as returned from the contract.\n   * @returns - The mapped interface.\n   */\n  async mapListing(listing) {\n    return {\n      assetContractAddress: listing.assetContract,\n      buyoutPrice: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listing.buyoutPricePerToken),\n      currencyContractAddress: listing.currency,\n      buyoutCurrencyValuePerToken: await fetchCurrencyValue(this.contractWrapper.getProvider(), listing.currency, listing.buyoutPricePerToken),\n      id: listing.listingId.toString(),\n      tokenId: listing.tokenId,\n      quantity: listing.quantity,\n      startTimeInSeconds: listing.startTime,\n      asset: await fetchTokenMetadataForContract(listing.assetContract, this.contractWrapper.getProvider(), listing.tokenId, this.storage),\n      secondsUntilEnd: listing.endTime,\n      sellerAddress: listing.tokenOwner,\n      type: ListingType.Direct\n    };\n  }\n\n  /**\n   * Use this method to check if a direct listing is still valid.\n   *\n   * Ways a direct listing can become invalid:\n   * 1. The asset holder transferred the asset to another wallet\n   * 2. The asset holder burned the asset\n   * 3. The asset holder removed the approval on the marketplace\n   *\n   * @internal\n   * @param listing - The listing to check.\n   * @returns - True if the listing is valid, false otherwise.\n   */\n  async isStillValidListing(listing, quantity) {\n    const approved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), listing.assetContractAddress, listing.tokenId, listing.sellerAddress);\n    if (!approved) {\n      return {\n        valid: false,\n        error: `Token '${listing.tokenId}' from contract '${listing.assetContractAddress}' is not approved for transfer`\n      };\n    }\n    const provider = this.contractWrapper.getProvider();\n    const erc165 = new ethers__WEBPACK_IMPORTED_MODULE_58__.Contract(listing.assetContractAddress, _thirdweb_dev_contracts_js_dist_abis_IERC165_json__WEBPACK_IMPORTED_MODULE_0__, provider);\n    const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);\n    const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);\n    if (isERC721) {\n      const asset = new ethers__WEBPACK_IMPORTED_MODULE_58__.Contract(listing.assetContractAddress, _thirdweb_dev_contracts_js_dist_abis_IERC721_json__WEBPACK_IMPORTED_MODULE_1__, provider);\n      const valid = (await asset.ownerOf(listing.tokenId)).toLowerCase() === listing.sellerAddress.toLowerCase();\n      return {\n        valid,\n        error: valid ? undefined : `Seller is not the owner of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} anymore'`\n      };\n    } else if (isERC1155) {\n      const asset = new ethers__WEBPACK_IMPORTED_MODULE_58__.Contract(listing.assetContractAddress, _thirdweb_dev_contracts_js_dist_abis_IERC1155_json__WEBPACK_IMPORTED_MODULE_2__, provider);\n      const balance = await asset.balanceOf(listing.sellerAddress, listing.tokenId);\n      const valid = balance.gte(quantity || listing.quantity);\n      return {\n        valid,\n        error: valid ? undefined : `Seller does not have enough balance of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} to fulfill the listing`\n      };\n    } else {\n      return {\n        valid: false,\n        error: \"Contract does not implement ERC 1155 or ERC 721.\"\n      };\n    }\n  }\n}\n\n/**\n * Handles auction listings\n * @public\n */\nclass MarketplaceAuction {\n  constructor(contractWrapper, storage) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"encoder\", void 0);\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.encoder = new ContractEncoder(contractWrapper);\n  }\n  getAddress() {\n    return this.contractWrapper.readContract.address;\n  }\n\n  /** ******************************\n   * READ FUNCTIONS\n   *******************************/\n\n  /**\n   * Get an Auction listing by id\n   *\n   * @param listingId - the listing Id\n   * @returns the Auction listing object\n   */\n  async getListing(listingId) {\n    const listing = await this.contractWrapper.readContract.listings(listingId);\n    if (listing.listingId.toString() !== listingId.toString()) {\n      throw new ListingNotFoundError(this.getAddress(), listingId.toString());\n    }\n    if (listing.listingType !== ListingType.Auction) {\n      throw new WrongListingTypeError(this.getAddress(), listingId.toString(), \"Direct\", \"Auction\");\n    }\n    return await this.mapListing(listing);\n  }\n\n  /**\n   * Get Highest Bid\n   *\n   * @remarks Get the current highest bid of an active auction.\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the auction that closed\n   * const listingId = 0;\n   *\n   * contract.auction.\n   *   .getWinningBid(listingId)\n   *   .then((offer) => console.log(offer))\n   *   .catch((err) => console.error(err));\n   * ```\n   */\n  async getWinningBid(listingId) {\n    await this.validateListing(ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listingId));\n    const offers = await this.contractWrapper.readContract.winningBid(listingId);\n    if (offers.offeror === ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero) {\n      return undefined;\n    }\n    return await mapOffer(this.contractWrapper.getProvider(), ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listingId), offers);\n  }\n\n  /**\n   * Get Auction Winner\n   *\n   * @remarks Get the winner of the auction after an auction ends.\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the auction that closed\n   * const listingId = 0;\n   *\n   * contract.auction.\n   *   .getWinner(listingId)\n   *   .then((auctionWinner) => console.log(auctionWinner))\n   *   .catch((err) => console.error(err));\n   * ```\n   */\n  async getWinner(listingId) {\n    const listing = await this.validateListing(ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listingId));\n    const offers = await this.contractWrapper.readContract.winningBid(listingId);\n    const now = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(Math.floor(Date.now() / 1000));\n    const endTime = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listing.endTimeInEpochSeconds);\n\n    // if we have a winner in the map and the current time is past the endtime of the auction return the address of the winner\n    if (now.gt(endTime) && offers.offeror !== ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero) {\n      return offers.offeror;\n    }\n    // otherwise fall back to query filter things\n\n    // TODO this should be via indexer or direct contract call\n    const closedAuctions = await this.contractWrapper.readContract.queryFilter(this.contractWrapper.readContract.filters.AuctionClosed());\n    const auction = closedAuctions.find(a => a.args.listingId.eq(ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listingId)));\n    if (!auction) {\n      throw new Error(`Could not find auction with listingId ${listingId} in closed auctions`);\n    }\n    return auction.args.winningBidder;\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Create Auction\n   *\n   * @remarks Create a new auction where people can bid on an asset.\n   *\n   * @example\n   * ```javascript\n   * // Data of the auction you want to create\n   * const auction = {\n   *   // address of the contract the asset you want to list is on\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to list\n   *   tokenId: \"0\",\n   *  // when should the listing open up for offers\n   *   startTimestamp: new Date(),\n   *   // how long the listing will be open for\n   *   listingDurationInSeconds: 86400,\n   *   // how many of the asset you want to list\n   *   quantity: 1,\n   *   // address of the currency contract that will be used to pay for the listing\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // how much people would have to bid to instantly buy the asset\n   *   buyoutPricePerToken: \"10\",\n   *   // the minimum bid that will be accepted for the token\n   *   reservePricePerToken: \"1.5\",\n   * }\n   *\n   * const tx = await contract.auction.createListing(auction);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created listing\n   * ```\n   */\n  async createListing(listing) {\n    validateNewListingParam(listing);\n    await handleTokenApproval(this.contractWrapper.getSignerOrProvider(), this.getAddress(), listing.assetContractAddress, listing.tokenId, await this.contractWrapper.getSignerAddress());\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), listing.buyoutPricePerToken, listing.currencyContractAddress);\n    const normalizedReservePrice = await normalizePriceValue(this.contractWrapper.getProvider(), listing.reservePricePerToken, listing.currencyContractAddress);\n    let listingStartTime = Math.floor(listing.startTimestamp.getTime() / 1000);\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    if (listingStartTime < blockTime) {\n      listingStartTime = blockTime;\n    }\n    const receipt = await this.contractWrapper.sendTransaction(\"createListing\", [{\n      assetContract: listing.assetContractAddress,\n      tokenId: listing.tokenId,\n      buyoutPricePerToken: normalizedPricePerToken,\n      currencyToAccept: cleanCurrencyAddress(listing.currencyContractAddress),\n      listingType: ListingType.Auction,\n      quantityToList: listing.quantity,\n      reservePricePerToken: normalizedReservePrice,\n      secondsUntilEndTime: listing.listingDurationInSeconds,\n      startTime: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listingStartTime)\n    }], {\n      // Higher gas limit for create listing\n      gasLimit: 500000\n    });\n    const event = this.contractWrapper.parseLogs(\"ListingAdded\", receipt?.logs);\n    return {\n      id: event[0].args.listingId,\n      receipt\n    };\n  }\n\n  /**\n   * Buyout Auction\n   *\n   * @remarks Buy a specific direct listing from the marketplace.\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the asset you want to buy\n   * const listingId = 0;\n   *\n   * await contract.auction.buyoutListing(listingId);\n   * ```\n   */\n  async buyoutListing(listingId) {\n    const listing = await this.validateListing(ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listingId));\n    const currencyMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), listing.currencyContractAddress);\n    return this.makeBid(listingId, ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.formatUnits(listing.buyoutPrice, currencyMetadata.decimals));\n  }\n\n  /**\n   * Bid On Auction\n   *\n   * @remarks Make a bid on an auction listing\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the asset you want to bid on\n   * const listingId = 0;\n   * // The price you are willing to bid for a single token of the listing\n   * const pricePerToken = 1;\n   *\n   * await contract.auction.makeBid(listingId, pricePerToken);\n   * ```\n   */\n  async makeBid(listingId, pricePerToken) {\n    const listing = await this.validateListing(ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listingId));\n    const normalizedPrice = await normalizePriceValue(this.contractWrapper.getProvider(), pricePerToken, listing.currencyContractAddress);\n    if (normalizedPrice.eq(ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(0))) {\n      throw new Error(\"Cannot make a bid with 0 value\");\n    }\n    const bidBuffer = await this.contractWrapper.readContract.bidBufferBps();\n    const winningBid = await this.getWinningBid(listingId);\n    if (winningBid) {\n      const isWinnner = isWinningBid(winningBid.pricePerToken, normalizedPrice, bidBuffer);\n      (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(isWinnner, \"Bid price is too low based on the current winning bid and the bid buffer\");\n    } else {\n      const tokenPrice = normalizedPrice;\n      const reservePrice = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listing.reservePrice);\n      (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(tokenPrice.gte(reservePrice), \"Bid price is too low based on reserve price\");\n    }\n    const quantity = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listing.quantity);\n    const value = normalizedPrice.mul(quantity);\n    const overrides = (await this.contractWrapper.getCallOverrides()) || {};\n    await setErc20Allowance(this.contractWrapper, value, listing.currencyContractAddress, overrides);\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"offer\", [listingId, listing.quantity, listing.currencyContractAddress, normalizedPrice, ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.constants.MaxUint256], overrides)\n    };\n  }\n\n  /**\n   * Cancel Auction Listing\n   *\n   * @remarks Cancel an auction listing on the marketplace\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the auction listing you want to cancel\n   * const listingId = \"0\";\n   *\n   * await contract.auction.cancelListing(listingId);\n   * ```\n   */\n  async cancelListing(listingId) {\n    const listing = await this.validateListing(ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listingId));\n    const now = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(Math.floor(Date.now() / 1000));\n    const startTime = ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listing.startTimeInEpochSeconds);\n    const offers = await this.contractWrapper.readContract.winningBid(listingId);\n    if (now.gt(startTime) && offers.offeror !== ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero) {\n      throw new AuctionAlreadyStartedError(listingId.toString());\n    }\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"closeAuction\", [ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listingId), await this.contractWrapper.getSignerAddress()])\n    };\n  }\n\n  /**\n   * Close the Auction for the buyer or the seller\n   *\n   * @remarks Closes the Auction and executes the sale for the buyer or the seller.\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the auction listing you want to close\n   * const listingId = \"0\";\n   * await contract.auction.closeListing(listingId);\n   * ```\n   *\n   * @param listingId - the auction  listing ud to close\n   * @param closeFor - optionally pass the auction creator address or winning bid offeror address to close the auction on their behalf\n   */\n  async closeListing(listingId, closeFor) {\n    if (!closeFor) {\n      closeFor = await this.contractWrapper.getSignerAddress();\n    }\n    const listing = await this.validateListing(ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listingId));\n    try {\n      return {\n        receipt: await this.contractWrapper.sendTransaction(\"closeAuction\", [ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listingId), closeFor])\n      };\n    } catch (err) {\n      if (err.message.includes(\"cannot close auction before it has ended\")) {\n        throw new AuctionHasNotEndedError(listingId.toString(), listing.endTimeInEpochSeconds.toString());\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Execute the Auction Sale\n   *\n   * @remarks Closes the Auction and executes the sale for both parties.\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the auction listing you want to close\n   * const listingId = \"0\";\n   * await contract.auction.executeSale(listingId);\n   * ```\n   *\n   * @param listingId - the auction  listing ud to close\n   */\n  async executeSale(listingId) {\n    const listing = await this.validateListing(ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listingId));\n    try {\n      const winningBid = await this.getWinningBid(listingId);\n      (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(winningBid, \"No winning bid found\");\n      const closeForSeller = this.encoder.encode(\"closeAuction\", [listingId, listing.sellerAddress]);\n      const closeForBuyer = this.encoder.encode(\"closeAuction\", [listingId, winningBid.buyerAddress]);\n      return await this.contractWrapper.multiCall([closeForSeller, closeForBuyer]);\n    } catch (err) {\n      if (err.message.includes(\"cannot close auction before it has ended\")) {\n        throw new AuctionHasNotEndedError(listingId.toString(), listing.endTimeInEpochSeconds.toString());\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Update an Auction listing with new metadata\n   * @param listing - the listing id to update\n   */\n  async updateListing(listing) {\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"updateListing\", [listing.id, listing.quantity, listing.reservePrice, listing.buyoutPrice, listing.currencyContractAddress, listing.startTimeInEpochSeconds, listing.endTimeInEpochSeconds])\n    };\n  }\n\n  /**\n   * Get the buffer in basis points between offers\n   */\n  async getBidBufferBps() {\n    return this.contractWrapper.readContract.bidBufferBps();\n  }\n\n  /**\n   * returns the minimum bid a user can place to outbid the previous highest bid\n   * @param listingId - the listing id of the auction\n   */\n  async getMinimumNextBid(listingId) {\n    // we can fetch all of these at the same time using promise.all\n    const [currentBidBufferBps, winningBid, listing] = await Promise.all([this.getBidBufferBps(), this.getWinningBid(listingId), await this.validateListing(ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listingId))]);\n    const currentBidOrReservePrice = winningBid ?\n    // if there is a winning bid use the value of it\n    winningBid.currencyValue.value :\n    // if there is no winning bid use the reserve price\n    listing.reservePrice;\n    const minimumNextBid = currentBidOrReservePrice.add(\n    // the addition of the current bid and the buffer\n    // (have to divide by 10000 to get the fraction of the buffer (since it's in basis points))\n    currentBidOrReservePrice.mul(currentBidBufferBps).div(10000));\n\n    // it's more useful to return a currency value here\n    return fetchCurrencyValue(this.contractWrapper.getProvider(), listing.currencyContractAddress, minimumNextBid);\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Throws error if listing could not be found\n   *\n   * @param listingId - Listing to check for\n   */\n  async validateListing(listingId) {\n    try {\n      return await this.getListing(listingId);\n    } catch (err) {\n      console.error(`Error getting the listing with id ${listingId}`);\n      throw err;\n    }\n  }\n\n  /**\n   * Helper method maps the auction listing to the auction listing interface.\n   *\n   * @internal\n   * @param listing - The listing to map, as returned from the contract.\n   * @returns - The mapped interface.\n   */\n  async mapListing(listing) {\n    return {\n      assetContractAddress: listing.assetContract,\n      buyoutPrice: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listing.buyoutPricePerToken),\n      currencyContractAddress: listing.currency,\n      buyoutCurrencyValuePerToken: await fetchCurrencyValue(this.contractWrapper.getProvider(), listing.currency, listing.buyoutPricePerToken),\n      id: listing.listingId.toString(),\n      tokenId: listing.tokenId,\n      quantity: listing.quantity,\n      startTimeInEpochSeconds: listing.startTime,\n      asset: await fetchTokenMetadataForContract(listing.assetContract, this.contractWrapper.getProvider(), listing.tokenId, this.storage),\n      reservePriceCurrencyValuePerToken: await fetchCurrencyValue(this.contractWrapper.getProvider(), listing.currency, listing.reservePricePerToken),\n      reservePrice: ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(listing.reservePricePerToken),\n      endTimeInEpochSeconds: listing.endTime,\n      sellerAddress: listing.tokenOwner,\n      type: ListingType.Auction\n    };\n  }\n}\n\nconst DropErc20ContractInput = CommonContractSchema.merge(MerkleSchema).merge(CommonSymbolSchema);\nconst DropErc20ContractOutput = CommonContractOutputSchema.merge(MerkleSchema).merge(CommonSymbolSchema);\nconst DropErc20ContractDeploy = DropErc20ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);\nconst DropErc20ContractSchema = {\n  deploy: DropErc20ContractDeploy,\n  output: DropErc20ContractOutput,\n  input: DropErc20ContractInput\n};\n\nconst MultiwrapContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst MultiwrapContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst MultiwrapContractDeploy = MultiwrapContractInput.merge(CommonTrustedForwarderSchema);\nconst MultiwrapContractSchema = {\n  deploy: MultiwrapContractDeploy,\n  output: MultiwrapContractOutput,\n  input: MultiwrapContractInput\n};\n\nconst EditionDropInitializer = {\n  name: \"DropERC1155\",\n  contractType: \"edition-drop\",\n  schema: DropErc1155ContractSchema,\n  roles: [\"admin\", \"minter\", \"transfer\"],\n  initialize: async function () {\n    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {\n      _ref[_key] = arguments[_key];\n    }\n    let [network, address, storage, options] = _ref;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([await EditionDropInitializer.getAbi(address, provider), __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_sdk_dist_edition-drop-fd14fe0e_esm_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./edition-drop-fd14fe0e.esm.js */ \"./node_modules/@thirdweb-dev/sdk/dist/edition-drop-fd14fe0e.esm.js\")), provider.getNetwork()]);\n    return new contract.EditionDrop(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider) => {\n    const contractInfo = await assertContractType(address, provider, \"edition-drop\");\n    return contractInfo.version > 2 ? (await __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_contracts-js_dist_abis_DropERC1155_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! @thirdweb-dev/contracts-js/dist/abis/DropERC1155.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/DropERC1155.json\", 19))).default : (await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @thirdweb-dev/contracts-js/dist/abis/DropERC1155_V2.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/DropERC1155_V2.json\", 19))).default;\n  }\n};\nconst EditionInitializer = {\n  name: \"TokenERC1155\",\n  contractType: \"edition\",\n  schema: TokenErc1155ContractSchema,\n  roles: [\"admin\", \"minter\", \"transfer\"],\n  initialize: async function () {\n    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      _ref2[_key2] = arguments[_key2];\n    }\n    let [network, address, storage, options] = _ref2;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([EditionInitializer.getAbi(address, provider), __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_sdk_dist_edition-f3f43cee_esm_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./edition-f3f43cee.esm.js */ \"./node_modules/@thirdweb-dev/sdk/dist/edition-f3f43cee.esm.js\")), provider.getNetwork()]);\n    return new contract.Edition(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider) => {\n    await assertContractType(address, provider, \"edition\");\n    return (await __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_contracts-js_dist_abis_TokenERC1155_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! @thirdweb-dev/contracts-js/dist/abis/TokenERC1155.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/TokenERC1155.json\", 19))).default;\n  }\n};\nconst MarketplaceInitializer = {\n  name: \"Marketplace\",\n  contractType: \"marketplace\",\n  schema: MarketplaceContractSchema,\n  roles: [\"admin\", \"lister\", \"asset\"],\n  initialize: async function () {\n    for (var _len3 = arguments.length, _ref3 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      _ref3[_key3] = arguments[_key3];\n    }\n    let [network, address, storage, options] = _ref3;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([MarketplaceInitializer.getAbi(address, provider), __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_sdk_dist_marketplace-9bf7a027_esm_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./marketplace-9bf7a027.esm.js */ \"./node_modules/@thirdweb-dev/sdk/dist/marketplace-9bf7a027.esm.js\")), provider.getNetwork()]);\n    return new contract.Marketplace(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider) => {\n    await assertContractType(address, provider, \"marketplace\");\n    return (await __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_contracts-js_dist_abis_Marketplace_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! @thirdweb-dev/contracts-js/dist/abis/Marketplace.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/Marketplace.json\", 19))).default;\n  }\n};\nconst MultiwrapInitializer = {\n  name: \"Multiwrap\",\n  contractType: \"multiwrap\",\n  schema: MultiwrapContractSchema,\n  roles: [\"admin\", \"transfer\", \"minter\", \"unwrap\", \"asset\"],\n  initialize: async function () {\n    for (var _len4 = arguments.length, _ref4 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      _ref4[_key4] = arguments[_key4];\n    }\n    let [network, address, storage, options] = _ref4;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([MultiwrapInitializer.getAbi(address, provider), __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_sdk_dist_multiwrap-96ccfd6b_esm_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./multiwrap-96ccfd6b.esm.js */ \"./node_modules/@thirdweb-dev/sdk/dist/multiwrap-96ccfd6b.esm.js\")), provider.getNetwork()]);\n    return new contract.Multiwrap(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider) => {\n    await assertContractType(address, provider, \"multiwrap\");\n    return (await __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_contracts-js_dist_abis_Multiwrap_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! @thirdweb-dev/contracts-js/dist/abis/Multiwrap.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/Multiwrap.json\", 19))).default;\n  }\n};\nconst NFTCollectionInitializer = {\n  name: \"TokenERC721\",\n  contractType: \"nft-collection\",\n  schema: TokenErc721ContractSchema,\n  roles: [\"admin\", \"minter\", \"transfer\"],\n  initialize: async function () {\n    for (var _len5 = arguments.length, _ref5 = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      _ref5[_key5] = arguments[_key5];\n    }\n    let [network, address, storage, options] = _ref5;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([NFTCollectionInitializer.getAbi(address, provider), __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_sdk_dist_nft-collection-ad7bccd7_esm_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./nft-collection-ad7bccd7.esm.js */ \"./node_modules/@thirdweb-dev/sdk/dist/nft-collection-ad7bccd7.esm.js\")), provider.getNetwork()]);\n    return new contract.NFTCollection(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider) => {\n    await assertContractType(address, provider, \"nft-collection\");\n    return (await __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_contracts-js_dist_abis_TokenERC721_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! @thirdweb-dev/contracts-js/dist/abis/TokenERC721.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/TokenERC721.json\", 19))).default;\n  }\n};\nconst NFTDropInitializer = {\n  name: \"DropERC721\",\n  contractType: \"nft-drop\",\n  schema: DropErc721ContractSchema,\n  roles: [\"admin\", \"minter\", \"transfer\"],\n  initialize: async function () {\n    for (var _len6 = arguments.length, _ref6 = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      _ref6[_key6] = arguments[_key6];\n    }\n    let [network, address, storage, options] = _ref6;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([NFTDropInitializer.getAbi(address, provider), __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_sdk_dist_nft-drop-37f6ba3a_esm_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./nft-drop-37f6ba3a.esm.js */ \"./node_modules/@thirdweb-dev/sdk/dist/nft-drop-37f6ba3a.esm.js\")), provider.getNetwork()]);\n    return new contract.NFTDrop(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider) => {\n    const contractInfo = await assertContractType(address, provider, \"nft-drop\");\n    return contractInfo.version > 3 ? (await __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_contracts-js_dist_abis_DropERC721_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! @thirdweb-dev/contracts-js/dist/abis/DropERC721.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/DropERC721.json\", 19))).default : (await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @thirdweb-dev/contracts-js/dist/abis/DropERC721_V3.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/DropERC721_V3.json\", 19))).default;\n  }\n};\nconst PackInitializer = {\n  name: \"Pack\",\n  contractType: \"pack\",\n  schema: PackContractSchema,\n  roles: [\"admin\", \"minter\", \"asset\", \"transfer\"],\n  initialize: async function () {\n    for (var _len7 = arguments.length, _ref7 = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      _ref7[_key7] = arguments[_key7];\n    }\n    let [network, address, storage, options] = _ref7;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([PackInitializer.getAbi(address, provider), __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_sdk_dist_pack-4c187c50_esm_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./pack-4c187c50.esm.js */ \"./node_modules/@thirdweb-dev/sdk/dist/pack-4c187c50.esm.js\")), provider.getNetwork()]);\n    return new contract.Pack(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider) => {\n    await assertContractType(address, provider, \"pack\");\n    return (await __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_contracts-js_dist_abis_Pack_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! @thirdweb-dev/contracts-js/dist/abis/Pack.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/Pack.json\", 19))).default;\n  }\n};\nconst SignatureDropInitializer = {\n  name: \"SignatureDrop\",\n  contractType: \"signature-drop\",\n  schema: DropErc721ContractSchema,\n  roles: [\"admin\", \"minter\", \"transfer\"],\n  initialize: async function () {\n    for (var _len8 = arguments.length, _ref8 = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      _ref8[_key8] = arguments[_key8];\n    }\n    let [network, address, storage, options] = _ref8;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([SignatureDropInitializer.getAbi(address, provider), __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_sdk_dist_signature-drop-3ecdd0f0_esm_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./signature-drop-3ecdd0f0.esm.js */ \"./node_modules/@thirdweb-dev/sdk/dist/signature-drop-3ecdd0f0.esm.js\")), provider.getNetwork()]);\n    return new contract.SignatureDrop(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider) => {\n    const contractInfo = await assertContractType(address, provider, \"signature-drop\");\n    return contractInfo.version > 4 ? (await __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_contracts-js_dist_abis_SignatureDrop_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! @thirdweb-dev/contracts-js/dist/abis/SignatureDrop.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/SignatureDrop.json\", 19))).default : (await __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_contracts-js_dist_abis_SignatureDrop_V4_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! @thirdweb-dev/contracts-js/dist/abis/SignatureDrop_V4.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/SignatureDrop_V4.json\", 19))).default;\n  }\n};\nconst SplitInitializer = {\n  name: \"Split\",\n  contractType: \"split\",\n  schema: SplitsContractSchema,\n  roles: [\"admin\"],\n  initialize: async function () {\n    for (var _len9 = arguments.length, _ref9 = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      _ref9[_key9] = arguments[_key9];\n    }\n    let [network, address, storage, options] = _ref9;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([SplitInitializer.getAbi(address, provider), __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_sdk_dist_split-c46f1f5d_esm_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./split-c46f1f5d.esm.js */ \"./node_modules/@thirdweb-dev/sdk/dist/split-c46f1f5d.esm.js\")), provider.getNetwork()]);\n    return new contract.Split(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider) => {\n    await assertContractType(address, provider, \"split\");\n    return (await __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_contracts-js_dist_abis_Split_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! @thirdweb-dev/contracts-js/dist/abis/Split.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/Split.json\", 19))).default;\n  }\n};\nconst TokenDropInitializer = {\n  name: \"DropERC20\",\n  contractType: \"token-drop\",\n  schema: DropErc20ContractSchema,\n  roles: [\"admin\", \"transfer\"],\n  initialize: async function () {\n    for (var _len10 = arguments.length, _ref10 = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      _ref10[_key10] = arguments[_key10];\n    }\n    let [network, address, storage, options] = _ref10;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([TokenDropInitializer.getAbi(address, provider), __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_sdk_dist_token-drop-fb1bdf9c_esm_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./token-drop-fb1bdf9c.esm.js */ \"./node_modules/@thirdweb-dev/sdk/dist/token-drop-fb1bdf9c.esm.js\")), provider.getNetwork()]);\n    return new contract.TokenDrop(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider) => {\n    const contractInfo = await assertContractType(address, provider, \"token-drop\");\n    return contractInfo.version > 2 ? (await __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_contracts-js_dist_abis_DropERC20_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! @thirdweb-dev/contracts-js/dist/abis/DropERC20.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/DropERC20.json\", 19))).default : (await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @thirdweb-dev/contracts-js/dist/abis/DropERC20_V2.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/DropERC20_V2.json\", 19))).default;\n  }\n};\nconst TokenInitializer = {\n  name: \"TokenERC20\",\n  contractType: \"token\",\n  schema: TokenErc20ContractSchema,\n  roles: [\"admin\", \"minter\", \"transfer\"],\n  initialize: async function () {\n    for (var _len11 = arguments.length, _ref11 = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n      _ref11[_key11] = arguments[_key11];\n    }\n    let [network, address, storage, options] = _ref11;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([TokenInitializer.getAbi(address, provider), __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_sdk_dist_token-8c18bb71_esm_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./token-8c18bb71.esm.js */ \"./node_modules/@thirdweb-dev/sdk/dist/token-8c18bb71.esm.js\")), provider.getNetwork()]);\n    return new contract.Token(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider) => {\n    await assertContractType(address, provider, \"token\");\n    return (await __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_contracts-js_dist_abis_TokenERC20_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! @thirdweb-dev/contracts-js/dist/abis/TokenERC20.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/TokenERC20.json\", 19))).default;\n  }\n};\nconst VoteInitializer = {\n  name: \"VoteERC20\",\n  contractType: \"vote\",\n  schema: VoteContractSchema,\n  roles: [],\n  initialize: async function () {\n    for (var _len12 = arguments.length, _ref12 = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n      _ref12[_key12] = arguments[_key12];\n    }\n    let [network, address, storage, options] = _ref12;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([VoteInitializer.getAbi(address, provider), __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_sdk_dist_vote-f869962a_esm_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./vote-f869962a.esm.js */ \"./node_modules/@thirdweb-dev/sdk/dist/vote-f869962a.esm.js\")), provider.getNetwork()]);\n    return new contract.Vote(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider) => {\n    await assertContractType(address, provider, \"vote\");\n    return (await __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_contracts-js_dist_abis_VoteERC20_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! @thirdweb-dev/contracts-js/dist/abis/VoteERC20.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/VoteERC20.json\", 19))).default;\n  }\n};\nasync function assertContractType(address, provider, type) {\n  const contractInfo = await getPrebuiltInfo(address, provider);\n  if (!contractInfo || contractInfo.type !== getContractName(type)) {\n    throw new Error(`Contract is not a ${type}`);\n  }\n  return contractInfo;\n}\n\n/**\n * a map from contractType -> contract metadata\n * @internal\n */\nconst PREBUILT_CONTRACTS_MAP = {\n  [EditionDropInitializer.contractType]: EditionDropInitializer,\n  [EditionInitializer.contractType]: EditionInitializer,\n  [MarketplaceInitializer.contractType]: MarketplaceInitializer,\n  [MultiwrapInitializer.contractType]: MultiwrapInitializer,\n  [NFTCollectionInitializer.contractType]: NFTCollectionInitializer,\n  [NFTDropInitializer.contractType]: NFTDropInitializer,\n  [PackInitializer.contractType]: PackInitializer,\n  [SignatureDropInitializer.contractType]: SignatureDropInitializer,\n  [SplitInitializer.contractType]: SplitInitializer,\n  [TokenDropInitializer.contractType]: TokenDropInitializer,\n  [TokenInitializer.contractType]: TokenInitializer,\n  [VoteInitializer.contractType]: VoteInitializer\n};\nconst SmartContract$1 = {\n  name: \"SmartContract\",\n  contractType: \"custom\",\n  schema: CustomContractSchema,\n  roles: ALL_ROLES\n};\nconst CONTRACTS_MAP = {\n  ...PREBUILT_CONTRACTS_MAP,\n  [SmartContract$1.contractType]: SmartContract$1\n};\n\n/**\n * @internal\n */\nfunction getContractTypeForRemoteName(name) {\n  return Object.values(CONTRACTS_MAP).find(contract => contract.name === name)?.contractType || \"custom\";\n}\nfunction getContractName(type) {\n  return Object.values(CONTRACTS_MAP).find(contract => contract.contractType === type)?.name;\n}\n\n/**\n * Have an official Application URI for this contract.\n * @remarks Configure an official Application URI for this contract.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const appURI = await contract.appuri.get();\n * appURI = \"ipfs://some_ipfs_hash\";\n *\n * await contract.appuri.set(appURI)\n * ```\n * @public\n */\nclass ContractAppURI {\n  constructor(contractWrapper, metadata) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_APPURI.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"metadata\", void 0);\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n  }\n\n  /**\n   * Get the appURI for the contract\n   * @returns the appURI object\n   */\n  async get() {\n    if (detectContractFeature(this.contractWrapper, \"AppURI\")) {\n      return await this.contractWrapper.readContract.appURI();\n    }\n    return (await this.metadata.get()).appURI || \"\";\n  }\n\n  /**\n   * Set the appURI for the contract\n   * @param appURI - the uri to set (typically an IPFS hash)\n   */\n  async set(appURI) {\n    if (detectContractFeature(this.contractWrapper, \"AppURI\")) {\n      return {\n        receipt: await this.contractWrapper.sendTransaction(\"setAppURI\", [appURI])\n      };\n    }\n    return await this.metadata.update({\n      appURI\n    });\n  }\n}\n\n/**\n * Listen to Contract events in real time\n * @public\n */\nclass ContractEvents {\n  constructor(contractWrapper) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Subscribe to transactions in this contract.\n   * @remarks Will emit an \"event\" object containing the transaction status ('submitted' and 'completed') and hash\n   * @example\n   * ```javascript\n   * contract.events.addTransactionListener((event) => {\n   *   console.log(event);\n   * }\n   * ```\n   * @param listener - the callback function that will be called on every transaction\n   * @public\n   */\n  addTransactionListener(listener) {\n    this.contractWrapper.addListener(EventType.Transaction, listener);\n  }\n\n  /**\n   * Remove a transaction listener\n   * @remarks Remove a listener that was added with addTransactionListener\n   * @example\n   * ```javascript\n   * contract.events.removeTransactionListener((event) => {\n   *  console.log(event);\n   * }\n   * ```\n   * @param listener - the callback function to remove\n   * @public\n   */\n  removeTransactionListener(listener) {\n    this.contractWrapper.off(EventType.Transaction, listener);\n  }\n\n  /**\n   * Subscribe to contract events\n   * @remarks You can add a listener for any contract event to run a function when\n   * the event is emitted. For example, if you wanted to listen for a \"TokensMinted\" event,\n   * you could do the following:\n   * @example\n   * ```javascript\n   * contract.events.addEventListener(\"TokensMinted\", (event) => {\n   *   console.log(event);\n   * });\n   * ```\n   * @public\n   * @param eventName - the event name as defined in the contract\n   * @param listener - the callback function that will be called on every new event\n   * @returns a function to un-subscribe from the event\n   */\n  addEventListener(eventName, listener) {\n    // validates event, throws error if not found\n    const event = this.contractWrapper.readContract.interface.getEvent(eventName);\n    const address = this.contractWrapper.readContract.address;\n    const filter = {\n      address,\n      topics: [this.contractWrapper.readContract.interface.getEventTopic(event)]\n    };\n    const wrappedListener = log => {\n      const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);\n      listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));\n    };\n    this.contractWrapper.getProvider().on(filter, wrappedListener);\n    return () => {\n      this.contractWrapper.getProvider().off(filter, wrappedListener);\n    };\n  }\n\n  /**\n   * Listen to all events emitted from this contract\n   *\n   * @example\n   * ```javascript\n   * contract.events.listenToAllEvents((event) => {\n   *   console.log(event.eventName) // the name of the emitted event\n   *   console.log(event.data) // event payload\n   * }\n   * ```\n   * @public\n   * @param listener - the callback function that will be called on every new event\n   * @returns A function that can be called to stop listening to events\n   */\n  listenToAllEvents(listener) {\n    const address = this.contractWrapper.readContract.address;\n    const filter = {\n      address\n    };\n    const wrappedListener = log => {\n      try {\n        const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);\n        listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));\n      } catch (e) {\n        console.error(\"Could not parse event:\", log, e);\n      }\n    };\n    this.contractWrapper.getProvider().on(filter, wrappedListener);\n    return () => {\n      this.contractWrapper.getProvider().off(filter, wrappedListener);\n    };\n  }\n\n  /**\n   * Remove an event listener from this contract\n   * @remarks Remove a listener that was added with addEventListener\n   * @example\n   * ```javascript\n   * contract.events.removeEventListener(\"TokensMinted\", (event) => {\n   *   console.log(event);\n   * });\n   * ```\n   * @public\n   * @param eventName - the event name as defined in the contract\n   * @param listener - the listener to unregister\n   */\n  removeEventListener(eventName, listener) {\n    // validates event, throws error if not found\n    const event = this.contractWrapper.readContract.interface.getEvent(eventName);\n    this.contractWrapper.readContract.off(event.name, listener);\n  }\n\n  /**\n   * Remove all listeners on this contract\n   * @remarks Remove all listeners from a contract\n   * @example\n   * ```javascript\n   * contract.events.removeAllListeners();\n   * ```\n   * @public\n   */\n  removeAllListeners() {\n    this.contractWrapper.readContract.removeAllListeners();\n    const address = this.contractWrapper.readContract.address;\n    const filter = {\n      address\n    };\n    this.contractWrapper.getProvider().removeAllListeners(filter);\n  }\n\n  /**\n   * Get All Events\n   * @remarks Get a list of all the events emitted from this contract during the specified time period\n   * @example\n   * ```javascript\n   * // Optionally pass in filters to limit the blocks from which events are retrieved\n   * const filters = {\n   *   fromBlock: 0,\n   *   toBlock: 1000000,\n   * }\n   * const events = await contract.events.getAllEvents(filters);\n   * console.log(events[0].eventName);\n   * console.log(events[0].data);\n   * ```\n   *\n   * @param filters - Specify the from and to block numbers to get events for, defaults to all blocks\n   * @returns The event objects of the events emitted with event names and data for each event\n   */\n  async getAllEvents() {\n    let filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      fromBlock: 0,\n      toBlock: \"latest\",\n      order: \"desc\"\n    };\n    const events = await this.contractWrapper.readContract.queryFilter({}, filters.fromBlock, filters.toBlock);\n    const orderedEvents = events.sort((a, b) => {\n      return filters.order === \"desc\" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;\n    });\n    return this.parseEvents(orderedEvents);\n  }\n\n  /**\n   * Get Events\n   * @remarks Get a list of the events of a specific type emitted from this contract during the specified time period\n   * @example\n   * ```javascript\n   * // The name of the event to get logs for\n   * const eventName = \"Transfer\";\n   *\n   * // Optionally pass in options to limit the blocks from which events are retrieved\n   * const options = {\n   *   fromBlock: 0,\n   *   toBlock: 1000000, // can also pass \"latest\"\n   *   order: \"desc\",\n   *   // Configure event filters (filter on indexed event parameters)\n   *   filters: {\n   *     from: \"0x...\",\n   *     to: \"0x...\"\n   *   }\n   * };\n   *\n   * const events = await contract.events.getEvents(eventName, options);\n   * console.log(events[0].eventName);\n   * console.log(events[0].data);\n   * ```\n   *\n   * @param eventName - The name of the event to get logs for\n   * @param options - Specify the from and to block numbers to get events for, defaults to all blocks. @see EventQueryOptions\n   * @returns The requested event objects with event data\n   */\n  async getEvents(eventName) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      fromBlock: 0,\n      toBlock: \"latest\",\n      order: \"desc\"\n    };\n    const event = this.contractWrapper.readContract.interface.getEvent(eventName);\n    const eventInterface = this.contractWrapper.readContract.interface.getEvent(eventName);\n    const args = options.filters ? eventInterface.inputs.map(e => options.filters[e.name]) : [];\n    const filter = this.contractWrapper.readContract.filters[event.name](...args);\n    const events = await this.contractWrapper.readContract.queryFilter(filter, options.fromBlock, options.toBlock);\n    const orderedEvents = events.sort((a, b) => {\n      return options.order === \"desc\" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;\n    });\n    return this.parseEvents(orderedEvents);\n  }\n  parseEvents(events) {\n    return events.map(e => {\n      const transaction = Object.fromEntries(Object.entries(e).filter(a => typeof a[1] !== \"function\" && a[0] !== \"args\"));\n      if (e.args) {\n        const entries = Object.entries(e.args);\n        const args = entries.slice(entries.length / 2, entries.length);\n        const data = {};\n        for (const [key, value] of args) {\n          data[key] = value;\n        }\n        return {\n          eventName: e.event || \"\",\n          data: data,\n          transaction\n        };\n      }\n      return {\n        eventName: e.event || \"\",\n        data: {},\n        transaction\n      };\n    });\n  }\n  toContractEvent(event, args, rawLog) {\n    const transaction = Object.fromEntries(Object.entries(rawLog).filter(a => typeof a[1] !== \"function\" && a[0] !== \"args\"));\n    const results = {};\n    event.inputs.forEach((param, index) => {\n      if (Array.isArray(args[index])) {\n        const obj = {};\n        const components = param.components;\n        if (components) {\n          const arr = args[index];\n          for (let i = 0; i < components.length; i++) {\n            const name = components[i].name;\n            obj[name] = arr[i];\n          }\n          results[param.name] = obj;\n        }\n      } else {\n        results[param.name] = args[index];\n      }\n    });\n    return {\n      eventName: event.name,\n      data: results,\n      transaction\n    };\n  }\n}\n\n/**\n * Allows overriding transaction behavior for this contract\n * @public\n */\nclass ContractInterceptor {\n  constructor(contractWrapper) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * The next transaction executed will add/replace any overrides passed via the passed in hook.\n   * @remarks Overridden values will be applied to the next transaction executed.\n   * @example\n   * ```javascript\n   * contract.interceptor.overrideNextTransaction(() => ({\n   *   gasLimit: 3000000,\n   * }));\n   * ```\n   * @param hook - the hook to add or replace any CallOverrides (gas limit, gas price, nonce, from, value, etc...)\n   * @public\n   */\n  overrideNextTransaction(hook) {\n    this.contractWrapper.withTransactionOverride(hook);\n  }\n}\n\n/**\n * Handle platform fees and recipients\n * @remarks Configure platform fees for a contract, which can be applied on certain paid transactions\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const feeInfo = await contract.platformFee.get();\n * await contract.platformFee.set({\n *   platform_fee_basis_points: 100, // 1% fee\n *   platform_fee_recipient: \"0x...\" // the fee recipient\n * })\n * ```\n * @public\n */\nclass ContractPlatformFee {\n  constructor(contractWrapper) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_PLATFORM_FEE.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get the platform fee recipient and basis points\n   *  * @example\n   * ```javascript\n   * const feeInfo = await contract.platformFee.get();\n   * ```\n   * @twfeature PlatformFee\n   */\n  async get() {\n    const [platformFeeRecipient, platformFeeBps] = await this.contractWrapper.readContract.getPlatformFeeInfo();\n    return CommonPlatformFeeSchema.parse({\n      platform_fee_recipient: platformFeeRecipient,\n      platform_fee_basis_points: platformFeeBps\n    });\n  }\n\n  /**\n   * Set the platform fee recipient and basis points\n   * @param platformFeeInfo - the platform fee information\n   * ```javascript\n   * await contract.platformFee.set({\n   *   platform_fee_basis_points: 100, // 1% fee\n   *   platform_fee_recipient: \"0x...\" // the fee recipient\n   * })\n   * ```\n   * @twfeature PlatformFee\n   */\n  async set(platformFeeInfo) {\n    const parsed = CommonPlatformFeeSchema.parse(platformFeeInfo);\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"setPlatformFeeInfo\", [parsed.platform_fee_recipient, parsed.platform_fee_basis_points])\n    };\n  }\n}\n\n/**\n * Handles publish metadata for a contract\n * @internal\n */\nclass ContractPublishedMetadata {\n  constructor(contractWrapper, storage) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"_cachedMetadata\", void 0);\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Get the published metadata for this contract\n   * @public\n   */\n  async get() {\n    if (this._cachedMetadata) {\n      return this._cachedMetadata;\n    }\n    this._cachedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.readContract.address, this.contractWrapper.getProvider(), this.storage);\n    return this._cachedMetadata;\n  }\n\n  /**\n   * @public\n   */\n  async extractFunctions() {\n    let publishedMetadata;\n    try {\n      publishedMetadata = await this.get();\n    } catch (e) {\n      // ignore for built-in contracts\n    }\n    // to construct a contract we already **have** to have the abi on the contract wrapper, so there is no reason to look fetch it again (means this function can become synchronous as well!)\n    return extractFunctionsFromAbi(AbiSchema.parse(this.contractWrapper.abi), publishedMetadata?.metadata);\n  }\n\n  /**\n   * @public\n   */\n  async extractEvents() {\n    let publishedMetadata;\n    try {\n      publishedMetadata = await this.get();\n    } catch (e) {\n      // ignore for built-in contracts\n    }\n    // to construct a contract we already **have** to have the abi on the contract wrapper, so there is no reason to look fetch it again (means this function can become synchronous as well!)\n    return extractEventsFromAbi(AbiSchema.parse(this.contractWrapper.abi), publishedMetadata?.metadata);\n  }\n}\n\n/**\n * Custom contract dynamic class with feature detection\n *\n * @example\n *\n * ```javascript\n * import { ThirdwebSDK } from \"@thirdweb-dev/sdk\";\n *\n * const sdk = new ThirdwebSDK(provider);\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n *\n * // call any function in your contract\n * await contract.call(\"myCustomFunction\", param1, param2);\n *\n * // if your contract follows the ERC721 standard, contract.nft will be present\n * const allNFTs = await contract.erc721.query.all()\n *\n * // if your contract extends IMintableERC721, contract.nft.mint() will be available\n * const tx = await contract.erc721.mint({\n *     name: \"Cool NFT\",\n *     image: readFileSync(\"some_image.png\"),\n *   });\n * ```\n *\n * @beta\n */\nclass SmartContract {\n  // utilities\n\n  /**\n   * Handle royalties\n   */\n  get royalties() {\n    return assertEnabled(this.detectRoyalties(), FEATURE_ROYALTY);\n  }\n\n  /**\n   * Handle permissions\n   */\n  get roles() {\n    return assertEnabled(this.detectRoles(), FEATURE_PERMISSIONS);\n  }\n\n  /**\n   * Handle primary sales\n   */\n  get sales() {\n    return assertEnabled(this.detectPrimarySales(), FEATURE_PRIMARY_SALE);\n  }\n\n  /**\n   * Handle platform fees\n   */\n  get platformFees() {\n    return assertEnabled(this.detectPlatformFees(), FEATURE_PLATFORM_FEE);\n  }\n\n  /**\n   * Set and get the owner of the contract\n   */\n  get owner() {\n    return assertEnabled(this.detectOwnable(), FEATURE_OWNER);\n  }\n\n  /**\n   * Auto-detects ERC20 standard functions.\n   */\n  get erc20() {\n    return assertEnabled(this.detectErc20(), FEATURE_TOKEN);\n  }\n\n  /**\n   * Auto-detects ERC721 standard functions.\n   */\n  get erc721() {\n    return assertEnabled(this.detectErc721(), FEATURE_NFT);\n  }\n\n  /**\n   * Auto-detects ERC1155 standard functions.\n   */\n  get erc1155() {\n    return assertEnabled(this.detectErc1155(), FEATURE_EDITION);\n  }\n  get chainId() {\n    return this._chainId;\n  }\n  constructor(network, address, abi, storage) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    let chainId = arguments.length > 5 ? arguments[5] : undefined;\n    let contractWrapper = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new ContractWrapper(network, address, abi, options);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"events\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"interceptor\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"encoder\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"estimator\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"publishedMetadata\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"abi\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"metadata\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"appURI\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"_chainId\", void 0);\n    this._chainId = chainId;\n    this.storage = storage;\n    this.contractWrapper = contractWrapper;\n    this.abi = abi;\n    this.events = new ContractEvents(this.contractWrapper);\n    this.encoder = new ContractEncoder(this.contractWrapper);\n    this.interceptor = new ContractInterceptor(this.contractWrapper);\n    this.estimator = new GasCostEstimator(this.contractWrapper);\n    this.publishedMetadata = new ContractPublishedMetadata(this.contractWrapper, this.storage);\n    this.metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);\n    this.appURI = new ContractAppURI(this.contractWrapper, this.metadata);\n  }\n  onNetworkUpdated(network) {\n    this.contractWrapper.updateSignerOrProvider(network);\n  }\n  getAddress() {\n    return this.contractWrapper.readContract.address;\n  }\n\n  /**\n   * Call any function on this contract\n   * @example\n   * ```javascript\n   * // read functions will return the data from the contract\n   * const myValue = await contract.call(\"myReadFunction\");\n   * console.log(myValue);\n   *\n   * // write functions will return the transaction receipt\n   * const tx = await contract.call(\"myWriteFunction\", arg1, arg2);\n   * const receipt = tx.receipt;\n   *\n   * // Optionally override transaction options\n   * await contract.call(\"myWriteFunction\", arg1, arg2, {\n   *  gasLimit: 1000000, // override default gas limit\n   *  value: ethers.utils.parseEther(\"0.1\"), // send 0.1 ether with the contract call\n   * };\n   * ```\n   * @param functionName - the name of the function to call\n   * @param args - the arguments of the function\n   */\n  async call(functionName) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    return this.contractWrapper.call(functionName, ...args);\n  }\n\n  /** ********************\n   * FEATURE DETECTION\n   * ********************/\n\n  detectRoyalties() {\n    if (detectContractFeature(this.contractWrapper, \"Royalty\")) {\n      // ContractMetadata is stateless, it's fine to create a new one here\n      // This also makes it not order dependent in the feature detection process\n      const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);\n      return new ContractRoyalty(this.contractWrapper, metadata);\n    }\n    return undefined;\n  }\n  detectRoles() {\n    if (detectContractFeature(this.contractWrapper, \"Permissions\")) {\n      return new ContractRoles(this.contractWrapper, ALL_ROLES);\n    }\n    return undefined;\n  }\n  detectPrimarySales() {\n    if (detectContractFeature(this.contractWrapper, \"PrimarySale\")) {\n      return new ContractPrimarySale(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectPlatformFees() {\n    if (detectContractFeature(this.contractWrapper, \"PlatformFee\")) {\n      return new ContractPlatformFee(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc20() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20\")) {\n      return new Erc20(this.contractWrapper, this.storage, this.chainId);\n    }\n    return undefined;\n  }\n  detectErc721() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721\")) {\n      return new Erc721(this.contractWrapper, this.storage, this.chainId);\n    }\n    return undefined;\n  }\n  detectErc1155() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155\")) {\n      return new Erc1155(this.contractWrapper, this.storage, this.chainId);\n    }\n    return undefined;\n  }\n  detectOwnable() {\n    if (detectContractFeature(this.contractWrapper, \"Ownable\")) {\n      return new ContractOwner(this.contractWrapper);\n    }\n    return undefined;\n  }\n}\n\n/**\n * Handles publishing contracts (EXPERIMENTAL)\n * @internal\n */\nclass ContractPublisher extends RPCConnectionHandler {\n  constructor(network, options, storage) {\n    super(network, options);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"publisher\", void 0);\n    this.storage = storage;\n    this.publisher = new ContractWrapper(network, getContractPublisherAddress(), _thirdweb_dev_contracts_js_dist_abis_ContractPublisher_json__WEBPACK_IMPORTED_MODULE_46__, options);\n  }\n  updateSignerOrProvider(network) {\n    super.updateSignerOrProvider(network);\n    this.publisher.updateSignerOrProvider(network);\n  }\n\n  /**\n   * @internal\n   * @param metadataUri\n   */\n  async extractConstructorParams(metadataUri) {\n    return extractConstructorParams(metadataUri, this.storage);\n  }\n\n  /**\n   * @internal\n   * @param predeployMetadataUri\n   */\n  async extractFunctions(predeployMetadataUri) {\n    return extractFunctions(predeployMetadataUri, this.storage);\n  }\n\n  /**\n   * @internal\n   * @param predeployUri\n   */\n  async fetchCompilerMetadataFromPredeployURI(predeployUri) {\n    return fetchPreDeployMetadata(predeployUri, this.storage);\n  }\n\n  /**\n   * @internal\n   * @param prepublishUri\n   * @param publisherAddress\n   */\n  async fetchPrePublishMetadata(prepublishUri, publisherAddress) {\n    const preDeployMetadataFetched = await fetchPreDeployMetadata(prepublishUri, this.storage);\n    const latestPublishedContract = publisherAddress ? await this.getLatest(publisherAddress, preDeployMetadataFetched.name) : undefined;\n    const latestPublishedContractMetadata = latestPublishedContract ? await this.fetchPublishedContractInfo(latestPublishedContract) : undefined;\n    return {\n      preDeployMetadata: preDeployMetadataFetched,\n      latestPublishedContractMetadata\n    };\n  }\n\n  /**\n   * @internal\n   * @param address\n   */\n  async fetchCompilerMetadataFromAddress(address) {\n    return fetchContractMetadataFromAddress(address, this.getProvider(), this.storage);\n  }\n\n  /**\n   * @internal\n   * Get the full information about a published contract\n   * @param contract\n   */\n  async fetchPublishedContractInfo(contract) {\n    return {\n      name: contract.id,\n      publishedTimestamp: contract.timestamp,\n      publishedMetadata: await this.fetchFullPublishMetadata(contract.metadataUri)\n    };\n  }\n\n  /**\n   * @internal\n   * @param publishedMetadataUri\n   */\n  async fetchFullPublishMetadata(publishedMetadataUri) {\n    return fetchExtendedReleaseMetadata(publishedMetadataUri, this.storage);\n  }\n\n  /**\n   * @internal\n   * // TODO expose a resolvePublishMetadata(contractAddress, chainId) that handles the dual chain case\n   * // TODO will be easy to do with the multichain pattern of 3.0\n   * @param compilerMetadataUri\n   */\n  async resolvePublishMetadataFromCompilerMetadata(compilerMetadataUri) {\n    const publishedMetadataUri = await this.publisher.readContract.getPublishedUriFromCompilerUri(compilerMetadataUri);\n    if (publishedMetadataUri.length === 0) {\n      throw Error(`Could not resolve published metadata URI from ${compilerMetadataUri}`);\n    }\n    return await Promise.all(publishedMetadataUri.filter(uri => uri.length > 0).map(uri => this.fetchFullPublishMetadata(uri)));\n  }\n\n  /**\n   * @internal\n   * TODO clean this up (see method above, too)\n   */\n  async resolveContractUriFromAddress(address) {\n    const contractUri = await resolveContractUriFromAddress(address, this.getProvider());\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(contractUri, \"Could not resolve contract URI from address\");\n    return contractUri;\n  }\n\n  /**\n   * @internal\n   * @param address\n   */\n  async fetchContractSourcesFromAddress(address) {\n    const metadata = await this.fetchCompilerMetadataFromAddress(address);\n    return await fetchSourceFilesFromMetadata(metadata, this.storage);\n  }\n\n  /**\n   * @internal\n   * @param profileMetadata\n   */\n  async updatePublisherProfile(profileMetadata) {\n    const signer = this.getSigner();\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(signer, \"A signer is required\");\n    const publisher = await signer.getAddress();\n    const profileUri = await this.storage.upload(profileMetadata);\n    return {\n      receipt: await this.publisher.sendTransaction(\"setPublisherProfileUri\", [publisher, profileUri])\n    };\n  }\n\n  /**\n   * @internal\n   * @param publisherAddress\n   */\n  async getPublisherProfile(publisherAddress) {\n    const profileUri = await this.publisher.readContract.getPublisherProfileUri(publisherAddress);\n    if (!profileUri || profileUri.length === 0) {\n      return {};\n    }\n    return ProfileSchemaOutput.parse(await this.storage.downloadJSON(profileUri));\n  }\n\n  /**\n   * @internal\n   * @param publisherAddress\n   */\n  async getAll(publisherAddress) {\n    const data = await this.publisher.readContract.getAllPublishedContracts(publisherAddress);\n    // since we can fetch from multiple publisher contracts, just keep the latest one in the list\n    const map = data.reduce((acc, curr) => {\n      // replaces the previous contract with the latest one\n      acc[curr.contractId] = curr;\n      return acc;\n    }, {});\n    return Object.entries(map).map(_ref => {\n      let [, struct] = _ref;\n      return this.toPublishedContract(struct);\n    });\n  }\n\n  /**\n   * @internal\n   * @param publisherAddress\n   * @param contractId\n   */\n  async getAllVersions(publisherAddress, contractId) {\n    const contractStructs = await this.publisher.readContract.getPublishedContractVersions(publisherAddress, contractId);\n    if (contractStructs.length === 0) {\n      throw Error(\"Not found\");\n    }\n    return contractStructs.map(d => this.toPublishedContract(d));\n  }\n  async getVersion(publisherAddress, contractId) {\n    let version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"latest\";\n    if (version === \"latest\") {\n      return this.getLatest(publisherAddress, contractId);\n    }\n    const allVersions = await this.getAllVersions(publisherAddress, contractId);\n    // get the metadata for each version\n    const versionMetadata = await Promise.all(allVersions.map(contract => this.fetchPublishedContractInfo(contract)));\n    // find the version that matches the version string\n    const versionMatch = versionMetadata.find(metadata => metadata.publishedMetadata.version === version);\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(versionMatch, \"Contract version not found\");\n    // match the version back to the contract based on the release timestamp\n    return allVersions.find(contract => contract.timestamp === versionMatch.publishedTimestamp);\n  }\n  async getLatest(publisherAddress, contractId) {\n    const model = await this.publisher.readContract.getPublishedContract(publisherAddress, contractId);\n    if (model && model.publishMetadataUri) {\n      return this.toPublishedContract(model);\n    }\n    return undefined;\n  }\n  async publish(predeployUri, extraMetadata) {\n    const signer = this.getSigner();\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(signer, \"A signer is required\");\n    const publisher = await signer.getAddress();\n    const predeployMetadata = await fetchRawPredeployMetadata(predeployUri, this.storage);\n\n    // ensure version is incremental\n    const latestContract = await this.getLatest(publisher, predeployMetadata.name);\n    if (latestContract && latestContract.metadataUri) {\n      const latestMetadata = await this.fetchPublishedContractInfo(latestContract);\n      const latestVersion = latestMetadata.publishedMetadata.version;\n      if (!isIncrementalVersion(latestVersion, extraMetadata.version)) {\n        throw Error(`Version ${extraMetadata.version} is not greater than ${latestVersion}`);\n      }\n    }\n    const fetchedBytecode = await (await this.storage.download(predeployMetadata.bytecodeUri)).text();\n    const bytecode = fetchedBytecode.startsWith(\"0x\") ? fetchedBytecode : `0x${fetchedBytecode}`;\n    const bytecodeHash = ethers__WEBPACK_IMPORTED_MODULE_58__.utils.solidityKeccak256([\"bytes\"], [bytecode]);\n    const contractId = predeployMetadata.name;\n    const fullMetadata = FullPublishMetadataSchemaInput.parse({\n      ...extraMetadata,\n      metadataUri: predeployMetadata.metadataUri,\n      bytecodeUri: predeployMetadata.bytecodeUri,\n      name: predeployMetadata.name,\n      analytics: predeployMetadata.analytics,\n      publisher\n    });\n    const fullMetadataUri = await this.storage.upload(fullMetadata);\n    const receipt = await this.publisher.sendTransaction(\"publishContract\", [publisher, contractId, fullMetadataUri, predeployMetadata.metadataUri, bytecodeHash, ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero]);\n    const events = this.publisher.parseLogs(\"ContractPublished\", receipt.logs);\n    if (events.length < 1) {\n      throw new Error(\"No ContractPublished event found\");\n    }\n    const contract = events[0].args.publishedContract;\n    return {\n      receipt,\n      data: async () => this.toPublishedContract(contract)\n    };\n  }\n  async unpublish(publisher, contractId) {\n    return {\n      receipt: await this.publisher.sendTransaction(\"unpublishContract\", [publisher, contractId])\n    };\n  }\n  toPublishedContract(contractModel) {\n    return PublishedContractSchema.parse({\n      id: contractModel.contractId,\n      timestamp: contractModel.publishTimestamp,\n      metadataUri: contractModel.publishMetadataUri\n    });\n  }\n}\n\n/**\n *\n * {@link UserWallet} events that you can subscribe to using `sdk.wallet.events`.\n *\n * @public\n */\n\n/**\n * Connect and Interact with a user wallet\n * @example\n * ```javascript\n * const balance = await sdk.wallet.balance();\n * ```\n * @public\n */\nclass UserWallet {\n  constructor(network, options) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"connection\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"options\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"events\", new eventemitter3__WEBPACK_IMPORTED_MODULE_5__[\"default\"]());\n    this.connection = new RPCConnectionHandler(network, options);\n    this.options = options;\n    this.events = new eventemitter3__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n  }\n\n  // TODO disconnect()\n  // TODO switchChain()\n  // TODO tokens()\n  // TODO NFTs()\n\n  // TODO this will become the source of truth of the signer and have every contract read from it\n  // TODO separate signer and provider logics\n  connect(network) {\n    this.connection.updateSignerOrProvider(network);\n    this.events.emit(\"signerChanged\", this.connection.getSigner());\n  }\n\n  /**\n   * Transfer native or ERC20 tokens from this wallet to another wallet\n   * @example\n   * ```javascript\n   *  // transfer 0.8 ETH\n   * await sdk.wallet.transfer(\"0x...\", 0.8);\n   *  // transfer 0.8 tokens of `tokenContractAddress`\n   * await sdk.wallet.transfer(\"0x...\", 0.8, tokenContractAddress);\n   * ```\n   * @param to - the account to send funds to\n   * @param amount - the amount in tokens\n   * @param currencyAddress - Optional - ERC20 contract address of the token to transfer\n   */\n  async transfer(to, amount) {\n    let currencyAddress = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NATIVE_TOKEN_ADDRESS;\n    const signer = this.requireWallet();\n    const amountInWei = await normalizePriceValue(this.connection.getProvider(), amount, currencyAddress);\n    if (isNativeToken(currencyAddress)) {\n      // native token transfer\n      const from = await signer.getAddress();\n      const tx = await signer.sendTransaction({\n        from,\n        to,\n        value: amountInWei\n      });\n      return {\n        receipt: await tx.wait()\n      };\n    } else {\n      // ERC20 token transfer\n      return {\n        receipt: await this.createErc20(currencyAddress).sendTransaction(\"transfer\", [to, amountInWei])\n      };\n    }\n  }\n\n  /**\n   * Fetch the native or ERC20 token balance of this wallet\n   * @example\n   * ```javascript\n   * // native currency balance\n   * const balance = await sdk.wallet.balance();\n   * // ERC20 token balance\n   * const erc20balance = await sdk.wallet.balance(tokenContractAddress);\n   *\n   * ```\n   */\n  async balance() {\n    let currencyAddress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NATIVE_TOKEN_ADDRESS;\n    this.requireWallet();\n    const provider = this.connection.getProvider();\n    let balance;\n    if (isNativeToken(currencyAddress)) {\n      balance = await provider.getBalance(await this.getAddress());\n    } else {\n      balance = await this.createErc20(currencyAddress).readContract.balanceOf(await this.getAddress());\n    }\n    return await fetchCurrencyValue(provider, currencyAddress, balance);\n  }\n\n  /**\n   * Get the currently connected address\n   * @example\n   * ```javascript\n   * const address = await sdk.wallet.getAddress();\n   * ```\n   */\n  async getAddress() {\n    return await this.requireWallet().getAddress();\n  }\n\n  /**\n   * Get the currently connected wallet's chainId\n   * @internal\n   */\n  async getChainId() {\n    return await this.requireWallet().getChainId();\n  }\n\n  /**\n   * Checks whether there's a signer connected with the SDK\n   * @internal\n   */\n  isConnected() {\n    try {\n      this.requireWallet();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Sign any message with the connected wallet private key\n   * @param message - the message to sign\n   * @returns the signed message\n   *\n   * @example\n   * ```javascript\n   * // This is the message to be signed\n   * const message = \"Sign this message...\";\n   *\n   * // Now we can sign the message with the connected wallet\n   * const signature = await sdk.wallet.sign(message);\n   * ```\n   */\n  async sign(message) {\n    const signer = this.requireWallet();\n    return await signer.signMessage(message);\n  }\n\n  /**\n   * Recover the signing address from a signed message\n   * @param message - the original message that was signed\n   * @param signature - the signature to recover the address from\n   * @returns the address that signed the message\n   *\n   * @example\n   * ```javascript\n   * const message = \"Sign this message...\";\n   * const signature = await sdk.wallet.sign(message);\n   *\n   * // Now we can recover the signing address\n   * const address = sdk.wallet.recoverAddress(message, signature);\n   * ```\n   */\n  recoverAddress(message, signature) {\n    const messageHash = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.hashMessage(message);\n    const messageHashBytes = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.arrayify(messageHash);\n    return ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.recoverAddress(messageHashBytes, signature);\n  }\n\n  /**\n   * Send a raw transaction to the blockchain from the connected wallet\n   * @param transactionRequest - raw transaction data to send to the blockchain\n   */\n  async sendRawTransaction(transactionRequest) {\n    const signer = this.requireWallet();\n    const tx = await signer.sendTransaction(transactionRequest);\n    return {\n      receipt: await tx.wait()\n    };\n  }\n\n  /** ***********************\n   * PRIVATE FUNCTIONS\n   * ***********************/\n\n  requireWallet() {\n    const signer = this.connection.getSigner();\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(signer, \"This action requires a connected wallet. Please pass a valid signer to the SDK.\");\n    return signer;\n  }\n  createErc20(currencyAddress) {\n    return new ContractWrapper(this.connection.getSignerOrProvider(), currencyAddress, _thirdweb_dev_contracts_js_dist_abis_IERC20_json__WEBPACK_IMPORTED_MODULE_13__, this.options);\n  }\n}\n\n/**\n * The main entry point for the thirdweb SDK\n * @public\n */\nclass ThirdwebSDK extends RPCConnectionHandler {\n  /**\n   * Get an instance of the thirdweb SDK based on an AbstractWallet\n   *\n   * @example\n   * ```javascript\n   * import { ThirdwebSDK } from \"@thirdweb-dev/sdk\"\n   *\n   * const wallet = new AbstractWalletImplementation();\n   * const sdk = await ThirdwebSDK.fromWallet(wallet, \"mainnet\");\n   * ```\n   *\n   * @param wallet - the implementation of the AbstractWallet class to use for signing\n   * @param network - the network (chain) to connect to (e.g. \"mainnet\", \"rinkeby\", \"polygon\", \"mumbai\"...) or a fully formed RPC url\n   * @param options - the SDK options to use\n   * @param storage - optional storage implementation to use\n   * @returns an instance of the SDK\n   *\n   * @beta\n   */\n  static async fromWallet(wallet, network) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let storage = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _thirdweb_dev_storage__WEBPACK_IMPORTED_MODULE_47__.ThirdwebStorage();\n    const signerOrProvider = getProviderForNetwork(network);\n    const provider = ethers__WEBPACK_IMPORTED_MODULE_58__.Signer.isSigner(signerOrProvider) ? signerOrProvider.provider : typeof signerOrProvider === \"string\" ? getReadOnlyProvider(signerOrProvider) : signerOrProvider;\n    const signer = await wallet.getSigner(provider);\n    return ThirdwebSDK.fromSigner(signer, network, options, storage);\n  }\n\n  /**\n   * Get an instance of the thirdweb SDK based on an existing ethers signer\n   *\n   * @example\n   * ```javascript\n   * // get a signer from somewhere (createRandom is being used purely for example purposes)\n   * const signer = ethers.Wallet.createRandom();\n   *\n   * // get an instance of the SDK with the signer already setup\n   * const sdk = ThirdwebSDK.fromSigner(signer, \"mainnet\");\n   * ```\n   *\n   * @param signer - a ethers Signer to be used for transactions\n   * @param network - the network (chain) to connect to (e.g. \"mainnet\", \"rinkeby\", \"polygon\", \"mumbai\"...) or a fully formed RPC url\n   * @param options - the SDK options to use\n   * @param storage - optional storage implementation to use\n   * @returns an instance of the SDK\n   *\n   * @beta\n   */\n  static fromSigner(signer, network) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let storage = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _thirdweb_dev_storage__WEBPACK_IMPORTED_MODULE_47__.ThirdwebStorage();\n    const sdk = new ThirdwebSDK(network || signer, options, storage);\n    sdk.updateSignerOrProvider(signer);\n    return sdk;\n  }\n\n  /**\n   * Get an instance of the thirdweb SDK based on a private key.\n   *\n   * @remarks\n   * This should only be used for backend services or scripts, with the private key stored in a secure way.\n   * **NEVER** expose your private key to the public in any way.\n   *\n   * @example\n   * ```javascript\n   * const sdk = ThirdwebSDK.fromPrivateKey(\"SecretPrivateKey\", \"mainnet\");\n   * ```\n   *\n   * @param privateKey - the private key - **DO NOT EXPOSE THIS TO THE PUBLIC**\n   * @param network - the network (chain) to connect to (e.g. \"mainnet\", \"rinkeby\", \"polygon\", \"mumbai\"...) or a fully formed RPC url\n   * @param options - the SDK options to use\n   * @param storage - optional storage implementation to use\n   * @returns an instance of the SDK\n   *\n   * @beta\n   */\n  static fromPrivateKey(privateKey, network) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let storage = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _thirdweb_dev_storage__WEBPACK_IMPORTED_MODULE_47__.ThirdwebStorage();\n    const signerOrProvider = getProviderForNetwork(network);\n    const provider = ethers__WEBPACK_IMPORTED_MODULE_58__.Signer.isSigner(signerOrProvider) ? signerOrProvider.provider : typeof signerOrProvider === \"string\" ? getReadOnlyProvider(signerOrProvider) : signerOrProvider;\n    const signer = new ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.Wallet(privateKey, provider);\n    return ThirdwebSDK.fromSigner(signer, network, options, storage);\n  }\n\n  /**\n   * @internal\n   * the cache of contracts that we have already seen\n   */\n\n  constructor(network) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let storage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _thirdweb_dev_storage__WEBPACK_IMPORTED_MODULE_47__.ThirdwebStorage();\n    const signerOrProvider = getProviderForNetwork(network);\n    super(signerOrProvider, options);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractCache\", new Map());\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"_publisher\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storageHandler\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"deployer\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"wallet\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"auth\", void 0);\n    this.storageHandler = storage;\n    this.storage = storage;\n    this.wallet = new UserWallet(signerOrProvider, options);\n    this.deployer = new ContractDeployer(signerOrProvider, options, storage);\n    this.auth = new WalletAuthenticator(signerOrProvider, this.wallet, options);\n    this._publisher = new ContractPublisher(signerOrProvider, this.options, this.storageHandler);\n  }\n\n  /**\n   * Get an instance of a NFT Drop contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const dropContract = await sdk.getDropContract(\"0x1234...\");\n   * + const dropContract = await sdk.getContract(\"0x1234...\", \"nft-drop\");\n   * ```\n   */\n  async getNFTDrop(contractAddress) {\n    return await this.getContract(contractAddress, \"nft-drop\");\n  }\n\n  /**\n   * Get an instance of a Signature Drop contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const signatureDrop = await sdk.getSignatureDrop(\"0x1234...\");\n   * + const signatureDrop = await sdk.getContract(\"0x1234...\", \"signature-drop\");\n   * ```\n   */\n  async getSignatureDrop(contractAddress) {\n    return await this.getContract(contractAddress, \"signature-drop\");\n  }\n\n  /**\n   * Get an instance of a NFT Collection Drop contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const signatureDrop = await sdk.getNFTCollection(\"0x1234...\");\n   * + const signatureDrop = await sdk.getContract(\"0x1234...\", \"nft-collection\");\n   * ```\n   */\n  async getNFTCollection(contractAddress) {\n    return await this.getContract(contractAddress, \"nft-collection\");\n  }\n\n  /**\n   * Get an instance of a Edition Drop contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const editionDrop = await sdk.getEditionDrop(\"0x1234...\");\n   * + const editionDrop = await sdk.getContract(\"0x1234...\", \"edition-drop\");\n   * ```\n   */\n  async getEditionDrop(contractAddress) {\n    return await this.getContract(contractAddress, \"edition-drop\");\n  }\n\n  /**\n   * Get an instance of a Edition contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const edition = await sdk.getEdition(\"0x1234...\");\n   * + const edition = await sdk.getContract(\"0x1234...\", \"edition\");\n   * ```\n   */\n  async getEdition(contractAddress) {\n    return await this.getContract(contractAddress, \"edition\");\n  }\n\n  /**\n   * Get an instance of a Token Drop contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const tokenDrop = await sdk.getTokenDrop(\"0x1234...\");\n   * + const tokenDrop = await sdk.getContract(\"0x1234...\", \"token-drop\");\n   * ```\n   */\n  async getTokenDrop(contractAddress) {\n    return await this.getContract(contractAddress, \"token-drop\");\n  }\n\n  /**\n   * Get an instance of a Token contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const token = await sdk.getToken(\"0x1234...\");\n   * + const token = await sdk.getContract(\"0x1234...\", \"token\");\n   * ```\n   */\n  async getToken(contractAddress) {\n    return await this.getContract(contractAddress, \"token\");\n  }\n\n  /**\n   * Get an instance of a Vote contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const vote = await sdk.getVote(\"0x1234...\");\n   * + const vote = await sdk.getContract(\"0x1234...\", \"vote\");\n   * ```\n   */\n  async getVote(contractAddress) {\n    return await this.getContract(contractAddress, \"vote\");\n  }\n\n  /**\n   * Get an instance of a Split contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const split = await sdk.getSplit(\"0x1234...\");\n   * + const split = await sdk.getContract(\"0x1234...\", \"split\");\n   * ```\n   */\n  async getSplit(contractAddress) {\n    return await this.getContract(contractAddress, \"split\");\n  }\n\n  /**\n   * Get an instance of a Marketplace contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const marketplace = await sdk.getMarketplace(\"0x1234...\");\n   * + const marketplace = await sdk.getContract(\"0x1234...\", \"marketplace\");\n   * ```\n   */\n  async getMarketplace(contractAddress) {\n    return await this.getContract(contractAddress, \"marketplace\");\n  }\n\n  /**\n   * Get an instance of a Pack contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const pack = await sdk.getPack(\"0x1234...\");\n   * + const pack = await sdk.getContract(\"0x1234...\", \"pack\");\n   * ```\n   */\n  async getPack(contractAddress) {\n    return await this.getContract(contractAddress, \"pack\");\n  }\n\n  /**\n   * Get an instance of a Pack contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const multiWrap = await sdk.getMultiwrap(\"0x1234...\");\n   * + const multiWrap = await sdk.getContract(\"0x1234...\", \"multiwrap\");\n   * ```\n   */\n  async getMultiwrap(contractAddress) {\n    return await this.getContract(contractAddress, \"multiwrap\");\n  }\n\n  /**\n   * Get an instance of a Custom ThirdwebContract\n   * @param address - the address of the deployed contract\n   * @returns the contract\n   * @public\n   * @example\n   * ```javascript\n   * const contract = await sdk.getContract(\"{{contract_address}}\");\n   * ```\n   */\n\n  async getContract(address, contractTypeOrABI) {\n    // if we have a contract in the cache we will return it\n    // we will do this **without** checking any contract type things for simplicity, this may have to change in the future?\n    if (this.contractCache.has(address)) {\n      // we know this will be there since we check the has above\n      return this.contractCache.get(address);\n    }\n    let newContract;\n\n    // if we don't have a contractType or ABI then we will have to resolve it regardless\n    // we also handle it being \"custom\" just in case...\n    if (!contractTypeOrABI || contractTypeOrABI === \"custom\") {\n      const resolvedContractType = await this.resolveContractType(address);\n      if (resolvedContractType === \"custom\") {\n        // if it's a custom contract we gotta fetch the compilet metadata\n        try {\n          const publisher = this.getPublisher();\n          const metadata = await publisher.fetchCompilerMetadataFromAddress(address);\n          newContract = await this.getContractFromAbi(address, metadata.abi);\n        } catch (e) {\n          throw new Error(`Error fetching ABI for this contract\\n\\n${e}`);\n        }\n      } else {\n        // otherwise if it's a prebuilt contract we can just use the contract type\n        const contractAbi = await PREBUILT_CONTRACTS_MAP[resolvedContractType].getAbi(address, this.getProvider());\n        newContract = await this.getContractFromAbi(address, contractAbi);\n      }\n    }\n    // if it's a builtin contract type we can just use the contract type to initialize the contract instance\n    else if (typeof contractTypeOrABI === \"string\" && contractTypeOrABI in PREBUILT_CONTRACTS_MAP) {\n      newContract = await PREBUILT_CONTRACTS_MAP[contractTypeOrABI].initialize(this.getSignerOrProvider(), address, this.storage, this.options);\n    }\n    // otherwise it has to be an ABI\n    else {\n      newContract = await this.getContractFromAbi(address, contractTypeOrABI);\n    }\n\n    // set whatever we have on the cache\n    this.contractCache.set(address, newContract);\n    // return it\n    return newContract;\n  }\n\n  /**\n   * @internal\n   * @deprecated use {@link getContract} directly instead\n   */\n  async getBuiltInContract(address, contractType) {\n    return await this.getContract(address, contractType);\n  }\n\n  /**\n   * @param contractAddress - the address of the contract to attempt to resolve the contract type for\n   * @returns the {@link ContractType} for the given contract address\n   *\n   */\n  async resolveContractType(contractAddress) {\n    try {\n      const contract = new ethers__WEBPACK_IMPORTED_MODULE_58__.Contract(contractAddress, _thirdweb_dev_contracts_js_dist_abis_IThirdwebContract_json__WEBPACK_IMPORTED_MODULE_4__,\n      // !provider only! - signer can break things here!\n      this.getProvider());\n      const remoteContractType = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.toUtf8String(await contract.contractType())\n      // eslint-disable-next-line no-control-regex\n      .replace(/\\x00/g, \"\");\n      return getContractTypeForRemoteName(remoteContractType);\n    } catch (err) {\n      return \"custom\";\n    }\n  }\n\n  /**\n   * Return all the contracts deployed by the specified address\n   * @param walletAddress - the deployed address\n   * @example\n   * ```javascript\n   * const contracts = sdk.getContractList(\"{{wallet_address}}\");\n   * ```\n   */\n  async getContractList(walletAddress) {\n    const addresses = (await (await this.deployer.getRegistry())?.getContractAddresses(walletAddress)) || [];\n    const addressesWithContractTypes = await Promise.all(addresses.map(async address => {\n      let contractType = \"custom\";\n      try {\n        contractType = await this.resolveContractType(address);\n      } catch (e) {\n        // this going to happen frequently and be OK, we'll just catch it and ignore it\n      }\n      let metadata;\n      if (contractType === \"custom\") {\n        try {\n          metadata = (await this.getContract(address)).metadata;\n        } catch (e) {\n          console.warn(`Couldn't get contract metadata for custom contract: ${address} - ${e}`);\n        }\n      } else {\n        metadata = (await this.getContract(address, contractType)).metadata;\n      }\n      return {\n        address,\n        contractType,\n        metadata\n      };\n    }));\n    return addressesWithContractTypes.filter(e => e.metadata).map(_ref => {\n      let {\n        address,\n        contractType,\n        metadata\n      } = _ref;\n      (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(metadata, \"All ThirdwebContracts require metadata\");\n      return {\n        address,\n        contractType,\n        metadata: () => metadata.get()\n      };\n    });\n  }\n\n  /**\n   * Update the active signer or provider for all contracts\n   * @param network - the new signer or provider\n   */\n  updateSignerOrProvider(network) {\n    super.updateSignerOrProvider(network);\n    this.updateContractSignerOrProvider();\n  }\n  updateContractSignerOrProvider() {\n    this.wallet.connect(this.getSignerOrProvider());\n    this.auth.updateSignerOrProvider(this.getSignerOrProvider());\n    this.deployer.updateSignerOrProvider(this.getSignerOrProvider());\n    this._publisher.updateSignerOrProvider(this.getSignerOrProvider());\n    for (const [, contract] of this.contractCache) {\n      contract.onNetworkUpdated(this.getSignerOrProvider());\n    }\n  }\n\n  /**\n   * Get an instance of a Custom contract from a json ABI\n   * @param address - the address of the deployed contract\n   * @param abi - the JSON abi\n   * @returns the contract\n   * @beta\n   * @example\n   * ```javascript\n   * // Import your ABI from a JSON file\n   * import myABI from \"./path/to/myABI.json\";\n   *\n   * const contract = sdk.getContractFromAbi(\n   *   \"{{contract_address}}\",\n   *   // Pass in the \"abi\" field from the JSON file\n   *   myABI.abi\n   * );\n   * ```\n   */\n  async getContractFromAbi(address, abi) {\n    if (this.contractCache.has(address)) {\n      return this.contractCache.get(address);\n    }\n    const [, provider] = getSignerAndProvider(this.getSignerOrProvider(), this.options);\n    // TODO we still might want to lazy-fy this\n    const contract = new SmartContract(this.getSignerOrProvider(), address, abi, this.storageHandler, this.options, (await provider.getNetwork()).chainId);\n    this.contractCache.set(address, contract);\n    return contract;\n  }\n\n  /**\n   * Get the native balance of a given address (wallet or contract)\n   * @example\n   * ```javascript\n   * const balance = await sdk.getBalance(\"0x...\");\n   * console.log(balance.displayValue);\n   * ```\n   * @param address - the address to check the balance for\n   */\n  async getBalance(address) {\n    return fetchCurrencyValue(this.getProvider(), NATIVE_TOKEN_ADDRESS, await this.getProvider().getBalance(address));\n  }\n\n  /**\n   * @internal\n   */\n  getPublisher() {\n    return this._publisher;\n  }\n}\n\n/**\n * @internal\n */\nclass ContractFactory extends ContractWrapper {\n  // Map from contract type to version to deploy specific versions by default\n\n  constructor(factoryAddr, network, storage, options) {\n    super(network, factoryAddr, _thirdweb_dev_contracts_js_dist_abis_TWFactory_json__WEBPACK_IMPORTED_MODULE_44__, options);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"DEFAULT_VERSION_MAP\", {\n      [NFTDropInitializer.contractType]: 3,\n      [NFTCollectionInitializer.contractType]: 1,\n      [SignatureDropInitializer.contractType]: 4,\n      [MultiwrapInitializer.contractType]: 1,\n      [EditionDropInitializer.contractType]: 2,\n      [EditionInitializer.contractType]: 1,\n      [TokenDropInitializer.contractType]: 2,\n      [TokenInitializer.contractType]: 1,\n      [VoteInitializer.contractType]: 1,\n      [SplitInitializer.contractType]: 1,\n      [MarketplaceInitializer.contractType]: 2,\n      [PackInitializer.contractType]: 2\n    });\n    this.storage = storage;\n  }\n  async deploy(contractType, contractMetadata, version) {\n    const contract = PREBUILT_CONTRACTS_MAP[contractType];\n    const metadata = contract.schema.deploy.parse(contractMetadata);\n\n    // TODO: is there any special pre-processing we need to do before uploading?\n    const contractURI = await this.storage.upload(metadata);\n    const implementationAddress = await this.getImplementation(contract, version);\n    if (!implementationAddress || implementationAddress === ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero) {\n      throw new Error(`No implementation found for ${contractType}`);\n    }\n    const ABI = await contract.getAbi(implementationAddress, this.getProvider());\n    const encodedFunc = ethers__WEBPACK_IMPORTED_MODULE_58__.Contract.getInterface(ABI).encodeFunctionData(\"initialize\", await this.getDeployArguments(contractType, metadata, contractURI));\n    const blockNumber = await this.getProvider().getBlockNumber();\n    const salt = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.formatBytes32String(blockNumber.toString());\n    const receipt = await this.sendTransaction(\"deployProxyByImplementation\", [implementationAddress, encodedFunc, salt]);\n    const events = this.parseLogs(\"ProxyDeployed\", receipt.logs);\n    if (events.length < 1) {\n      throw new Error(\"No ProxyDeployed event found\");\n    }\n    return events[0].args.proxy;\n  }\n\n  // TODO once IContractFactory is implemented, this can be probably be moved to its own class\n  async deployProxyByImplementation(implementationAddress, implementationAbi, initializerFunction, initializerArgs) {\n    const encodedFunc = ethers__WEBPACK_IMPORTED_MODULE_58__.Contract.getInterface(implementationAbi).encodeFunctionData(initializerFunction, initializerArgs);\n    const blockNumber = await this.getProvider().getBlockNumber();\n    const receipt = await this.sendTransaction(\"deployProxyByImplementation\", [implementationAddress, encodedFunc, ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.formatBytes32String(blockNumber.toString())]);\n    const events = this.parseLogs(\"ProxyDeployed\", receipt.logs);\n    if (events.length < 1) {\n      throw new Error(\"No ProxyDeployed event found\");\n    }\n    return events[0].args.proxy;\n  }\n\n  /**\n   *\n   * @param contractType\n   * @param metadata\n   * @param contractURI\n   * @returns\n   * @internal\n   */\n  async getDeployArguments(contractType, metadata, contractURI) {\n    let trustedForwarders = contractType === PackInitializer.contractType ? [] : await this.getDefaultTrustedForwarders();\n    // override default forwarders if custom ones are passed in\n    if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {\n      trustedForwarders = metadata.trusted_forwarders;\n    }\n    switch (contractType) {\n      case NFTDropInitializer.contractType:\n      case NFTCollectionInitializer.contractType:\n        const erc721metadata = NFTDropInitializer.schema.deploy.parse(metadata);\n        return [await this.getSignerAddress(), erc721metadata.name, erc721metadata.symbol, contractURI, trustedForwarders, erc721metadata.primary_sale_recipient, erc721metadata.fee_recipient, erc721metadata.seller_fee_basis_points, erc721metadata.platform_fee_basis_points, erc721metadata.platform_fee_recipient];\n      case SignatureDropInitializer.contractType:\n        const signatureDropmetadata = SignatureDropInitializer.schema.deploy.parse(metadata);\n        return [await this.getSignerAddress(), signatureDropmetadata.name, signatureDropmetadata.symbol, contractURI, trustedForwarders, signatureDropmetadata.primary_sale_recipient, signatureDropmetadata.fee_recipient, signatureDropmetadata.seller_fee_basis_points, signatureDropmetadata.platform_fee_basis_points, signatureDropmetadata.platform_fee_recipient];\n      case MultiwrapInitializer.contractType:\n        const multiwrapMetadata = MultiwrapInitializer.schema.deploy.parse(metadata);\n        return [await this.getSignerAddress(), multiwrapMetadata.name, multiwrapMetadata.symbol, contractURI, trustedForwarders, multiwrapMetadata.fee_recipient, multiwrapMetadata.seller_fee_basis_points];\n      case EditionDropInitializer.contractType:\n      case EditionInitializer.contractType:\n        const erc1155metadata = EditionDropInitializer.schema.deploy.parse(metadata);\n        return [await this.getSignerAddress(), erc1155metadata.name, erc1155metadata.symbol, contractURI, trustedForwarders, erc1155metadata.primary_sale_recipient, erc1155metadata.fee_recipient, erc1155metadata.seller_fee_basis_points, erc1155metadata.platform_fee_basis_points, erc1155metadata.platform_fee_recipient];\n      case TokenDropInitializer.contractType:\n      case TokenInitializer.contractType:\n        const erc20metadata = TokenInitializer.schema.deploy.parse(metadata);\n        return [await this.getSignerAddress(), erc20metadata.name, erc20metadata.symbol, contractURI, trustedForwarders, erc20metadata.primary_sale_recipient, erc20metadata.platform_fee_recipient, erc20metadata.platform_fee_basis_points];\n      case VoteInitializer.contractType:\n        const voteMetadata = VoteInitializer.schema.deploy.parse(metadata);\n        return [voteMetadata.name, contractURI, trustedForwarders, voteMetadata.voting_token_address, voteMetadata.voting_delay_in_blocks, voteMetadata.voting_period_in_blocks, ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(voteMetadata.proposal_token_threshold), voteMetadata.voting_quorum_fraction];\n      case SplitInitializer.contractType:\n        const splitsMetadata = SplitInitializer.schema.deploy.parse(metadata);\n        return [await this.getSignerAddress(), contractURI, trustedForwarders, splitsMetadata.recipients.map(s => s.address), splitsMetadata.recipients.map(s => ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(s.sharesBps))];\n      case MarketplaceInitializer.contractType:\n        const marketplaceMetadata = MarketplaceInitializer.schema.deploy.parse(metadata);\n        return [await this.getSignerAddress(), contractURI, trustedForwarders, marketplaceMetadata.platform_fee_recipient, marketplaceMetadata.platform_fee_basis_points];\n      case PackInitializer.contractType:\n        const packsMetadata = PackInitializer.schema.deploy.parse(metadata);\n        return [await this.getSignerAddress(), packsMetadata.name, packsMetadata.symbol, contractURI, trustedForwarders, packsMetadata.fee_recipient, packsMetadata.seller_fee_basis_points];\n      default:\n        return [];\n    }\n  }\n  async getDefaultTrustedForwarders() {\n    const chainId = await this.getChainID();\n    return getDefaultTrustedForwarders(chainId);\n  }\n  async getImplementation(contract, version) {\n    const encodedType = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.formatBytes32String(contract.name);\n    const chainId = await this.getChainID();\n    const approvedImplementation = getApprovedImplementation(chainId, contract.contractType);\n    // return approved implementation if it exists and we're not overriding the version\n    if (approvedImplementation && approvedImplementation.length > 0 && version === undefined) {\n      return approvedImplementation;\n    }\n    return this.readContract.getImplementation(encodedType, version !== undefined ? version : this.DEFAULT_VERSION_MAP[contract.contractType]);\n  }\n  async getLatestVersion(contractType) {\n    const name = getContractName(contractType);\n    if (!name) {\n      throw new Error(`Invalid contract type ${contractType}`);\n    }\n    const encodedType = ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.formatBytes32String(name);\n    return this.readContract.currentVersion(encodedType);\n  }\n}\n\nclass FactoryEvents extends ContractEvents {\n  constructor(contractWrapper) {\n    super(contractWrapper);\n  }\n  addDeployListener(listener) {\n    this.addTransactionListener(async event => {\n      if (!event.transactionHash) {\n        return;\n      }\n      const receipt = await this.contractWrapper.getProvider().getTransactionReceipt(event.transactionHash);\n      const events = this.contractWrapper.parseLogs(\"ProxyDeployed\", receipt.logs);\n      if (events.length > 0) {\n        listener({\n          ...event,\n          contractAddress: events[0].args.proxy\n        });\n      }\n    });\n  }\n}\n\n/**\n * @internal\n */\nclass ContractRegistry extends ContractWrapper {\n  constructor(registryAddress, network, options) {\n    super(network, registryAddress, _thirdweb_dev_contracts_js_dist_abis_TWRegistry_json__WEBPACK_IMPORTED_MODULE_45__, options);\n  }\n  async getContractAddresses(walletAddress) {\n    // TODO @fixme the filter here is necessary because for some reason getAll returns a 0x0 address for the first entry\n    return (await this.readContract.getAll(walletAddress)).filter(adr => ethers__WEBPACK_IMPORTED_MODULE_58__.utils.isAddress(adr) && adr.toLowerCase() !== ethers__WEBPACK_IMPORTED_MODULE_58__.constants.AddressZero);\n  }\n  async addContract(contractAddress) {\n    return await this.addContracts([contractAddress]);\n  }\n  async addContracts(contractAddresses) {\n    const deployerAddress = await this.getSignerAddress();\n    const encoded = [];\n    contractAddresses.forEach(address => {\n      encoded.push(this.readContract.interface.encodeFunctionData(\"add\", [deployerAddress, address]));\n    });\n    return {\n      receipt: await this.multiCall(encoded)\n    };\n  }\n  async removeContract(contractAddress) {\n    return await this.removeContracts([contractAddress]);\n  }\n  async removeContracts(contractAddresses) {\n    const deployerAddress = await this.getSignerAddress();\n    const encoded = [];\n    contractAddresses.forEach(address => {\n      encoded.push(this.readContract.interface.encodeFunctionData(\"remove\", [deployerAddress, address]));\n    });\n    return {\n      receipt: await this.multiCall(encoded)\n    };\n  }\n}\n\n/**\n * Handles deploying new contracts\n * @public\n */\nclass ContractDeployer extends RPCConnectionHandler {\n  /**\n   * @internal\n   * should never be accessed directly, use {@link ContractDeployer.getFactory} instead\n   */\n\n  /**\n   * @internal\n   * should never be accessed directly, use {@link ContractDeployer.getRegistry} instead\n   */\n\n  constructor(network, options, storage) {\n    super(network, options);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"_factory\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"_registry\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"events\", void 0);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"storage\", void 0);\n    this.storage = storage;\n\n    // Initialize factory and registry (we don't need to make these calls async)\n    this.getFactory();\n    this.getRegistry();\n  }\n\n  /**\n   * Deploys an NFT Collection contract\n   *\n   * @remarks Deploys an NFT Collection contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployNFTCollection({\n   *   name: \"My Collection\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns the address of the deployed contract\n   */\n  async deployNFTCollection(metadata) {\n    return await this.deployBuiltInContract(NFTCollectionInitializer.contractType, metadata);\n  }\n\n  /**\n   * Deploys a new NFTDrop contract\n   *\n   * @remarks Deploys an NFT Drop contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployNFTDrop({\n   *   name: \"My Drop\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns the address of the deployed contract\n   */\n  async deployNFTDrop(metadata) {\n    return await this.deployBuiltInContract(NFTDropInitializer.contractType, metadata);\n  }\n\n  /**\n   * Deploys a new SignatureDrop contract\n   *\n   * @remarks Deploys a SignatureDrop contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deploySignatureDrop({\n   *   name: \"My Signature Drop\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns the address of the deployed contract\n   */\n  async deploySignatureDrop(metadata) {\n    return await this.deployBuiltInContract(SignatureDropInitializer.contractType, metadata);\n  }\n\n  /**\n   * Deploys a new Multiwrap contract\n   *\n   * @remarks Deploys a Multiwrap contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployMultiwrap({\n   *   name: \"My Multiwrap\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns the address of the deployed contract\n   * @beta\n   */\n  async deployMultiwrap(metadata) {\n    return await this.deployBuiltInContract(MultiwrapInitializer.contractType, metadata);\n  }\n\n  /**\n   * Deploys a new Edition contract\n   *\n   * @remarks Deploys an Edition contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployEdition({\n   *   name: \"My Edition\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns the address of the deployed contract\n   */\n  async deployEdition(metadata) {\n    return await this.deployBuiltInContract(EditionInitializer.contractType, metadata);\n  }\n\n  /**\n   * Deploys a new EditionDrop contract\n   *\n   * @remarks Deploys an Edition Drop contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployEditionDrop({\n   *   name: \"My Edition Drop\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns the address of the deployed contract\n   */\n  async deployEditionDrop(metadata) {\n    return await this.deployBuiltInContract(EditionDropInitializer.contractType, metadata);\n  }\n\n  /**\n   * Deploys a new Token contract\n   *\n   * @remarks Deploys a Token contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployToken({\n   *   name: \"My Token\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns the address of the deployed contract\n   */\n  async deployToken(metadata) {\n    return await this.deployBuiltInContract(TokenInitializer.contractType, metadata);\n  }\n\n  /**\n   * Deploys a new Token Drop contract\n   *\n   * @remarks Deploys a Token Drop contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployTokenDrop({\n   *   name: \"My Token Drop\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns the address of the deployed contract\n   */\n  async deployTokenDrop(metadata) {\n    return await this.deployBuiltInContract(TokenDropInitializer.contractType, metadata);\n  }\n\n  /**\n   * Deploys a new Marketplace contract\n   *\n   * @remarks Deploys a Marketplace contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployMarketplace({\n   *   name: \"My Marketplace\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns the address of the deployed contract\n   */\n  async deployMarketplace(metadata) {\n    return await this.deployBuiltInContract(MarketplaceInitializer.contractType, metadata);\n  }\n\n  /**\n   * Deploys a new Pack contract\n   *\n   * @remarks Deploys a Pack contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployPack({\n   *   name: \"My Pack\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns the address of the deployed contract\n   */\n  async deployPack(metadata) {\n    return await this.deployBuiltInContract(PackInitializer.contractType, metadata);\n  }\n\n  /**\n   * Deploys a new Split contract\n   *\n   * @remarks Deploys a Split contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deploySplit({\n   *   name: \"My Split\",\n   *   primary_sale_recipient: \"your-address\",\n   *   recipients: [\n   *    {\n   *      address: \"your-address\",\n   *      sharesBps: 80 * 100, // 80%\n   *    },\n   *    {\n   *      address: \"another-address\",\n   *      sharesBps: 20 * 100, // 20%\n   *    },\n   *   ],\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns the address of the deployed contract\n   */\n  async deploySplit(metadata) {\n    return await this.deployBuiltInContract(SplitInitializer.contractType, metadata);\n  }\n\n  /**\n   * Deploys a new Vote contract\n   *\n   * @remarks Deploys an Vote contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployVote({\n   *   name: \"My Vote\",\n   *   primary_sale_recipient: \"your-address\",\n   *   voting_token_address: \"your-token-contract-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns the address of the deployed contract\n   */\n  async deployVote(metadata) {\n    return await this.deployBuiltInContract(VoteInitializer.contractType, metadata);\n  }\n\n  /**\n   * Deploys a new contract\n   *\n   * @internal\n   * @param contractType - the type of contract to deploy\n   * @param contractMetadata - the metadata to deploy the contract with\n   * @param version\n   * @returns a promise of the address of the newly deployed contract\n   */\n  async deployBuiltInContract(contractType, contractMetadata) {\n    let version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"latest\";\n    const activeChainId = (await this.getProvider().getNetwork()).chainId;\n    const parsedMetadata = PREBUILT_CONTRACTS_MAP[contractType].schema.deploy.parse(contractMetadata);\n    const factory = await this.getFactory();\n    if (activeChainId === ChainId.Hardhat || activeChainId === ChainId.Localhost) {\n      //\n      // old behavior for hardhat and localhost chains\n      //\n\n      // parse version into the first number of the version string (or undefined if unparseable)\n      let parsedVersion = undefined;\n      try {\n        parsedVersion = parseInt(version);\n        if (isNaN(parsedVersion)) {\n          parsedVersion = undefined;\n        }\n      } catch (e) {\n        parsedVersion = undefined;\n      }\n      return await factory.deploy(contractType, parsedMetadata, parsedVersion);\n    }\n\n    //\n    // new behavior for all other chains\n    //\n\n    // resolve contract name from type\n    const contractName = getContractName(contractType);\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(contractName, \"contract name not found\");\n    // get deploy arugments for the contractType\n    // first upload the contractmetadata\n    const contractURI = await this.storage.upload(parsedMetadata);\n    // the get the deploy arguments\n    const constructorParams = await factory.getDeployArguments(contractType, parsedMetadata, contractURI);\n    return this.deployReleasedContract(\n    // 0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024 === deployer.thirdweb.eth\n    \"0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024\", contractName, constructorParams, version);\n  }\n\n  /**\n   * @internal\n   * @param contractType\n   */\n  async getLatestBuiltInContractVersion(contractType) {\n    const factory = await this.getFactory();\n    return await factory.getLatestVersion(contractType);\n  }\n\n  /**\n   * Deploy any released contract by its name\n   * @param releaserAddress the address of the releaser\n   * @param contractName the name of the contract to deploy\n   * @param constructorParams the constructor params to pass to the contract\n   */\n  async deployReleasedContract(releaserAddress, contractName, constructorParams) {\n    let version = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"latest\";\n    const release = await new ThirdwebSDK(\"polygon\").getPublisher().getVersion(releaserAddress, contractName, version);\n    if (!release) {\n      throw new Error(`No release found for '${contractName}' at version '${version}' by '${releaserAddress}'`);\n    }\n    return await this.deployContractFromUri(release.metadataUri, constructorParams);\n  }\n\n  /**\n   * Deploy a proxy contract of a given implementation via the given factory\n   * @param factoryAddress\n   * @param implementationAddress\n   * @param implementationAbi\n   * @param initializerFunction\n   * @param initializerArgs\n   */\n  async deployViaFactory(factoryAddress, implementationAddress, implementationAbi, initializerFunction, initializerArgs) {\n    const signer = this.getSigner();\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(signer, \"signer is required\");\n    // TODO only require factory interface here - IProxyFactory\n    const proxyFactory = new ContractFactory(factoryAddress, this.getSignerOrProvider(), this.storage, {});\n    return await proxyFactory.deployProxyByImplementation(implementationAddress, implementationAbi, initializerFunction, initializerArgs);\n  }\n\n  /**\n   * Deploy a proxy contract of a given implementation directly\n   * @param implementationAddress\n   * @param implementationAbi\n   * @param initializerFunction\n   * @param initializerArgs\n   */\n  async deployProxy(implementationAddress, implementationAbi, initializerFunction, initializerArgs) {\n    const encodedInitializer = ethers__WEBPACK_IMPORTED_MODULE_58__.Contract.getInterface(implementationAbi).encodeFunctionData(initializerFunction, initializerArgs);\n    const {\n      TWProxy__factory\n    } = await __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_contracts-js_factories_TWProxy__factory_dist_thirdweb-dev-contracts-a26ff3\").then(__webpack_require__.bind(__webpack_require__, /*! @thirdweb-dev/contracts-js/factories/TWProxy__factory */ \"./node_modules/@thirdweb-dev/contracts-js/factories/TWProxy__factory/dist/thirdweb-dev-contracts-js-factories-TWProxy__factory.esm.js\"));\n    return this.deployContractWithAbi(TWProxy__factory.abi, TWProxy__factory.bytecode, [implementationAddress, encodedInitializer]);\n  }\n\n  /**\n   * @internal\n   */\n  async getRegistry() {\n    // if we already have a registry just return it back\n    if (this._registry) {\n      return this._registry;\n    }\n\n    // otherwise get the registry address for the active chain and get a new one\n\n    // have to do it like this otherwise we run it over and over and over\n    // \"this._registry\" has to be assigned to the promise upfront.\n    return this._registry = this.getProvider().getNetwork().then(async _ref => {\n      let {\n        chainId\n      } = _ref;\n      const registryAddress = getContractAddressByChainId(chainId, \"twRegistry\");\n      return new ContractRegistry(registryAddress, this.getSignerOrProvider(), this.options);\n    });\n  }\n  async getFactory() {\n    // if we already have a factory just return it back\n    if (this._factory) {\n      return this._factory;\n    }\n\n    // otherwise get the factory address for the active chain and get a new one\n\n    // have to do it like this otherwise we run it over and over and over\n    // \"this._factory\" has to be assigned to the promise upfront.\n    return this._factory = this.getProvider().getNetwork().then(async _ref2 => {\n      let {\n        chainId\n      } = _ref2;\n      const factoryAddress = getContractAddressByChainId(chainId, \"twFactory\");\n      const factory = new ContractFactory(factoryAddress, this.getSignerOrProvider(), this.storage, this.options);\n      this.events = new FactoryEvents(factory);\n      return factory;\n    });\n  }\n  updateSignerOrProvider(network) {\n    super.updateSignerOrProvider(network);\n    this.updateContractSignerOrProvider();\n  }\n  updateContractSignerOrProvider() {\n    // has to be promises now\n    this._factory?.then(factory => {\n      factory.updateSignerOrProvider(this.getSignerOrProvider());\n    }).catch(() => {\n      // ignore\n    });\n    // has to be promises now\n    this._registry?.then(registry => {\n      registry.updateSignerOrProvider(this.getSignerOrProvider());\n    }).catch(() => {\n      // ignore\n    });\n  }\n\n  /**\n   * @internal\n   * @param publishMetadataUri\n   * @param constructorParamValues\n   * @param options\n   */\n  async deployContractFromUri(publishMetadataUri, constructorParamValues, options) {\n    const signer = this.getSigner();\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(signer, \"A signer is required\");\n    const compilerMetadata = await fetchPreDeployMetadata(publishMetadataUri, this.storage);\n    let isDeployableViaFactory;\n    let isDeployableViaProxy;\n    let factoryDeploymentData;\n    try {\n      const extendedMetadata = await fetchExtendedReleaseMetadata(publishMetadataUri, this.storage);\n      isDeployableViaFactory = extendedMetadata.isDeployableViaFactory;\n      isDeployableViaProxy = extendedMetadata.isDeployableViaProxy;\n      factoryDeploymentData = FactoryDeploymentSchema.parse(extendedMetadata.factoryDeploymentData);\n    } catch (e) {\n      // not a factory deployment, ignore\n    }\n    const forceDirectDeploy = options?.forceDirectDeploy || false;\n    if (factoryDeploymentData && (isDeployableViaProxy || isDeployableViaFactory) && !forceDirectDeploy) {\n      const chainId = (await this.getProvider().getNetwork()).chainId;\n      (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(factoryDeploymentData.implementationAddresses, \"implementationAddresses is required\");\n      const implementationAddress = factoryDeploymentData.implementationAddresses[chainId];\n      (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(implementationAddress, `implementationAddress not found for chainId '${chainId}'`);\n      (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(factoryDeploymentData.implementationInitializerFunction, `implementationInitializerFunction not set'`);\n      const initializerParamTypes = extractFunctionParamsFromAbi(compilerMetadata.abi, factoryDeploymentData.implementationInitializerFunction).map(p => p.type);\n      const paramValues = this.convertParamValues(initializerParamTypes, constructorParamValues);\n      if (isDeployableViaFactory) {\n        // deploy via a factory (prioritise factory)\n        (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(factoryDeploymentData.factoryAddresses, \"isDeployableViaFactory is true so factoryAddresses is required\");\n        const factoryAddress = factoryDeploymentData.factoryAddresses[chainId];\n        (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(factoryAddress, `isDeployableViaFactory is true and factoryAddress not found for chainId '${chainId}'`);\n        return await this.deployViaFactory(factoryAddress, implementationAddress, compilerMetadata.abi, factoryDeploymentData.implementationInitializerFunction, paramValues);\n      } else if (isDeployableViaProxy) {\n        // deploy a proxy directly\n        return await this.deployProxy(implementationAddress, compilerMetadata.abi, factoryDeploymentData.implementationInitializerFunction, paramValues);\n      }\n    }\n    const bytecode = compilerMetadata.bytecode.startsWith(\"0x\") ? compilerMetadata.bytecode : `0x${compilerMetadata.bytecode}`;\n    if (!ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.isHexString(bytecode)) {\n      throw new Error(`Contract bytecode is invalid.\\n\\n${bytecode}`);\n    }\n    const constructorParamTypes = extractConstructorParamsFromAbi(compilerMetadata.abi).map(p => p.type);\n    const paramValues = this.convertParamValues(constructorParamTypes, constructorParamValues);\n    return this.deployContractWithAbi(compilerMetadata.abi, bytecode, paramValues);\n  }\n  convertParamValues(constructorParamTypes, constructorParamValues) {\n    // check that both arrays are same length\n    if (constructorParamTypes.length !== constructorParamValues.length) {\n      throw Error(\"Passed the wrong number of constructor arguments\");\n    }\n    return constructorParamTypes.map((p, index) => {\n      if (p === \"tuple\" || p.endsWith(\"[]\")) {\n        if (typeof constructorParamValues[index] === \"string\") {\n          return JSON.parse(constructorParamValues[index]);\n        } else {\n          return constructorParamValues[index];\n        }\n      }\n      if (p === \"bytes32\") {\n        (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.isHexString(constructorParamValues[index]), `Could not parse bytes32 value. Expected valid hex string but got \"${constructorParamValues[index]}\".`);\n        return ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.hexZeroPad(constructorParamValues[index], 32);\n      }\n      if (p.startsWith(\"bytes\")) {\n        (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.utils.isHexString(constructorParamValues[index]), `Could not parse bytes value. Expected valid hex string but got \"${constructorParamValues[index]}\".`);\n        return constructorParamValues[index];\n      }\n      if (p.startsWith(\"uint\") || p.startsWith(\"int\")) {\n        return ethers__WEBPACK_IMPORTED_MODULE_58__.BigNumber.from(constructorParamValues[index].toString());\n      }\n      return constructorParamValues[index];\n    });\n  }\n\n  /**\n   * @internal\n   * @param abi\n   * @param bytecode\n   * @param constructorParams\n   */\n  async deployContractWithAbi(abi, bytecode, constructorParams) {\n    const signer = this.getSigner();\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(signer, \"Signer is required to deploy contracts\");\n    const deployer = await new ethers__WEBPACK_IMPORTED_MODULE_58__.ethers.ContractFactory(abi, bytecode).connect(signer).deploy(...constructorParams);\n    const deployedContract = await deployer.deployed();\n    // TODO parse transaction receipt\n    return deployedContract.address;\n  }\n}\n\n/**\n * Encodes and decodes Contract functions\n * @public\n */\nclass ContractOwner {\n  constructor(contractWrapper) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"featureName\", FEATURE_OWNER.name);\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Return the current owner of the contract\n   * @returns the owner address\n   */\n  async get() {\n    return this.contractWrapper.readContract.owner();\n  }\n\n  /**\n   * Set the new owner of the contract\n   * @remarks Can only be called by the current owner.\n   *\n   * @param address - the address of the new owner\n   *\n   * @example\n   * ```javascript\n   * await contract.owner.set(\"0x1234567890123456789012345678901234567890\");\n   * ```\n   */\n  async set(address) {\n    return {\n      receipt: await this.contractWrapper.sendTransaction(\"setOwner\", [address])\n    };\n  }\n}\n\nconst PAPER_API_BASE = `https://paper.xyz/api`;\nconst PAPER_API_VERSION = `2022-08-12`;\n\n/**\n * @internal\n */\nconst PAPER_API_URL = `${PAPER_API_BASE}/${PAPER_API_VERSION}/platform/thirdweb`;\nconst PAPER_CHAIN_ID_MAP = {\n  [ChainId.Mainnet]: \"Ethereum\",\n  [ChainId.Goerli]: \"Goerli\",\n  [ChainId.Polygon]: \"Polygon\",\n  [ChainId.Mumbai]: \"Mumbai\",\n  [ChainId.Avalanche]: \"Avalanche\"\n};\n\n/**\n * @internal\n */\nfunction parseChainIdToPaperChain(chainId) {\n  (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(chainId in PAPER_CHAIN_ID_MAP, `chainId not supported by paper: ${chainId}`);\n  return PAPER_CHAIN_ID_MAP[chainId];\n}\n/**\n *\n * @param contractAddress\n * @param chainId\n * @internal\n * @returns the paper xyz contract id\n * @throws if the contract is not registered on paper xyz\n */\nasync function fetchRegisteredCheckoutId(contractAddress, chainId) {\n  const paperChain = parseChainIdToPaperChain(chainId);\n  const res = await fetch(`${PAPER_API_URL}/register-contract?contractAddress=${contractAddress}&chain=${paperChain}`);\n  const json = await res.json();\n  (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(json.result.id, \"Contract is not registered with paper\");\n  return json.result.id;\n}\n\n/**\n * The parameters for creating a paper.xyz checkout link.\n * @public\n */\n\nconst DEFAULT_PARAMS = {\n  expiresInMinutes: 15,\n  feeBearer: \"BUYER\",\n  sendEmailOnSuccess: true,\n  redirectAfterPayment: false\n};\n\n/**\n * @internal\n */\nasync function createCheckoutLinkIntent(contractId, params) {\n  const res = await fetch(`${PAPER_API_URL}/checkout-link-intent`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      contractId,\n      ...DEFAULT_PARAMS,\n      ...params,\n      metadata: {\n        ...params.metadata,\n        via_platform: \"thirdweb\"\n      },\n      // overrides that are hard coded\n      hideNativeMint: true,\n      hidePaperWallet: !!params.walletAddress,\n      hideExternalWallet: true,\n      hidePayWithCrypto: true,\n      usePaperKey: false\n    })\n  });\n  const json = await res.json();\n  (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(json.checkoutLinkIntentUrl, \"Failed to create checkout link intent\");\n  return json.checkoutLinkIntentUrl;\n}\n\n/**\n * @internal\n */\nclass PaperCheckout {\n  constructor(contractWrapper) {\n    (0,_defineProperty_e24c82ea_esm_js__WEBPACK_IMPORTED_MODULE_61__._)(this, \"contractWrapper\", void 0);\n    this.contractWrapper = contractWrapper;\n  }\n  async getCheckoutId() {\n    return fetchRegisteredCheckoutId(this.contractWrapper.readContract.address, await this.contractWrapper.getChainID());\n  }\n  async isEnabled() {\n    try {\n      return !!(await this.getCheckoutId());\n    } catch (err) {\n      return false;\n    }\n  }\n  async createLinkIntent(params) {\n    return await createCheckoutLinkIntent(await this.getCheckoutId(), params);\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi9zZGsvZGlzdC90aGlyZHdlYi1jaGVja291dC1hYTc4NjlmNy5lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0I7QUFDbVM7QUFDblA7QUFDa0I7QUFDaEI7QUFDQTtBQUNFO0FBQ3JDO0FBQ3dEO0FBQ3REO0FBQ1A7QUFDNkM7QUFDTTtBQUNJO0FBQ3JCO0FBQ3NCO0FBQ0s7QUFDdkI7QUFDaUI7QUFDVDtBQUNtQjtBQUNaO0FBQ0k7QUFDRDtBQUNGO0FBQ007QUFDUjtBQUNQO0FBQ1k7QUFDUztBQUNNO0FBQ25CO0FBQ0U7QUFDSTtBQUNEO0FBQ047QUFDWTtBQUNNO0FBQ1I7QUFDSDtBQUNVO0FBQy9FO0FBQ2dFO0FBQzlDO0FBQ0Y7QUFDZDtBQUNnRTtBQUNFO0FBQ0c7QUFDaEI7QUFDRTtBQUNjO0FBQ3ZDO0FBQ2tDO0FBQ2xCO0FBQ3VCO0FBQ1Y7QUFDb0I7QUFDWjtBQUNBO0FBQ1I7QUFDVDs7QUFFNUUsd0JBQXdCLHlDQUFPLEVBQUUsMENBQVEsSUFBSSwwQ0FBUSxJQUFJLDBDQUFRLElBQUksMENBQVE7QUFDN0UsU0FBUywwREFBcUI7QUFDOUIsQ0FBQyxxQkFBcUIsbURBQWM7QUFDcEM7QUFDQSxpQ0FBaUMseUNBQU8sRUFBRSwwQ0FBUSxJQUFJ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LENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBDQUFRO0FBQ3JDLFFBQVEsMENBQVE7QUFDaEIsZUFBZSwwQ0FBUTtBQUN2QixTQUFTLHFFQUFtQztBQUM1QyxpQkFBaUIsMENBQVE7QUFDekIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwQ0FBUTtBQUNqQixDQUFDLFdBQVcsMkNBQVM7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQ0FBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1RUFBeUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywwREFBcUI7QUFDNUQsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMENBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwQ0FBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUVBQXlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwwREFBcUI7QUFDckUsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMENBQVE7QUFDN0Msc0JBQXNCLHlDQUFPO0FBQzdCLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBDQUFRO0FBQ25DLFVBQVUsMENBQVE7QUFDbEIsQ0FBQzs7QUFFRCx3QkFBd0IsMENBQVEsR0FBRyxXQUFXLHlDQUFPLDRCQUE0QiwyQ0FBUzs7QUFFMUY7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlDQUFPLEVBQUUseUNBQU87O0FBRWhEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwwQ0FBUTtBQUNyQztBQUNBLFVBQVUsNERBQVk7QUFDdEIsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBDQUFRO0FBQzVDO0FBQ0EsWUFBWSw0REFBZTtBQUMzQixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwQ0FBUTtBQUNqQjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBDQUFRO0FBQzNDO0FBQ0EsWUFBWSw0REFBYztBQUMxQixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywwQ0FBUTtBQUNoRDtBQUNBLFlBQVksNERBQW1CO0FBQy9CLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjs7QUFFaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQXFCO0FBQ3pDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQXFCO0FBQ3pDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQXFCO0FBQ3pDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQXFCO0FBQ3pDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMERBQXFCO0FBQzVDO0FBQ0E7QUFDQSxvQkFBb0IsMERBQXFCO0FBQ3pDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQXFCO0FBQ3pDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMERBQXFCO0FBQzVDO0FBQ0E7QUFDQSxvQkFBb0IsMERBQXFCO0FBQ3pDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwREFBcUI7QUFDekM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwREFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNB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QztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFV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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQixPQUFPLG1CQUFtQixPQUFPLG1CQUFtQjtBQUMzRzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFlBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsdUJB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4REFBeUI7QUFDdEQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1FQUFlO0FBQ25CLElBQUksbUVBQWU7QUFDbkIsSUFBSSxtRUFBZTtBQUNuQixJQUFJLG1FQUFlO0FBQ25CLElBQUksbUVBQWU7QUFDbkIsSUFBSSxtRUFBZTtBQUNuQixJQUFJLG1FQUFlO0FBQ25CLElBQUksbUVBQWU7QUFDbkIsSUFBSSxtRUFBZTtBQUNuQixJQUFJLG1FQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRiwwREFBcUI7QUFDeEc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsdUdBQXVHLG1EQUFjO0FBQ3JIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDRCQUE0QjtBQUM1QixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw0QkFBNEI7QUFDNUIsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQywwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnRUFBZ0U7QUFDaEUseUNBQXlDO0FBQ3pDLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxtQ0FBbUM7QUFDbkMseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQixHQUFHO0FBQzNDLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLG1DQUFtQztBQUNuQyx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQkFBa0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUVBQWU7QUFDbkIsSUFBSSxtRUFBZTtBQUNuQixJQUFJLG1FQUFlO0FBQ25CLElBQUksbUVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMENBQVE7QUFDcEM7QUFDQSxZQUFZLHVFQUFvQjtBQUNoQyxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5Q0FBTyxFQUFFLHlDQUFPLENBQUMsMENBQVE7QUFDcEQ7QUFDQSxDQUFDLEtBQUsseUNBQU87O0FBRWI7QUFDQTtBQUNBLElBQUksbUVBQWU7QUFDbkIsSUFBSSxtRUFBZTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUVBQWU7QUFDbkIsSUFBSSxtRUFBZTtBQUNuQixJQUFJLG1FQUFlO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbURBQWM7QUFDaEMsa0JBQWtCLG1EQUFjLHVCQUF1Qiw0REFBdUI7QUFDOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFlLFVBQVUsd0ZBQW9CO0FBQ3RFLCtDQUErQyw4REFBeUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUVBQWU7QUFDbkIsSUFBSSxtRUFBZTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0IsR0FBRztBQUMzQyx3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1FQUFlO0FBQ25CLElBQUksbUVBQWU7QUFDbkIsSUFBSSxtRUFBZTtBQUNuQixJQUFJLG1FQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCLEdBQUc7QUFDM0Msd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLG1FQUFlO0FBQ25CLElBQUksbUVBQWU7QUFDbkIsSUFBSSxtRUFBZTtBQUNuQixJQUFJLG1FQUFlO0FBQ25CLElBQUksbUVBQWU7QUFDbkIsSUFBSSxtRUFBZTtBQUNuQixJQUFJLG1FQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxpRUFBaUU7QUFDakUseUNBQXlDO0FBQ3pDLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBLGtIQUFrSCxRQUFRLGFBQWEsSUFBSTtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLHFDQUFxQyxRQUFRLEdBQUc7QUFDekksTUFBTTtBQUNOO0FBQ0EseUZBQXlGLHFDQUFxQyxRQUFRLEdBQUcsR0FBRyw2REFBd0I7QUFDcEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQkFBcUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUVBQWU7QUFDbkIsSUFBSSxtRUFBZTtBQUNuQixJQUFJLG1FQUFlO0FBQ25CLElBQUksbUVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ047QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJIQUEySCxnRUFBMkI7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksbUVBQWU7QUFDbkIsSUFBSSxtRUFBZTtBQUNuQixJQUFJLG1FQUFlO0FBQ25CLElBQUksbUVBQWU7QUFDbkIsSUFBSSxtRUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNEJBQTRCO0FBQzVCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxnRUFBMkI7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1EQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtRUFBZTtBQUNuQixJQUFJLG1FQUFlO0FBQ25CLElBQUksbUVBQWU7QUFDbkIsSUFBSSxtRUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1EQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnRUFBMkI7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdFQUEyQjtBQUMxQyxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUVBQWU7QUFDbkIsSUFBSSxtRUFBZTtBQUNuQixJQUFJLG1FQUFlO0FBQ25CLElBQUksbUVBQWU7QUFDbkIsSUFBSSxtRUFBZTtBQUNuQixJQUFJLG1FQUFlO0FBQ25CLElBQUksbUVBQWU7QUFDbkIsSUFBSSxtRUFBZTtBQUNuQixJQUFJLG1FQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUhBQXFILG1EQUFjO0FBQ25JO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsaUVBQTRCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5Qyx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUMsMEJBQTBCO0FBQzFCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5Q0FBeUMsc0JBQXNCLDZCQUE2QixnQkFBZ0I7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDRCQUE0QjtBQUM1QixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNEJBQTRCO0FBQzVCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTjtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQywwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsTUFBTTtBQUNOO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGlFQUFpRTtBQUNqRSx5Q0FBeUM7QUFDekMsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RUFBZTtBQUNuQixJQUFJLG1FQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLG1CQUFtQjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLG1CQUFtQjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLG1CQUFtQjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLG1CQUFtQjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLG1CQUFtQjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLG1CQUFtQjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLG1CQUFtQjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLG1CQUFtQjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLG1CQUFtQjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLG1CQUFtQjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThG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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFB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O0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThnTiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi9zZGsvZGlzdC90aGlyZHdlYi1jaGVja291dC1hYTc4NjlmNy5lc20uanM/ODA3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB6IH0gZnJvbSAnem9kJztcbmltcG9ydCB7IFEgYXMgUXVhbnRpdHlTY2hlbWEsIEEgYXMgQW1vdW50U2NoZW1hLCBCIGFzIEJ5dGVzTGlrZVNjaGVtYSwgTiBhcyBORlRJbnB1dE9yVXJpU2NoZW1hLCBhIGFzIEJhc2lzUG9pbnRzU2NoZW1hLCBGIGFzIEZpbGVPckJ1ZmZlck9yU3RyaW5nU2NoZW1hLCBDIGFzIENvbW1vbk5GVE91dHB1dCwgYiBhcyBDb21tb25ORlRJbnB1dCwgZyBhcyBnZXRScGNVcmwsIFAgYXMgUGVyY2VudFNjaGVtYSwgRCBhcyBERUZBVUxUX1FVRVJZX0FMTF9DT1VOVCwgTSBhcyBNQVhfQlBTIH0gZnJvbSAnLi9RdWVyeVBhcmFtcy1hYzAxNDljNi5lc20uanMnO1xuaW1wb3J0IHsgXyBhcyBfZGVmaW5lUHJvcGVydHkgfSBmcm9tICcuL2RlZmluZVByb3BlcnR5LWUyNGM4MmVhLmVzbS5qcyc7XG5pbXBvcnQgeyBCaWdOdW1iZXIsIHV0aWxzLCBldGhlcnMsIGNvbnN0YW50cywgcHJvdmlkZXJzLCBDb250cmFjdCwgU2lnbmVyIH0gZnJvbSAnZXRoZXJzJztcbmltcG9ydCBFUkMxNjVBYmkgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lFUkMxNjUuanNvbic7XG5pbXBvcnQgRXJjNzIxQWJpIGZyb20gJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JRVJDNzIxLmpzb24nO1xuaW1wb3J0IEVyYzExNTVBYmkgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lFUkMxMTU1Lmpzb24nO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICd0aW55LWludmFyaWFudCc7XG5pbXBvcnQgSVRoaXJkd2ViQ29udHJhY3RBQkkgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lUaGlyZHdlYkNvbnRyYWN0Lmpzb24nO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCBmZXRjaCQxIGZyb20gJ2Nyb3NzLWZldGNoJztcbmltcG9ydCBGb3J3YXJkZXJBQkkgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0ZvcndhcmRlci5qc29uJztcbmltcG9ydCBEcm9wRVJDMjBfVjJBYmkgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0Ryb3BFUkMyMF9WMi5qc29uJztcbmltcG9ydCBJQnVybmFibGVFUkMyMEFiaSBmcm9tICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSUJ1cm5hYmxlRVJDMjAuanNvbic7XG5pbXBvcnQgSURyb3AgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lEcm9wLmpzb24nO1xuaW1wb3J0IElEcm9wU2luZ2xlUGhhc2UgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lEcm9wU2luZ2xlUGhhc2UuanNvbic7XG5pbXBvcnQgSURyb3BTaW5nbGVQaGFzZVYxIGZyb20gJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JRHJvcFNpbmdsZVBoYXNlX1YxLmpzb24nO1xuaW1wb3J0IEVSQzIwQWJpIGZyb20gJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JRVJDMjAuanNvbic7XG5pbXBvcnQgSU1pbnRhYmxlRVJDMjBBYmkgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lNaW50YWJsZUVSQzIwLmpzb24nO1xuaW1wb3J0IE11bHRpY2FsbEFiaSBmcm9tICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSU11bHRpY2FsbC5qc29uJztcbmltcG9ydCBJU2lnbmF0dXJlTWludEVSQzIwQWJpIGZyb20gJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JU2lnbmF0dXJlTWludEVSQzIwLmpzb24nO1xuaW1wb3J0IERyb3BFUkM3MjFfVjNBYmkgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0Ryb3BFUkM3MjFfVjMuanNvbic7XG5pbXBvcnQgSUJ1cm5hYmxlRVJDNzIxQWJpIGZyb20gJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JQnVybmFibGVFUkM3MjEuanNvbic7XG5pbXBvcnQgSUNsYWltYWJsZUVSQzcyMSBmcm9tICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSUNsYWltYWJsZUVSQzcyMS5qc29uJztcbmltcG9ydCBEZWxheWVkUmV2ZWFsQWJpIGZyb20gJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JRGVsYXllZFJldmVhbC5qc29uJztcbmltcG9ydCBFcmM3MjFFbnVtZXJhYmxlQWJpIGZyb20gJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JRVJDNzIxRW51bWVyYWJsZS5qc29uJztcbmltcG9ydCBFcmM3MjFTdXBwbHlBYmkgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lFUkM3MjFTdXBwbHkuanNvbic7XG5pbXBvcnQgSUxhenlNaW50QWJpIGZyb20gJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JTGF6eU1pbnQuanNvbic7XG5pbXBvcnQgSU1pbnRhYmxlRVJDNzIxQWJpIGZyb20gJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JTWludGFibGVFUkM3MjEuanNvbic7XG5pbXBvcnQgU2lnbmF0dXJlTWludEVSQzcyMUFiaSBmcm9tICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSVNpZ25hdHVyZU1pbnRFUkM3MjEuanNvbic7XG5pbXBvcnQgU2lnbmF0dXJlTWludEVSQzcyMV9WMUFiaSBmcm9tICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSVNpZ25hdHVyZU1pbnRFUkM3MjFfVjEuanNvbic7XG5pbXBvcnQgVGllcmVkRHJvcEFiaSBmcm9tICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvTGF6eU1pbnRXaXRoVGllci5qc29uJztcbmltcG9ydCBEcm9wRVJDMTE1NV9WMkFiaSBmcm9tICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvRHJvcEVSQzExNTVfVjIuanNvbic7XG5pbXBvcnQgSUJ1cm5hYmxlRVJDMTE1NUFiaSBmcm9tICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSUJ1cm5hYmxlRVJDMTE1NS5qc29uJztcbmltcG9ydCBJQ2xhaW1hYmxlRVJDMTE1NSBmcm9tICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSUNsYWltYWJsZUVSQzExNTUuanNvbic7XG5pbXBvcnQgSURyb3BNdWx0aVBoYXNlMTE1NSBmcm9tICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSURyb3AxMTU1Lmpzb24nO1xuaW1wb3J0IElEcm9wU2luZ2xlUGhhc2UxMTU1IGZyb20gJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JRHJvcFNpbmdsZVBoYXNlMTE1NS5qc29uJztcbmltcG9ydCBJRHJvcFNpbmdsZVBoYXNlMTE1NV9WMSBmcm9tICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSURyb3BTaW5nbGVQaGFzZTExNTVfVjEuanNvbic7XG5pbXBvcnQgRXJjMTE1NUVudW1lcmFibGVBYmkgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lFUkMxMTU1RW51bWVyYWJsZS5qc29uJztcbmltcG9ydCBJTWludGFibGVFUkMxMTU1QWJpIGZyb20gJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JTWludGFibGVFUkMxMTU1Lmpzb24nO1xuaW1wb3J0IElTaWduYXR1cmVNaW50RVJDMTE1NUFiaSBmcm9tICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSVNpZ25hdHVyZU1pbnRFUkMxMTU1Lmpzb24nO1xuaW1wb3J0IGJzNTggZnJvbSAnYnM1OCc7XG5pbXBvcnQgRVJDMjBNZXRhZGF0YUFiaSBmcm9tICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSUVSQzIwTWV0YWRhdGEuanNvbic7XG5pbXBvcnQgeyBNZXJrbGVUcmVlIH0gZnJvbSAnbWVya2xldHJlZWpzJztcbmltcG9ydCBkZWVwRXF1YWwgZnJvbSAnZmFzdC1kZWVwLWVxdWFsJztcbmltcG9ydCB7IHY0IH0gZnJvbSAndXVpZCc7XG5pbXBvcnQgRVJDNzIxTWV0YWRhdGFBYmkgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lFUkM3MjFNZXRhZGF0YS5qc29uJztcbmltcG9ydCBFUkMxMTU1TWV0YWRhdGFBYmkgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lFUkMxMTU1TWV0YWRhdGEuanNvbic7XG5pbXBvcnQgRGVwcmVjYXRlZEFiaSBmcm9tICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSURlbGF5ZWRSZXZlYWxEZXByZWNhdGVkLmpzb24nO1xuaW1wb3J0IFRXRmFjdG9yeUFiaSBmcm9tICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvVFdGYWN0b3J5Lmpzb24nO1xuaW1wb3J0IFRXUmVnaXN0cnlBQkkgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL1RXUmVnaXN0cnkuanNvbic7XG5pbXBvcnQgQ29udHJhY3RQdWJsaXNoZXJBYmkgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0NvbnRyYWN0UHVibGlzaGVyLmpzb24nO1xuaW1wb3J0IHsgVGhpcmR3ZWJTdG9yYWdlIH0gZnJvbSAnQHRoaXJkd2ViLWRldi9zdG9yYWdlJztcbmltcG9ydCBJRVJDMjc3MUNvbnRleHRBYmkgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0VSQzI3NzFDb250ZXh0Lmpzb24nO1xuaW1wb3J0IElBcHBVUkkgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lBcHBVUkkuanNvbic7XG5pbXBvcnQgSUNvbnRyYWN0TWV0YWRhdGFBYmkgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lDb250cmFjdE1ldGFkYXRhLmpzb24nO1xuaW1wb3J0IElQZXJtaXNzaW9uc0FiaSBmcm9tICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSVBlcm1pc3Npb25zLmpzb24nO1xuaW1wb3J0IElQZXJtaXNzaW9uc0VudW1lcmFibGVBYmkgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lQZXJtaXNzaW9uc0VudW1lcmFibGUuanNvbic7XG5pbXBvcnQgSVRoaXJkd2ViUGxhdGZvcm1GZWVBYmkgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lQbGF0Zm9ybUZlZS5qc29uJztcbmltcG9ydCBJVGhpcmR3ZWJQcmltYXJ5U2FsZUFiaSBmcm9tICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSVByaW1hcnlTYWxlLmpzb24nO1xuaW1wb3J0IElUaGlyZHdlYlJveWFsdHlBYmkgZnJvbSAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lSb3lhbHR5Lmpzb24nO1xuaW1wb3J0IElPd25hYmxlQWJpIGZyb20gJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9Pd25hYmxlLmpzb24nO1xuXG5jb25zdCBCaWdOdW1iZXJTY2hlbWEgPSB6LnVuaW9uKFt6LnN0cmluZygpLCB6Lm51bWJlcigpLCB6LmJpZ2ludCgpLCB6LmN1c3RvbShkYXRhID0+IHtcbiAgcmV0dXJuIEJpZ051bWJlci5pc0JpZ051bWJlcihkYXRhKTtcbn0pXSkudHJhbnNmb3JtKGFyZyA9PiBCaWdOdW1iZXIuZnJvbShhcmcpKTtcbmNvbnN0IEJpZ051bWJlcmlzaFNjaGVtYSA9IEJpZ051bWJlclNjaGVtYS50cmFuc2Zvcm0oYXJnID0+IGFyZy50b1N0cmluZygpKTtcbmNvbnN0IEJpZ051bWJlclRyYW5zZm9ybVNjaGVtYSA9IHoudW5pb24oW3ouYmlnaW50KCksIHouY3VzdG9tKGRhdGEgPT4ge1xuICByZXR1cm4gQmlnTnVtYmVyLmlzQmlnTnVtYmVyKGRhdGEpO1xufSldKS50cmFuc2Zvcm0oYXJnID0+IHtcbiAgcmV0dXJuIEJpZ051bWJlci5mcm9tKGFyZykudG9TdHJpbmcoKTtcbn0pO1xuY29uc3QgQWRkcmVzc1NjaGVtYSA9IHouc3RyaW5nKCkucmVmaW5lKGFyZyA9PiB1dGlscy5pc0FkZHJlc3MoYXJnKSwgb3V0ID0+IHtcbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlOiBgJHtvdXR9IGlzIG5vdCBhIHZhbGlkIGFkZHJlc3NgXG4gIH07XG59KTtcbmNvbnN0IFJhd0RhdGVTY2hlbWEgPSB6LmRhdGUoKS50cmFuc2Zvcm0oaSA9PiB7XG4gIHJldHVybiBCaWdOdW1iZXIuZnJvbShNYXRoLmZsb29yKGkuZ2V0VGltZSgpIC8gMTAwMCkpO1xufSk7XG5cbi8qKlxuICogRGVmYXVsdCB0byBub3dcbiAqL1xuY29uc3QgU3RhcnREYXRlU2NoZW1hID0gUmF3RGF0ZVNjaGVtYS5kZWZhdWx0KG5ldyBEYXRlKDApKTtcblxuLyoqXG4gKiBEZWZhdWx0IHRvIDEwIHllYXJzIGZyb20gbm93XG4gKi9cbmNvbnN0IEVuZERhdGVTY2hlbWEgPSBSYXdEYXRlU2NoZW1hLmRlZmF1bHQobmV3IERhdGUoRGF0ZS5ub3coKSArIDEwMDAgKiA2MCAqIDYwICogMjQgKiAzNjUgKiAxMCkpO1xuY29uc3QgQ2FsbE92ZXJyaWRlU2NoZW1hID0gei5vYmplY3Qoe1xuICBnYXNMaW1pdDogQmlnTnVtYmVyaXNoU2NoZW1hLm9wdGlvbmFsKCksXG4gIGdhc1ByaWNlOiBCaWdOdW1iZXJpc2hTY2hlbWEub3B0aW9uYWwoKSxcbiAgbWF4RmVlUGVyR2FzOiBCaWdOdW1iZXJpc2hTY2hlbWEub3B0aW9uYWwoKSxcbiAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IEJpZ051bWJlcmlzaFNjaGVtYS5vcHRpb25hbCgpLFxuICBub25jZTogQmlnTnVtYmVyaXNoU2NoZW1hLm9wdGlvbmFsKCksXG4gIHZhbHVlOiBCaWdOdW1iZXJpc2hTY2hlbWEub3B0aW9uYWwoKSxcbiAgYmxvY2tUYWc6IHoudW5pb24oW3ouc3RyaW5nKCksIHoubnVtYmVyKCldKS5vcHRpb25hbCgpLFxuICBmcm9tOiBBZGRyZXNzU2NoZW1hLm9wdGlvbmFsKCksXG4gIHR5cGU6IHoubnVtYmVyKCkub3B0aW9uYWwoKVxufSkuc3RyaWN0KCk7XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5sZXQgQ2hhaW5JZDtcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbihmdW5jdGlvbiAoQ2hhaW5JZCkge1xuICBDaGFpbklkW0NoYWluSWRbXCJNYWlubmV0XCJdID0gMV0gPSBcIk1haW5uZXRcIjtcbiAgQ2hhaW5JZFtDaGFpbklkW1wiR29lcmxpXCJdID0gNV0gPSBcIkdvZXJsaVwiO1xuICBDaGFpbklkW0NoYWluSWRbXCJQb2x5Z29uXCJdID0gMTM3XSA9IFwiUG9seWdvblwiO1xuICBDaGFpbklkW0NoYWluSWRbXCJNdW1iYWlcIl0gPSA4MDAwMV0gPSBcIk11bWJhaVwiO1xuICBDaGFpbklkW0NoYWluSWRbXCJMb2NhbGhvc3RcIl0gPSAxMzM3XSA9IFwiTG9jYWxob3N0XCI7XG4gIENoYWluSWRbQ2hhaW5JZFtcIkhhcmRoYXRcIl0gPSAzMTMzN10gPSBcIkhhcmRoYXRcIjtcbiAgQ2hhaW5JZFtDaGFpbklkW1wiRmFudG9tXCJdID0gMjUwXSA9IFwiRmFudG9tXCI7XG4gIENoYWluSWRbQ2hhaW5JZFtcIkZhbnRvbVRlc3RuZXRcIl0gPSA0MDAyXSA9IFwiRmFudG9tVGVzdG5ldFwiO1xuICBDaGFpbklkW0NoYWluSWRbXCJBdmFsYW5jaGVcIl0gPSA0MzExNF0gPSBcIkF2YWxhbmNoZVwiO1xuICBDaGFpbklkW0NoYWluSWRbXCJBdmFsYW5jaGVGdWppVGVzdG5ldFwiXSA9IDQzMTEzXSA9IFwiQXZhbGFuY2hlRnVqaVRlc3RuZXRcIjtcbiAgQ2hhaW5JZFtDaGFpbklkW1wiT3B0aW1pc21cIl0gPSAxMF0gPSBcIk9wdGltaXNtXCI7XG4gIENoYWluSWRbQ2hhaW5JZFtcIk9wdGltaXNtR29lcmxpXCJdID0gNDIwXSA9IFwiT3B0aW1pc21Hb2VybGlcIjtcbiAgQ2hhaW5JZFtDaGFpbklkW1wiQXJiaXRydW1cIl0gPSA0MjE2MV0gPSBcIkFyYml0cnVtXCI7XG4gIENoYWluSWRbQ2hhaW5JZFtcIkFyYml0cnVtR29lcmxpXCJdID0gNDIxNjEzXSA9IFwiQXJiaXRydW1Hb2VybGlcIjtcbiAgQ2hhaW5JZFtDaGFpbklkW1wiQmluYW5jZVNtYXJ0Q2hhaW5NYWlubmV0XCJdID0gNTZdID0gXCJCaW5hbmNlU21hcnRDaGFpbk1haW5uZXRcIjtcbiAgQ2hhaW5JZFtDaGFpbklkW1wiQmluYW5jZVNtYXJ0Q2hhaW5UZXN0bmV0XCJdID0gOTddID0gXCJCaW5hbmNlU21hcnRDaGFpblRlc3RuZXRcIjtcbn0pKENoYWluSWQgfHwgKENoYWluSWQgPSB7fSkpO1xuLyoqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IFNVUFBPUlRFRF9DSEFJTl9JRFMgPSBbQ2hhaW5JZC5NYWlubmV0LCBDaGFpbklkLkdvZXJsaSwgQ2hhaW5JZC5Qb2x5Z29uLCBDaGFpbklkLk11bWJhaSwgQ2hhaW5JZC5GYW50b20sIENoYWluSWQuRmFudG9tVGVzdG5ldCwgQ2hhaW5JZC5BdmFsYW5jaGUsIENoYWluSWQuQXZhbGFuY2hlRnVqaVRlc3RuZXQsIENoYWluSWQuT3B0aW1pc20sIENoYWluSWQuT3B0aW1pc21Hb2VybGksIENoYWluSWQuQXJiaXRydW0sIENoYWluSWQuQXJiaXRydW1Hb2VybGksIENoYWluSWQuQmluYW5jZVNtYXJ0Q2hhaW5NYWlubmV0LCBDaGFpbklkLkJpbmFuY2VTbWFydENoYWluVGVzdG5ldF07XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBOQVRJVkVfVE9LRU5fQUREUkVTUyA9IFwiMHhlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlXCI7XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBOQVRJVkVfVE9LRU5TID0ge1xuICBbQ2hhaW5JZC5NYWlubmV0XToge1xuICAgIG5hbWU6IFwiRXRoZXJcIixcbiAgICBzeW1ib2w6IFwiRVRIXCIsXG4gICAgZGVjaW1hbHM6IDE4LFxuICAgIHdyYXBwZWQ6IHtcbiAgICAgIGFkZHJlc3M6IFwiMHhDMDJhYUEzOWIyMjNGRThEMEEwZTVDNEYyN2VBRDkwODNDNzU2Q2MyXCIsXG4gICAgICBuYW1lOiBcIldyYXBwZWQgRXRoZXJcIixcbiAgICAgIHN5bWJvbDogXCJXRVRIXCJcbiAgICB9XG4gIH0sXG4gIFtDaGFpbklkLkdvZXJsaV06IHtcbiAgICBuYW1lOiBcIkfDtnJsaSBFdGhlclwiLFxuICAgIHN5bWJvbDogXCJHT1JcIixcbiAgICBkZWNpbWFsczogMTgsXG4gICAgd3JhcHBlZDoge1xuICAgICAgYWRkcmVzczogXCIweGI0ZmJmMjcxMTQzZjRmYmY3YjkxYTVkZWQzMTgwNWU0MmIyMjA4ZDZcIixcbiAgICAgIG5hbWU6IFwiV3JhcHBlZCBFdGhlclwiLFxuICAgICAgc3ltYm9sOiBcIldFVEhcIlxuICAgIH1cbiAgfSxcbiAgW0NoYWluSWQuUG9seWdvbl06IHtcbiAgICBuYW1lOiBcIk1hdGljXCIsXG4gICAgc3ltYm9sOiBcIk1BVElDXCIsXG4gICAgZGVjaW1hbHM6IDE4LFxuICAgIHdyYXBwZWQ6IHtcbiAgICAgIGFkZHJlc3M6IFwiMHgwZDUwMEIxZDhFOGVGMzFFMjFDOTlkMURiOUE2NDQ0ZDNBRGYxMjcwXCIsXG4gICAgICBuYW1lOiBcIldyYXBwZWQgTWF0aWNcIixcbiAgICAgIHN5bWJvbDogXCJXTUFUSUNcIlxuICAgIH1cbiAgfSxcbiAgW0NoYWluSWQuTXVtYmFpXToge1xuICAgIG5hbWU6IFwiTWF0aWNcIixcbiAgICBzeW1ib2w6IFwiTUFUSUNcIixcbiAgICBkZWNpbWFsczogMTgsXG4gICAgd3JhcHBlZDoge1xuICAgICAgYWRkcmVzczogXCIweDljM0M5MjgzRDNlNDQ4NTQ2OTdDZDIyRDNGYWEyNDBDZmIwMzI4ODlcIixcbiAgICAgIG5hbWU6IFwiV3JhcHBlZCBNYXRpY1wiLFxuICAgICAgc3ltYm9sOiBcIldNQVRJQ1wiXG4gICAgfVxuICB9LFxuICBbQ2hhaW5JZC5BdmFsYW5jaGVdOiB7XG4gICAgbmFtZTogXCJBdmFsYW5jaGVcIixcbiAgICBzeW1ib2w6IFwiQVZBWFwiLFxuICAgIGRlY2ltYWxzOiAxOCxcbiAgICB3cmFwcGVkOiB7XG4gICAgICBhZGRyZXNzOiBcIjB4QjMxZjY2QUEzQzFlNzg1MzYzRjA4NzVBMUI3NEUyN2I4NUZENjZjN1wiLFxuICAgICAgbmFtZTogXCJXcmFwcGVkIEFWQVhcIixcbiAgICAgIHN5bWJvbDogXCJXQVZBWFwiXG4gICAgfVxuICB9LFxuICBbQ2hhaW5JZC5BdmFsYW5jaGVGdWppVGVzdG5ldF06IHtcbiAgICBuYW1lOiBcIkF2YWxhbmNoZVwiLFxuICAgIHN5bWJvbDogXCJBVkFYXCIsXG4gICAgZGVjaW1hbHM6IDE4LFxuICAgIHdyYXBwZWQ6IHtcbiAgICAgIGFkZHJlc3M6IFwiMHhkMDBhZTA4NDAzQjliYmI5MTI0YkIzMDVDMDkwNThFMzJDMzlBNDhjXCIsXG4gICAgICBuYW1lOiBcIldyYXBwZWQgQVZBWFwiLFxuICAgICAgc3ltYm9sOiBcIldBVkFYXCJcbiAgICB9XG4gIH0sXG4gIFtDaGFpbklkLkZhbnRvbV06IHtcbiAgICBuYW1lOiBcIkZhbnRvbVwiLFxuICAgIHN5bWJvbDogXCJGVE1cIixcbiAgICBkZWNpbWFsczogMTgsXG4gICAgd3JhcHBlZDoge1xuICAgICAgYWRkcmVzczogXCIweDIxYmUzNzBENTMxMmY0NGNCNDJjZTM3N0JDOWI4YTBjRUYxQTRDODNcIixcbiAgICAgIG5hbWU6IFwiV3JhcHBlZCBGYW50b21cIixcbiAgICAgIHN5bWJvbDogXCJXRlRNXCJcbiAgICB9XG4gIH0sXG4gIFtDaGFpbklkLkZhbnRvbVRlc3RuZXRdOiB7XG4gICAgbmFtZTogXCJGYW50b21cIixcbiAgICBzeW1ib2w6IFwiRlRNXCIsXG4gICAgZGVjaW1hbHM6IDE4LFxuICAgIHdyYXBwZWQ6IHtcbiAgICAgIGFkZHJlc3M6IFwiMHhmMTI3N2QxRWQ4QUQ0NjZiZWRkRjkyZWY0NDhBMTMyNjYxOTU2NjIxXCIsXG4gICAgICBuYW1lOiBcIldyYXBwZWQgRmFudG9tXCIsXG4gICAgICBzeW1ib2w6IFwiV0ZUTVwiXG4gICAgfVxuICB9LFxuICBbQ2hhaW5JZC5BcmJpdHJ1bV06IHtcbiAgICBuYW1lOiBcIkV0aGVyXCIsXG4gICAgc3ltYm9sOiBcIkVUSFwiLFxuICAgIGRlY2ltYWxzOiAxOCxcbiAgICB3cmFwcGVkOiB7XG4gICAgICBhZGRyZXNzOiBcIjB4ODJhZjQ5NDQ3ZDhhMDdlM2JkOTViZDBkNTZmMzUyNDE1MjNmYmFiMVwiLFxuICAgICAgbmFtZTogXCJXcmFwcGVkIEV0aGVyXCIsXG4gICAgICBzeW1ib2w6IFwiV0VUSFwiXG4gICAgfVxuICB9LFxuICBbQ2hhaW5JZC5BcmJpdHJ1bUdvZXJsaV06IHtcbiAgICBuYW1lOiBcIkFyYml0cnVtIEdvZXJsaSBFdGhlclwiLFxuICAgIHN5bWJvbDogXCJBR09SXCIsXG4gICAgZGVjaW1hbHM6IDE4LFxuICAgIHdyYXBwZWQ6IHtcbiAgICAgIGFkZHJlc3M6IFwiMHhlMzlBYjg4ZjhBNDc3NzAzMEE1MzQxNDZBOUNhM0I1MmJkNUQ0M0EzXCIsXG4gICAgICBuYW1lOiBcIldyYXBwZWQgRXRoZXJcIixcbiAgICAgIHN5bWJvbDogXCJXRVRIXCJcbiAgICB9XG4gIH0sXG4gIFtDaGFpbklkLk9wdGltaXNtXToge1xuICAgIG5hbWU6IFwiRXRoZXJcIixcbiAgICBzeW1ib2w6IFwiRVRIXCIsXG4gICAgZGVjaW1hbHM6IDE4LFxuICAgIHdyYXBwZWQ6IHtcbiAgICAgIGFkZHJlc3M6IFwiMHg0MjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2XCIsXG4gICAgICBuYW1lOiBcIldyYXBwZWQgRXRoZXJcIixcbiAgICAgIHN5bWJvbDogXCJXRVRIXCJcbiAgICB9XG4gIH0sXG4gIFtDaGFpbklkLk9wdGltaXNtR29lcmxpXToge1xuICAgIG5hbWU6IFwiR29lcmxpIEV0aGVyXCIsXG4gICAgc3ltYm9sOiBcIkVUSFwiLFxuICAgIGRlY2ltYWxzOiAxOCxcbiAgICB3cmFwcGVkOiB7XG4gICAgICBhZGRyZXNzOiBcIjB4NDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNlwiLFxuICAgICAgbmFtZTogXCJXcmFwcGVkIEV0aGVyXCIsXG4gICAgICBzeW1ib2w6IFwiV0VUSFwiXG4gICAgfVxuICB9LFxuICBbQ2hhaW5JZC5IYXJkaGF0XToge1xuICAgIG5hbWU6IFwiRXRoZXJcIixcbiAgICBzeW1ib2w6IFwiRVRIXCIsXG4gICAgZGVjaW1hbHM6IDE4LFxuICAgIHdyYXBwZWQ6IHtcbiAgICAgIGFkZHJlc3M6IFwiMHg1RmJEQjIzMTU2NzhhZmVjYjM2N2YwMzJkOTNGNjQyZjY0MTgwYWEzXCIsXG4gICAgICBuYW1lOiBcIldyYXBwZWQgRXRoZXJcIixcbiAgICAgIHN5bWJvbDogXCJXRVRIXCJcbiAgICB9XG4gIH0sXG4gIFtDaGFpbklkLkJpbmFuY2VTbWFydENoYWluTWFpbm5ldF06IHtcbiAgICBuYW1lOiBcIkJpbmFuY2UgQ2hhaW4gTmF0aXZlIFRva2VuXCIsXG4gICAgc3ltYm9sOiBcIkJOQlwiLFxuICAgIGRlY2ltYWxzOiAxOCxcbiAgICB3cmFwcGVkOiB7XG4gICAgICBhZGRyZXNzOiBcIjB4YmI0Q2RCOUNCZDM2QjAxYkQxY0JhRUJGMkRlMDhkOTE3M2JjMDk1Y1wiLFxuICAgICAgbmFtZTogXCJXcmFwcGVkIEJpbmFuY2UgQ2hhaW4gVG9rZW5cIixcbiAgICAgIHN5bWJvbDogXCJXQk5CXCJcbiAgICB9XG4gIH0sXG4gIFtDaGFpbklkLkJpbmFuY2VTbWFydENoYWluVGVzdG5ldF06IHtcbiAgICBuYW1lOiBcIkJpbmFuY2UgQ2hhaW4gTmF0aXZlIFRva2VuXCIsXG4gICAgc3ltYm9sOiBcIlRCTkJcIixcbiAgICBkZWNpbWFsczogMTgsXG4gICAgd3JhcHBlZDoge1xuICAgICAgYWRkcmVzczogXCIweGFlMTNkOTg5ZGFDMmYwZEViRmY0NjBhQzExMmE4MzdDODlCQWE3Y2RcIixcbiAgICAgIG5hbWU6IFwiV3JhcHBlZCBCaW5hbmNlIENoYWluIFRlc3RuZXQgVG9rZW5cIixcbiAgICAgIHN5bWJvbDogXCJXQk5CXCJcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmF0aXZlIHRva2VuIGZvciBhIGdpdmVuIGNoYWluXG4gKiBAcGFyYW0gY2hhaW5JZCAtIHRoZSBjaGFpbiBpZFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBnZXROYXRpdmVUb2tlbkJ5Q2hhaW5JZChjaGFpbklkKSB7XG4gIHJldHVybiBOQVRJVkVfVE9LRU5TW2NoYWluSWRdO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBDdXJyZW5jeVNjaGVtYSA9IHoub2JqZWN0KHtcbiAgbmFtZTogei5zdHJpbmcoKSxcbiAgc3ltYm9sOiB6LnN0cmluZygpLFxuICBkZWNpbWFsczogei5udW1iZXIoKVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEN1cnJlbmN5VmFsdWVTY2hlbWEgPSBDdXJyZW5jeVNjaGVtYS5leHRlbmQoe1xuICB2YWx1ZTogQmlnTnVtYmVyU2NoZW1hLFxuICBkaXNwbGF5VmFsdWU6IHouc3RyaW5nKClcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBNZXJrbGVTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIG1lcmtsZTogei5yZWNvcmQoei5zdHJpbmcoKSkuZGVmYXVsdCh7fSlcbn0pO1xuY29uc3QgU25hcHNob3RFbnRyeUlucHV0ID0gei5vYmplY3Qoe1xuICBhZGRyZXNzOiBBZGRyZXNzU2NoZW1hLFxuICBtYXhDbGFpbWFibGU6IFF1YW50aXR5U2NoZW1hLmRlZmF1bHQoMCksXG4gIC8vIGRlZmF1bHRzIHRvIDBcbiAgcHJpY2U6IFF1YW50aXR5U2NoZW1hLm9wdGlvbmFsKCksXG4gIC8vIGRlZmF1bHRzIHRvIHVubGltaXRlZCwgYnV0IGNhbiBiZSB1bmRlZmluZWQgaW4gb2xkIHNuYXBzaG90c1xuICBjdXJyZW5jeUFkZHJlc3M6IEFkZHJlc3NTY2hlbWEuZGVmYXVsdChldGhlcnMuY29uc3RhbnRzLkFkZHJlc3NaZXJvKS5vcHRpb25hbCgpIC8vIGRlZmF1bHRzIHRvIEFkZHJlc3NaZXJvLCBidXQgY2FuIGJlIHVuZGVmaW5lZCBmb3Igb2xkIHNuYXBzaG90c1xufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNuYXBzaG90SW5wdXRTY2hlbWEgPSB6LnVuaW9uKFt6LmFycmF5KHouc3RyaW5nKCkpLnRyYW5zZm9ybShzdHJpbmdzID0+IHN0cmluZ3MubWFwKGFkZHJlc3MgPT4gU25hcHNob3RFbnRyeUlucHV0LnBhcnNlKHtcbiAgYWRkcmVzc1xufSkpKSwgei5hcnJheShTbmFwc2hvdEVudHJ5SW5wdXQpXSk7XG5jb25zdCBTbmFwc2hvdEVudHJ5V2l0aFByb29mU2NoZW1hID0gU25hcHNob3RFbnRyeUlucHV0LmV4dGVuZCh7XG4gIHByb29mOiB6LmFycmF5KHouc3RyaW5nKCkpXG59KTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNuYXBzaG90U2NoZW1hID0gei5vYmplY3Qoe1xuICAvKipcbiAgICogVGhlIG1lcmtsZSByb290XG4gICAqL1xuICBtZXJrbGVSb290OiB6LnN0cmluZygpLFxuICBjbGFpbXM6IHouYXJyYXkoU25hcHNob3RFbnRyeVdpdGhQcm9vZlNjaGVtYSlcbn0pO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTbmFwc2hvdEluZm9TY2hlbWEgPSB6Lm9iamVjdCh7XG4gIG1lcmtsZVJvb3Q6IHouc3RyaW5nKCksXG4gIHNuYXBzaG90VXJpOiB6LnN0cmluZygpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQ2xhaW1Db25kaXRpb25NZXRhZGF0YVNjaGVtYSA9IHoub2JqZWN0KHtcbiAgbmFtZTogei5zdHJpbmcoKS5vcHRpb25hbCgpXG59KS5jYXRjaGFsbCh6LnVua25vd24oKSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IENsYWltQ29uZGl0aW9uSW5wdXRTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHN0YXJ0VGltZTogU3RhcnREYXRlU2NoZW1hLFxuICBjdXJyZW5jeUFkZHJlc3M6IHouc3RyaW5nKCkuZGVmYXVsdChOQVRJVkVfVE9LRU5fQUREUkVTUyksXG4gIHByaWNlOiBBbW91bnRTY2hlbWEuZGVmYXVsdCgwKSxcbiAgbWF4Q2xhaW1hYmxlU3VwcGx5OiBRdWFudGl0eVNjaGVtYSxcbiAgbWF4Q2xhaW1hYmxlUGVyV2FsbGV0OiBRdWFudGl0eVNjaGVtYSxcbiAgd2FpdEluU2Vjb25kczogQmlnTnVtYmVyaXNoU2NoZW1hLmRlZmF1bHQoMCksXG4gIG1lcmtsZVJvb3RIYXNoOiBCeXRlc0xpa2VTY2hlbWEuZGVmYXVsdCh1dGlscy5oZXhaZXJvUGFkKFswXSwgMzIpKSxcbiAgc25hcHNob3Q6IHoub3B0aW9uYWwoU25hcHNob3RJbnB1dFNjaGVtYSkubnVsbGFibGUoKSxcbiAgbWV0YWRhdGE6IENsYWltQ29uZGl0aW9uTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IENsYWltQ29uZGl0aW9uSW5wdXRBcnJheSA9IHouYXJyYXkoQ2xhaW1Db25kaXRpb25JbnB1dFNjaGVtYSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFBhcnRpYWxDbGFpbUNvbmRpdGlvbklucHV0U2NoZW1hID0gQ2xhaW1Db25kaXRpb25JbnB1dFNjaGVtYS5wYXJ0aWFsKCk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IENsYWltQ29uZGl0aW9uT3V0cHV0U2NoZW1hID0gQ2xhaW1Db25kaXRpb25JbnB1dFNjaGVtYS5leHRlbmQoe1xuICBhdmFpbGFibGVTdXBwbHk6IFF1YW50aXR5U2NoZW1hLFxuICBjdXJyZW50TWludFN1cHBseTogUXVhbnRpdHlTY2hlbWEsXG4gIGN1cnJlbmN5TWV0YWRhdGE6IEN1cnJlbmN5VmFsdWVTY2hlbWEuZGVmYXVsdCh7XG4gICAgdmFsdWU6IEJpZ051bWJlci5mcm9tKFwiMFwiKSxcbiAgICBkaXNwbGF5VmFsdWU6IFwiMFwiLFxuICAgIHN5bWJvbDogXCJcIixcbiAgICBkZWNpbWFsczogMTgsXG4gICAgbmFtZTogXCJcIlxuICB9KSxcbiAgcHJpY2U6IEJpZ051bWJlclNjaGVtYSxcbiAgd2FpdEluU2Vjb25kczogQmlnTnVtYmVyU2NoZW1hLFxuICBzdGFydFRpbWU6IEJpZ051bWJlclNjaGVtYS50cmFuc2Zvcm0obiA9PiBuZXcgRGF0ZShuLnRvTnVtYmVyKCkgKiAxMDAwKSksXG4gIHNuYXBzaG90OiBTbmFwc2hvdElucHV0U2NoZW1hLm9wdGlvbmFsKCkubnVsbGFibGUoKVxufSk7XG5cbmZ1bmN0aW9uIHJlc29sdmVPckdlbmVyYXRlSWQocmVxdWVzdFVJZCkge1xuICBpZiAocmVxdWVzdFVJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2KTtcbiAgICB2NCh7fSwgYnVmZmVyKTtcbiAgICByZXR1cm4gdXRpbHMuaGV4bGlmeSh1dGlscy50b1V0ZjhCeXRlcyhidWZmZXIudG9TdHJpbmcoXCJoZXhcIikpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdXRpbHMuaGV4bGlmeShyZXF1ZXN0VUlkKTtcbiAgfVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBCYXNlU2lnbmF0dXJlUGF5bG9hZElucHV0ID0gei5vYmplY3Qoe1xuICB0bzogei5zdHJpbmcoKS5yZWZpbmUoYWRkcmVzcyA9PiBhZGRyZXNzLnRvTG93ZXJDYXNlKCkgIT09IGNvbnN0YW50cy5BZGRyZXNzWmVybywge1xuICAgIG1lc3NhZ2U6IFwiQ2Fubm90IGNyZWF0ZSBwYXlsb2FkIHRvIG1pbnQgdG8gemVybyBhZGRyZXNzXCJcbiAgfSksXG4gIHByaWNlOiBBbW91bnRTY2hlbWEuZGVmYXVsdCgwKSxcbiAgY3VycmVuY3lBZGRyZXNzOiB6LnN0cmluZygpLmRlZmF1bHQoTkFUSVZFX1RPS0VOX0FERFJFU1MpLFxuICBtaW50U3RhcnRUaW1lOiBTdGFydERhdGVTY2hlbWEsXG4gIG1pbnRFbmRUaW1lOiBFbmREYXRlU2NoZW1hLFxuICB1aWQ6IHouc3RyaW5nKCkub3B0aW9uYWwoKS50cmFuc2Zvcm0oYXJnID0+IHJlc29sdmVPckdlbmVyYXRlSWQoYXJnKSksXG4gIHByaW1hcnlTYWxlUmVjaXBpZW50OiB6LnN0cmluZygpLmRlZmF1bHQoY29uc3RhbnRzLkFkZHJlc3NaZXJvKVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNpZ25hdHVyZTIwUGF5bG9hZElucHV0ID0gQmFzZVNpZ25hdHVyZVBheWxvYWRJbnB1dC5leHRlbmQoe1xuICBxdWFudGl0eTogQW1vdW50U2NoZW1hXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU2lnbmF0dXJlMjBQYXlsb2FkT3V0cHV0ID0gU2lnbmF0dXJlMjBQYXlsb2FkSW5wdXQuZXh0ZW5kKHtcbiAgbWludFN0YXJ0VGltZTogQmlnTnVtYmVyU2NoZW1hLFxuICBtaW50RW5kVGltZTogQmlnTnVtYmVyU2NoZW1hXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU2lnbmF0dXJlNzIxUGF5bG9hZElucHV0ID0gQmFzZVNpZ25hdHVyZVBheWxvYWRJbnB1dC5leHRlbmQoe1xuICBtZXRhZGF0YTogTkZUSW5wdXRPclVyaVNjaGVtYSxcbiAgcm95YWx0eVJlY2lwaWVudDogei5zdHJpbmcoKS5kZWZhdWx0KGNvbnN0YW50cy5BZGRyZXNzWmVybyksXG4gIHJveWFsdHlCcHM6IEJhc2lzUG9pbnRzU2NoZW1hLmRlZmF1bHQoMClcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTaWduYXR1cmU3MjFQYXlsb2FkT3V0cHV0ID0gU2lnbmF0dXJlNzIxUGF5bG9hZElucHV0LmV4dGVuZCh7XG4gIHVyaTogei5zdHJpbmcoKSxcbiAgcm95YWx0eUJwczogQmlnTnVtYmVyU2NoZW1hLFxuICBtaW50U3RhcnRUaW1lOiBCaWdOdW1iZXJTY2hlbWEsXG4gIG1pbnRFbmRUaW1lOiBCaWdOdW1iZXJTY2hlbWFcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTaWduYXR1cmUxMTU1UGF5bG9hZElucHV0ID0gU2lnbmF0dXJlNzIxUGF5bG9hZElucHV0LmV4dGVuZCh7XG4gIG1ldGFkYXRhOiBORlRJbnB1dE9yVXJpU2NoZW1hLmRlZmF1bHQoXCJcIiksXG4gIHF1YW50aXR5OiBCaWdOdW1iZXJpc2hTY2hlbWFcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTaWduYXR1cmUxMTU1UGF5bG9hZElucHV0V2l0aFRva2VuSWQgPSBTaWduYXR1cmUxMTU1UGF5bG9hZElucHV0LmV4dGVuZCh7XG4gIHRva2VuSWQ6IEJpZ051bWJlcmlzaFNjaGVtYVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNpZ25hdHVyZTExNTVQYXlsb2FkT3V0cHV0ID0gU2lnbmF0dXJlNzIxUGF5bG9hZE91dHB1dC5leHRlbmQoe1xuICB0b2tlbklkOiBCaWdOdW1iZXJTY2hlbWEsXG4gIHF1YW50aXR5OiBCaWdOdW1iZXJTY2hlbWFcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTaWduYXR1cmU3MjFXaXRoUXVhbnRpdHlJbnB1dCA9IFNpZ25hdHVyZTcyMVBheWxvYWRJbnB1dC5leHRlbmQoe1xuICBtZXRhZGF0YTogTkZUSW5wdXRPclVyaVNjaGVtYS5kZWZhdWx0KFwiXCIpLFxuICBxdWFudGl0eTogQmlnTnVtYmVyU2NoZW1hLmRlZmF1bHQoMSlcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTaWduYXR1cmU3MjFXaXRoUXVhbnRpdHlPdXRwdXQgPSBTaWduYXR1cmU3MjFQYXlsb2FkT3V0cHV0LmV4dGVuZCh7XG4gIHF1YW50aXR5OiBCaWdOdW1iZXJTY2hlbWEuZGVmYXVsdCgxKVxufSk7XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5cbmNvbnN0IE1pbnRSZXF1ZXN0MjAgPSBbe1xuICBuYW1lOiBcInRvXCIsXG4gIHR5cGU6IFwiYWRkcmVzc1wiXG59LCB7XG4gIG5hbWU6IFwicHJpbWFyeVNhbGVSZWNpcGllbnRcIixcbiAgdHlwZTogXCJhZGRyZXNzXCJcbn0sIHtcbiAgbmFtZTogXCJxdWFudGl0eVwiLFxuICB0eXBlOiBcInVpbnQyNTZcIlxufSwge1xuICBuYW1lOiBcInByaWNlXCIsXG4gIHR5cGU6IFwidWludDI1NlwiXG59LCB7XG4gIG5hbWU6IFwiY3VycmVuY3lcIixcbiAgdHlwZTogXCJhZGRyZXNzXCJcbn0sIHtcbiAgbmFtZTogXCJ2YWxpZGl0eVN0YXJ0VGltZXN0YW1wXCIsXG4gIHR5cGU6IFwidWludDEyOFwiXG59LCB7XG4gIG5hbWU6IFwidmFsaWRpdHlFbmRUaW1lc3RhbXBcIixcbiAgdHlwZTogXCJ1aW50MTI4XCJcbn0sIHtcbiAgbmFtZTogXCJ1aWRcIixcbiAgdHlwZTogXCJieXRlczMyXCJcbn1dO1xuY29uc3QgTWludFJlcXVlc3Q3MjEgPSBbe1xuICBuYW1lOiBcInRvXCIsXG4gIHR5cGU6IFwiYWRkcmVzc1wiXG59LCB7XG4gIG5hbWU6IFwicm95YWx0eVJlY2lwaWVudFwiLFxuICB0eXBlOiBcImFkZHJlc3NcIlxufSwge1xuICBuYW1lOiBcInJveWFsdHlCcHNcIixcbiAgdHlwZTogXCJ1aW50MjU2XCJcbn0sIHtcbiAgbmFtZTogXCJwcmltYXJ5U2FsZVJlY2lwaWVudFwiLFxuICB0eXBlOiBcImFkZHJlc3NcIlxufSwge1xuICBuYW1lOiBcInVyaVwiLFxuICB0eXBlOiBcInN0cmluZ1wiXG59LCB7XG4gIG5hbWU6IFwicHJpY2VcIixcbiAgdHlwZTogXCJ1aW50MjU2XCJcbn0sIHtcbiAgbmFtZTogXCJjdXJyZW5jeVwiLFxuICB0eXBlOiBcImFkZHJlc3NcIlxufSwge1xuICBuYW1lOiBcInZhbGlkaXR5U3RhcnRUaW1lc3RhbXBcIixcbiAgdHlwZTogXCJ1aW50MTI4XCJcbn0sIHtcbiAgbmFtZTogXCJ2YWxpZGl0eUVuZFRpbWVzdGFtcFwiLFxuICB0eXBlOiBcInVpbnQxMjhcIlxufSwge1xuICBuYW1lOiBcInVpZFwiLFxuICB0eXBlOiBcImJ5dGVzMzJcIlxufV07XG5jb25zdCBNaW50UmVxdWVzdDExNTUgPSBbe1xuICBuYW1lOiBcInRvXCIsXG4gIHR5cGU6IFwiYWRkcmVzc1wiXG59LCB7XG4gIG5hbWU6IFwicm95YWx0eVJlY2lwaWVudFwiLFxuICB0eXBlOiBcImFkZHJlc3NcIlxufSwge1xuICBuYW1lOiBcInJveWFsdHlCcHNcIixcbiAgdHlwZTogXCJ1aW50MjU2XCJcbn0sIHtcbiAgbmFtZTogXCJwcmltYXJ5U2FsZVJlY2lwaWVudFwiLFxuICB0eXBlOiBcImFkZHJlc3NcIlxufSwge1xuICBuYW1lOiBcInRva2VuSWRcIixcbiAgdHlwZTogXCJ1aW50MjU2XCJcbn0sIHtcbiAgbmFtZTogXCJ1cmlcIixcbiAgdHlwZTogXCJzdHJpbmdcIlxufSwge1xuICBuYW1lOiBcInF1YW50aXR5XCIsXG4gIHR5cGU6IFwidWludDI1NlwiXG59LCB7XG4gIG5hbWU6IFwicHJpY2VQZXJUb2tlblwiLFxuICB0eXBlOiBcInVpbnQyNTZcIlxufSwge1xuICBuYW1lOiBcImN1cnJlbmN5XCIsXG4gIHR5cGU6IFwiYWRkcmVzc1wiXG59LCB7XG4gIG5hbWU6IFwidmFsaWRpdHlTdGFydFRpbWVzdGFtcFwiLFxuICB0eXBlOiBcInVpbnQxMjhcIlxufSwge1xuICBuYW1lOiBcInZhbGlkaXR5RW5kVGltZXN0YW1wXCIsXG4gIHR5cGU6IFwidWludDEyOFwiXG59LCB7XG4gIG5hbWU6IFwidWlkXCIsXG4gIHR5cGU6IFwiYnl0ZXMzMlwiXG59XTtcbmNvbnN0IE1pbnRSZXF1ZXN0NzIxd2l0aFF1YW50aXR5ID0gW3tcbiAgbmFtZTogXCJ0b1wiLFxuICB0eXBlOiBcImFkZHJlc3NcIlxufSwge1xuICBuYW1lOiBcInJveWFsdHlSZWNpcGllbnRcIixcbiAgdHlwZTogXCJhZGRyZXNzXCJcbn0sIHtcbiAgbmFtZTogXCJyb3lhbHR5QnBzXCIsXG4gIHR5cGU6IFwidWludDI1NlwiXG59LCB7XG4gIG5hbWU6IFwicHJpbWFyeVNhbGVSZWNpcGllbnRcIixcbiAgdHlwZTogXCJhZGRyZXNzXCJcbn0sIHtcbiAgbmFtZTogXCJ1cmlcIixcbiAgdHlwZTogXCJzdHJpbmdcIlxufSwge1xuICBuYW1lOiBcInF1YW50aXR5XCIsXG4gIHR5cGU6IFwidWludDI1NlwiXG59LCB7XG4gIG5hbWU6IFwicHJpY2VQZXJUb2tlblwiLFxuICB0eXBlOiBcInVpbnQyNTZcIlxufSwge1xuICBuYW1lOiBcImN1cnJlbmN5XCIsXG4gIHR5cGU6IFwiYWRkcmVzc1wiXG59LCB7XG4gIG5hbWU6IFwidmFsaWRpdHlTdGFydFRpbWVzdGFtcFwiLFxuICB0eXBlOiBcInVpbnQxMjhcIlxufSwge1xuICBuYW1lOiBcInZhbGlkaXR5RW5kVGltZXN0YW1wXCIsXG4gIHR5cGU6IFwidWludDEyOFwiXG59LCB7XG4gIG5hbWU6IFwidWlkXCIsXG4gIHR5cGU6IFwiYnl0ZXMzMlwiXG59XTtcbmNvbnN0IEdlbmVyaWNSZXF1ZXN0ID0gW3tcbiAgbmFtZTogXCJ2YWxpZGl0eVN0YXJ0VGltZXN0YW1wXCIsXG4gIHR5cGU6IFwidWludDEyOFwiXG59LCB7XG4gIG5hbWU6IFwidmFsaWRpdHlFbmRUaW1lc3RhbXBcIixcbiAgdHlwZTogXCJ1aW50MTI4XCJcbn0sIHtcbiAgbmFtZTogXCJ1aWRcIixcbiAgdHlwZTogXCJieXRlczMyXCJcbn0sIHtcbiAgbmFtZTogXCJkYXRhXCIsXG4gIHR5cGU6IFwiYnl0ZXNcIlxufV07XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IENvbW1vbkNvbnRyYWN0U2NoZW1hID0gei5vYmplY3Qoe1xuICBuYW1lOiB6LnN0cmluZygpLFxuICBkZXNjcmlwdGlvbjogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBpbWFnZTogRmlsZU9yQnVmZmVyT3JTdHJpbmdTY2hlbWEub3B0aW9uYWwoKSxcbiAgZXh0ZXJuYWxfbGluazogei5zdHJpbmcoKS51cmwoKS5vcHRpb25hbCgpXG59KTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IENvbW1vbkNvbnRyYWN0T3V0cHV0U2NoZW1hID0gQ29tbW9uQ29udHJhY3RTY2hlbWEuZXh0ZW5kKHtcbiAgaW1hZ2U6IHouc3RyaW5nKCkub3B0aW9uYWwoKVxufSkuY2F0Y2hhbGwoei51bmtub3duKCkpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBDb21tb25Sb3lhbHR5U2NoZW1hID0gei5vYmplY3Qoe1xuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiByb3lhbHR5IGNvbGxlY3RlZCBvbiBhbGwgcm95YWx0aWVzIHJlcHJlc2VudGVkIGFzIGJhc2lzIHBvaW50cy5cbiAgICogVGhlIGRlZmF1bHQgaXMgMCAobm8gcm95YWx0aWVzKS5cbiAgICpcbiAgICogMSBiYXNpcyBwb2ludCA9IDAuMDElXG4gICAqXG4gICAqIEZvciBleGFtcGxlOiBpZiB0aGlzIHZhbHVlIGlzIDEwMCwgdGhlbiB0aGUgcm95YWx0eSBpcyAxJSBvZiB0aGUgdG90YWwgc2FsZXMuXG4gICAqXG4gICAqICBAaW50ZXJuYWxyZW1hcmtzIHVzZWQgYnkgT3BlblNlYSBcInNlbGxlcl9mZWVfYmFzaXNfcG9pbnRzXCJcbiAgICovXG4gIHNlbGxlcl9mZWVfYmFzaXNfcG9pbnRzOiBCYXNpc1BvaW50c1NjaGVtYS5kZWZhdWx0KDApLFxuICAvKipcbiAgICogVGhlIGFkZHJlc3Mgb2YgdGhlIHJveWFsdHkgcmVjaXBpZW50LiBBbGwgcm95YWx0aWVzIHdpbGwgYmUgc2VudFxuICAgKiB0byB0aGlzIGFkZHJlc3MuXG4gICAqIEBpbnRlcm5hbHJlbWFya3MgdXNlZCBieSBPcGVuU2VhIFwiZmVlX3JlY2lwaWVudFwiXG4gICAqL1xuICBmZWVfcmVjaXBpZW50OiBBZGRyZXNzU2NoZW1hLmRlZmF1bHQoY29uc3RhbnRzLkFkZHJlc3NaZXJvKVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IENvbW1vblByaW1hcnlTYWxlU2NoZW1hID0gei5vYmplY3Qoe1xuICAvKipcbiAgICogcHJpbWFyeSBzYWxlIHJlY2lwaWVudCBhZGRyZXNzXG4gICAqL1xuICBwcmltYXJ5X3NhbGVfcmVjaXBpZW50OiBBZGRyZXNzU2NoZW1hXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQ29tbW9uUGxhdGZvcm1GZWVTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIC8qKlxuICAgKiBwbGF0Zm9ybSBmZWUgYmFzaXMgcG9pbnRzXG4gICAqL1xuICBwbGF0Zm9ybV9mZWVfYmFzaXNfcG9pbnRzOiBCYXNpc1BvaW50c1NjaGVtYS5kZWZhdWx0KDApLFxuICAvKipcbiAgICogcGxhdGZvcm0gZmVlIHJlY2lwaWVudCBhZGRyZXNzXG4gICAqL1xuICBwbGF0Zm9ybV9mZWVfcmVjaXBpZW50OiBBZGRyZXNzU2NoZW1hLmRlZmF1bHQoY29uc3RhbnRzLkFkZHJlc3NaZXJvKVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IENvbW1vblRydXN0ZWRGb3J3YXJkZXJTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHRydXN0ZWRfZm9yd2FyZGVyczogei5hcnJheShBZGRyZXNzU2NoZW1hKS5kZWZhdWx0KFtdKVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IENvbW1vblN5bWJvbFNjaGVtYSA9IHoub2JqZWN0KHtcbiAgc3ltYm9sOiB6LnN0cmluZygpLm9wdGlvbmFsKCkuZGVmYXVsdChcIlwiKVxufSk7XG5cbmNvbnN0IFByb3BlcnRpZXNJbnB1dCA9IHoub2JqZWN0KHt9KS5jYXRjaGFsbCh6LnVuaW9uKFtCaWdOdW1iZXJUcmFuc2Zvcm1TY2hlbWEsIHoudW5rbm93bigpXSkpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBPcHRpb25hbFByb3BlcnRpZXNJbnB1dCA9IHoudW5pb24oW3ouYXJyYXkoUHJvcGVydGllc0lucHV0KSwgUHJvcGVydGllc0lucHV0XSkub3B0aW9uYWwoKTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgVG9rZW5NaW50SW5wdXRTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHRvQWRkcmVzczogQWRkcmVzc1NjaGVtYSxcbiAgYW1vdW50OiBBbW91bnRTY2hlbWFcbn0pO1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBFZGl0aW9uTWV0YWRhdGFPdXRwdXRTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHN1cHBseTogQmlnTnVtYmVyU2NoZW1hLFxuICBtZXRhZGF0YTogQ29tbW9uTkZUT3V0cHV0XG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgRWRpdGlvbk1ldGFkYXRhV2l0aE93bmVyT3V0cHV0U2NoZW1hID0gRWRpdGlvbk1ldGFkYXRhT3V0cHV0U2NoZW1hLmV4dGVuZCh7XG4gIG93bmVyOiB6LnN0cmluZygpLFxuICBxdWFudGl0eU93bmVkOiBCaWdOdW1iZXJTY2hlbWFcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBFZGl0aW9uTWV0YWRhdGFJbnB1dFNjaGVtYSA9IHoub2JqZWN0KHtcbiAgc3VwcGx5OiBCaWdOdW1iZXJpc2hTY2hlbWEsXG4gIG1ldGFkYXRhOiBDb21tb25ORlRJbnB1dFxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEVkaXRpb25NZXRhZGF0YUlucHV0T3JVcmlTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHN1cHBseTogQmlnTnVtYmVyaXNoU2NoZW1hLFxuICBtZXRhZGF0YTogTkZUSW5wdXRPclVyaVNjaGVtYVxufSk7XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IE9aX0RFRkVOREVSX0ZPUldBUkRFUl9BRERSRVNTID0gXCIweGM4MkJiRTQxZjJjRjA0ZTNhOGVmQTE4RjcwMzJCREQ3ZjZkOThhODFcIjtcbmNvbnN0IFRXUmVnaXN0cnlfYWRkcmVzcyA9IFwiMHg3YzQ4Nzg0NWY5ODkzOEJiOTU1QjFENUFEMDY5ZDlhMzBlNDEzMWZkXCI7XG5jb25zdCBUV0ZhY3RvcnlfYWRkcmVzcyA9IFwiMHg1REJDN0I4NDBiYWE5ZGFCY0JlOUQyNDkyRTQ1RDcyNDRCNTRBMkEwXCI7XG5jb25zdCBDb250cmFjdFB1Ymxpc2hlcl9hZGRyZXNzID0gXCIweDY2NDI0NDU2MGVCYTIxQmY4MmQ3MTUwQzc5MWJFMUFiY0Q1QjRjZDdcIjsgLy8gUG9seWdvbiBvbmx5XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IENPTlRSQUNUX0FERFJFU1NFUyA9IHtcbiAgW0NoYWluSWQuTWFpbm5ldF06IHtcbiAgICBvcGVuemVwcGVsaW5Gb3J3YXJkZXI6IE9aX0RFRkVOREVSX0ZPUldBUkRFUl9BRERSRVNTLFxuICAgIG9wZW56ZXBwZWxpbkZvcndhcmRlckVPQTogXCIweDc2Y2UyQ0IxQWU0OEZhMDY3ZjRmYjhjNWY4MDMxMTFBRTBCMjRCRUFcIixcbiAgICBiaWNvbm9teUZvcndhcmRlcjogXCIweDg0YTA4NTZiMDM4ZWFBZDFjQzdFMjk3Y0YzNEE3ZTcyNjg1QTg2OTNcIixcbiAgICB0d0ZhY3Rvcnk6IFRXRmFjdG9yeV9hZGRyZXNzLFxuICAgIHR3UmVnaXN0cnk6IFRXUmVnaXN0cnlfYWRkcmVzcyxcbiAgICB0d0JZT0NSZWdpc3RyeTogY29uc3RhbnRzLkFkZHJlc3NaZXJvXG4gIH0sXG4gIFtDaGFpbklkLkdvZXJsaV06IHtcbiAgICBvcGVuemVwcGVsaW5Gb3J3YXJkZXI6IFwiMHg1MDAxQTE0Q0E2MTYzMTQzMzE2YTdDNjE0ZTMwZTYwNDEwMzNBYzIwXCIsXG4gICAgb3BlbnplcHBlbGluRm9yd2FyZGVyRU9BOiBcIjB4ZTczYzUwY0I5YzVCMzc4NjI3ZmY2MjVCQjZlNjcyNUE0QTVENjVkMlwiLFxuICAgIGJpY29ub215Rm9yd2FyZGVyOiBcIjB4RTA0MTYwODkyMmQwNmE0RjI2QzBkNGMyN2Q4YkNEMDFkYWYxZjc5MlwiLFxuICAgIHR3RmFjdG9yeTogVFdGYWN0b3J5X2FkZHJlc3MsXG4gICAgdHdSZWdpc3RyeTogVFdSZWdpc3RyeV9hZGRyZXNzLFxuICAgIHR3QllPQ1JlZ2lzdHJ5OiBcIjB4QjFCZDlkNzk0MkEyNTBCQTJEY2UyN0RENjAxRjJFRDQyMTFBNjBDNFwiXG4gIH0sXG4gIFtDaGFpbklkLlBvbHlnb25dOiB7XG4gICAgb3BlbnplcHBlbGluRm9yd2FyZGVyOiBPWl9ERUZFTkRFUl9GT1JXQVJERVJfQUREUkVTUyxcbiAgICBvcGVuemVwcGVsaW5Gb3J3YXJkZXJFT0E6IFwiMHg0ZjI0N2M2OTE4NGFkNjEwMzZFQzJCYjMyMTNiNjlGMTBGYkVEZTFGXCIsXG4gICAgYmljb25vbXlGb3J3YXJkZXI6IFwiMHg4NkM4MGE4YWE1OGUwQTRmYTA5QTY5NjI0YzMxQWIyYTZDQUQ1NmI4XCIsXG4gICAgdHdGYWN0b3J5OiBUV0ZhY3RvcnlfYWRkcmVzcyxcbiAgICB0d1JlZ2lzdHJ5OiBUV1JlZ2lzdHJ5X2FkZHJlc3MsXG4gICAgdHdCWU9DUmVnaXN0cnk6IFwiMHgzMDg0NzNCZTkwMEY0MTg1QTU2NTg3ZEU1NGJERkY1RThmN2E2QUU3XCJcbiAgfSxcbiAgW0NoYWluSWQuTXVtYmFpXToge1xuICAgIG9wZW56ZXBwZWxpbkZvcndhcmRlcjogT1pfREVGRU5ERVJfRk9SV0FSREVSX0FERFJFU1MsXG4gICAgb3BlbnplcHBlbGluRm9yd2FyZGVyRU9BOiBcIjB4YjFBMjg4M2ZjNGQyODdkOWNCOERiYjk2Y0ZGNjBDNzZCRWYyRDI1MFwiLFxuICAgIGJpY29ub215Rm9yd2FyZGVyOiBcIjB4OTM5OUJCMjREQkI1QzRiNzgyQzcwYzI5NjlGNTg3MTZFYmJkNmEzYlwiLFxuICAgIHR3RmFjdG9yeTogVFdGYWN0b3J5X2FkZHJlc3MsXG4gICAgdHdSZWdpc3RyeTogVFdSZWdpc3RyeV9hZGRyZXNzLFxuICAgIHR3QllPQ1JlZ2lzdHJ5OiBcIjB4M0YxNzk3MkNCMjc1MDZlYjRhNmEzRDU5NjU5ZTBCNTdhNDNmZDE2Q1wiXG4gIH0sXG4gIFtDaGFpbklkLkF2YWxhbmNoZV06IHtcbiAgICBvcGVuemVwcGVsaW5Gb3J3YXJkZXI6IE9aX0RFRkVOREVSX0ZPUldBUkRFUl9BRERSRVNTLFxuICAgIG9wZW56ZXBwZWxpbkZvcndhcmRlckVPQTogXCIweGIxQTI4ODNmYzRkMjg3ZDljQjhEYmI5NmNGRjYwQzc2QkVmMkQyNTBcIixcbiAgICBiaWNvbm9teUZvcndhcmRlcjogXCIweDY0Q0QzNTMzODQxMDk0MjNhOTY2ZENkM0FhMzBEODg0QzliMkUwNTdcIixcbiAgICB0d0ZhY3Rvcnk6IFRXRmFjdG9yeV9hZGRyZXNzLFxuICAgIHR3UmVnaXN0cnk6IFRXUmVnaXN0cnlfYWRkcmVzcyxcbiAgICB0d0JZT0NSZWdpc3RyeTogY29uc3RhbnRzLkFkZHJlc3NaZXJvXG4gIH0sXG4gIFtDaGFpbklkLkF2YWxhbmNoZUZ1amlUZXN0bmV0XToge1xuICAgIG9wZW56ZXBwZWxpbkZvcndhcmRlcjogT1pfREVGRU5ERVJfRk9SV0FSREVSX0FERFJFU1MsXG4gICAgb3BlbnplcHBlbGluRm9yd2FyZGVyRU9BOiBcIjB4ZTczYzUwY0I5YzVCMzc4NjI3ZmY2MjVCQjZlNjcyNUE0QTVENjVkMlwiLFxuICAgIGJpY29ub215Rm9yd2FyZGVyOiBcIjB4NjI3MUNhNjNEMzA1MDdmMkRjYmY5OUI1Mjc4NzAzMjUwNkQ3NUJCRlwiLFxuICAgIHR3RmFjdG9yeTogVFdGYWN0b3J5X2FkZHJlc3MsXG4gICAgdHdSZWdpc3RyeTogVFdSZWdpc3RyeV9hZGRyZXNzLFxuICAgIHR3QllPQ1JlZ2lzdHJ5OiBcIjB4M0U2ZUU4NjRmODUwRjVlNUE5OGJjOTUwQjY4RTE4MUNmNDAxMEYyM1wiXG4gIH0sXG4gIFtDaGFpbklkLkZhbnRvbV06IHtcbiAgICBvcGVuemVwcGVsaW5Gb3J3YXJkZXI6IE9aX0RFRkVOREVSX0ZPUldBUkRFUl9BRERSRVNTLFxuICAgIG9wZW56ZXBwZWxpbkZvcndhcmRlckVPQTogXCIweGIxQTI4ODNmYzRkMjg3ZDljQjhEYmI5NmNGRjYwQzc2QkVmMkQyNTBcIixcbiAgICBiaWNvbm9teUZvcndhcmRlcjogXCIweDY0Q0QzNTMzODQxMDk0MjNhOTY2ZENkM0FhMzBEODg0QzliMkUwNTdcIixcbiAgICB0d0ZhY3Rvcnk6IFwiMHg5N0VBMEZjYzU1MkQ1QThGYjVlOTEwMTMxNkFBZDBENjJFYTA4NzZCXCIsXG4gICAgdHdSZWdpc3RyeTogVFdSZWdpc3RyeV9hZGRyZXNzLFxuICAgIHR3QllPQ1JlZ2lzdHJ5OiBjb25zdGFudHMuQWRkcmVzc1plcm9cbiAgfSxcbiAgW0NoYWluSWQuRmFudG9tVGVzdG5ldF06IHtcbiAgICBvcGVuemVwcGVsaW5Gb3J3YXJkZXI6IE9aX0RFRkVOREVSX0ZPUldBUkRFUl9BRERSRVNTLFxuICAgIG9wZW56ZXBwZWxpbkZvcndhcmRlckVPQTogXCIweDQyRDMwNDhiNTk1QjZlMWMyOGE1ODhkNzAzNjZDY0MyQUE0ZEI0N2JcIixcbiAgICBiaWNvbm9teUZvcndhcmRlcjogXCIweDY5RkI4RGNhODA2N0E1RDM4NzAzYjllOGIzOWNmMkQ1MTQ3M0U0YjRcIixcbiAgICB0d0ZhY3Rvcnk6IFRXRmFjdG9yeV9hZGRyZXNzLFxuICAgIHR3UmVnaXN0cnk6IFRXUmVnaXN0cnlfYWRkcmVzcyxcbiAgICB0d0JZT0NSZWdpc3RyeTogXCIweDNFNmVFODY0Zjg1MEY1ZTVBOThiYzk1MEI2OEUxODFDZjQwMTBGMjNcIlxuICB9LFxuICBbQ2hhaW5JZC5BcmJpdHJ1bV06IHtcbiAgICBvcGVuemVwcGVsaW5Gb3J3YXJkZXI6IE9aX0RFRkVOREVSX0ZPUldBUkRFUl9BRERSRVNTLFxuICAgIG9wZW56ZXBwZWxpbkZvcndhcmRlckVPQTogXCIweDRmMjQ3YzY5MTg0YWQ2MTAzNkVDMkJiMzIxM2I2OUYxMEZiRURlMUZcIixcbiAgICBiaWNvbm9teUZvcndhcmRlcjogXCIweGZlMGZhM0MwNmQwM2JEQzdmYjQ5Yzg5MkJiQjM5MTEzQjUzNGZCNTdcIixcbiAgICB0d0ZhY3Rvcnk6IFwiMHhkMjRiM2RlMDg1Q0ZkOGM1NGI5NGZlQUQwOGE3OTYyRDM0M0U2REUwXCIsXG4gICAgdHdSZWdpc3RyeTogXCIweDdjNDg3ODQ1Zjk4OTM4QmI5NTVCMUQ1QUQwNjlkOWEzMGU0MTMxZmRcIixcbiAgICB0d0JZT0NSZWdpc3RyeTogY29uc3RhbnRzLkFkZHJlc3NaZXJvXG4gIH0sXG4gIFtDaGFpbklkLkFyYml0cnVtR29lcmxpXToge1xuICAgIG9wZW56ZXBwZWxpbkZvcndhcmRlcjogXCIweDhjYmM4QjVkNzE3MDIwMzI5MDQ3NTBBNjZBRWZFOEI2MDNlQkM1MzhcIixcbiAgICBvcGVuemVwcGVsaW5Gb3J3YXJkZXJFT0E6IFwiMHgxMTk3MDQzMTRFZjMwNEVhQUFFNGIzYzdDOUFCZDU5MjcyQTI4MzEwXCIsXG4gICAgYmljb25vbXlGb3J3YXJkZXI6IGNvbnN0YW50cy5BZGRyZXNzWmVybyxcbiAgICB0d0ZhY3Rvcnk6IFwiMHhkMjRiM2RlMDg1Q0ZkOGM1NGI5NGZlQUQwOGE3OTYyRDM0M0U2REUwXCIsXG4gICAgdHdSZWdpc3RyeTogXCIweDdjNDg3ODQ1Zjk4OTM4QmI5NTVCMUQ1QUQwNjlkOWEzMGU0MTMxZmRcIixcbiAgICB0d0JZT0NSZWdpc3RyeTogY29uc3RhbnRzLkFkZHJlc3NaZXJvXG4gIH0sXG4gIFtDaGFpbklkLk9wdGltaXNtXToge1xuICAgIG9wZW56ZXBwZWxpbkZvcndhcmRlcjogT1pfREVGRU5ERVJfRk9SV0FSREVSX0FERFJFU1MsXG4gICAgb3BlbnplcHBlbGluRm9yd2FyZGVyRU9BOiBcIjB4N2U4MDY0OEVCMjA3MUUyNjkzN0Y5RDQyQTUxM2NjZjQ4MTVmYzcwMlwiLFxuICAgIGJpY29ub215Rm9yd2FyZGVyOiBcIjB4ZWZiYThhMmE4MmVjMWZiMTI3MzgwNjE3NGY1ZTI4ZmJiOTE3Y2Y5NVwiLFxuICAgIHR3RmFjdG9yeTogXCIweGQyNGIzZGUwODVDRmQ4YzU0Yjk0ZmVBRDA4YTc5NjJEMzQzRTZERTBcIixcbiAgICB0d1JlZ2lzdHJ5OiBcIjB4N2M0ODc4NDVmOTg5MzhCYjk1NUIxRDVBRDA2OWQ5YTMwZTQxMzFmZFwiLFxuICAgIHR3QllPQ1JlZ2lzdHJ5OiBjb25zdGFudHMuQWRkcmVzc1plcm9cbiAgfSxcbiAgW0NoYWluSWQuT3B0aW1pc21Hb2VybGldOiB7XG4gICAgb3BlbnplcHBlbGluRm9yd2FyZGVyOiBcIjB4OGNiYzhCNWQ3MTcwMjAzMjkwNDc1MEE2NkFFZkU4QjYwM2VCQzUzOFwiLFxuICAgIG9wZW56ZXBwZWxpbkZvcndhcmRlckVPQTogXCIweDExOTcwNDMxNEVmMzA0RWFBQUU0YjNjN0M5QUJkNTkyNzJBMjgzMTBcIixcbiAgICBiaWNvbm9teUZvcndhcmRlcjogY29uc3RhbnRzLkFkZHJlc3NaZXJvLFxuICAgIHR3RmFjdG9yeTogXCIweGQyNGIzZGUwODVDRmQ4YzU0Yjk0ZmVBRDA4YTc5NjJEMzQzRTZERTBcIixcbiAgICB0d1JlZ2lzdHJ5OiBcIjB4N2M0ODc4NDVmOTg5MzhCYjk1NUIxRDVBRDA2OWQ5YTMwZTQxMzFmZFwiLFxuICAgIHR3QllPQ1JlZ2lzdHJ5OiBjb25zdGFudHMuQWRkcmVzc1plcm9cbiAgfSxcbiAgW0NoYWluSWQuQmluYW5jZVNtYXJ0Q2hhaW5NYWlubmV0XToge1xuICAgIG9wZW56ZXBwZWxpbkZvcndhcmRlcjogXCIweDhjYmM4QjVkNzE3MDIwMzI5MDQ3NTBBNjZBRWZFOEI2MDNlQkM1MzhcIixcbiAgICBvcGVuemVwcGVsaW5Gb3J3YXJkZXJFT0E6IFwiMHhFOGRkMkZmMDIxMkY4NmQzMTk3YjRBZkRDNmRBQzZhYzQ3ZWIxMGFDXCIsXG4gICAgYmljb25vbXlGb3J3YXJkZXI6IFwiMHg4NkM4MGE4YWE1OGUwQTRmYTA5QTY5NjI0YzMxQWIyYTZDQUQ1NmI4XCIsXG4gICAgdHdCWU9DUmVnaXN0cnk6IGNvbnN0YW50cy5BZGRyZXNzWmVybyxcbiAgICB0d0ZhY3Rvcnk6IFwiMHhkMjRiM2RlMDg1Q0ZkOGM1NGI5NGZlQUQwOGE3OTYyRDM0M0U2REUwXCIsXG4gICAgdHdSZWdpc3RyeTogXCIweDdjNDg3ODQ1Zjk4OTM4QmI5NTVCMUQ1QUQwNjlkOWEzMGU0MTMxZmRcIlxuICB9LFxuICBbQ2hhaW5JZC5CaW5hbmNlU21hcnRDaGFpblRlc3RuZXRdOiB7XG4gICAgb3BlbnplcHBlbGluRm9yd2FyZGVyOiBcIjB4OGNiYzhCNWQ3MTcwMjAzMjkwNDc1MEE2NkFFZkU4QjYwM2VCQzUzOFwiLFxuICAgIG9wZW56ZXBwZWxpbkZvcndhcmRlckVPQTogXCIweDdlODA2NDhFQjIwNzFFMjY5MzdGOUQ0MkE1MTNjY2Y0ODE1ZmM3MDJcIixcbiAgICBiaWNvbm9teUZvcndhcmRlcjogXCIweDYxNDU2QkYxNzE1QzE0MTU3MzAwNzZCQjc5YWUxMThFODA2RTc0ZDJcIixcbiAgICB0d0JZT0NSZWdpc3RyeTogY29uc3RhbnRzLkFkZHJlc3NaZXJvLFxuICAgIHR3RmFjdG9yeTogXCIweGQyNGIzZGUwODVDRmQ4YzU0Yjk0ZmVBRDA4YTc5NjJEMzQzRTZERTBcIixcbiAgICB0d1JlZ2lzdHJ5OiBcIjB4N2M0ODc4NDVmOTg5MzhCYjk1NUIxRDVBRDA2OWQ5YTMwZTQxMzFmZFwiXG4gIH1cbn07XG5jb25zdCBBUFBST1ZFRF9JTVBMRU1FTlRBVElPTlMgPSB7XG4gIFtDaGFpbklkLk1haW5uZXRdOiB7XG4gICAgXCJuZnQtZHJvcFwiOiBcIjB4NjBmRjk5NTJlMDA4NEE2REVhYzQ0MjAzODM4Y0RDOTFBQmVDODczNlwiLFxuICAgIFwiZWRpdGlvbi1kcm9wXCI6IFwiMHg3NGFmMjYyZDA2NzFGMzc4Rjk3YTFFREMzZDA5NzBEYmU4QTFDNTUwXCIsXG4gICAgXCJ0b2tlbi1kcm9wXCI6IFwiMHhFMWVFNDNEMjNmMjQ3YjZBOWFGODFmY0UyNzY2RTc2NzA5NDgyNzI4XCIsXG4gICAgXCJzaWduYXR1cmUtZHJvcFwiOiBcIjB4NmZENjkwRUI1MDlCZEU0QzUwMDI4QzVEOUMwZEUzNzUwQzJGYWQ2QVwiXG4gIH0sXG4gIFtDaGFpbklkLlBvbHlnb25dOiB7XG4gICAgXCJuZnQtZHJvcFwiOiBcIjB4Qjk2NTA4MDUwQmEwOTI1MjU2MTg0MTAzNTYwRUJBREE5MTJGY2M2OVwiLFxuICAgIFwiZWRpdGlvbi1kcm9wXCI6IFwiMHg3NGFmMjYyZDA2NzFGMzc4Rjk3YTFFREMzZDA5NzBEYmU4QTFDNTUwXCIsXG4gICAgXCJ0b2tlbi1kcm9wXCI6IFwiMHg1QThlQTRBZGFkODI4OTc0NkQwNzM5NDdCQTA2RDY5QTYyNDk5YWFmXCIsXG4gICAgXCJzaWduYXR1cmUtZHJvcFwiOiBcIjB4QkUyZkRjMzU0MTBFMjY4ZTQxQmVjNjJEQmIwMUFFYjQzMjQ1YzdkNVwiXG4gIH0sXG4gIFtDaGFpbklkLkZhbnRvbV06IHtcbiAgICBcIm5mdC1kcm9wXCI6IFwiMHgyQTM5NmIyRDkwQkFjRUYxOWNEYTk3MzU4NkIyNjMzZDIyNzEwZkMyXCIsXG4gICAgXCJlZGl0aW9uLWRyb3BcIjogXCIweDA2Mzk1RkNGOUFDNkVEODI3ZjlkRDZlNzc2ODA5Y0VGMUJlMGQyMUJcIixcbiAgICBcInRva2VuLWRyb3BcIjogXCIweDAxNDhiMjhhMzhlZmFhQzMxYjZhYTBhNkQ5RkViNzBGRTdDOTFGRmFcIixcbiAgICBcInNpZ25hdHVyZS1kcm9wXCI6IFwiMHhlMTM1RWY2NUMyQjIyMTNDM2ZENTZkMEJkNjUwMEEyY0ExNDdhQzEwXCJcbiAgfSxcbiAgW0NoYWluSWQuQXZhbGFuY2hlXToge1xuICAgIFwibmZ0LWRyb3BcIjogXCIweDljRjkxMTE4QzhlZTI5MTNGMDU4OGUwRjEwZTM2QjNkNjNGNjhiRjZcIixcbiAgICBcImVkaXRpb24tZHJvcFwiOiBcIjB4MTM1ZkM5RDI2RTVlQzUxMjYwZWNlMURGNEVENDI0RTJmNTVjNzc2NlwiLFxuICAgIFwidG9rZW4tZHJvcFwiOiBcIjB4Y2EwQjA3MTg5OUU1NzVCQTg2NDk1RDQ2YzUwNjY5NzFiNmYzQTkwMVwiLFxuICAgIFwic2lnbmF0dXJlLWRyb3BcIjogXCIweDFkNDc1MjZDMzI5MkIwMTMwZWYwYWZENUYwMmMxREEwNTJBMDE3QjNcIlxuICB9LFxuICBbQ2hhaW5JZC5PcHRpbWlzbV06IHtcbiAgICBcIm5mdC1kcm9wXCI6IFwiMHhGQmQ3RDI0ZDgwZWUwMDU2NzFFNzMxYTcyODdERUI2MDczMjY0ZEQxXCIsXG4gICAgXCJlZGl0aW9uLWRyb3BcIjogXCIweGUxMzVFZjY1QzJCMjIxM0MzZkQ1NmQwQmQ2NTAwQTJjQTE0N2FDMTBcIixcbiAgICBcInRva2VuLWRyb3BcIjogXCIweDkwMkRkMjQ2ZTY2ZDhDM0NFNjUyMzc1YTcyM0YyYTUyYjQzYjlBQUVcIixcbiAgICBcInNpZ25hdHVyZS1kcm9wXCI6IFwiMHg4YTRjZDM1NDllNTQ4YmJFRWIzOEMxNkUwNDFGRmYwNDBhNWFjYWJEXCJcbiAgfSxcbiAgW0NoYWluSWQuQXJiaXRydW1dOiB7XG4gICAgXCJuZnQtZHJvcFwiOiBcIjB4QzQ5MDNjMUZmNTM2N2I5YWMyYzM0OUI2M0RDMjQwOTQyMUFhRUUyYVwiLFxuICAgIFwiZWRpdGlvbi1kcm9wXCI6IFwiMHhDY2RkY2VjMTgzMTY0NkJlZmYyNzUzMjQ5ZjFCOUM1ODAzMjdFODlGXCIsXG4gICAgXCJ0b2tlbi1kcm9wXCI6IFwiMHgxYjU5NDdlMWEyZDVhMjlEMGRmMjA5MzFEZUFCMEI4NzgxODIwOUI5XCIsXG4gICAgXCJzaWduYXR1cmUtZHJvcFwiOiBcIjB4MmRGOTg1MWFmNDVkZDQxQzg1ODRhYzU1RDk4M0M2MDRkYTk4NUJjN1wiXG4gIH0sXG4gIFtDaGFpbklkLkJpbmFuY2VTbWFydENoYWluTWFpbm5ldF06IHtcbiAgICBcIm5mdC1kcm9wXCI6IFwiMHg5MDJEZDI0NmU2NmQ4QzNDRTY1MjM3NWE3MjNGMmE1MmI0M2I5QUFFXCIsXG4gICAgXCJlZGl0aW9uLWRyb3BcIjogXCIweDJBMzk2YjJEOTBCQWNFRjE5Y0RhOTczNTg2QjI2MzNkMjI3MTBmQzJcIixcbiAgICBcInRva2VuLWRyb3BcIjogXCIweGUxMzVFZjY1QzJCMjIxM0MzZkQ1NmQwQmQ2NTAwQTJjQTE0N2FDMTBcIixcbiAgICBcInNpZ25hdHVyZS1kcm9wXCI6IFwiMHhGQmQ3RDI0ZDgwZWUwMDU2NzFFNzMxYTcyODdERUI2MDczMjY0ZEQxXCJcbiAgfSxcbiAgW0NoYWluSWQuR29lcmxpXToge1xuICAgIFwibmZ0LWRyb3BcIjogXCIweEQxMWM5N0RENUY1NTQ2QjViQmQ2MzBEN0QxZDczMjc0ODFCMGI5MkNcIixcbiAgICBcImVkaXRpb24tZHJvcFwiOiBcIjB4NUE4ZUE0QWRhZDgyODk3NDZEMDczOTQ3QkEwNkQ2OUE2MjQ5OWFhZlwiLFxuICAgIFwidG9rZW4tZHJvcFwiOiBcIjB4NTY4MDkzMzIyMUI3NTJFQjQ0MzY1NGEwMTRmODhCMTAxRjg2OGQ1MFwiLFxuICAgIFwic2lnbmF0dXJlLWRyb3BcIjogXCIweDFiNTk0N2UxYTJkNWEyOUQwZGYyMDkzMURlQUIwQjg3ODE4MjA5QjlcIlxuICB9LFxuICBbQ2hhaW5JZC5NdW1iYWldOiB7XG4gICAgXCJuZnQtZHJvcFwiOiBcIjB4QzQ5MDNjMUZmNTM2N2I5YWMyYzM0OUI2M0RDMjQwOTQyMUFhRUUyYVwiLFxuICAgIFwiZWRpdGlvbi1kcm9wXCI6IFwiMHhDY2RkY2VjMTgzMTY0NkJlZmYyNzUzMjQ5ZjFCOUM1ODAzMjdFODlGXCIsXG4gICAgXCJ0b2tlbi1kcm9wXCI6IFwiMHgxYjU5NDdlMWEyZDVhMjlEMGRmMjA5MzFEZUFCMEI4NzgxODIwOUI5XCIsXG4gICAgXCJzaWduYXR1cmUtZHJvcFwiOiBcIjB4MmRGOTg1MWFmNDVkZDQxQzg1ODRhYzU1RDk4M0M2MDRkYTk4NUJjN1wiXG4gIH0sXG4gIFtDaGFpbklkLkZhbnRvbVRlc3RuZXRdOiB7XG4gICAgXCJuZnQtZHJvcFwiOiBcIjB4OGE0Y2QzNTQ5ZTU0OGJiRUViMzhDMTZFMDQxRkZmMDQwYTVhY2FiRFwiLFxuICAgIFwiZWRpdGlvbi1kcm9wXCI6IFwiMHg5MDJEZDI0NmU2NmQ4QzNDRTY1MjM3NWE3MjNGMmE1MmI0M2I5QUFFXCIsXG4gICAgXCJ0b2tlbi1kcm9wXCI6IFwiMHhGQmQ3RDI0ZDgwZWUwMDU2NzFFNzMxYTcyODdERUI2MDczMjY0ZEQxXCIsXG4gICAgXCJzaWduYXR1cmUtZHJvcFwiOiBcIjB4NUE4ZUE0QWRhZDgyODk3NDZEMDczOTQ3QkEwNkQ2OUE2MjQ5OWFhZlwiXG4gIH0sXG4gIFtDaGFpbklkLkF2YWxhbmNoZUZ1amlUZXN0bmV0XToge1xuICAgIFwibmZ0LWRyb3BcIjogXCIweEQxMWM5N0RENUY1NTQ2QjViQmQ2MzBEN0QxZDczMjc0ODFCMGI5MkNcIixcbiAgICBcImVkaXRpb24tZHJvcFwiOiBcIjB4RTFlRTQzRDIzZjI0N2I2QTlhRjgxZmNFMjc2NkU3NjcwOTQ4MjcyOFwiLFxuICAgIFwidG9rZW4tZHJvcFwiOiBcIjB4NmZENjkwRUI1MDlCZEU0QzUwMDI4QzVEOUMwZEUzNzUwQzJGYWQ2QVwiLFxuICAgIFwic2lnbmF0dXJlLWRyb3BcIjogXCIweENjZGRjZWMxODMxNjQ2QmVmZjI3NTMyNDlmMUI5QzU4MDMyN0U4OUZcIlxuICB9LFxuICBbQ2hhaW5JZC5PcHRpbWlzbUdvZXJsaV06IHtcbiAgICBcIm5mdC1kcm9wXCI6IFwiMHhDY2RkY2VjMTgzMTY0NkJlZmYyNzUzMjQ5ZjFCOUM1ODAzMjdFODlGXCIsXG4gICAgXCJlZGl0aW9uLWRyb3BcIjogXCIweDZmRDY5MEVCNTA5QmRFNEM1MDAyOEM1RDlDMGRFMzc1MEMyRmFkNkFcIixcbiAgICBcInRva2VuLWRyb3BcIjogXCIweEQxMWM5N0RENUY1NTQ2QjViQmQ2MzBEN0QxZDczMjc0ODFCMGI5MkNcIixcbiAgICBcInNpZ25hdHVyZS1kcm9wXCI6IFwiMHgxYjU5NDdlMWEyZDVhMjlEMGRmMjA5MzFEZUFCMEI4NzgxODIwOUI5XCJcbiAgfSxcbiAgW0NoYWluSWQuQXJiaXRydW1Hb2VybGldOiB7XG4gICAgXCJuZnQtZHJvcFwiOiBcIjB4OUNmRTgwN2E1YjEyNGI5NjIwNjRGYThGN0ZEODIzQ2M3MDEyNTViNlwiLFxuICAgIFwiZWRpdGlvbi1kcm9wXCI6IFwiMHg5Y0Y5MTExOEM4ZWUyOTEzRjA1ODhlMEYxMGUzNkIzZDYzRjY4YkY2XCIsXG4gICAgXCJ0b2tlbi1kcm9wXCI6IFwiMHgxZDQ3NTI2QzMyOTJCMDEzMGVmMGFmRDVGMDJjMURBMDUyQTAxN0IzXCIsXG4gICAgXCJzaWduYXR1cmUtZHJvcFwiOiBcIjB4RTFlRTQzRDIzZjI0N2I2QTlhRjgxZmNFMjc2NkU3NjcwOTQ4MjcyOFwiXG4gIH0sXG4gIFtDaGFpbklkLkJpbmFuY2VTbWFydENoYWluVGVzdG5ldF06IHtcbiAgICBcIm5mdC1kcm9wXCI6IFwiXCIsXG4gICAgXCJlZGl0aW9uLWRyb3BcIjogXCJcIixcbiAgICBcInRva2VuLWRyb3BcIjogXCJcIixcbiAgICBcInNpZ25hdHVyZS1kcm9wXCI6IFwiXCIgLy8gVE9ET1xuICB9XG59O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGNoYWluSWRcbiAqIEBwYXJhbSBjb250cmFjdFR5cGVcbiAqL1xuZnVuY3Rpb24gZ2V0QXBwcm92ZWRJbXBsZW1lbnRhdGlvbihjaGFpbklkLFxuLy8gVE9ETyB1c2UgU3VwcG9ydGVkQ2hhaW5JZCBvbmNlIHdlIGRlcGxveSB0byBhbGwgY2hhaW5zXG5jb250cmFjdFR5cGUpIHtcbiAgaWYgKGNoYWluSWQgaW4gQVBQUk9WRURfSU1QTEVNRU5UQVRJT05TKSB7XG4gICAgY29uc3QgYXBwcm92ZWRJbXBscyA9IEFQUFJPVkVEX0lNUExFTUVOVEFUSU9OU1tjaGFpbklkXTtcbiAgICBpZiAoY29udHJhY3RUeXBlIGluIGFwcHJvdmVkSW1wbHMpIHtcbiAgICAgIHJldHVybiBhcHByb3ZlZEltcGxzW2NvbnRyYWN0VHlwZV07XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRDb250cmFjdEFkZHJlc3NCeUNoYWluSWQoY2hhaW5JZCwgY29udHJhY3ROYW1lKSB7XG4gIC8vIGZvciB0ZXN0aW5nIG9ubHlcbiAgaWYgKGNoYWluSWQgPT09IENoYWluSWQuSGFyZGhhdCkge1xuICAgIGlmIChjb250cmFjdE5hbWUgPT09IFwidHdGYWN0b3J5XCIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB0dXJiby9uby11bmRlY2xhcmVkLWVudi12YXJzXG4gICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuZmFjdG9yeUFkZHJlc3M7XG4gICAgfSBlbHNlIGlmIChjb250cmFjdE5hbWUgPT09IFwidHdSZWdpc3RyeVwiKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdHVyYm8vbm8tdW5kZWNsYXJlZC1lbnYtdmFyc1xuICAgICAgcmV0dXJuIHByb2Nlc3MuZW52LnJlZ2lzdHJ5QWRkcmVzcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbnN0YW50cy5BZGRyZXNzWmVybztcbiAgICB9XG4gIH1cbiAgLy8gcmVhbCBvdXRwdXQgaGVyZVxuICByZXR1cm4gQ09OVFJBQ1RfQUREUkVTU0VTW2NoYWluSWRdW2NvbnRyYWN0TmFtZV07XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldENvbnRyYWN0UHVibGlzaGVyQWRkcmVzcygpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHR1cmJvL25vLXVuZGVjbGFyZWQtZW52LXZhcnNcbiAgaWYgKHByb2Nlc3MuZW52LmNvbnRyYWN0UHVibGlzaGVyQWRkcmVzcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB0dXJiby9uby11bmRlY2xhcmVkLWVudi12YXJzXG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LmNvbnRyYWN0UHVibGlzaGVyQWRkcmVzcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQ29udHJhY3RQdWJsaXNoZXJfYWRkcmVzcztcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gY2hhaW5JZCAtIGNoYWluIGlkXG4gKiBAcmV0dXJucyB0aGUgYXJyYXkgb2YgdHJ1c3RlZCBmb3J3YXJkZXJzIGZvciB0aGUgZ2l2ZW4gY2hhaW4gaWRcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0VHJ1c3RlZEZvcndhcmRlcnMoY2hhaW5JZCkge1xuICBjb25zdCBjaGFpbkVudW0gPSBTVVBQT1JURURfQ0hBSU5fSURTLmZpbmQoYyA9PiBjID09PSBjaGFpbklkKTtcbiAgY29uc3QgYmljb25vbXlGb3J3YXJkZXIgPSBjaGFpbkVudW0gPyBDT05UUkFDVF9BRERSRVNTRVNbY2hhaW5FbnVtXS5iaWNvbm9teUZvcndhcmRlciA6IGNvbnN0YW50cy5BZGRyZXNzWmVybztcbiAgY29uc3Qgb3BlbnplcHBlbGluRm9yd2FyZGVyID0gY2hhaW5FbnVtID8gQ09OVFJBQ1RfQUREUkVTU0VTW2NoYWluRW51bV0ub3BlbnplcHBlbGluRm9yd2FyZGVyIDogY29uc3RhbnRzLkFkZHJlc3NaZXJvO1xuICByZXR1cm4gYmljb25vbXlGb3J3YXJkZXIgIT09IGNvbnN0YW50cy5BZGRyZXNzWmVybyA/IFtvcGVuemVwcGVsaW5Gb3J3YXJkZXIsIGJpY29ub215Rm9yd2FyZGVyXSA6IFtvcGVuemVwcGVsaW5Gb3J3YXJkZXJdO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEludGVyZmFjZUlkX0lFUkM3MjEgPSB1dGlscy5hcnJheWlmeShcIjB4ODBhYzU4Y2RcIik7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEludGVyZmFjZUlkX0lFUkMxMTU1ID0gdXRpbHMuYXJyYXlpZnkoXCIweGQ5YjY3YTI2XCIpO1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xubGV0IEV2ZW50VHlwZTtcbihmdW5jdGlvbiAoRXZlbnRUeXBlKSB7XG4gIEV2ZW50VHlwZVtcIlRyYW5zYWN0aW9uXCJdID0gXCJ0cmFuc2FjdGlvblwiO1xuICBFdmVudFR5cGVbXCJTaWduYXR1cmVcIl0gPSBcInNpZ25hdHVyZVwiO1xufSkoRXZlbnRUeXBlIHx8IChFdmVudFR5cGUgPSB7fSkpO1xuXG5jb25zdCBERUZBVUxUX0JBVENIX1RJTUVfTElNSVRfTVMgPSA1MDtcbmNvbnN0IERFRkFVTFRfQkFUQ0hfU0laRV9MSU1JVCA9IDI1MDtcbmNvbnN0IERFRkFVTFRfQkFUQ0hfT1BUSU9OUyA9IHtcbiAgdGltZUxpbWl0TXM6IERFRkFVTFRfQkFUQ0hfVElNRV9MSU1JVF9NUyxcbiAgc2l6ZUxpbWl0OiBERUZBVUxUX0JBVENIX1NJWkVfTElNSVRcbn07XG4vLyBtb3N0bHkgY29waWVkIGZyb20gZXRoZXJzLmpzIGRpcmVjdGx5IGJ1dCBtYWtlIGl0IGEgU3RhdGljSnNvblJwY1Byb3ZpZGVyXG5jbGFzcyBTdGF0aWNKc29uUnBjQmF0Y2hQcm92aWRlciBleHRlbmRzIHByb3ZpZGVycy5TdGF0aWNKc29uUnBjUHJvdmlkZXIge1xuICBjb25zdHJ1Y3Rvcih1cmwsIG5ldHdvcmspIHtcbiAgICBsZXQgYmF0Y2hPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBERUZBVUxUX0JBVENIX09QVElPTlM7XG4gICAgc3VwZXIodXJsLCBuZXR3b3JrKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGltZUxpbWl0TXNcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2l6ZUxpbWl0XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BlbmRpbmdCYXRjaEFnZ3JlZ2F0b3JcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcGVuZGluZ0JhdGNoXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5fdGltZUxpbWl0TXMgPSBiYXRjaE9wdGlvbnMudGltZUxpbWl0TXMgfHwgREVGQVVMVF9CQVRDSF9TSVpFX0xJTUlUO1xuICAgIHRoaXMuX3NpemVMaW1pdCA9IGJhdGNoT3B0aW9ucy5zaXplTGltaXQgfHwgREVGQVVMVF9CQVRDSF9USU1FX0xJTUlUX01TO1xuICAgIHRoaXMuX3BlbmRpbmdCYXRjaEFnZ3JlZ2F0b3IgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdCYXRjaCA9IG51bGw7XG4gIH1cbiAgc2VuZEN1cnJlbnRCYXRjaChyZXF1ZXN0KSB7XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBhIHRpbWVvdXQgY2xlYXIgdGhhdCBmaXJzdFxuICAgIGlmICh0aGlzLl9wZW5kaW5nQmF0Y2hBZ2dyZWdhdG9yKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fcGVuZGluZ0JhdGNoQWdncmVnYXRvcik7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgY3VycmVudCBiYXRjaCBhbmQgY2xlYXIgaXQsIHNvIG5ldyByZXF1ZXN0c1xuICAgIC8vIGdvIGludG8gdGhlIG5leHQgYmF0Y2hcbiAgICBjb25zdCBiYXRjaCA9IHRoaXMuX3BlbmRpbmdCYXRjaCB8fCBbXTtcbiAgICB0aGlzLl9wZW5kaW5nQmF0Y2ggPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdCYXRjaEFnZ3JlZ2F0b3IgPSBudWxsO1xuXG4gICAgLy8gR2V0IHRoZSByZXF1ZXN0IGFzIGFuIGFycmF5IG9mIHJlcXVlc3RzXG4gICAgY29uc3QgcmVxdWVzdF8gPSBiYXRjaC5tYXAoaW5mbGlnaHQgPT4gaW5mbGlnaHQucmVxdWVzdCk7XG4gICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgYWN0aW9uOiBcInJlcXVlc3RCYXRjaFwiLFxuICAgICAgcmVxdWVzdDogdXRpbHMuZGVlcENvcHkocmVxdWVzdCksXG4gICAgICBwcm92aWRlcjogdGhpc1xuICAgIH0pO1xuICAgIHJldHVybiB1dGlscy5mZXRjaEpzb24odGhpcy5jb25uZWN0aW9uLCBKU09OLnN0cmluZ2lmeShyZXF1ZXN0XykpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RfLFxuICAgICAgICByZXNwb25zZTogcmVzdWx0LFxuICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEZvciBlYWNoIHJlc3VsdCwgZmVlZCBpdCB0byB0aGUgY29ycmVjdCBQcm9taXNlLCBkZXBlbmRpbmdcbiAgICAgIC8vIG9uIHdoZXRoZXIgaXQgd2FzIGEgc3VjY2VzcyBvciBlcnJvclxuICAgICAgYmF0Y2guZm9yRWFjaCgoaW5mbGlnaHRSZXF1ZXN0XywgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHJlc3VsdFtpbmRleF07XG4gICAgICAgIGlmIChwYXlsb2FkLmVycm9yKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IocGF5bG9hZC5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICBlcnJvci5jb2RlID0gcGF5bG9hZC5lcnJvci5jb2RlO1xuICAgICAgICAgIGVycm9yLmRhdGEgPSBwYXlsb2FkLmVycm9yLmRhdGE7XG4gICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0Xy5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdF8ucmVzb2x2ZShwYXlsb2FkLnJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGVycm9yID0+IHtcbiAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdF8sXG4gICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICB9KTtcblxuICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGVycm9yLCByZWplY3QgYWxsIHRoZSByZXF1ZXN0c1xuICAgICAgYmF0Y2guZm9yRWFjaChpbmZsaWdodFJlcXVlc3RfID0+IHtcbiAgICAgICAgaW5mbGlnaHRSZXF1ZXN0Xy5yZWplY3QoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgc2VuZChtZXRob2QsIHBhcmFtcykge1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgaWQ6IHRoaXMuX25leHRJZCsrLFxuICAgICAganNvbnJwYzogXCIyLjBcIlxuICAgIH07XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdCYXRjaCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fcGVuZGluZ0JhdGNoID0gW107XG4gICAgfVxuICAgIGNvbnN0IGluZmxpZ2h0UmVxdWVzdCA9IHtcbiAgICAgIHJlcXVlc3QsXG4gICAgICByZXNvbHZlOiBudWxsLFxuICAgICAgcmVqZWN0OiBudWxsXG4gICAgfTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIC8vIGlmIHdlIHdvdWxkIGdvICpvdmVyKiB0aGUgc2l6ZSBsaW1pdCBvZiB0aGUgYmF0Y2ggd2l0aCB0aGlzIHJlcXVlc3QsIHNlbmQgdGhlIGJhdGNoIG5vd1xuICAgIGlmICh0aGlzLl9wZW5kaW5nQmF0Y2gubGVuZ3RoID09PSB0aGlzLl9zaXplTGltaXQpIHtcbiAgICAgIHRoaXMuc2VuZEN1cnJlbnRCYXRjaChyZXF1ZXN0KTtcbiAgICB9XG4gICAgdGhpcy5fcGVuZGluZ0JhdGNoLnB1c2goaW5mbGlnaHRSZXF1ZXN0KTtcbiAgICBpZiAoIXRoaXMuX3BlbmRpbmdCYXRjaEFnZ3JlZ2F0b3IpIHtcbiAgICAgIC8vIFNjaGVkdWxlIGJhdGNoIGZvciBuZXh0IGV2ZW50IGxvb3AgKyBzaG9ydCBkdXJhdGlvblxuICAgICAgdGhpcy5fcGVuZGluZ0JhdGNoQWdncmVnYXRvciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnNlbmRDdXJyZW50QmF0Y2gocmVxdWVzdCk7XG4gICAgICB9LCB0aGlzLl90aW1lTGltaXRNcyk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IERFRkFVTFRfSVBGU19HQVRFV0FZID0gXCJodHRwczovL2dhdGV3YXkuaXBmc2Nkbi5pby9pcGZzL1wiO1xuY29uc3QgQ0hBSU5fTkFNRV9UT19JRCA9IHtcbiAgXCJhdmFsYW5jaGUtZnVqaVwiOiBDaGFpbklkLkF2YWxhbmNoZUZ1amlUZXN0bmV0LFxuICBcImF2YWxhbmNoZS10ZXN0bmV0XCI6IENoYWluSWQuQXZhbGFuY2hlRnVqaVRlc3RuZXQsXG4gIFwiZmFudG9tLXRlc3RuZXRcIjogQ2hhaW5JZC5GYW50b21UZXN0bmV0LFxuICBldGhlcmV1bTogQ2hhaW5JZC5NYWlubmV0LFxuICBtYXRpYzogQ2hhaW5JZC5Qb2x5Z29uLFxuICBtdW1iYWk6IENoYWluSWQuTXVtYmFpLFxuICBnb2VybGk6IENoYWluSWQuR29lcmxpLFxuICBwb2x5Z29uOiBDaGFpbklkLlBvbHlnb24sXG4gIG1haW5uZXQ6IENoYWluSWQuTWFpbm5ldCxcbiAgb3B0aW1pc206IENoYWluSWQuT3B0aW1pc20sXG4gIFwib3B0aW1pc20tZ29lcmxpXCI6IENoYWluSWQuT3B0aW1pc21Hb2VybGksXG4gIGFyYml0cnVtOiBDaGFpbklkLkFyYml0cnVtLFxuICBcImFyYml0cnVtLWdvZXJsaVwiOiBDaGFpbklkLkFyYml0cnVtR29lcmxpLFxuICBmYW50b206IENoYWluSWQuRmFudG9tLFxuICBhdmFsYW5jaGU6IENoYWluSWQuQXZhbGFuY2hlLFxuICBiaW5hbmNlOiBDaGFpbklkLkJpbmFuY2VTbWFydENoYWluTWFpbm5ldCxcbiAgXCJiaW5hbmNlLXRlc3RuZXRcIjogQ2hhaW5JZC5CaW5hbmNlU21hcnRDaGFpblRlc3RuZXRcbn07XG5jb25zdCBDSEFJTl9JRF9UT19OQU1FID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKENIQUlOX05BTUVfVE9fSUQpLm1hcChfcmVmID0+IHtcbiAgbGV0IFtuYW1lLCBpZF0gPSBfcmVmO1xuICByZXR1cm4gW2lkLCBuYW1lXTtcbn0pKTtcbmZ1bmN0aW9uIGJ1aWxkRGVmYXVsdE1hcCgpIHtcbiAgcmV0dXJuIFNVUFBPUlRFRF9DSEFJTl9JRFMucmVkdWNlKChwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpID0+IHtcbiAgICBwcmV2aW91c1ZhbHVlW2N1cnJlbnRWYWx1ZV0gPSBnZXRQcm92aWRlckZvck5ldHdvcmsoQ0hBSU5fSURfVE9fTkFNRVtjdXJyZW50VmFsdWVdKTtcbiAgICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbiAgfSwge30pO1xufVxuY29uc3QgREVGQVVMVF9SUENfVVJMUyA9IGJ1aWxkRGVmYXVsdE1hcCgpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIG5ldHdvcmsgLSB0aGUgY2hhaW4gbmFtZSBvciBycGMgdXJsXG4gKiBAcmV0dXJucyB0aGUgcnBjIHVybCBmb3IgdGhhdCBjaGFpblxuICovXG5mdW5jdGlvbiBnZXRQcm92aWRlckZvck5ldHdvcmsobmV0d29yaykge1xuICBpZiAodHlwZW9mIG5ldHdvcmsgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbmV0d29yaztcbiAgfVxuICBzd2l0Y2ggKG5ldHdvcmspIHtcbiAgICBjYXNlIFwibWFpbm5ldFwiOlxuICAgIGNhc2UgXCJldGhlcmV1bVwiOlxuICAgICAgcmV0dXJuIGdldFJwY1VybChcImV0aGVyZXVtXCIpO1xuICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgIHJldHVybiBnZXRScGNVcmwoXCJnb2VybGlcIik7XG4gICAgY2FzZSBcInBvbHlnb25cIjpcbiAgICBjYXNlIFwibWF0aWNcIjpcbiAgICAgIHJldHVybiBnZXRScGNVcmwoXCJwb2x5Z29uXCIpO1xuICAgIGNhc2UgXCJtdW1iYWlcIjpcbiAgICAgIHJldHVybiBnZXRScGNVcmwoXCJtdW1iYWlcIik7XG4gICAgY2FzZSBcIm9wdGltaXNtXCI6XG4gICAgICByZXR1cm4gZ2V0UnBjVXJsKFwib3B0aW1pc21cIik7XG4gICAgY2FzZSBcIm9wdGltaXNtLWdvZXJsaVwiOlxuICAgICAgcmV0dXJuIGdldFJwY1VybChcIm9wdGltaXNtLWdvZXJsaVwiKTtcbiAgICBjYXNlIFwiYXJiaXRydW1cIjpcbiAgICAgIHJldHVybiBnZXRScGNVcmwoXCJhcmJpdHJ1bVwiKTtcbiAgICBjYXNlIFwiYXJiaXRydW0tZ29lcmxpXCI6XG4gICAgICByZXR1cm4gZ2V0UnBjVXJsKFwiYXJiaXRydW0tZ29lcmxpXCIpO1xuICAgIGNhc2UgXCJmYW50b21cIjpcbiAgICAgIHJldHVybiBnZXRScGNVcmwoXCJmYW50b21cIik7XG4gICAgY2FzZSBcImZhbnRvbS10ZXN0bmV0XCI6XG4gICAgICByZXR1cm4gZ2V0UnBjVXJsKFwiZmFudG9tLXRlc3RuZXRcIik7XG4gICAgY2FzZSBcImF2YWxhbmNoZVwiOlxuICAgICAgcmV0dXJuIGdldFJwY1VybChcImF2YWxhbmNoZVwiKTtcbiAgICBjYXNlIFwiYXZhbGFuY2hlLXRlc3RuZXRcIjpcbiAgICBjYXNlIFwiYXZhbGFuY2hlLWZ1amlcIjpcbiAgICAgIHJldHVybiBnZXRScGNVcmwoXCJhdmFsYW5jaGUtZnVqaVwiKTtcbiAgICBjYXNlIFwiYmluYW5jZVwiOlxuICAgICAgcmV0dXJuIGdldFJwY1VybChcImJpbmFuY2VcIik7XG4gICAgY2FzZSBcImJpbmFuY2UtdGVzdG5ldFwiOlxuICAgICAgcmV0dXJuIGdldFJwY1VybChcImJpbmFuY2UtdGVzdG5ldFwiKTtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKG5ldHdvcmsuc3RhcnRzV2l0aChcImh0dHBcIikgfHwgbmV0d29yay5zdGFydHNXaXRoKFwid3NcIikpIHtcbiAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBjaGFpbiBuYW1lIG9yIFJQQyB1cmw6ICR7bmV0d29ya31gKTtcbiAgICAgIH1cbiAgfVxufVxuY29uc3QgUkVBRE9OTFlfUFJPVklERVJfTUFQID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gbmV0d29yayAtIHRoZSBjaGFpbiBuYW1lIG9yIHJwYyB1cmxcbiAqIEBwYXJhbSBjaGFpbklkIC0gdGhlIG9wdGlvbmFsIGNoYWluIGlkXG4gKiBAcmV0dXJucyB0aGUgcHJvdmlkZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UmVhZE9ubHlQcm92aWRlcihuZXR3b3JrLCBjaGFpbklkKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgbWF0Y2ggPSBuZXR3b3JrLm1hdGNoKC9eKHdzfGh0dHApcz86L2kpO1xuICAgIC8vIHRyeSB0aGUgSlNPTiBiYXRjaCBwcm92aWRlciBpZiBhdmFpbGFibGVcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHN3aXRjaCAobWF0Y2hbMV0pIHtcbiAgICAgICAgY2FzZSBcImh0dHBcIjpcbiAgICAgICAgICBjb25zdCBzZXJhbGl6ZWRPcHRzID0gYCR7bmV0d29ya30tJHtjaGFpbklkIHx8IC0xfWA7XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdQcm92aWRlciA9IFJFQURPTkxZX1BST1ZJREVSX01BUC5nZXQoc2VyYWxpemVkT3B0cyk7XG4gICAgICAgICAgaWYgKGV4aXN0aW5nUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ1Byb3ZpZGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBuZXdQcm92aWRlciA9IGNoYWluSWQgP1xuICAgICAgICAgIC8vIGlmIHdlIGtub3cgdGhlIGNoYWluSWQgd2Ugc2hvdWxkIHVzZSB0aGUgU3RhdGljSnNvblJwY0JhdGNoUHJvdmlkZXJcbiAgICAgICAgICBuZXcgU3RhdGljSnNvblJwY0JhdGNoUHJvdmlkZXIobmV0d29yaywgY2hhaW5JZCkgOlxuICAgICAgICAgIC8vIG90aGVyd2lzZSBmYWxsIGJhY2sgdG8gdGhlIGJ1aWx0IGluIGpzb24gcnBjIGJhdGNoIHByb3ZpZGVyXG4gICAgICAgICAgbmV3IHByb3ZpZGVycy5Kc29uUnBjQmF0Y2hQcm92aWRlcihuZXR3b3JrLCBjaGFpbklkKTtcbiAgICAgICAgICBSRUFET05MWV9QUk9WSURFUl9NQVAuc2V0KHNlcmFsaXplZE9wdHMsIG5ld1Byb3ZpZGVyKTtcbiAgICAgICAgICByZXR1cm4gbmV3UHJvdmlkZXI7XG4gICAgICAgIGNhc2UgXCJ3c1wiOlxuICAgICAgICAgIHJldHVybiBuZXcgcHJvdmlkZXJzLldlYlNvY2tldFByb3ZpZGVyKG5ldHdvcmssIGNoYWluSWQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBldGhlcnMuZ2V0RGVmYXVsdFByb3ZpZGVyKG5ldHdvcmspO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXRoZXJzLmdldERlZmF1bHRQcm92aWRlcihuZXR3b3JrKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBmYWxsYmFjayB0byB0aGUgZGVmYXVsdCBwcm92aWRlclxuICAgIHJldHVybiBldGhlcnMuZ2V0RGVmYXVsdFByb3ZpZGVyKG5ldHdvcmspO1xuICB9XG59XG5cbi8qKlxuICogRXJyb3IgdGhhdCBtYXkgZ2V0IHRocm93biBpZiBJUEZTIHJldHVybnMgbm90aGluZyBmb3IgYSBnaXZlbiB1cmkuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihpZGVudGlmaWVyKSB7XG4gICAgc3VwZXIoaWRlbnRpZmllciA/IGBPYmplY3Qgd2l0aCBpZCAke2lkZW50aWZpZXJ9IE5PVCBGT1VORGAgOiBcIk5PVF9GT1VORFwiKTtcbiAgfVxufVxuXG4vKipcbiAqIEVycm9yIHRoYXQgbWF5IGdldCB0aHJvd24gaWYgYW4gaW52YWxpZCBhZGRyZXNzIHdhcyBwYXNzZWRcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBJbnZhbGlkQWRkcmVzc0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKiogQGludGVybmFsICovXG4gIGNvbnN0cnVjdG9yKGFkZHJlc3MpIHtcbiAgICBzdXBlcihhZGRyZXNzID8gYCcke2FkZHJlc3N9JyBpcyBhbiBpbnZhbGlkIGFkZHJlc3NgIDogXCJJbnZhbGlkIGFkZHJlc3MgcGFzc2VkXCIpO1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIE1pc3NpbmdSb2xlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCByb2xlKSB7XG4gICAgc3VwZXIoYE1JU1NJTkcgUk9MRTogJHthZGRyZXNzfSBkb2VzIG5vdCBoYXZlIHRoZSAnJHtyb2xlfScgcm9sZWApO1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIEFzc2V0Tm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICAvKiogQGludGVybmFsICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBtZXNzYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBcIlRoZSBhc3NldCB5b3UncmUgdHJ5aW5nIHRvIHVzZSBjb3VsZCBub3QgYmUgZm91bmQuXCI7XG4gICAgc3VwZXIoYG1lc3NhZ2U6ICR7bWVzc2FnZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBVcGxvYWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoYFVQTE9BRF9GQUlMRUQ6ICR7bWVzc2FnZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBGaWxlTmFtZU1pc3NpbmdFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIkZpbGUgbmFtZSBpcyByZXF1aXJlZCB3aGVuIG9iamVjdCBpcyBub3QgYSBgRmlsZWAgdHlwZSBvYmplY3QuXCIpO1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIER1cGxpY2F0ZUZpbGVOYW1lRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3IoZmlsZU5hbWUpIHtcbiAgICBzdXBlcihgRFVQTElDQVRFX0ZJTEVfTkFNRV9FUlJPUjogRmlsZSBuYW1lICR7ZmlsZU5hbWV9IHdhcyBwYXNzZWQgZm9yIG1vcmUgdGhhbiBvbmUgZmlsZS5gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBOb3RFbm91Z2hUb2tlbnNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3Rvcihjb250cmFjdEFkZHJlc3MsIHF1YW50aXR5LCBhdmFpbGFibGUpIHtcbiAgICBzdXBlcihgQkFMQU5DRSBFUlJPUjogeW91IGRvIG5vdCBoYXZlIGVub3VnaCBiYWxhbmNlIG9uIGNvbnRyYWN0ICR7Y29udHJhY3RBZGRyZXNzfSB0byB1c2UgJHtxdWFudGl0eX0gdG9rZW5zLiBZb3UgaGF2ZSAke2F2YWlsYWJsZX0gdG9rZW5zIGF2YWlsYWJsZS5gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBNaXNzaW5nT3duZXJSb2xlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoYExJU1QgRVJST1I6IHlvdSBzaG91bGQgYmUgdGhlIG93bmVyIG9mIHRoZSB0b2tlbiB0byBsaXN0IGl0LmApO1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFF1YW50aXR5QWJvdmVMaW1pdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKiogQGludGVybmFsICovXG4gIGNvbnN0cnVjdG9yKHF1YW50aXR5KSB7XG4gICAgc3VwZXIoYEJVWSBFUlJPUjogWW91IGNhbm5vdCBidXkgbW9yZSB0aGFuICR7cXVhbnRpdHl9IHRva2Vuc2ApO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gZGF0YSBmYWlscyB0byBmZXRjaCBmcm9tIHN0b3JhZ2UuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgRmV0Y2hFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBpbm5lckVycm9yKSB7XG4gICAgc3VwZXIoYEZFVENIX0ZBSUxFRDogJHttZXNzYWdlfWApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlubmVyRXJyb3JcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmlubmVyRXJyb3IgPSBpbm5lckVycm9yO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byBjcmVhdGUgYSBzbmFwc2hvdCB3aXRoIGR1cGxpY2F0ZSBsZWFmc1xuICogQGludGVybmFsXG4gKi9cbmNsYXNzIER1cGxpY2F0ZUxlYWZzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihgRFVQTElDQVRFX0xFQUZTJHttZXNzYWdlID8gYCA6ICR7bWVzc2FnZX1gIDogXCJcIn1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gdXBkYXRlL2NhbmNlbCBhbiBhdWN0aW9uIHRoYXQgYWxyZWFkeSBzdGFydGVkXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgQXVjdGlvbkFscmVhZHlTdGFydGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGlkKSB7XG4gICAgc3VwZXIoYEF1Y3Rpb24gYWxyZWFkeSBzdGFydGVkIHdpdGggZXhpc3RpbmcgYmlkJHtpZCA/IGAsIGlkOiAke2lkfWAgOiBcIlwifWApO1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIEZ1bmN0aW9uRGVwcmVjYXRlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKiogQGludGVybmFsICovXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihgRlVOQ1RJT04gREVQUkVDQVRFRC4gJHttZXNzYWdlID8gYFVzZSAke21lc3NhZ2V9IGluc3RlYWRgIDogXCJcIn1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIHRyeWluZyB0byByZXRyaWV2ZSBhIGxpc3RpbmcgZnJvbSBhIG1hcmtldHBsYWNlIHRoYXQgZG9lc24ndCBleGlzdFxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIExpc3RpbmdOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtYXJrZXRwbGFjZUNvbnRyYWN0QWRkcmVzcywgbGlzdGluZ0lkKSB7XG4gICAgc3VwZXIoYENvdWxkIG5vdCBmaW5kIGxpc3RpbmcuJHttYXJrZXRwbGFjZUNvbnRyYWN0QWRkcmVzcyA/IGAgbWFya2V0cGxhY2UgYWRkcmVzczogJHttYXJrZXRwbGFjZUNvbnRyYWN0QWRkcmVzc31gIDogXCJcIn0ke2xpc3RpbmdJZCA/IGAgbGlzdGluZyBpZDogJHtsaXN0aW5nSWR9YCA6IFwiXCJ9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiB0cnlpbmcgdG8gcmV0cmlldmUgYSBsaXN0aW5nIG9mIHRoZSB3cm9uZyB0eXBlXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgV3JvbmdMaXN0aW5nVHlwZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtYXJrZXRwbGFjZUNvbnRyYWN0QWRkcmVzcywgbGlzdGluZ0lkLCBhY3R1YWxUeXBlLCBleHBlY3RlZFR5cGUpIHtcbiAgICBzdXBlcihgSW5jb3JyZWN0IGxpc3RpbmcgdHlwZS4gQXJlIHlvdSBzdXJlIHlvdSdyZSB1c2luZyB0aGUgcmlnaHQgbWV0aG9kPy4ke21hcmtldHBsYWNlQ29udHJhY3RBZGRyZXNzID8gYCBtYXJrZXRwbGFjZSBhZGRyZXNzOiAke21hcmtldHBsYWNlQ29udHJhY3RBZGRyZXNzfWAgOiBcIlwifSR7bGlzdGluZ0lkID8gYCBsaXN0aW5nIGlkOiAke2xpc3RpbmdJZH1gIDogXCJcIn0ke2V4cGVjdGVkVHlwZSA/IGAgZXhwZWN0ZWQgdHlwZTogJHtleHBlY3RlZFR5cGV9YCA6IFwiXCJ9JHthY3R1YWxUeXBlID8gYCBhY3R1YWwgdHlwZTogJHthY3R1YWxUeXBlfWAgOiBcIlwifWApO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byB0cmFuc2ZlciBhbiBhc3NldCB0aGF0IGhhcyByZXN0cmljdGVkIHRyYW5zZmVyYWJpbGl0eVxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFJlc3RyaWN0ZWRUcmFuc2ZlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihhc3NldEFkZHJlc3MpIHtcbiAgICBzdXBlcihgRmFpbGVkIHRvIHRyYW5zZmVyIGFzc2V0LCB0cmFuc2ZlciBpcyByZXN0cmljdGVkLiR7YXNzZXRBZGRyZXNzID8gYCBBZGRyZXNzIDogJHthc3NldEFkZHJlc3N9YCA6IFwiXCJ9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhdHRlbXB0aW5nIHRvIGV4ZWN1dGUgYW4gYWRtaW4tcm9sZSBmdW5jdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBBZG1pblJvbGVNaXNzaW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGFkZHJlc3MsIGNvbnRyYWN0QWRkcmVzcykge1xuICAgIGxldCBtZXNzYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBcIkZhaWxlZCB0byBleGVjdXRlIHRyYW5zYWN0aW9uXCI7XG4gICAgc3VwZXIoYCR7bWVzc2FnZX0sIGFkbWluIHJvbGUgaXMgbWlzc2luZyR7YWRkcmVzcyA/IGAgb24gYWRkcmVzczogJHthZGRyZXNzfWAgOiBcIlwifSR7Y29udHJhY3RBZGRyZXNzID8gYCBvbiBjb250cmFjdDogJHtjb250cmFjdEFkZHJlc3N9YCA6IFwiXCJ9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhdHRlbXB0aW5nIHRvIGNsb3NlIGFuIGF1Y3Rpb24gdGhhdCBoYXMgbm90IGVuZGVkXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgQXVjdGlvbkhhc05vdEVuZGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGlkLCBlbmRUaW1lKSB7XG4gICAgc3VwZXIoYEF1Y3Rpb24gaGFzIG5vdCBlbmRlZCB5ZXQke2lkID8gYCwgaWQ6ICR7aWR9YCA6IFwiXCJ9JHtlbmRUaW1lID8gYCwgZW5kIHRpbWU6ICR7ZW5kVGltZS50b1N0cmluZygpfWAgOiBcIlwifWApO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byBjYWxsIGEgY29udHJhY3QgZnVuY3Rpb24gdGhhdCBpcyBub3QgaW1wbGVtZW50ZWRcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBFeHRlbnNpb25Ob3RJbXBsZW1lbnRlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihmZWF0dXJlKSB7XG4gICAgc3VwZXIoYFRoaXMgZnVuY3Rpb25hbGl0eSBpcyBub3QgYXZhaWxhYmxlIGJlY2F1c2UgdGhlIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgJyR7ZmVhdHVyZS5kb2NMaW5rcy5jb250cmFjdHN9JyBFeHRlbnNpb24uIExlYXJuIGhvdyB0byB1bmxvY2sgdGhpcyBmdW5jdGlvbmFsaXR5IGF0IGh0dHBzOi8vcG9ydGFsLnRoaXJkd2ViLmNvbS9leHRlbnNpb25zIGApO1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbiwgZnJvbSwgdG8sIGRhdGEsIG5ldHdvcmssIHJwY1VybCwgcmF3LCBmdW5jdGlvbkluZm8pIHtcbiAgICBsZXQgYnVpbHRFcnJvck1zZyA9IFwiQ29udHJhY3QgdHJhbnNhY3Rpb24gZmFpbGVkXFxuXFxuXCI7XG4gICAgYnVpbHRFcnJvck1zZyArPSBgTWVzc2FnZTogJHtyZWFzb259YDtcbiAgICBidWlsdEVycm9yTXNnICs9IFwiXFxuXFxufCBUcmFuc2FjdGlvbiBpbmZvIHxcXG5cIjtcbiAgICBidWlsdEVycm9yTXNnICs9IHdpdGhTcGFjZXMoXCJmcm9tXCIsIGZyb20pO1xuICAgIGJ1aWx0RXJyb3JNc2cgKz0gd2l0aFNwYWNlcyhcInRvXCIsIHRvKTtcbiAgICBidWlsdEVycm9yTXNnICs9IHdpdGhTcGFjZXMoYGNoYWluYCwgYCR7bmV0d29yay5uYW1lfSAoJHtuZXR3b3JrLmNoYWluSWR9KWApO1xuICAgIGlmIChmdW5jdGlvbkluZm8pIHtcbiAgICAgIGJ1aWx0RXJyb3JNc2cgKz0gXCJcXG5cXG58IEZhaWxlZCBjb250cmFjdCBjYWxsIGluZm8gfFxcblwiO1xuICAgICAgYnVpbHRFcnJvck1zZyArPSB3aXRoU3BhY2VzKFwiZnVuY3Rpb25cIiwgZnVuY3Rpb25JbmZvLnNpZ25hdHVyZSk7XG4gICAgICBidWlsdEVycm9yTXNnICs9IHdpdGhTcGFjZXMoYGFyZ3VtZW50c2AsIEpTT04uc3RyaW5naWZ5KGZ1bmN0aW9uSW5mby5pbnB1dHMsIG51bGwsIDIpKTtcbiAgICAgIGlmIChmdW5jdGlvbkluZm8udmFsdWUuZ3QoMCkpIHtcbiAgICAgICAgYnVpbHRFcnJvck1zZyArPSB3aXRoU3BhY2VzKFwidmFsdWVcIiwgYCR7ZXRoZXJzLnV0aWxzLmZvcm1hdEV0aGVyKGZ1bmN0aW9uSW5mby52YWx1ZSl9ICR7TkFUSVZFX1RPS0VOU1tuZXR3b3JrLmNoYWluSWRdPy5zeW1ib2x9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJwY1VybCk7XG4gICAgICBidWlsdEVycm9yTXNnICs9IHdpdGhTcGFjZXMoYFJQQ2AsIHVybC5ob3N0bmFtZSk7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgIC8vIGlnbm9yZSBpZiBjYW4ndCBwYXJzZSBVUkxcbiAgICB9XG4gICAgYnVpbHRFcnJvck1zZyArPSBcIlxcblxcblwiO1xuICAgIGJ1aWx0RXJyb3JNc2cgKz0gXCJOZWVkIGhlbHAgd2l0aCB0aGlzIGVycm9yPyBKb2luIG91ciBjb21tdW5pdHk6IGh0dHBzOi8vZGlzY29yZC5nZy90aGlyZHdlYlwiO1xuICAgIGJ1aWx0RXJyb3JNc2cgKz0gXCJcXG5cXG5cXG5cXG5cIjtcbiAgICBidWlsdEVycm9yTXNnICs9IFwifCBSYXcgZXJyb3IgfFwiO1xuICAgIGJ1aWx0RXJyb3JNc2cgKz0gXCJcXG5cXG5cIjtcbiAgICBidWlsdEVycm9yTXNnICs9IHJhdztcbiAgICBzdXBlcihidWlsdEVycm9yTXNnKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWFzb25cIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmcm9tXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG9cIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkYXRhXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hhaW5cIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJycGNVcmxcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmdW5jdGlvbkluZm9cIiwgdm9pZCAwKTtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgIHRoaXMudG8gPSB0bztcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuY2hhaW4gPSBuZXR3b3JrO1xuICAgIHRoaXMucnBjVXJsID0gcnBjVXJsO1xuICAgIHRoaXMuZnVuY3Rpb25JbmZvID0gZnVuY3Rpb25JbmZvO1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gZGF0YVxuICogQHBhcmFtIGNvbnRyYWN0SW50ZXJmYWNlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRnVuY3Rpb25JbmZvKGRhdGEsIGNvbnRyYWN0SW50ZXJmYWNlKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZm5GcmFnbWVudCA9IGNvbnRyYWN0SW50ZXJmYWNlLnBhcnNlVHJhbnNhY3Rpb24oe1xuICAgICAgZGF0YVxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgICBjb25zdCBhcmdzID0gZm5GcmFnbWVudC5hcmdzO1xuICAgIGZuRnJhZ21lbnQuZnVuY3Rpb25GcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzW2luZGV4XSkpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBwYXJhbS5jb21wb25lbnRzO1xuICAgICAgICBpZiAoY29tcG9uZW50cykge1xuICAgICAgICAgIGNvbnN0IGFyciA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbXBvbmVudHNbaV0ubmFtZTtcbiAgICAgICAgICAgIG9ialtuYW1lXSA9IGFycltpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0c1twYXJhbS5uYW1lXSA9IG9iajtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0c1twYXJhbS5uYW1lXSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBzaWduYXR1cmU6IGZuRnJhZ21lbnQuc2lnbmF0dXJlLFxuICAgICAgaW5wdXRzOiByZXN1bHRzLFxuICAgICAgdmFsdWU6IGZuRnJhZ21lbnQudmFsdWVcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGVycm9yXG4gKiBAcGFyYW0gbmV0d29ya1xuICogQHBhcmFtIHNpZ25lckFkZHJlc3NcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3NcbiAqIEBwYXJhbSBjb250cmFjdEludGVyZmFjZVxuICovXG5hc3luYyBmdW5jdGlvbiBjb252ZXJ0VG9UV0Vycm9yKGVycm9yLCBuZXR3b3JrLCBzaWduZXJBZGRyZXNzLCBjb250cmFjdEFkZHJlc3MsIGNvbnRyYWN0SW50ZXJmYWNlKSB7XG4gIGxldCByYXc7XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIpIHtcbiAgICAvLyBtZXRhbWFzayBlcnJvcnMgY29tZXMgYXMgb2JqZWN0cywgYXBwbHkgcGFyc2luZyBvbiBkYXRhIG9iamVjdFxuICAgIHJhdyA9IEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBub3Qgc3VyZSB3aGF0IHRoaXMgaXMsIGp1c3QgdGhyb3cgaXQgYmFja1xuICAgIHJhdyA9IGVycm9yLnRvU3RyaW5nKCk7XG4gIH1cbiAgY29uc3QgcmVhc29uID0gcGFyc2VNZXNzYWdlUGFydHMoLy4qP1wibWVzc2FnZVteYS16QS1aMC05XSooW15cIlxcXFxdKikuKj8vLCByYXcpIHx8IHBhcnNlTWVzc2FnZVBhcnRzKC8uKj9cInJlYXNvblteYS16QS1aMC05XSooW15cIlxcXFxdKikuKj8vLCByYXcpO1xuICBjb25zdCBkYXRhID0gcGFyc2VNZXNzYWdlUGFydHMoLy4qP1wiZGF0YVteYS16QS1aMC05XSooW15cIlxcXFxdKikuKj8vLCByYXcpO1xuICBjb25zdCBycGNVcmwgPSBwYXJzZU1lc3NhZ2VQYXJ0cygvLio/XCJ1cmxbXmEtekEtWjAtOV0qKFteXCJcXFxcXSopLio/LywgcmF3KTtcbiAgbGV0IGZyb20gPSBwYXJzZU1lc3NhZ2VQYXJ0cygvLio/XCJmcm9tW15hLXpBLVowLTldKihbXlwiXFxcXF0qKS4qPy8sIHJhdyk7XG4gIGxldCB0byA9IHBhcnNlTWVzc2FnZVBhcnRzKC8uKj9cInRvW15hLXpBLVowLTldKihbXlwiXFxcXF0qKS4qPy8sIHJhdyk7XG4gIGlmICh0byA9PT0gXCJcIikge1xuICAgIC8vIGZhbGxiYWNrIHRvIGNvbnRyYWN0QWRkcmVzc1xuICAgIHRvID0gY29udHJhY3RBZGRyZXNzO1xuICB9XG4gIGlmIChmcm9tID09PSBcIlwiKSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gc2lnbmVyQWRkcmVzc1xuICAgIGZyb20gPSBzaWduZXJBZGRyZXNzO1xuICB9XG4gIGNvbnN0IGZ1bmN0aW9uSW5mbyA9IGRhdGEubGVuZ3RoID4gMCA/IHBhcnNlRnVuY3Rpb25JbmZvKGRhdGEsIGNvbnRyYWN0SW50ZXJmYWNlKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkVycm9yKHJlYXNvbiwgZnJvbSwgdG8sIGRhdGEsIG5ldHdvcmssIHJwY1VybCwgcmF3LCBmdW5jdGlvbkluZm8pO1xufVxuZnVuY3Rpb24gd2l0aFNwYWNlcyhsYWJlbCwgY29udGVudCkge1xuICBpZiAoY29udGVudCA9PT0gXCJcIikge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGNvbnN0IHNwYWNlcyA9IEFycmF5KDEwIC0gbGFiZWwubGVuZ3RoKS5maWxsKFwiIFwiKS5qb2luKFwiXCIpO1xuICByZXR1cm4gYFxcbiR7bGFiZWx9OiR7c3BhY2VzfSR7Y29udGVudH1gO1xufVxuZnVuY3Rpb24gcGFyc2VNZXNzYWdlUGFydHMocmVnZXgsIHJhdykge1xuICBjb25zdCBtc2dNYXRjaGVzID0gcmF3Lm1hdGNoKHJlZ2V4KSB8fCBbXTtcbiAgbGV0IGV4dHJhY3RlZCA9IFwiXCI7XG4gIGlmIChtc2dNYXRjaGVzPy5sZW5ndGggPiAwKSB7XG4gICAgZXh0cmFjdGVkICs9IG1zZ01hdGNoZXNbMV07XG4gIH1cbiAgcmV0dXJuIGV4dHJhY3RlZDtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBlcnJcbiAqIEBwYXJhbSBtZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVzRXJyb3JNZXNzYWdlKGVyciwgbWVzc2FnZSkge1xuICBpZiAoIWVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZXJyICYmIGVyci50b1N0cmluZygpLmluY2x1ZGVzKG1lc3NhZ2UpIHx8IGVyciAmJiBlcnIubWVzc2FnZSAmJiBlcnIubWVzc2FnZS50b1N0cmluZygpLmluY2x1ZGVzKG1lc3NhZ2UpIHx8IGVyciAmJiBlcnIuZXJyb3IgJiYgZXJyLmVycm9yLnRvU3RyaW5nKCkuaW5jbHVkZXMobWVzc2FnZSk7XG59XG5cbmNvbnN0IERyb3BFcmM3MjFDb250cmFjdElucHV0ID0gQ29tbW9uQ29udHJhY3RTY2hlbWEubWVyZ2UoQ29tbW9uUm95YWx0eVNjaGVtYSkubWVyZ2UoTWVya2xlU2NoZW1hKS5tZXJnZShDb21tb25TeW1ib2xTY2hlbWEpO1xuY29uc3QgRHJvcEVyYzcyMUNvbnRyYWN0T3V0cHV0ID0gQ29tbW9uQ29udHJhY3RPdXRwdXRTY2hlbWEubWVyZ2UoQ29tbW9uUm95YWx0eVNjaGVtYSkubWVyZ2UoTWVya2xlU2NoZW1hKS5tZXJnZShDb21tb25TeW1ib2xTY2hlbWEpO1xuY29uc3QgRHJvcEVyYzcyMUNvbnRyYWN0RGVwbG95ID0gRHJvcEVyYzcyMUNvbnRyYWN0SW5wdXQubWVyZ2UoQ29tbW9uUGxhdGZvcm1GZWVTY2hlbWEpLm1lcmdlKENvbW1vblByaW1hcnlTYWxlU2NoZW1hKS5tZXJnZShDb21tb25UcnVzdGVkRm9yd2FyZGVyU2NoZW1hKTtcbmNvbnN0IERyb3BFcmM3MjFDb250cmFjdFNjaGVtYSA9IHtcbiAgZGVwbG95OiBEcm9wRXJjNzIxQ29udHJhY3REZXBsb3ksXG4gIG91dHB1dDogRHJvcEVyYzcyMUNvbnRyYWN0T3V0cHV0LFxuICBpbnB1dDogRHJvcEVyYzcyMUNvbnRyYWN0SW5wdXRcbn07XG5cbmNvbnN0IERyb3BFcmMxMTU1Q29udHJhY3RJbnB1dCA9IENvbW1vbkNvbnRyYWN0U2NoZW1hLm1lcmdlKENvbW1vblJveWFsdHlTY2hlbWEpLm1lcmdlKE1lcmtsZVNjaGVtYSkubWVyZ2UoQ29tbW9uU3ltYm9sU2NoZW1hKTtcbmNvbnN0IERyb3BFcmMxMTU1Q29udHJhY3RPdXRwdXQgPSBDb21tb25Db250cmFjdE91dHB1dFNjaGVtYS5tZXJnZShDb21tb25Sb3lhbHR5U2NoZW1hKS5tZXJnZShNZXJrbGVTY2hlbWEpLm1lcmdlKENvbW1vblN5bWJvbFNjaGVtYSk7XG5jb25zdCBEcm9wRXJjMTE1NUNvbnRyYWN0RGVwbG95ID0gRHJvcEVyYzExNTVDb250cmFjdElucHV0Lm1lcmdlKENvbW1vblBsYXRmb3JtRmVlU2NoZW1hKS5tZXJnZShDb21tb25QcmltYXJ5U2FsZVNjaGVtYSkubWVyZ2UoQ29tbW9uVHJ1c3RlZEZvcndhcmRlclNjaGVtYSk7XG5jb25zdCBEcm9wRXJjMTE1NUNvbnRyYWN0U2NoZW1hID0ge1xuICBkZXBsb3k6IERyb3BFcmMxMTU1Q29udHJhY3REZXBsb3ksXG4gIG91dHB1dDogRHJvcEVyYzExNTVDb250cmFjdE91dHB1dCxcbiAgaW5wdXQ6IERyb3BFcmMxMTU1Q29udHJhY3RJbnB1dFxufTtcblxuY29uc3QgTWFya2V0cGxhY2VDb250cmFjdElucHV0ID0gQ29tbW9uQ29udHJhY3RTY2hlbWE7XG5jb25zdCBNYXJrZXRwbGFjZUNvbnRyYWN0T3V0cHV0ID0gQ29tbW9uQ29udHJhY3RPdXRwdXRTY2hlbWE7XG5jb25zdCBNYXJrZXRwbGFjZUNvbnRyYWN0RGVwbG95ID0gTWFya2V0cGxhY2VDb250cmFjdElucHV0Lm1lcmdlKENvbW1vblBsYXRmb3JtRmVlU2NoZW1hKS5tZXJnZShDb21tb25UcnVzdGVkRm9yd2FyZGVyU2NoZW1hKTtcbmNvbnN0IE1hcmtldHBsYWNlQ29udHJhY3RTY2hlbWEgPSB7XG4gIGRlcGxveTogTWFya2V0cGxhY2VDb250cmFjdERlcGxveSxcbiAgb3V0cHV0OiBNYXJrZXRwbGFjZUNvbnRyYWN0T3V0cHV0LFxuICBpbnB1dDogTWFya2V0cGxhY2VDb250cmFjdElucHV0XG59O1xuXG5jb25zdCBQYWNrQ29udHJhY3RJbnB1dCA9IENvbW1vbkNvbnRyYWN0U2NoZW1hLm1lcmdlKENvbW1vblJveWFsdHlTY2hlbWEpLm1lcmdlKENvbW1vblN5bWJvbFNjaGVtYSk7XG5jb25zdCBQYWNrQ29udHJhY3RPdXRwdXQgPSBDb21tb25Db250cmFjdE91dHB1dFNjaGVtYS5tZXJnZShDb21tb25Sb3lhbHR5U2NoZW1hKS5tZXJnZShDb21tb25TeW1ib2xTY2hlbWEpO1xuY29uc3QgUGFja0NvbnRyYWN0RGVwbG95ID0gUGFja0NvbnRyYWN0SW5wdXQubWVyZ2UoQ29tbW9uUGxhdGZvcm1GZWVTY2hlbWEpLm1lcmdlKENvbW1vblRydXN0ZWRGb3J3YXJkZXJTY2hlbWEpO1xuY29uc3QgUGFja0NvbnRyYWN0U2NoZW1hID0ge1xuICBkZXBsb3k6IFBhY2tDb250cmFjdERlcGxveSxcbiAgb3V0cHV0OiBQYWNrQ29udHJhY3RPdXRwdXQsXG4gIGlucHV0OiBQYWNrQ29udHJhY3RJbnB1dFxufTtcblxuY29uc3QgU3BsaXRSZWNpcGllbnRJbnB1dFNjaGVtYSA9IHoub2JqZWN0KHtcbiAgYWRkcmVzczogQWRkcmVzc1NjaGVtYSxcbiAgc2hhcmVzQnBzOiBCYXNpc1BvaW50c1NjaGVtYS5ndCgwLCBcIlNoYXJlcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpXG59KTtcbmNvbnN0IFNwbGl0UmVjaXBpZW50T3VwdXRTY2hlbWEgPSBTcGxpdFJlY2lwaWVudElucHV0U2NoZW1hLmV4dGVuZCh7XG4gIGFkZHJlc3M6IEFkZHJlc3NTY2hlbWEsXG4gIHNoYXJlc0JwczogQmFzaXNQb2ludHNTY2hlbWFcbn0pO1xuY29uc3QgU3BsaXRzQ29udHJhY3RJbnB1dCA9IENvbW1vbkNvbnRyYWN0U2NoZW1hLmV4dGVuZCh7XG4gIHJlY2lwaWVudHM6IHouYXJyYXkoU3BsaXRSZWNpcGllbnRJbnB1dFNjaGVtYSkuZGVmYXVsdChbXSkuc3VwZXJSZWZpbmUoKHZhbCwgY29udGV4dCkgPT4ge1xuICAgIGNvbnN0IGFkZHJlc3NNYXAgPSB7fTtcbiAgICBsZXQgdG90YWxTaGFyZXMgPSAwO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB2YWwubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IHZhbFtpbmRleF07XG4gICAgICBpZiAoYWRkcmVzc01hcFtlbnRyeS5hZGRyZXNzXSkge1xuICAgICAgICBjb250ZXh0LmFkZElzc3VlKHtcbiAgICAgICAgICBjb2RlOiB6LlpvZElzc3VlQ29kZS5jdXN0b20sXG4gICAgICAgICAgbWVzc2FnZTogYER1cGxpY2F0ZSBhZGRyZXNzLmAsXG4gICAgICAgICAgcGF0aDogW2luZGV4LCBgYWRkcmVzc2BdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYWRkcmVzc01hcFtlbnRyeS5hZGRyZXNzXSA9IHRydWU7XG4gICAgICB0b3RhbFNoYXJlcyArPSBlbnRyeS5zaGFyZXNCcHM7XG4gICAgICBpZiAodG90YWxTaGFyZXMgPiAxMDAwMCkge1xuICAgICAgICBjb250ZXh0LmFkZElzc3VlKHtcbiAgICAgICAgICBjb2RlOiB6LlpvZElzc3VlQ29kZS5jdXN0b20sXG4gICAgICAgICAgbWVzc2FnZTogYFRvdGFsIHNoYXJlcyBjYW5ub3QgZ28gb3ZlciAxMDAlLmAsXG4gICAgICAgICAgcGF0aDogW2luZGV4LCBgc2hhcmVzQnBzYF1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0b3RhbFNoYXJlcyAhPT0gMTAwMDApIHtcbiAgICAgIGNvbnRleHQuYWRkSXNzdWUoe1xuICAgICAgICBjb2RlOiB6LlpvZElzc3VlQ29kZS5jdXN0b20sXG4gICAgICAgIG1lc3NhZ2U6IGBUb3RhbCBzaGFyZXMgbmVlZCB0byBhZGQgdXAgdG8gMTAwJS4gVG90YWwgc2hhcmVzIGFyZSBjdXJyZW50bHkgJHt0b3RhbFNoYXJlcyAvIDEwMH0lYCxcbiAgICAgICAgcGF0aDogW11cbiAgICAgIH0pO1xuICAgIH1cbiAgfSlcbn0pO1xuY29uc3QgU3BsaXRzQ29udHJhY3RPdXRwdXQgPSBDb21tb25Db250cmFjdE91dHB1dFNjaGVtYS5leHRlbmQoe1xuICByZWNpcGllbnRzOiB6LmFycmF5KFNwbGl0UmVjaXBpZW50T3VwdXRTY2hlbWEpXG59KTtcbmNvbnN0IFNwbGl0c0NvbnRyYWN0RGVwbG95ID0gU3BsaXRzQ29udHJhY3RJbnB1dC5tZXJnZShTcGxpdHNDb250cmFjdElucHV0KS5tZXJnZShDb21tb25UcnVzdGVkRm9yd2FyZGVyU2NoZW1hKTtcbmNvbnN0IFNwbGl0c0NvbnRyYWN0U2NoZW1hID0ge1xuICBkZXBsb3k6IFNwbGl0c0NvbnRyYWN0RGVwbG95LFxuICBvdXRwdXQ6IFNwbGl0c0NvbnRyYWN0T3V0cHV0LFxuICBpbnB1dDogU3BsaXRzQ29udHJhY3RJbnB1dFxufTtcblxuY29uc3QgVG9rZW5FcmMyMENvbnRyYWN0SW5wdXQgPSBDb21tb25Db250cmFjdFNjaGVtYS5tZXJnZShDb21tb25TeW1ib2xTY2hlbWEpO1xuY29uc3QgVG9rZW5FcmMyMENvbnRyYWN0T3V0cHV0ID0gQ29tbW9uQ29udHJhY3RPdXRwdXRTY2hlbWEubWVyZ2UoQ29tbW9uU3ltYm9sU2NoZW1hKTtcbmNvbnN0IFRva2VuRXJjMjBDb250cmFjdERlcGxveSA9IFRva2VuRXJjMjBDb250cmFjdElucHV0Lm1lcmdlKENvbW1vblBsYXRmb3JtRmVlU2NoZW1hKS5tZXJnZShDb21tb25QcmltYXJ5U2FsZVNjaGVtYSkubWVyZ2UoQ29tbW9uVHJ1c3RlZEZvcndhcmRlclNjaGVtYSk7XG5jb25zdCBUb2tlbkVyYzIwQ29udHJhY3RTY2hlbWEgPSB7XG4gIGRlcGxveTogVG9rZW5FcmMyMENvbnRyYWN0RGVwbG95LFxuICBvdXRwdXQ6IFRva2VuRXJjMjBDb250cmFjdE91dHB1dCxcbiAgaW5wdXQ6IFRva2VuRXJjMjBDb250cmFjdElucHV0XG59O1xuXG5jb25zdCBUb2tlbkVyYzcyMUNvbnRyYWN0SW5wdXQgPSBDb21tb25Db250cmFjdFNjaGVtYS5tZXJnZShDb21tb25Sb3lhbHR5U2NoZW1hKS5tZXJnZShDb21tb25TeW1ib2xTY2hlbWEpO1xuY29uc3QgVG9rZW5FcmM3MjFDb250cmFjdE91dHB1dCA9IENvbW1vbkNvbnRyYWN0T3V0cHV0U2NoZW1hLm1lcmdlKENvbW1vblJveWFsdHlTY2hlbWEpLm1lcmdlKENvbW1vblN5bWJvbFNjaGVtYSk7XG5jb25zdCBUb2tlbkVyYzcyMUNvbnRyYWN0RGVwbG95ID0gVG9rZW5FcmM3MjFDb250cmFjdElucHV0Lm1lcmdlKENvbW1vblBsYXRmb3JtRmVlU2NoZW1hKS5tZXJnZShDb21tb25QcmltYXJ5U2FsZVNjaGVtYSkubWVyZ2UoQ29tbW9uVHJ1c3RlZEZvcndhcmRlclNjaGVtYSk7XG5jb25zdCBUb2tlbkVyYzcyMUNvbnRyYWN0U2NoZW1hID0ge1xuICBkZXBsb3k6IFRva2VuRXJjNzIxQ29udHJhY3REZXBsb3ksXG4gIG91dHB1dDogVG9rZW5FcmM3MjFDb250cmFjdE91dHB1dCxcbiAgaW5wdXQ6IFRva2VuRXJjNzIxQ29udHJhY3RJbnB1dFxufTtcblxuY29uc3QgVG9rZW5FcmMxMTU1Q29udHJhY3RJbnB1dCA9IENvbW1vbkNvbnRyYWN0U2NoZW1hLm1lcmdlKENvbW1vblJveWFsdHlTY2hlbWEpLm1lcmdlKENvbW1vblN5bWJvbFNjaGVtYSk7XG5jb25zdCBUb2tlbkVyYzExNTVDb250cmFjdE91dHB1dCA9IENvbW1vbkNvbnRyYWN0T3V0cHV0U2NoZW1hLm1lcmdlKENvbW1vblJveWFsdHlTY2hlbWEpLm1lcmdlKENvbW1vblN5bWJvbFNjaGVtYSk7XG5jb25zdCBUb2tlbkVyYzExNTVDb250cmFjdERlcGxveSA9IFRva2VuRXJjMTE1NUNvbnRyYWN0SW5wdXQubWVyZ2UoQ29tbW9uUGxhdGZvcm1GZWVTY2hlbWEpLm1lcmdlKENvbW1vblByaW1hcnlTYWxlU2NoZW1hKS5tZXJnZShDb21tb25UcnVzdGVkRm9yd2FyZGVyU2NoZW1hKTtcbmNvbnN0IFRva2VuRXJjMTE1NUNvbnRyYWN0U2NoZW1hID0ge1xuICBkZXBsb3k6IFRva2VuRXJjMTE1NUNvbnRyYWN0RGVwbG95LFxuICBvdXRwdXQ6IFRva2VuRXJjMTE1NUNvbnRyYWN0T3V0cHV0LFxuICBpbnB1dDogVG9rZW5FcmMxMTU1Q29udHJhY3RJbnB1dFxufTtcblxuY29uc3QgVm90ZVNldHRpbmdzSW5wdXRTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHZvdGluZ19kZWxheV9pbl9ibG9ja3M6IHoubnVtYmVyKCkubWluKDApLmRlZmF1bHQoMCksXG4gIHZvdGluZ19wZXJpb2RfaW5fYmxvY2tzOiB6Lm51bWJlcigpLm1pbigxKS5kZWZhdWx0KDEpLFxuICB2b3RpbmdfdG9rZW5fYWRkcmVzczogQWRkcmVzc1NjaGVtYSxcbiAgdm90aW5nX3F1b3J1bV9mcmFjdGlvbjogUGVyY2VudFNjaGVtYS5kZWZhdWx0KDApLFxuICBwcm9wb3NhbF90b2tlbl90aHJlc2hvbGQ6IEJpZ051bWJlcmlzaFNjaGVtYS5kZWZhdWx0KDEpXG59KTtcbmNvbnN0IFZvdGVTZXR0aW5nc091cHV0U2NoZW1hID0gVm90ZVNldHRpbmdzSW5wdXRTY2hlbWEuZXh0ZW5kKHtcbiAgcHJvcG9zYWxfdG9rZW5fdGhyZXNob2xkOiBCaWdOdW1iZXJTY2hlbWFcbn0pO1xuY29uc3QgVm90ZUNvbnRyYWN0SW5wdXQgPSBDb21tb25Db250cmFjdFNjaGVtYS5tZXJnZShWb3RlU2V0dGluZ3NJbnB1dFNjaGVtYSk7XG5jb25zdCBWb3RlQ29udHJhY3RPdXRwdXQgPSBDb21tb25Db250cmFjdE91dHB1dFNjaGVtYS5tZXJnZShWb3RlU2V0dGluZ3NPdXB1dFNjaGVtYSk7XG5jb25zdCBWb3RlQ29udHJhY3REZXBsb3kgPSBWb3RlQ29udHJhY3RJbnB1dC5tZXJnZShDb21tb25UcnVzdGVkRm9yd2FyZGVyU2NoZW1hKTtcbmNvbnN0IFZvdGVDb250cmFjdFNjaGVtYSA9IHtcbiAgZGVwbG95OiBWb3RlQ29udHJhY3REZXBsb3ksXG4gIG91dHB1dDogVm90ZUNvbnRyYWN0T3V0cHV0LFxuICBpbnB1dDogVm90ZUNvbnRyYWN0SW5wdXRcbn07XG56Lm9iamVjdCh7XG4gIHByb3Bvc2FsSWQ6IEJpZ051bWJlclNjaGVtYSxcbiAgcHJvcG9zZXI6IHouc3RyaW5nKCksXG4gIHRhcmdldHM6IHouYXJyYXkoei5zdHJpbmcoKSksXG4gIHZhbHVlczogei5hcnJheShCaWdOdW1iZXJTY2hlbWEpLFxuICBzaWduYXR1cmVzOiB6LmFycmF5KHouc3RyaW5nKCkpLFxuICBjYWxsZGF0YXM6IHouYXJyYXkoei5zdHJpbmcoKSksXG4gIHN0YXJ0QmxvY2s6IEJpZ051bWJlclNjaGVtYSxcbiAgZW5kQmxvY2s6IEJpZ051bWJlclNjaGVtYSxcbiAgZGVzY3JpcHRpb246IHouc3RyaW5nKClcbn0pO1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgU0RLT3B0aW9uc1NjaGVtYSA9IHoub2JqZWN0KHtcbiAgcmVhZG9ubHlTZXR0aW5nczogei5vYmplY3Qoe1xuICAgIHJwY1VybDogei5zdHJpbmcoKS51cmwoKSxcbiAgICBjaGFpbklkOiB6Lm51bWJlcigpLm9wdGlvbmFsKClcbiAgfSkub3B0aW9uYWwoKSxcbiAgZ2FzU2V0dGluZ3M6IHoub2JqZWN0KHtcbiAgICBtYXhQcmljZUluR3dlaTogei5udW1iZXIoKS5taW4oMSwgXCJnYXMgcHJpY2UgY2Fubm90IGJlIGxlc3MgdGhhbiAxXCIpLmRlZmF1bHQoMzAwKSxcbiAgICBzcGVlZDogei5lbnVtKFtcInN0YW5kYXJkXCIsIFwiZmFzdFwiLCBcImZhc3Rlc3RcIl0pLmRlZmF1bHQoXCJmYXN0ZXN0XCIpXG4gIH0pLmRlZmF1bHQoe1xuICAgIG1heFByaWNlSW5Hd2VpOiAzMDAsXG4gICAgc3BlZWQ6IFwiZmFzdGVzdFwiXG4gIH0pLFxuICBnYXNsZXNzOiB6LnVuaW9uKFt6Lm9iamVjdCh7XG4gICAgb3BlbnplcHBlbGluOiB6Lm9iamVjdCh7XG4gICAgICByZWxheWVyVXJsOiB6LnN0cmluZygpLnVybCgpLFxuICAgICAgcmVsYXllckZvcndhcmRlckFkZHJlc3M6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgIHVzZUVPQUZvcndhcmRlcjogei5ib29sZWFuKCkuZGVmYXVsdChmYWxzZSlcbiAgICB9KSxcbiAgICBleHBlcmltZW50YWxDaGFpbmxlc3NTdXBwb3J0OiB6LmJvb2xlYW4oKS5kZWZhdWx0KGZhbHNlKVxuICB9KSwgei5vYmplY3Qoe1xuICAgIGJpY29ub215OiB6Lm9iamVjdCh7XG4gICAgICBhcGlJZDogei5zdHJpbmcoKSxcbiAgICAgIGFwaUtleTogei5zdHJpbmcoKSxcbiAgICAgIGRlYWRsaW5lU2Vjb25kczogei5udW1iZXIoKS5taW4oMSwgXCJkZWFkbGluZVNlY29uZHMgY2Fubm90IGJlIGxlcyB0aGFuIDFcIikuZGVmYXVsdCgzNjAwKVxuICAgIH0pXG4gIH0pXSkub3B0aW9uYWwoKVxufSkuZGVmYXVsdCh7XG4gIGdhc1NldHRpbmdzOiB7XG4gICAgbWF4UHJpY2VJbkd3ZWk6IDMwMCxcbiAgICBzcGVlZDogXCJmYXN0ZXN0XCJcbiAgfVxufSk7XG5cbi8qKlxuICogQHB1YmxpY1xuICogQWxsIHRoZXNlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBhcmUgb3B0aW9uYWwgd2l0aCBzYW5lIGRlZmF1bHRzOlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHtcbiAqICAgcmVhZG9ubHlTZXR0aW5nczoge1xuICogICAgIHJwY1VybCwgLy8gZm9yY2UgcmVhZCBjYWxscyB0byBnbyB0aHJvdWdoIHlvdXIgb3duIFJQQyB1cmxcbiAqICAgICBjaGFpbklkLCAvLyByZWR1Y2UgUlBDIGNhbGxzIGJ5IHNlcGNpZnlpbmcgeW91ciBjaGFpbiBJRFxuICogICB9LFxuICogICBnYXNTZXR0aW5nczoge1xuICogICAgIG1heFByaWNlSW5Hd2VpLCAvLyBNYXhpbXVtIGdhcyBwcmljZSBmb3IgdHJhbnNhY3Rpb25zIChkZWZhdWx0IDMwMCBnd2VpKVxuICogICAgIHNwZWVkLCAvLyB0aGUgdHggc3BlZWQgc2V0dGluZzogJ3N0YW5kYXJkJ3wnZmFzdHwnZmFzdGVzdCcgKGRlZmF1bHQ6ICdmYXN0ZXN0JylcbiAqICAgfSxcbiAqICAgZ2FzbGVzczoge1xuICogICAgIC8vIEJ5IHNwZWNpZnlpbmcgYSBnYXNsZXNzIGNvbmZpZ3VyYXRpb24gLSBhbGwgdHJhbnNhY3Rpb25zIHdpbGwgZ2V0IGZvcndhcmRlZCB0byBlbmFibGUgZ2FzbGVzcyB0cmFuc2FjdGlvbnNcbiAqICAgICBvcGVuemVwcGVsaW46IHtcbiAqICAgICAgIHJlbGF5ZXJVcmwsIC8vIHlvdXIgT1ogRGVmZW5kZXIgcmVsYXllciBVUkxcbiAqICAgICAgIHJlbGF5ZXJGb3J3YXJkZXJBZGRyZXNzLCAvLyB0aGUgT1ogZGVmZW5kZXIgcmVsYXllciBhZGRyZXNzIChkZWZhdWx0cyB0byB0aGUgc3RhbmRhcmQgb25lKVxuICogICAgIH0sXG4gKiAgICAgYmljb25vbXk6IHtcbiAqICAgICAgIGFwaUlkLCAvLyB5b3VyIEJpY29ub215IEFQSSBJZFxuICogICAgICAgYXBpS2V5LCAvLyB5b3VyIEJpY29ub215IEFQSSBLZXlcbiAqICAgICAgIGRlYWRsaW5lU2Vjb25kcywgLy8geW91ciBCaWNvbm9teSB0aW1lb3V0IHByZWZlcmVuY2VcbiAqICAgICB9LFxuICogICB9LFxuICogfVxuICogYGBgXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTG9naW5PcHRpb25zU2NoZW1hID0gei5vYmplY3Qoe1xuICAvKipcbiAgICogVGhlIG9wdGlvbmFsIG5vbmNlIG9mIHRoZSBsb2dpbiByZXF1ZXN0IHVzZWQgdG8gcHJldmVudCByZXBsYXkgYXR0YWNrc1xuICAgKi9cbiAgbm9uY2U6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgLyoqXG4gICAqIFRoZSBvcHRpb25hbCB0aW1lIGFmdGVyIHdoaWNoIHRoZSBsb2dpbiBwYXlsb2FkIHdpbGwgYmUgaW52YWxpZFxuICAgKi9cbiAgZXhwaXJhdGlvblRpbWU6IHouZGF0ZSgpLm9wdGlvbmFsKCksXG4gIC8qKlxuICAgKiBUaGUgb3B0aW9uYWwgY2hhaW4gSUQgdGhhdCB0aGUgbG9naW4gcmVxdWVzdCB3YXMgaW50ZW5kZWQgZm9yXG4gICAqL1xuICBjaGFpbklkOiB6Lm51bWJlcigpLm9wdGlvbmFsKClcbn0pLm9wdGlvbmFsKCk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IExvZ2luUGF5bG9hZERhdGFTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIC8qKlxuICAgKiBUaGUgZG9tYWluIHRoYXQgdGhlIHVzZXIgaXMgYXR0ZW1wdGluZyB0byBsb2dpbiB0b1xuICAgKi9cbiAgZG9tYWluOiB6LnN0cmluZygpLFxuICAvKipcbiAgICogVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdGhhdCBpcyBsb2dnaW5nIGluXG4gICAqL1xuICBhZGRyZXNzOiBBZGRyZXNzU2NoZW1hLFxuICAvKipcbiAgICogVGhlIG5vbmNlIG9mIHRoZSBsb2dpbiByZXF1ZXN0IHVzZWQgdG8gcHJldmVudCByZXBsYXkgYXR0YWNrcywgZGVmYXVsdHMgdG8gYSByYW5kb20gVVVJRFxuICAgKi9cbiAgbm9uY2U6IHouc3RyaW5nKCkuZGVmYXVsdCh2NCgpKSxcbiAgLyoqXG4gICAqIFRoZSB0aW1lIGFmdGVyIHdoaWNoIHRoZSBsb2dpbiBwYXlsb2FkIHdpbGwgYmUgaW52YWxpZCwgZGVmYXVsdHMgdG8gNSBtaW51dGVzIGZyb20gbm93XG4gICAqL1xuICBleHBpcmF0aW9uX3RpbWU6IHouZGF0ZSgpLnRyYW5zZm9ybShkID0+IGQudG9JU09TdHJpbmcoKSksXG4gIC8qKlxuICAgKiBUaGUgY2hhaW4gSUQgdGhhdCB0aGUgbG9naW4gcmVxdWVzdCB3YXMgaW50ZW5kZWQgZm9yLCBkZWZhdWx0cyB0byBub25lXG4gICAqL1xuICBjaGFpbl9pZDogei5udW1iZXIoKS5vcHRpb25hbCgpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTG9naW5QYXlsb2FkU2NoZW1hID0gei5vYmplY3Qoe1xuICAvKipcbiAgICogVGhlIHBheWxvYWQgZGF0YSB1c2VkIGZvciBsb2dpblxuICAgKi9cbiAgcGF5bG9hZDogTG9naW5QYXlsb2FkRGF0YVNjaGVtYSxcbiAgLyoqXG4gICAqIFRoZSBzaWduYXR1cmUgb2YgdGhlIGxvZ2luIHJlcXVlc3QgdXNlZCBmb3IgdmVyaWZpY2F0aW9uXG4gICAqL1xuICBzaWduYXR1cmU6IHouc3RyaW5nKClcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBWZXJpZnlPcHRpb25zU2NoZW1hID0gei5vYmplY3Qoe1xuICAvKipcbiAgICogVGhlIG9wdGlvbmFsIGNoYWluIElEIHRvIGV4cGVjdCB0aGUgcmVxdWVzdCB0byBiZSBmb3JcbiAgICovXG4gIGNoYWluSWQ6IHoubnVtYmVyKCkub3B0aW9uYWwoKVxufSkub3B0aW9uYWwoKTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQXV0aGVudGljYXRpb25PcHRpb25zU2NoZW1hID0gei5vYmplY3Qoe1xuICAvKipcbiAgICogVGhlIGRhdGUgYmVmb3JlIHdoaWNoIHRoZSBhdXRoZW50aWNhdGlvbiBwYXlsb2FkIGlzIGludmFsaWRcbiAgICovXG4gIGludmFsaWRCZWZvcmU6IHouZGF0ZSgpLm9wdGlvbmFsKCksXG4gIC8qKlxuICAgKiBUaGUgZGF0ZSBhZnRlciB3aGljaCB0aGUgYXV0aGVudGljYXRpb24gcGF5bG9hZCBpcyBpbnZhbGlkXG4gICAqL1xuICBleHBpcmF0aW9uVGltZTogei5kYXRlKCkub3B0aW9uYWwoKVxufSkub3B0aW9uYWwoKTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQXV0aGVudGljYXRpb25QYXlsb2FkRGF0YVNjaGVtYSA9IHoub2JqZWN0KHtcbiAgLyoqXG4gICAqIFRoZSBhZGRyZXNzIG9mIHRoZSB3YWxsZXQgaXNzdWluZyB0aGUgcGF5bG9hZFxuICAgKi9cbiAgaXNzOiB6LnN0cmluZygpLFxuICAvKipcbiAgICogVGhlIGFkZHJlc3Mgb2YgdGhlIHdhbGxldCByZXF1ZXN0aW5nIHRvIGF1dGhlbnRpY2F0ZVxuICAgKi9cbiAgc3ViOiB6LnN0cmluZygpLFxuICAvKipcbiAgICogVGhlIGRvbWFpbiBpbnRlbmRlZCB0byByZWNlaXZlIHRoZSBhdXRoZW50aWNhdGlvbiBwYXlsb2FkXG4gICAqL1xuICBhdWQ6IHouc3RyaW5nKCksXG4gIC8qKlxuICAgKiBUaGUgZGF0ZSBiZWZvcmUgd2hpY2ggdGhlIGF1dGhlbnRpY2F0aW9uIHBheWxvYWQgaXMgaW52YWxpZFxuICAgKi9cbiAgZXhwOiBSYXdEYXRlU2NoZW1hLnRyYW5zZm9ybShiID0+IGIudG9OdW1iZXIoKSksXG4gIC8qKlxuICAgKiBUaGUgZGF0ZSBhZnRlciB3aGljaCB0aGUgYXV0aGVudGljYXRpb24gcGF5bG9hZCBpcyBpbnZhbGlkXG4gICAqL1xuICBuYmY6IFJhd0RhdGVTY2hlbWEudHJhbnNmb3JtKGIgPT4gYi50b051bWJlcigpKSxcbiAgLyoqXG4gICAqIFRoZSBkYXRlIG9uIHdoaWNoIHRoZSBwYXlsb2FkIHdhcyBpc3N1ZWRcbiAgICovXG4gIGlhdDogUmF3RGF0ZVNjaGVtYS50cmFuc2Zvcm0oYiA9PiBiLnRvTnVtYmVyKCkpLFxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBwYXlsb2FkXG4gICAqL1xuICBqdGk6IHouc3RyaW5nKCkuZGVmYXVsdCh2NCgpKVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEF1dGhlbnRpY2F0aW9uUGF5bG9hZFNjaGVtYSA9IHoub2JqZWN0KHtcbiAgLyoqXG4gICAqIFRoZSBwYXlsb2FkIGRhdGEgdXNlZCBmb3IgYXV0aGVudGljYXRpb25cbiAgICovXG4gIHBheWxvYWQ6IEF1dGhlbnRpY2F0aW9uUGF5bG9hZERhdGFTY2hlbWEsXG4gIC8qKlxuICAgKiBUaGUgc2lnbmF0dXJlIG9mIHRoZSBhdXRoZW50aWNhdGlvbiBwYXlsb2FkIHVzZWQgZm9yIGF1dGhlbnRpY2F0aW9uXG4gICAqL1xuICBzaWduYXR1cmU6IHouc3RyaW5nKClcbn0pO1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBGb3J3YXJkUmVxdWVzdCA9IFt7XG4gIG5hbWU6IFwiZnJvbVwiLFxuICB0eXBlOiBcImFkZHJlc3NcIlxufSwge1xuICBuYW1lOiBcInRvXCIsXG4gIHR5cGU6IFwiYWRkcmVzc1wiXG59LCB7XG4gIG5hbWU6IFwidmFsdWVcIixcbiAgdHlwZTogXCJ1aW50MjU2XCJcbn0sIHtcbiAgbmFtZTogXCJnYXNcIixcbiAgdHlwZTogXCJ1aW50MjU2XCJcbn0sIHtcbiAgbmFtZTogXCJub25jZVwiLFxuICB0eXBlOiBcInVpbnQyNTZcIlxufSwge1xuICBuYW1lOiBcImRhdGFcIixcbiAgdHlwZTogXCJieXRlc1wiXG59XTtcbmNvbnN0IENoYWluQXdhcmVGb3J3YXJkUmVxdWVzdCA9IFt7XG4gIG5hbWU6IFwiZnJvbVwiLFxuICB0eXBlOiBcImFkZHJlc3NcIlxufSwge1xuICBuYW1lOiBcInRvXCIsXG4gIHR5cGU6IFwiYWRkcmVzc1wiXG59LCB7XG4gIG5hbWU6IFwidmFsdWVcIixcbiAgdHlwZTogXCJ1aW50MjU2XCJcbn0sIHtcbiAgbmFtZTogXCJnYXNcIixcbiAgdHlwZTogXCJ1aW50MjU2XCJcbn0sIHtcbiAgbmFtZTogXCJub25jZVwiLFxuICB0eXBlOiBcInVpbnQyNTZcIlxufSwge1xuICBuYW1lOiBcImRhdGFcIixcbiAgdHlwZTogXCJieXRlc1wiXG59LCB7XG4gIG5hbWU6IFwiY2hhaW5pZFwiLFxuICB0eXBlOiBcInVpbnQyNTZcIlxufV07XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEJpY29ub215Rm9yd2FyZGVyQWJpID0gW3tcbiAgaW5wdXRzOiBbe1xuICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgbmFtZTogXCJmcm9tXCIsXG4gICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgfSwge1xuICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgbmFtZTogXCJiYXRjaElkXCIsXG4gICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgfV0sXG4gIG5hbWU6IFwiZ2V0Tm9uY2VcIixcbiAgb3V0cHV0czogW3tcbiAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgIG5hbWU6IFwiXCIsXG4gICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgfV0sXG4gIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gIHR5cGU6IFwiZnVuY3Rpb25cIlxufV07XG5jb25zdCBfbm9uY2VzID0ge307XG5jb25zdCBfbm9uY2VzU3luY1RpbWVzdGFtcCA9IHt9O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRBbmRJbmNyZW1lbnROb25jZShmb3J3YXJkZXIsIGZvcndhcmRlckZ1bmN0aW9uLCBmb3J3YXJkZXJBcmdzKSB7XG4gIC8vIGFkZHJlc3MgaXMgb25seSB1c2VkIGZvciBpbnRlcm5hbCBjYWNoaW5nIDopXG4gIGNvbnN0IGFkZHJlc3MgPSBmb3J3YXJkZXJBcmdzLmpvaW4oXCJ8XCIpO1xuICBjb25zdCB0aW1lc3RhbXAgPSBfbm9uY2VzU3luY1RpbWVzdGFtcFthZGRyZXNzXTtcbiAgLy8gaWYgaXQncyB3aXRoaW4gMiBzZWNvbmRzIHdlJ3JlIG9wdGltaXN0aWNhbGx5IGluY3JlbWVudCB0aGUgbm9uY2VcbiAgLy8gc2hvdWxkIHdlIGFsd2F5cyBzeW5jP1xuICBjb25zdCBzaG91bGRTeW5jID0gRGF0ZS5ub3coKSAtIHRpbWVzdGFtcCA+PSAyMDAwO1xuICBpZiAoIShhZGRyZXNzIGluIF9ub25jZXMpIHx8IHNob3VsZFN5bmMpIHtcbiAgICBjb25zdCBub25jZVJlc3VsdCA9IGF3YWl0IGZvcndhcmRlci5mdW5jdGlvbnNbZm9yd2FyZGVyRnVuY3Rpb25dKC4uLmZvcndhcmRlckFyZ3MpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5vbmNlUmVzdWx0KSAmJiBub25jZVJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICBfbm9uY2VzW2FkZHJlc3NdID0gQmlnTnVtYmVyLmZyb20obm9uY2VSZXN1bHRbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBfbm9uY2VzW2FkZHJlc3NdID0gQmlnTnVtYmVyLmZyb20obm9uY2VSZXN1bHQpO1xuICAgIH1cbiAgICBfbm9uY2VzU3luY1RpbWVzdGFtcFthZGRyZXNzXSA9IERhdGUubm93KCk7XG4gIH1cbiAgY29uc3Qgbm9uY2UgPSBfbm9uY2VzW2FkZHJlc3NdO1xuICBfbm9uY2VzW2FkZHJlc3NdID0gQmlnTnVtYmVyLmZyb20oX25vbmNlc1thZGRyZXNzXSkuYWRkKDEpO1xuICByZXR1cm4gbm9uY2U7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldEdhc1N0YXRpb25VcmwoY2hhaW5JZCkge1xuICBzd2l0Y2ggKGNoYWluSWQpIHtcbiAgICBjYXNlIENoYWluSWQuUG9seWdvbjpcbiAgICAgIHJldHVybiBcImh0dHBzOi8vZ2Fzc3RhdGlvbi1tYWlubmV0Lm1hdGljLm5ldHdvcmsvdjJcIjtcbiAgICBjYXNlIENoYWluSWQuTXVtYmFpOlxuICAgICAgcmV0dXJuIFwiaHR0cHM6Ly9nYXNzdGF0aW9uLW11bWJhaS5tYXRpYy50b2RheS92MlwiO1xuICB9XG59XG5jb25zdCBNSU5fUE9MWUdPTl9HQVNfUFJJQ0UgPSBldGhlcnMudXRpbHMucGFyc2VVbml0cyhcIjMxXCIsIFwiZ3dlaVwiKTtcbmNvbnN0IE1JTl9NVU1CQUlfR0FTX1BSSUNFID0gZXRoZXJzLnV0aWxzLnBhcnNlVW5pdHMoXCIxXCIsIFwiZ3dlaVwiKTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEdhc0ZlZShjaGFpbklkKSB7XG4gIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgIGNhc2UgQ2hhaW5JZC5Qb2x5Z29uOlxuICAgICAgcmV0dXJuIE1JTl9QT0xZR09OX0dBU19QUklDRTtcbiAgICBjYXNlIENoYWluSWQuTXVtYmFpOlxuICAgICAgcmV0dXJuIE1JTl9NVU1CQUlfR0FTX1BSSUNFO1xuICB9XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm5zIHRoZSBnYXMgcHJpY2VcbiAqIEBpbnRlcm5hbFxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRQb2x5Z29uR2FzUHJpb3JpdHlGZWUoY2hhaW5JZCkge1xuICBjb25zdCBnYXNTdGF0aW9uVXJsID0gZ2V0R2FzU3RhdGlvblVybChjaGFpbklkKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgKGF3YWl0IGZldGNoJDEoZ2FzU3RhdGlvblVybCkpLmpzb24oKTtcbiAgICAvLyB0YWtlIHRoZSBzdGFuZGFyZCBzcGVlZCBoZXJlLCBTREsgb3B0aW9ucyB3aWxsIGRlZmluZSB0aGUgZXh0cmEgdGlwXG4gICAgY29uc3QgcHJpb3JpdHlGZWUgPSBkYXRhW1wic3RhbmRhcmRcIl1bXCJtYXhQcmlvcml0eUZlZVwiXTtcbiAgICBpZiAocHJpb3JpdHlGZWUgPiAwKSB7XG4gICAgICBjb25zdCBmaXhlZEZlZSA9IHBhcnNlRmxvYXQocHJpb3JpdHlGZWUpLnRvRml4ZWQoOSk7XG4gICAgICByZXR1cm4gZXRoZXJzLnV0aWxzLnBhcnNlVW5pdHMoZml4ZWRGZWUsIFwiZ3dlaVwiKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiZmFpbGVkIHRvIGZldGNoIGdhc1wiLCBlKTtcbiAgfVxuICByZXR1cm4gZ2V0RGVmYXVsdEdhc0ZlZShjaGFpbklkKTtcbn1cblxuLy8gY291bGRuJ3QgZmluZCB0aGlzIGluIGJhcmJvbmVzIGV0aGVycyBleHBvcnQsIGJ1dCBcInR5cGVcIiBzaG91bGQgbWVhbiBpdCBkb2VzIG5vdCBpbmNyZWFzZSBidW5kbGUgc2l6ZSBlaXRoZXIgd2F5XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBlaXA3MTIgc2lnbiB0eXBlZCBkYXRhIHdpdGggZGlmZmVyZW50IHdhbGxldCBoYW5kbGluZyBpbmNsdWRpbmcgbGVkZ2VyIGxpdmVcbiAqIEBpbnRlcm5hbFxuICovXG5hc3luYyBmdW5jdGlvbiBzaWduVHlwZWREYXRhSW50ZXJuYWwoc2lnbmVyLCBkb21haW4sIHR5cGVzLCBtZXNzYWdlKSB7XG4gIGNvbnN0IHByb3ZpZGVyID0gc2lnbmVyPy5wcm92aWRlcjtcbiAgaWYgKCFwcm92aWRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgcHJvdmlkZXJcIik7XG4gIH1cbiAgY29uc3QgcGF5bG9hZCA9IGV0aGVycy51dGlscy5fVHlwZWREYXRhRW5jb2Rlci5nZXRQYXlsb2FkKGRvbWFpbiwgdHlwZXMsIG1lc3NhZ2UpO1xuICBsZXQgc2lnbmF0dXJlID0gXCJcIjtcblxuICAvLyBhbiBpbmRpcmVjdCB3YXkgZm9yIGFjY2Vzc2luZyB3YWxsZXRjb25uZWN0J3MgdW5kZXJseWluZyBwcm92aWRlclxuICBpZiAocHJvdmlkZXI/LnByb3ZpZGVyPy5pc1dhbGxldENvbm5lY3QpIHtcbiAgICBzaWduYXR1cmUgPSBhd2FpdCBwcm92aWRlci5zZW5kKFwiZXRoX3NpZ25UeXBlZERhdGFcIiwgWyhhd2FpdCBzaWduZXIuZ2V0QWRkcmVzcygpKS50b0xvd2VyQ2FzZSgpLCBKU09OLnN0cmluZ2lmeShwYXlsb2FkKV0pO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBzaWduYXR1cmUgPSBhd2FpdCBzaWduZXIuX3NpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgbWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyPy5tZXNzYWdlPy5pbmNsdWRlcyhcIk1ldGhvZCBldGhfc2lnblR5cGVkRGF0YV92NCBub3Qgc3VwcG9ydGVkXCIpKSB7XG4gICAgICAgIHNpZ25hdHVyZSA9IGF3YWl0IHByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblR5cGVkRGF0YVwiLCBbKGF3YWl0IHNpZ25lci5nZXRBZGRyZXNzKCkpLnRvTG93ZXJDYXNlKCksIEpTT04uc3RyaW5naWZ5KHBheWxvYWQpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gZml4IGxlZGdlciBsaXZlIHdoZXJlIHNpZ25hdHVyZSByZXN1bHQgaW4gdiA9IDAsIDEuIGV0aGVycyBtYWdpY2FsbHkgZml4IGl0IGluIHNwbGl0L2pvaW4uXG4gIHJldHVybiB7XG4gICAgcGF5bG9hZCxcbiAgICBzaWduYXR1cmU6IGV0aGVycy51dGlscy5qb2luU2lnbmF0dXJlKGV0aGVycy51dGlscy5zcGxpdFNpZ25hdHVyZShzaWduYXR1cmUpKVxuICB9O1xufVxuXG5jb25zdCBOQU1FX0FCSSA9IFt7XG4gIGlucHV0czogW10sXG4gIG5hbWU6IFwibmFtZVwiLFxuICBvdXRwdXRzOiBbe1xuICAgIGludGVybmFsVHlwZTogXCJzdHJpbmdcIixcbiAgICBuYW1lOiBcIlwiLFxuICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgfV0sXG4gIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gIHR5cGU6IFwiZnVuY3Rpb25cIlxufV07XG5jb25zdCBET01BSU5fU0VQQVJBVE9SX0FCSSA9IFt7XG4gIGNvbnN0YW50OiB0cnVlLFxuICBpbnB1dHM6IFtdLFxuICBuYW1lOiBcIkRPTUFJTl9TRVBBUkFUT1JcIixcbiAgb3V0cHV0czogW3tcbiAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgIG5hbWU6IFwiXCIsXG4gICAgdHlwZTogXCJieXRlczMyXCJcbiAgfV0sXG4gIHBheWFibGU6IGZhbHNlLFxuICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICB0eXBlOiBcImZ1bmN0aW9uXCJcbn0sIHtcbiAgaW5wdXRzOiBbXSxcbiAgbmFtZTogXCJnZXREb21haW5TZXBlcmF0b3JcIixcbiAgb3V0cHV0czogW3tcbiAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgIG5hbWU6IFwiXCIsXG4gICAgdHlwZTogXCJieXRlczMyXCJcbiAgfV0sXG4gIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gIHR5cGU6IFwiZnVuY3Rpb25cIlxufV07XG5jb25zdCBOT05DRVNfQUJJID0gW3tcbiAgaW5wdXRzOiBbe1xuICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgbmFtZTogXCJvd25lclwiLFxuICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gIH1dLFxuICBuYW1lOiBcIm5vbmNlc1wiLFxuICBvdXRwdXRzOiBbe1xuICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgbmFtZTogXCJcIixcbiAgICB0eXBlOiBcInVpbnQyNTZcIlxuICB9XSxcbiAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgdHlwZTogXCJmdW5jdGlvblwiXG59LCB7XG4gIGlucHV0czogW3tcbiAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgIG5hbWU6IFwidXNlclwiLFxuICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gIH1dLFxuICBuYW1lOiBcImdldE5vbmNlXCIsXG4gIG91dHB1dHM6IFt7XG4gICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICBuYW1lOiBcIm5vbmNlXCIsXG4gICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgfV0sXG4gIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gIHR5cGU6IFwiZnVuY3Rpb25cIlxufV07XG5hc3luYyBmdW5jdGlvbiBnZXRTaWduZXJOb25jZShzaWduZXIsIGNvbnRyYWN0QWRkcmVzcykge1xuICBjb25zdCBjb250cmFjdCA9IG5ldyBDb250cmFjdChjb250cmFjdEFkZHJlc3MsIE5PTkNFU19BQkksIHNpZ25lcik7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGNvbnRyYWN0Lm5vbmNlcyhhd2FpdCBzaWduZXIuZ2V0QWRkcmVzcygpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGF3YWl0IGNvbnRyYWN0LmdldE5vbmNlKGF3YWl0IHNpZ25lci5nZXRBZGRyZXNzKCkpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXREb21haW5TZXBlcmF0b3Ioc2lnbmVyLCBjb250cmFjdEFkZHJlc3MpIHtcbiAgY29uc3QgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBET01BSU5fU0VQQVJBVE9SX0FCSSwgc2lnbmVyKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgY29udHJhY3QuRE9NQUlOX1NFUEFSQVRPUigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gYXdhaXQgY29udHJhY3QuZ2V0RG9tYWluU2VwZXJhdG9yKCk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFRva2VuTmFtZShzaWduZXIsIGNvbnRyYWN0QWRkcmVzcykge1xuICByZXR1cm4gbmV3IENvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgTkFNRV9BQkksIHNpZ25lcikubmFtZSgpO1xufVxuXG4vKipcbiAqIFBvbHlnb24gY2hhaW4gaGFzIGRpZmZlcmVudCBFSVA3MTIgZG9tYWluIHNlcGFyYXRvciBmb3IgVVNEQywgREFJIGNvbXBhcmVkIHRvIG90aGVyIGNoYWlucyBhbmQgc2xpZ2h0bHkgZGlmZmVyZW50IHRoYW4gRUlQLTI2MTIuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldENoYWluRG9tYWluU2VwZXJhdG9yKHNpZ25lciwgZG9tYWluKSB7XG4gIGNvbnN0IGNvbnRyYWN0RG9tYWluU2VwYXJhdG9yID0gYXdhaXQgZ2V0RG9tYWluU2VwZXJhdG9yKHNpZ25lciwgZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0KTtcbiAgY29uc3QgcG9seWdvbkRvbWFpbiA9IHtcbiAgICBuYW1lOiBkb21haW4ubmFtZSxcbiAgICB2ZXJzaW9uOiBkb21haW4udmVyc2lvbixcbiAgICB2ZXJpZnlpbmdDb250cmFjdDogZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0LFxuICAgIHNhbHQ6IGV0aGVycy51dGlscy5oZXhaZXJvUGFkKEJpZ051bWJlci5mcm9tKGRvbWFpbi5jaGFpbklkKS50b0hleFN0cmluZygpLCAzMilcbiAgfTtcbiAgaWYgKGV0aGVycy51dGlscy5fVHlwZWREYXRhRW5jb2Rlci5oYXNoRG9tYWluKHBvbHlnb25Eb21haW4pID09PSBjb250cmFjdERvbWFpblNlcGFyYXRvcikge1xuICAgIHJldHVybiBwb2x5Z29uRG9tYWluO1xuICB9XG4gIHJldHVybiBkb21haW47XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNpZ25FSVAyNjEyUGVybWl0KHNpZ25lciwgY3VycmVuY3lBZGRyZXNzLCBvd25lciwgc3BlbmRlciwgdmFsdWUsIGRlYWRsaW5lLCBub25jZSkge1xuICBjb25zdCBkb21haW4gPSBhd2FpdCBnZXRDaGFpbkRvbWFpblNlcGVyYXRvcihzaWduZXIsIHtcbiAgICBuYW1lOiBhd2FpdCBnZXRUb2tlbk5hbWUoc2lnbmVyLCBjdXJyZW5jeUFkZHJlc3MpLFxuICAgIHZlcnNpb246IFwiMVwiLFxuICAgIGNoYWluSWQ6IGF3YWl0IHNpZ25lci5nZXRDaGFpbklkKCksXG4gICAgdmVyaWZ5aW5nQ29udHJhY3Q6IGN1cnJlbmN5QWRkcmVzc1xuICB9KTtcbiAgbm9uY2UgPSBub25jZSB8fCAoYXdhaXQgZ2V0U2lnbmVyTm9uY2Uoc2lnbmVyLCBjdXJyZW5jeUFkZHJlc3MpKS50b1N0cmluZygpO1xuICBkZWFkbGluZSA9IGRlYWRsaW5lIHx8IGV0aGVycy5jb25zdGFudHMuTWF4VWludDI1NjtcbiAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICBvd25lcixcbiAgICBzcGVuZGVyLFxuICAgIHZhbHVlLFxuICAgIG5vbmNlLFxuICAgIGRlYWRsaW5lXG4gIH07XG4gIGNvbnN0IHR5cGVzID0ge1xuICAgIFBlcm1pdDogW3tcbiAgICAgIG5hbWU6IFwib3duZXJcIixcbiAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgfSwge1xuICAgICAgbmFtZTogXCJzcGVuZGVyXCIsXG4gICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwidmFsdWVcIixcbiAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgfSwge1xuICAgICAgbmFtZTogXCJub25jZVwiLFxuICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImRlYWRsaW5lXCIsXG4gICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgIH1dXG4gIH07XG4gIGNvbnN0IHtcbiAgICBzaWduYXR1cmVcbiAgfSA9IGF3YWl0IHNpZ25UeXBlZERhdGFJbnRlcm5hbChzaWduZXIsIGRvbWFpbiwgdHlwZXMsIG1lc3NhZ2UpO1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2UsXG4gICAgc2lnbmF0dXJlXG4gIH07XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbi8vIEB0cy1leHBleHQtZXJyb3Igd2luZG93IGlzIG5vdCBkZWZpbmVkXG5jb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBpc05vZGUgPSAoKSA9PiAhaXNCcm93c2VyKCk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFJQQ0Nvbm5lY3Rpb25IYW5kbGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IobmV0d29yaywgb3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvdmlkZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaWduZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcHRpb25zXCIsIHZvaWQgMCk7XG4gICAgY29uc3QgW3NpZ25lciwgcHJvdmlkZXJdID0gZ2V0U2lnbmVyQW5kUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgdGhpcy5zaWduZXIgPSBzaWduZXI7XG4gICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBTREtPcHRpb25zU2NoZW1hLnBhcnNlKG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKG9wdGlvblBhcnNlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJpbnZhbGlkIHNkayBvcHRpb25zIG9iamVjdCBwYXNzZWQsIGZhbGxpbmcgYmFjayB0byBkZWZhdWx0IG9wdGlvbnNcIiwgb3B0aW9uUGFyc2VFcnJvcik7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBTREtPcHRpb25zU2NoZW1hLnBhcnNlKHt9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW5ldmVyIHRoZSBuZXR3b3JrIGNoYW5nZXMsIHN1Y2ggYXMgd2hlbiB0aGUgdXNlcnMgY29ubmVjdHMgdGhlaXIgd2FsbGV0LCBkaXNjb25uZWN0cyB0aGVpciB3YWxsZXQsIHRoZSBjb25uZWN0ZWQgY2hhaW4gY2hhbmdlcywgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0gbmV0d29yayAtIGEgbmV0d29yaywgc2lnbmVyIG9yIHByb3ZpZGVyIHRoYXQgZXRoZXJzIGpzIGNhbiBpbnRlcnByZXRcbiAgICovXG4gIHVwZGF0ZVNpZ25lck9yUHJvdmlkZXIobmV0d29yaykge1xuICAgIGNvbnN0IFtzaWduZXIsIHByb3ZpZGVyXSA9IGdldFNpZ25lckFuZFByb3ZpZGVyKG5ldHdvcmssIHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy5zaWduZXIgPSBzaWduZXI7XG4gICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhIHNpZ25lciBpcyBzZXQsIGB0cnVlYCBpZiB0aGVyZSBpcyBubyBzaWduZXIgc28gdGhlIGNsYXNzIGlzIGluIFwicmVhZCBvbmx5XCIgbW9kZVxuICAgKi9cbiAgaXNSZWFkT25seSgpIHtcbiAgICByZXR1cm4gIVNpZ25lci5pc1NpZ25lcih0aGlzLnNpZ25lcik7XG4gIH1cblxuICAvKipcbiAgICogRXhwbGljaXRseSBnZXQgdGhlIGFjdGl2ZSBzaWduZXIuXG4gICAqIEByZXR1cm5zIHRoZSBhY3RpdmUgc2lnbmVyLCBpZiB0aGVyZSBpcyBvbmVcbiAgICovXG4gIGdldFNpZ25lcigpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduZXI7XG4gIH1cblxuICAvKipcbiAgICogRXhwbGljaXRseSBnZXQgdGhlIGFjdGl2ZSBwcm92aWRlci5cbiAgICogQHJldHVybnMgdGhlIGFjdGl2ZSBwcm92aWRlclxuICAgKi9cbiAgZ2V0UHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXI7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgc2lnbmVyIGlmIHRoZXJlIGlzIG9uZSwgb3RoZXJ3aXNlIHRoZSBhY3RpdmUgcHJvdmlkZXJcbiAgICovXG4gIGdldFNpZ25lck9yUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2lnbmVyKCkgfHwgdGhpcy5nZXRQcm92aWRlcigpO1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFNpZ25lckFuZFByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgbGV0IHNpZ25lcjtcbiAgbGV0IHByb3ZpZGVyO1xuICBpZiAoU2lnbmVyLmlzU2lnbmVyKG5ldHdvcmspKSB7XG4gICAgc2lnbmVyID0gbmV0d29yaztcbiAgICBpZiAobmV0d29yay5wcm92aWRlcikge1xuICAgICAgcHJvdmlkZXIgPSBuZXR3b3JrLnByb3ZpZGVyO1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucz8ucmVhZG9ubHlTZXR0aW5ncykge1xuICAgIHByb3ZpZGVyID0gZ2V0UmVhZE9ubHlQcm92aWRlcihvcHRpb25zLnJlYWRvbmx5U2V0dGluZ3MucnBjVXJsLCBvcHRpb25zLnJlYWRvbmx5U2V0dGluZ3MuY2hhaW5JZCk7XG4gIH1cbiAgaWYgKCFwcm92aWRlcikge1xuICAgIGlmIChwcm92aWRlcnMuUHJvdmlkZXIuaXNQcm92aWRlcihuZXR3b3JrKSkge1xuICAgICAgcHJvdmlkZXIgPSBuZXR3b3JrO1xuICAgIH0gZWxzZSBpZiAoIVNpZ25lci5pc1NpZ25lcihuZXR3b3JrKSkge1xuICAgICAgaWYgKHR5cGVvZiBuZXR3b3JrID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHByb3ZpZGVyID0gZ2V0UmVhZE9ubHlQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zPy5yZWFkb25seVNldHRpbmdzPy5jaGFpbklkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIGEgc2lnbmVyLCBub3QgYSBwcm92aWRlciwgbm90IGEgc3RyaW5nPyB0cnkgd2l0aCBkZWZhdWx0IHByb3ZpZGVyXG4gICAgICAgIHByb3ZpZGVyID0gZXRoZXJzLmdldERlZmF1bHRQcm92aWRlcihuZXR3b3JrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFwcm92aWRlcikge1xuICAgIC8vIHdlIHNob3VsZCByZWFsbHkgbmV2ZXIgaGl0IHRoaXMgY2FzZSFcbiAgICBwcm92aWRlciA9IGV0aGVycy5nZXREZWZhdWx0UHJvdmlkZXIoKTtcbiAgICBjb25zb2xlLmVycm9yKFwiTm8gcHJvdmlkZXIgZm91bmQsIHVzaW5nIGRlZmF1bHQgcHJvdmlkZXIgb24gZGVmYXVsdCBjaGFpbiFcIik7XG4gIH1cbiAgcmV0dXJuIFtzaWduZXIsIHByb3ZpZGVyXTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgQ29udHJhY3RXcmFwcGVyIGV4dGVuZHMgUlBDQ29ubmVjdGlvbkhhbmRsZXIge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKG5ldHdvcmssIGNvbnRyYWN0QWRkcmVzcywgY29udHJhY3RBYmksIG9wdGlvbnMpIHtcbiAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpc1ZhbGlkQ29udHJhY3RcIiwgZmFsc2UpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImN1c3RvbU92ZXJyaWRlc1wiLCAoKSA9PiAoe30pKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3cml0ZUNvbnRyYWN0XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVhZENvbnRyYWN0XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYWJpXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5hYmkgPSBjb250cmFjdEFiaTtcbiAgICAvLyBzZXQgdXAgdGhlIGNvbnRyYWN0XG4gICAgdGhpcy53cml0ZUNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgY29udHJhY3RBYmksIHRoaXMuZ2V0U2lnbmVyT3JQcm92aWRlcigpKTtcbiAgICAvLyBzZXR1cCB0aGUgcmVhZCBvbmx5IGNvbnRyYWN0XG4gICAgdGhpcy5yZWFkQ29udHJhY3QgPSB0aGlzLndyaXRlQ29udHJhY3QuY29ubmVjdCh0aGlzLmdldFByb3ZpZGVyKCkpO1xuICB9XG4gIHVwZGF0ZVNpZ25lck9yUHJvdmlkZXIobmV0d29yaykge1xuICAgIC8vIHVwZGF0ZSB0aGUgdW5kZXJseWluZyBiYXNlIGNsYXNzXG4gICAgc3VwZXIudXBkYXRlU2lnbmVyT3JQcm92aWRlcihuZXR3b3JrKTtcbiAgICAvLyByZS1jb25uZWN0IHRoZSBjb250cmFjdCB3aXRoIHRoZSBuZXcgc2lnbmVyIC8gcHJvdmlkZXJcbiAgICB0aGlzLndyaXRlQ29udHJhY3QgPSB0aGlzLndyaXRlQ29udHJhY3QuY29ubmVjdCh0aGlzLmdldFNpZ25lck9yUHJvdmlkZXIoKSk7XG4gICAgLy8gc2V0dXAgdGhlIHJlYWQgb25seSBjb250cmFjdFxuICAgIHRoaXMucmVhZENvbnRyYWN0ID0gdGhpcy53cml0ZUNvbnRyYWN0LmNvbm5lY3QodGhpcy5nZXRQcm92aWRlcigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIGdldENoYWluSUQoKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgY29uc3Qge1xuICAgICAgY2hhaW5JZFxuICAgIH0gPSBhd2FpdCBwcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgcmV0dXJuIGNoYWluSWQ7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgZ2V0U2lnbmVyQWRkcmVzcygpIHtcbiAgICBjb25zdCBzaWduZXIgPSB0aGlzLmdldFNpZ25lcigpO1xuICAgIGlmICghc2lnbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGFjdGlvbiByZXF1aXJlcyBhIGNvbm5lY3RlZCB3YWxsZXQgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb24uIFBsZWFzZSBwYXNzIGEgdmFsaWQgc2lnbmVyIHRvIHRoZSBTREsuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgc2lnbmVyLmdldEFkZHJlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNhbGxTdGF0aWMoKSB7XG4gICAgcmV0dXJuIHRoaXMud3JpdGVDb250cmFjdC5jYWxsU3RhdGljO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgZ2V0Q2FsbE92ZXJyaWRlcygpIHtcbiAgICBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgIC8vIFdoZW4gcnVubmluZyBpbiB0aGUgYnJvd3NlciwgbGV0IHRoZSB3YWxsZXQgc3VnZ2VzdCBnYXMgZXN0aW1hdGVzXG4gICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgdGhlIGdhcyBzcGVlZCBwcmVmZXJlbmNlcyBzZXQgaW4gdGhlIFNESyBvcHRpb25zIGFyZSBpZ25vcmVkIGluIGEgYnJvd3NlciBjb250ZXh0XG4gICAgICAvLyBidXQgaXQgYWxzbyBhbGxvd3MgdXNlcnMgdG8gc2VsZWN0IHRoZWlyIG93biBnYXMgc3BlZWQgcHJlZnMgcGVyIHR4IGZyb20gdGhlaXIgd2FsbGV0IGRpcmVjdGx5XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCkuZ2V0RmVlRGF0YSgpO1xuICAgIGNvbnN0IHN1cHBvcnRzMTU1OSA9IGZlZURhdGEubWF4RmVlUGVyR2FzICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgaWYgKHN1cHBvcnRzMTU1OSkge1xuICAgICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JRCgpO1xuICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCkuZ2V0QmxvY2soXCJsYXRlc3RcIik7XG4gICAgICBjb25zdCBiYXNlQmxvY2tGZWUgPSBibG9jayAmJiBibG9jay5iYXNlRmVlUGVyR2FzID8gYmxvY2suYmFzZUZlZVBlckdhcyA6IGV0aGVycy51dGlscy5wYXJzZVVuaXRzKFwiMVwiLCBcImd3ZWlcIik7XG4gICAgICBsZXQgZGVmYXVsdFByaW9yaXR5RmVlO1xuICAgICAgaWYgKGNoYWluSWQgPT09IENoYWluSWQuTXVtYmFpIHx8IGNoYWluSWQgPT09IENoYWluSWQuUG9seWdvbikge1xuICAgICAgICAvLyBmb3IgcG9seWdvbiwgZ2V0IGZlZSBkYXRhIGZyb20gZ2FzIHN0YXRpb25cbiAgICAgICAgZGVmYXVsdFByaW9yaXR5RmVlID0gYXdhaXQgZ2V0UG9seWdvbkdhc1ByaW9yaXR5RmVlKGNoYWluSWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGdldCBpdCBmcm9tIGV0aGVyc1xuICAgICAgICBkZWZhdWx0UHJpb3JpdHlGZWUgPSBCaWdOdW1iZXIuZnJvbShmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICAgIH1cbiAgICAgIC8vIHRoZW4gYWRkIGFkZGl0aW9uYWwgZmVlIGJhc2VkIG9uIHVzZXIgcHJlZmVyZW5jZXNcbiAgICAgIGNvbnN0IG1heFByaW9yaXR5RmVlUGVyR2FzID0gdGhpcy5nZXRQcmVmZXJyZWRQcmlvcml0eUZlZShkZWZhdWx0UHJpb3JpdHlGZWUpO1xuICAgICAgLy8gU2VlOiBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTE1NTkgZm9yIGZvcm11bGFcbiAgICAgIGNvbnN0IGJhc2VNYXhGZWVQZXJHYXMgPSBiYXNlQmxvY2tGZWUubXVsKDIpO1xuICAgICAgY29uc3QgbWF4RmVlUGVyR2FzID0gYmFzZU1heEZlZVBlckdhcy5hZGQobWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF4RmVlUGVyR2FzLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhc1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2FzUHJpY2U6IGF3YWl0IHRoaXMuZ2V0UHJlZmVycmVkR2FzUHJpY2UoKVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgcHJpb3JpdHkgZmVlIHBlciBnYXMgYWNjb3JkaW5nIHRvIHVzZXIgcHJlZmVyZW5jZXNcbiAgICogQHBhcmFtIGRlZmF1bHRQcmlvcml0eUZlZVBlckdhcyAtIHRoZSBiYXNlIHByaW9yaXR5IGZlZVxuICAgKi9cbiAgZ2V0UHJlZmVycmVkUHJpb3JpdHlGZWUoZGVmYXVsdFByaW9yaXR5RmVlUGVyR2FzKSB7XG4gICAgY29uc3Qgc3BlZWQgPSB0aGlzLm9wdGlvbnMuZ2FzU2V0dGluZ3Muc3BlZWQ7XG4gICAgY29uc3QgbWF4R2FzUHJpY2UgPSB0aGlzLm9wdGlvbnMuZ2FzU2V0dGluZ3MubWF4UHJpY2VJbkd3ZWk7XG4gICAgbGV0IGV4dHJhVGlwO1xuICAgIHN3aXRjaCAoc3BlZWQpIHtcbiAgICAgIGNhc2UgXCJzdGFuZGFyZFwiOlxuICAgICAgICBleHRyYVRpcCA9IEJpZ051bWJlci5mcm9tKDApOyAvLyBkZWZhdWx0IGlzIDIuNSBnd2VpIGZvciBFVEgsIDMxIGd3ZWkgZm9yIHBvbHlnb25cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZmFzdFwiOlxuICAgICAgICBleHRyYVRpcCA9IGRlZmF1bHRQcmlvcml0eUZlZVBlckdhcy5kaXYoMTAwKS5tdWwoNSk7IC8vICsgNSUgLSAyLjYyNSBnd2VpIC8gMzIuNSBnd2VpXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZhc3Rlc3RcIjpcbiAgICAgICAgZXh0cmFUaXAgPSBkZWZhdWx0UHJpb3JpdHlGZWVQZXJHYXMuZGl2KDEwMCkubXVsKDEwKTsgLy8gKyAxMCUgLSAyLjc1IGd3ZWkgLyAzNC4xIGd3ZWlcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCB0eEdhc1ByaWNlID0gZGVmYXVsdFByaW9yaXR5RmVlUGVyR2FzLmFkZChleHRyYVRpcCk7XG4gICAgY29uc3QgbWF4ID0gZXRoZXJzLnV0aWxzLnBhcnNlVW5pdHMobWF4R2FzUHJpY2UudG9TdHJpbmcoKSwgXCJnd2VpXCIpOyAvLyBubyBtb3JlIHRoYW4gbWF4IGdhcyBzZXR0aW5nXG4gICAgY29uc3QgbWluID0gZXRoZXJzLnV0aWxzLnBhcnNlVW5pdHMoXCIyLjVcIiwgXCJnd2VpXCIpOyAvLyBubyBsZXNzIHRoYW4gMi41IGd3ZWlcbiAgICBpZiAodHhHYXNQcmljZS5ndChtYXgpKSB7XG4gICAgICB0eEdhc1ByaWNlID0gbWF4O1xuICAgIH1cbiAgICBpZiAodHhHYXNQcmljZS5sdChtaW4pKSB7XG4gICAgICB0eEdhc1ByaWNlID0gbWluO1xuICAgIH1cbiAgICByZXR1cm4gdHhHYXNQcmljZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBnYXMgcHJpY2UgZm9yIHRyYW5zYWN0aW9ucyBhY2NvcmRpbmcgdG8gdXNlciBwcmVmZXJlbmNlc1xuICAgKi9cbiAgYXN5bmMgZ2V0UHJlZmVycmVkR2FzUHJpY2UoKSB7XG4gICAgY29uc3QgZ2FzUHJpY2UgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCkuZ2V0R2FzUHJpY2UoKTtcbiAgICBjb25zdCBzcGVlZCA9IHRoaXMub3B0aW9ucy5nYXNTZXR0aW5ncy5zcGVlZDtcbiAgICBjb25zdCBtYXhHYXNQcmljZSA9IHRoaXMub3B0aW9ucy5nYXNTZXR0aW5ncy5tYXhQcmljZUluR3dlaTtcbiAgICBsZXQgdHhHYXNQcmljZSA9IGdhc1ByaWNlO1xuICAgIGxldCBleHRyYVRpcDtcbiAgICBzd2l0Y2ggKHNwZWVkKSB7XG4gICAgICBjYXNlIFwic3RhbmRhcmRcIjpcbiAgICAgICAgZXh0cmFUaXAgPSBCaWdOdW1iZXIuZnJvbSgxKTsgLy8gbWluIDEgd2VpXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZhc3RcIjpcbiAgICAgICAgZXh0cmFUaXAgPSBnYXNQcmljZS5kaXYoMTAwKS5tdWwoNSk7IC8vICsgNSVcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZmFzdGVzdFwiOlxuICAgICAgICBleHRyYVRpcCA9IGdhc1ByaWNlLmRpdigxMDApLm11bCgxMCk7IC8vICsgMTAlXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0eEdhc1ByaWNlID0gdHhHYXNQcmljZS5hZGQoZXh0cmFUaXApO1xuICAgIGNvbnN0IG1heCA9IGV0aGVycy51dGlscy5wYXJzZVVuaXRzKG1heEdhc1ByaWNlLnRvU3RyaW5nKCksIFwiZ3dlaVwiKTtcbiAgICBpZiAodHhHYXNQcmljZS5ndChtYXgpKSB7XG4gICAgICB0eEdhc1ByaWNlID0gbWF4O1xuICAgIH1cbiAgICByZXR1cm4gdHhHYXNQcmljZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVtaXRUcmFuc2FjdGlvbkV2ZW50KHN0YXR1cywgdHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgdGhpcy5lbWl0KEV2ZW50VHlwZS5UcmFuc2FjdGlvbiwge1xuICAgICAgc3RhdHVzLFxuICAgICAgdHJhbnNhY3Rpb25IYXNoXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBtdWx0aUNhbGwoZW5jb2RlZCkge1xuICAgIHJldHVybiB0aGlzLnNlbmRUcmFuc2FjdGlvbihcIm11bHRpY2FsbFwiLCBbZW5jb2RlZF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgZXN0aW1hdGVHYXMoZm4sIGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy53cml0ZUNvbnRyYWN0LmVzdGltYXRlR2FzW2ZuXSguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHdpdGhUcmFuc2FjdGlvbk92ZXJyaWRlKGhvb2spIHtcbiAgICB0aGlzLmN1c3RvbU92ZXJyaWRlcyA9IGhvb2s7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBjYWxsKGZ1bmN0aW9uTmFtZSkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICAvLyBwYXJzZSBsYXN0IGFyZyBhcyB0eCBvcHRpb25zIGlmIHByZXNlbnRcbiAgICBsZXQgdHhPcHRpb25zO1xuICAgIHRyeSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwICYmIHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgbGFzdCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgdHhPcHRpb25zID0gQ2FsbE92ZXJyaWRlU2NoZW1hLnBhcnNlKGxhc3QpO1xuICAgICAgICAvLyBpZiBjYWxsIG92ZXJyaWRlcyBmb3VuZCwgcmVtb3ZlIGl0IGZyb20gYXJncyBhcnJheVxuICAgICAgICBhcmdzID0gYXJncy5zbGljZSgwLCBhcmdzLmxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIG5vLW9wXG4gICAgfVxuICAgIGNvbnN0IGZ1bmN0aW9ucyA9IGV4dHJhY3RGdW5jdGlvbnNGcm9tQWJpKEFiaVNjaGVtYS5wYXJzZSh0aGlzLmFiaSkpLmZpbHRlcihmID0+IGYubmFtZSA9PT0gZnVuY3Rpb25OYW1lKTtcbiAgICBpZiAoIWZ1bmN0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRnVuY3Rpb24gXCIke2Z1bmN0aW9uTmFtZX1cIiBub3QgZm91bmQgaW4gY29udHJhY3QuIENoZWNrIHlvdXIgZGFzaGJvYXJkIGZvciB0aGUgbGlzdCBvZiBmdW5jdGlvbnMgYXZhaWxhYmxlYCk7XG4gICAgfVxuICAgIGNvbnN0IGZuID0gZnVuY3Rpb25zLmZpbmQoZiA9PiBmLm5hbWUgPT09IGZ1bmN0aW9uTmFtZSAmJiBmLmlucHV0cy5sZW5ndGggPT09IGFyZ3MubGVuZ3RoKTtcblxuICAgIC8vIFRPRE8gZXh0cmFjdCB0aGlzIGFuZCByZS11c2UgZm9yIGRlcGxveSBmdW5jdGlvbiB0byBjaGVjayBjb25zdHJ1Y3RvciBhcmdzXG4gICAgaWYgKCFmbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGdW5jdGlvbiBcIiR7ZnVuY3Rpb25OYW1lfVwiIHJlcXVpcmVzICR7ZnVuY3Rpb25zWzBdLmlucHV0cy5sZW5ndGh9IGFyZ3VtZW50cywgYnV0ICR7YXJncy5sZW5ndGh9IHdlcmUgcHJvdmlkZWQuXFxuRXhwZWN0ZWQgZnVuY3Rpb24gc2lnbmF0dXJlOiAke2Z1bmN0aW9uc1swXS5zaWduYXR1cmV9YCk7XG4gICAgfVxuICAgIGNvbnN0IGV0aGVyc0ZuTmFtZSA9IGAke2Z1bmN0aW9uTmFtZX0oJHtmbi5pbnB1dHMubWFwKGkgPT4gaS50eXBlKS5qb2luKCl9KWA7XG5cbiAgICAvLyBjaGVjayBpZiB0aGUgZnVuY3Rpb24gZXhpc3RzIG9uIHRoZSBjb250cmFjdCwgb3RoZXJ3aXNlIHVzZSB0aGUgbmFtZSBwYXNzZWQgaW5cbiAgICBjb25zdCBmbk5hbWUgPSBldGhlcnNGbk5hbWUgaW4gdGhpcy5yZWFkQ29udHJhY3QuZnVuY3Rpb25zID8gZXRoZXJzRm5OYW1lIDogZnVuY3Rpb25OYW1lO1xuXG4gICAgLy8gVE9ETyB2YWxpZGF0ZSBlYWNoIGFyZ3VtZW50XG4gICAgaWYgKGZuLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgZm4uc3RhdGVNdXRhYmlsaXR5ID09PSBcInB1cmVcIikge1xuICAgICAgLy8gcmVhZCBmdW5jdGlvblxuICAgICAgcmV0dXJuIHRoaXMucmVhZENvbnRyYWN0W2ZuTmFtZV0oLi4uYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdyaXRlIGZ1bmN0aW9uXG4gICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5zZW5kVHJhbnNhY3Rpb24oZm5OYW1lLCBhcmdzLCB0eE9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVjZWlwdFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBzZW5kVHJhbnNhY3Rpb24oZm4sIGFyZ3MsIGNhbGxPdmVycmlkZXMpIHtcbiAgICBpZiAoIWNhbGxPdmVycmlkZXMpIHtcbiAgICAgIGNhbGxPdmVycmlkZXMgPSBhd2FpdCB0aGlzLmdldENhbGxPdmVycmlkZXMoKTtcbiAgICB9XG4gICAgLy8gaWYgYSBjdXN0b20gb3ZlcnJpZGUgaXMgc2V0LCBtZXJnZSBvdXIgb3ZlcnJpZGUgd2l0aCB0aGUgY3VzdG9tIG9uZVxuICAgIGNhbGxPdmVycmlkZXMgPSB7XG4gICAgICAuLi5jYWxsT3ZlcnJpZGVzLFxuICAgICAgLi4udGhpcy5jdXN0b21PdmVycmlkZXMoKVxuICAgIH07XG4gICAgLy8gY2xlYXIgdXAgdGhlIG92ZXJyaWRlIChzaW5nbGUgdXNlKVxuICAgIHRoaXMuY3VzdG9tT3ZlcnJpZGVzID0gKCkgPT4gKHt9KTtcbiAgICBpZiAodGhpcy5vcHRpb25zPy5nYXNsZXNzICYmIChcIm9wZW56ZXBwZWxpblwiIGluIHRoaXMub3B0aW9ucy5nYXNsZXNzIHx8IFwiYmljb25vbXlcIiBpbiB0aGlzLm9wdGlvbnMuZ2FzbGVzcykpIHtcbiAgICAgIGlmIChmbiA9PT0gXCJtdWx0aWNhbGxcIiAmJiBBcnJheS5pc0FycmF5KGFyZ3NbMF0pICYmIGFyZ3NbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBmcm9tID0gYXdhaXQgdGhpcy5nZXRTaWduZXJBZGRyZXNzKCk7XG4gICAgICAgIGFyZ3NbMF0gPSBhcmdzWzBdLm1hcCh0eCA9PiBldGhlcnMudXRpbHMuc29saWRpdHlQYWNrKFtcImJ5dGVzXCIsIFwiYWRkcmVzc1wiXSwgW3R4LCBmcm9tXSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICBjb25zdCB0eEhhc2ggPSBhd2FpdCB0aGlzLnNlbmRHYXNsZXNzVHJhbnNhY3Rpb24oZm4sIGFyZ3MsIGNhbGxPdmVycmlkZXMpO1xuICAgICAgdGhpcy5lbWl0VHJhbnNhY3Rpb25FdmVudChcInN1Ym1pdHRlZFwiLCB0eEhhc2gpO1xuICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHByb3ZpZGVyLndhaXRGb3JUcmFuc2FjdGlvbih0eEhhc2gpO1xuICAgICAgdGhpcy5lbWl0VHJhbnNhY3Rpb25FdmVudChcImNvbXBsZXRlZFwiLCB0eEhhc2gpO1xuICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG9uZSB0aW1lIHZlcmlmaWNhdGlvbiB0aGF0IHRoaXMgaXMgYSB2YWxpZCBjb250cmFjdCAodG8gYXZvaWQgc2VuZGluZyBmdW5kcyB0byB3cm9uZyBhZGRyZXNzZXMpXG4gICAgICBpZiAoIXRoaXMuaXNWYWxpZENvbnRyYWN0KSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCkuZ2V0Q29kZSh0aGlzLnJlYWRDb250cmFjdC5hZGRyZXNzKTtcbiAgICAgICAgdGhpcy5pc1ZhbGlkQ29udHJhY3QgPSBjb2RlICE9PSBcIjB4XCI7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkQ29udHJhY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYWRkcmVzcyB5b3UncmUgdHJ5aW5nIHRvIHNlbmQgYSB0cmFuc2FjdGlvbiB0byBpcyBub3QgYSBzbWFydCBjb250cmFjdC4gTWFrZSBzdXJlIHlvdSBhcmUgb24gdGhlIGNvcnJlY3QgbmV0d29yayBhbmQgdGhlIGNvbnRyYWN0IGFkZHJlc3MgaXMgY29ycmVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnNlbmRUcmFuc2FjdGlvbkJ5RnVuY3Rpb24oZm4sIGFyZ3MsIGNhbGxPdmVycmlkZXMpO1xuICAgICAgdGhpcy5lbWl0VHJhbnNhY3Rpb25FdmVudChcInN1Ym1pdHRlZFwiLCB0eC5oYXNoKTtcbiAgICAgIGNvbnN0IHJlY2VpcHQgPSB0eC53YWl0KCk7XG4gICAgICB0aGlzLmVtaXRUcmFuc2FjdGlvbkV2ZW50KFwiY29tcGxldGVkXCIsIHR4Lmhhc2gpO1xuICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uQnlGdW5jdGlvbihmbiwgYXJncywgY2FsbE92ZXJyaWRlcykge1xuICAgIGNvbnN0IGZ1bmMgPSB0aGlzLndyaXRlQ29udHJhY3QuZnVuY3Rpb25zW2ZuXTtcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBmdW5jdGlvbjogXCIke2ZuLnRvU3RyaW5nKCl9XCJgKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBmdW5jKC4uLmFyZ3MsIGNhbGxPdmVycmlkZXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCkuZ2V0TmV0d29yaygpO1xuICAgICAgY29uc3Qgc2lnbmVyQWRkcmVzcyA9IGF3YWl0IHRoaXMuZ2V0U2lnbmVyQWRkcmVzcygpO1xuICAgICAgY29uc3QgY29udHJhY3RBZGRyZXNzID0gYXdhaXQgdGhpcy5yZWFkQ29udHJhY3QuYWRkcmVzcztcbiAgICAgIHRocm93IGF3YWl0IGNvbnZlcnRUb1RXRXJyb3IoZSwgbmV0d29yaywgc2lnbmVyQWRkcmVzcywgY29udHJhY3RBZGRyZXNzLCB0aGlzLnJlYWRDb250cmFjdC5pbnRlcmZhY2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIHNlbmRHYXNsZXNzVHJhbnNhY3Rpb24oZm4pIHtcbiAgICBsZXQgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgbGV0IGNhbGxPdmVycmlkZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBzaWduZXIgPSB0aGlzLmdldFNpZ25lcigpO1xuICAgIGludmFyaWFudChzaWduZXIsIFwiQ2Fubm90IGV4ZWN1dGUgZ2FzbGVzcyB0cmFuc2FjdGlvbiB3aXRob3V0IHZhbGlkIHNpZ25lclwiKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklEKCk7XG4gICAgY29uc3QgZnJvbSA9IGF3YWl0IHRoaXMuZ2V0U2lnbmVyQWRkcmVzcygpO1xuICAgIGNvbnN0IHRvID0gdGhpcy53cml0ZUNvbnRyYWN0LmFkZHJlc3M7XG4gICAgY29uc3QgdmFsdWUgPSBjYWxsT3ZlcnJpZGVzPy52YWx1ZSB8fCAwO1xuICAgIGlmIChCaWdOdW1iZXIuZnJvbSh2YWx1ZSkuZ3QoMCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZW5kIG5hdGl2ZSB0b2tlbiB2YWx1ZSB3aXRoIGdhc2xlc3MgdHJhbnNhY3Rpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLndyaXRlQ29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShmbiwgYXJncyk7XG4gICAgbGV0IGdhcyA9IEJpZ051bWJlci5mcm9tKDApO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBnYXNFc3RpbWF0ZSA9IGF3YWl0IHRoaXMucmVhZENvbnRyYWN0LmVzdGltYXRlR2FzW2ZuXSguLi5hcmdzKTtcbiAgICAgIGdhcyA9IGdhc0VzdGltYXRlLm11bCgyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBpZ25vcmVcbiAgICB9XG5cbiAgICAvLyBpbiBzb21lIGNhc2VzIFdhbGxldENvbm5lY3QgZG9lc24ndCBwcm9wZXJseSBnaXZlcyBhbiBlc3RpbWF0ZSBmb3IgaG93IG11Y2ggZ2FzIGl0IHdvdWxkIGFjdHVhbGx5IHVzZS5cbiAgICAvLyBhcyBhIGZpeCwgd2UncmUgc2V0dGluZyBpdCB0byBhIGhpZ2ggYXJiaXRyYXJ5IG51bWJlciAoNTAwaykgYXMgdGhlIGdhcyBsaW1pdCB0aGF0IHNob3VsZCBjb3ZlciBmb3IgbW9zdCBmdW5jdGlvbiBjYWxscy5cbiAgICBpZiAoZ2FzLmx0KDEwMDAwMCkpIHtcbiAgICAgIGdhcyA9IEJpZ051bWJlci5mcm9tKDUwMDAwMCk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIGdhcyBvdmVycmlkZSBpbiBjYWxsT3ZlcnJpZGVzXG4gICAgaWYgKGNhbGxPdmVycmlkZXMuZ2FzTGltaXQgJiYgQmlnTnVtYmVyLmZyb20oY2FsbE92ZXJyaWRlcy5nYXNMaW1pdCkuZ3QoZ2FzKSkge1xuICAgICAgZ2FzID0gQmlnTnVtYmVyLmZyb20oY2FsbE92ZXJyaWRlcy5nYXNMaW1pdCk7XG4gICAgfVxuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgZnJvbSxcbiAgICAgIHRvLFxuICAgICAgZGF0YSxcbiAgICAgIGNoYWluSWQsXG4gICAgICBnYXNMaW1pdDogZ2FzLFxuICAgICAgZnVuY3Rpb25OYW1lOiBmbi50b1N0cmluZygpLFxuICAgICAgZnVuY3Rpb25BcmdzOiBhcmdzLFxuICAgICAgY2FsbE92ZXJyaWRlc1xuICAgIH07XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGVmYXVsdEdhc2xlc3NTZW5kRnVuY3Rpb24odHgpO1xuICB9XG4gIGFzeW5jIHNpZ25UeXBlZERhdGEoc2lnbmVyLCBkb21haW4sIHR5cGVzLCBtZXNzYWdlKSB7XG4gICAgdGhpcy5lbWl0KEV2ZW50VHlwZS5TaWduYXR1cmUsIHtcbiAgICAgIHN0YXR1czogXCJzdWJtaXR0ZWRcIixcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBzaWduYXR1cmU6IFwiXCJcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBzaWduYXR1cmU6IHNpZ1xuICAgIH0gPSBhd2FpdCBzaWduVHlwZWREYXRhSW50ZXJuYWwoc2lnbmVyLCBkb21haW4sIHR5cGVzLCBtZXNzYWdlKTtcbiAgICB0aGlzLmVtaXQoRXZlbnRUeXBlLlNpZ25hdHVyZSwge1xuICAgICAgc3RhdHVzOiBcImNvbXBsZXRlZFwiLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNpZ25hdHVyZTogc2lnXG4gICAgfSk7XG4gICAgcmV0dXJuIHNpZztcbiAgfVxuICBwYXJzZUxvZ3MoZXZlbnROYW1lLCBsb2dzKSB7XG4gICAgaWYgKCFsb2dzIHx8IGxvZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHRvcGljID0gdGhpcy53cml0ZUNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudFRvcGljKGV2ZW50TmFtZSk7XG4gICAgY29uc3QgcGFyc2VkTG9ncyA9IGxvZ3MuZmlsdGVyKHggPT4geC50b3BpY3MuaW5kZXhPZih0b3BpYykgPj0gMCk7XG4gICAgcmV0dXJuIHBhcnNlZExvZ3MubWFwKGwgPT4gdGhpcy53cml0ZUNvbnRyYWN0LmludGVyZmFjZS5wYXJzZUxvZyhsKSk7XG4gIH1cbiAgYXN5bmMgZGVmYXVsdEdhc2xlc3NTZW5kRnVuY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmdhc2xlc3MgJiYgXCJiaWNvbm9teVwiIGluIHRoaXMub3B0aW9ucy5nYXNsZXNzKSB7XG4gICAgICByZXR1cm4gdGhpcy5iaWNvbm9teVNlbmRGdW5jdGlvbih0cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRlZmVuZGVyU2VuZEZ1bmN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgfVxuICBhc3luYyBiaWNvbm9teVNlbmRGdW5jdGlvbih0cmFuc2FjdGlvbikge1xuICAgIGludmFyaWFudCh0aGlzLm9wdGlvbnMuZ2FzbGVzcyAmJiBcImJpY29ub215XCIgaW4gdGhpcy5vcHRpb25zLmdhc2xlc3MsIFwiY2FsbGluZyBiaWNvbm9teVNlbmRGdW5jdGlvbiB3aXRob3V0IGJpY29ub215XCIpO1xuICAgIGNvbnN0IHNpZ25lciA9IHRoaXMuZ2V0U2lnbmVyKCk7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgaW52YXJpYW50KHNpZ25lciAmJiBwcm92aWRlciwgXCJzaWduZXIgYW5kIHByb3ZpZGVyIG11c3QgYmUgc2V0XCIpO1xuICAgIGNvbnN0IGZvcndhcmRlciA9IG5ldyBldGhlcnMuQ29udHJhY3QoZ2V0Q29udHJhY3RBZGRyZXNzQnlDaGFpbklkKHRyYW5zYWN0aW9uLmNoYWluSWQsIFwiYmljb25vbXlGb3J3YXJkZXJcIiksIEJpY29ub215Rm9yd2FyZGVyQWJpLCBwcm92aWRlcik7XG4gICAgY29uc3QgYmF0Y2hJZCA9IDA7XG4gICAgY29uc3QgYmF0Y2hOb25jZSA9IGF3YWl0IGdldEFuZEluY3JlbWVudE5vbmNlKGZvcndhcmRlciwgXCJnZXROb25jZVwiLCBbdHJhbnNhY3Rpb24uZnJvbSwgYmF0Y2hJZF0pO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICBmcm9tOiB0cmFuc2FjdGlvbi5mcm9tLFxuICAgICAgdG86IHRyYW5zYWN0aW9uLnRvLFxuICAgICAgdG9rZW46IGV0aGVycy5jb25zdGFudHMuQWRkcmVzc1plcm8sXG4gICAgICB0eEdhczogdHJhbnNhY3Rpb24uZ2FzTGltaXQudG9OdW1iZXIoKSxcbiAgICAgIHRva2VuR2FzUHJpY2U6IFwiMFwiLFxuICAgICAgYmF0Y2hJZCxcbiAgICAgIGJhdGNoTm9uY2U6IGJhdGNoTm9uY2UudG9OdW1iZXIoKSxcbiAgICAgIGRlYWRsaW5lOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwICsgKHRoaXMub3B0aW9ucz8uZ2FzbGVzcyAmJiBcImJpY29ub215XCIgaW4gdGhpcy5vcHRpb25zLmdhc2xlc3MgJiYgdGhpcy5vcHRpb25zLmdhc2xlc3MuYmljb25vbXk/LmRlYWRsaW5lU2Vjb25kcyB8fCAzNjAwKSksXG4gICAgICBkYXRhOiB0cmFuc2FjdGlvbi5kYXRhXG4gICAgfTtcbiAgICBjb25zdCBoYXNoVG9TaWduID0gZXRoZXJzLnV0aWxzLmFycmF5aWZ5KGV0aGVycy51dGlscy5zb2xpZGl0eUtlY2NhazI1NihbXCJhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgXCJ1aW50MjU2XCIsIFwidWludDI1NlwiLCBcInVpbnQyNTZcIiwgXCJ1aW50MjU2XCIsIFwidWludDI1NlwiLCBcImJ5dGVzMzJcIl0sIFtyZXF1ZXN0LmZyb20sIHJlcXVlc3QudG8sIHJlcXVlc3QudG9rZW4sIHJlcXVlc3QudHhHYXMsIHJlcXVlc3QudG9rZW5HYXNQcmljZSwgcmVxdWVzdC5iYXRjaElkLCByZXF1ZXN0LmJhdGNoTm9uY2UsIHJlcXVlc3QuZGVhZGxpbmUsIGV0aGVycy51dGlscy5rZWNjYWsyNTYocmVxdWVzdC5kYXRhKV0pKTtcbiAgICB0aGlzLmVtaXQoRXZlbnRUeXBlLlNpZ25hdHVyZSwge1xuICAgICAgc3RhdHVzOiBcInN1Ym1pdHRlZFwiLFxuICAgICAgbWVzc2FnZTogaGFzaFRvU2lnbixcbiAgICAgIHNpZ25hdHVyZTogXCJcIlxuICAgIH0pO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ25lci5zaWduTWVzc2FnZShoYXNoVG9TaWduKTtcbiAgICB0aGlzLmVtaXQoRXZlbnRUeXBlLlNpZ25hdHVyZSwge1xuICAgICAgc3RhdHVzOiBcImNvbXBsZXRlZFwiLFxuICAgICAgbWVzc2FnZTogaGFzaFRvU2lnbixcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gkMShcImh0dHBzOi8vYXBpLmJpY29ub215LmlvL2FwaS92Mi9tZXRhLXR4L25hdGl2ZVwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBmcm9tOiB0cmFuc2FjdGlvbi5mcm9tLFxuICAgICAgICBhcGlJZDogdGhpcy5vcHRpb25zLmdhc2xlc3MuYmljb25vbXkuYXBpSWQsXG4gICAgICAgIHBhcmFtczogW3JlcXVlc3QsIHNpZ25hdHVyZV0sXG4gICAgICAgIHRvOiB0cmFuc2FjdGlvbi50byxcbiAgICAgICAgZ2FzTGltaXQ6IHRyYW5zYWN0aW9uLmdhc0xpbWl0LnRvSGV4U3RyaW5nKClcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIngtYXBpLWtleVwiOiB0aGlzLm9wdGlvbnMuZ2FzbGVzcy5iaWNvbm9teS5hcGlLZXksXG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBpZiAoIXJlc3AudHhIYXNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVsYXkgdHJhbnNhY3Rpb24gZmFpbGVkOiAke3Jlc3AubG9nfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3AudHhIYXNoO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYHJlbGF5IHRyYW5zYWN0aW9uIGZhaWxlZCB3aXRoIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9ICgke3Jlc3BvbnNlLnN0YXR1c1RleHR9KWApO1xuICB9XG4gIGFzeW5jIGRlZmVuZGVyU2VuZEZ1bmN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgaW52YXJpYW50KHRoaXMub3B0aW9ucy5nYXNsZXNzICYmIFwib3BlbnplcHBlbGluXCIgaW4gdGhpcy5vcHRpb25zLmdhc2xlc3MsIFwiY2FsbGluZyBvcGVuemVwcGVsaW4gZ2FzbGVzcyB0cmFuc2FjdGlvbiB3aXRob3V0IG9wZW56ZXBwZWxpbiBjb25maWcgaW4gdGhlIFNESyBvcHRpb25zXCIpO1xuICAgIGNvbnN0IHNpZ25lciA9IHRoaXMuZ2V0U2lnbmVyKCk7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgaW52YXJpYW50KHNpZ25lciwgXCJwcm92aWRlciBpcyBub3Qgc2V0XCIpO1xuICAgIGludmFyaWFudChwcm92aWRlciwgXCJwcm92aWRlciBpcyBub3Qgc2V0XCIpO1xuICAgIGNvbnN0IGZvcndhcmRlckFkZHJlc3MgPSB0aGlzLm9wdGlvbnMuZ2FzbGVzcy5vcGVuemVwcGVsaW4ucmVsYXllckZvcndhcmRlckFkZHJlc3MgfHwgKHRoaXMub3B0aW9ucy5nYXNsZXNzLm9wZW56ZXBwZWxpbi51c2VFT0FGb3J3YXJkZXIgPyBDT05UUkFDVF9BRERSRVNTRVNbdHJhbnNhY3Rpb24uY2hhaW5JZF0ub3BlbnplcHBlbGluRm9yd2FyZGVyRU9BIDogQ09OVFJBQ1RfQUREUkVTU0VTW3RyYW5zYWN0aW9uLmNoYWluSWRdLm9wZW56ZXBwZWxpbkZvcndhcmRlcik7XG4gICAgY29uc3QgZm9yd2FyZGVyID0gbmV3IENvbnRyYWN0KGZvcndhcmRlckFkZHJlc3MsIEZvcndhcmRlckFCSSwgcHJvdmlkZXIpO1xuICAgIGNvbnN0IG5vbmNlID0gYXdhaXQgZ2V0QW5kSW5jcmVtZW50Tm9uY2UoZm9yd2FyZGVyLCBcImdldE5vbmNlXCIsIFt0cmFuc2FjdGlvbi5mcm9tXSk7XG4gICAgbGV0IGRvbWFpbjtcbiAgICBsZXQgdHlwZXM7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5nYXNsZXNzLmV4cGVyaW1lbnRhbENoYWlubGVzc1N1cHBvcnQpIHtcbiAgICAgIGRvbWFpbiA9IHtcbiAgICAgICAgbmFtZTogXCJHU052MiBGb3J3YXJkZXJcIixcbiAgICAgICAgdmVyc2lvbjogXCIwLjAuMVwiLFxuICAgICAgICB2ZXJpZnlpbmdDb250cmFjdDogZm9yd2FyZGVyQWRkcmVzc1xuICAgICAgfTtcbiAgICAgIHR5cGVzID0ge1xuICAgICAgICBGb3J3YXJkUmVxdWVzdDogQ2hhaW5Bd2FyZUZvcndhcmRSZXF1ZXN0XG4gICAgICB9O1xuICAgICAgbWVzc2FnZSA9IHtcbiAgICAgICAgZnJvbTogdHJhbnNhY3Rpb24uZnJvbSxcbiAgICAgICAgdG86IHRyYW5zYWN0aW9uLnRvLFxuICAgICAgICB2YWx1ZTogQmlnTnVtYmVyLmZyb20oMCkudG9TdHJpbmcoKSxcbiAgICAgICAgZ2FzOiBCaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbi5nYXNMaW1pdCkudG9TdHJpbmcoKSxcbiAgICAgICAgbm9uY2U6IEJpZ051bWJlci5mcm9tKG5vbmNlKS50b1N0cmluZygpLFxuICAgICAgICBkYXRhOiB0cmFuc2FjdGlvbi5kYXRhLFxuICAgICAgICBjaGFpbmlkOiBCaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbi5jaGFpbklkKS50b1N0cmluZygpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkb21haW4gPSB7XG4gICAgICAgIG5hbWU6IFwiR1NOdjIgRm9yd2FyZGVyXCIsXG4gICAgICAgIHZlcnNpb246IFwiMC4wLjFcIixcbiAgICAgICAgY2hhaW5JZDogdHJhbnNhY3Rpb24uY2hhaW5JZCxcbiAgICAgICAgdmVyaWZ5aW5nQ29udHJhY3Q6IGZvcndhcmRlckFkZHJlc3NcbiAgICAgIH07XG4gICAgICB0eXBlcyA9IHtcbiAgICAgICAgRm9yd2FyZFJlcXVlc3RcbiAgICAgIH07XG4gICAgICBtZXNzYWdlID0ge1xuICAgICAgICBmcm9tOiB0cmFuc2FjdGlvbi5mcm9tLFxuICAgICAgICB0bzogdHJhbnNhY3Rpb24udG8sXG4gICAgICAgIHZhbHVlOiBCaWdOdW1iZXIuZnJvbSgwKS50b1N0cmluZygpLFxuICAgICAgICBnYXM6IEJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uLmdhc0xpbWl0KS50b1N0cmluZygpLFxuICAgICAgICBub25jZTogQmlnTnVtYmVyLmZyb20obm9uY2UpLnRvU3RyaW5nKCksXG4gICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uLmRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCBzaWduYXR1cmU7XG4gICAgdGhpcy5lbWl0KEV2ZW50VHlwZS5TaWduYXR1cmUsIHtcbiAgICAgIHN0YXR1czogXCJzdWJtaXR0ZWRcIixcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBzaWduYXR1cmU6IFwiXCJcbiAgICB9KTtcblxuICAgIC8vIGlmIHRoZSBleGVjdXRpbmcgZnVuY3Rpb24gaXMgXCJhcHByb3ZlXCIgYW5kIG1hdGNoZXMgd2l0aCBlcmMyMCBhcHByb3ZlIHNpZ25hdHVyZVxuICAgIC8vIGFuZCBpZiB0aGUgdG9rZW4gc3VwcG9ydHMgcGVybWl0LCB0aGVuIHdlIHVzZSBwZXJtaXQgZm9yIGdhc2xlc3MgaW5zdGVhZCBvZiBhcHByb3ZlLlxuICAgIGlmICh0cmFuc2FjdGlvbi5mdW5jdGlvbk5hbWUgPT09IFwiYXBwcm92ZVwiICYmIHRyYW5zYWN0aW9uLmZ1bmN0aW9uQXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IHNwZW5kZXIgPSB0cmFuc2FjdGlvbi5mdW5jdGlvbkFyZ3NbMF07XG4gICAgICBjb25zdCBhbW91bnQgPSB0cmFuc2FjdGlvbi5mdW5jdGlvbkFyZ3NbMV07XG4gICAgICAvLyBUT0RPOiBzdXBwb3J0IERBSSBwZXJtaXQgYnkgc2lnbkRBSVBlcm1pdFxuICAgICAgY29uc3Qge1xuICAgICAgICBtZXNzYWdlOiBwZXJtaXQsXG4gICAgICAgIHNpZ25hdHVyZTogc2lnXG4gICAgICB9ID0gYXdhaXQgc2lnbkVJUDI2MTJQZXJtaXQoc2lnbmVyLCB0aGlzLndyaXRlQ29udHJhY3QuYWRkcmVzcywgdHJhbnNhY3Rpb24uZnJvbSwgc3BlbmRlciwgYW1vdW50KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcixcbiAgICAgICAgcyxcbiAgICAgICAgdlxuICAgICAgfSA9IGV0aGVycy51dGlscy5zcGxpdFNpZ25hdHVyZShzaWcpO1xuICAgICAgbWVzc2FnZSA9IHtcbiAgICAgICAgdG86IHRoaXMucmVhZENvbnRyYWN0LmFkZHJlc3MsXG4gICAgICAgIG93bmVyOiBwZXJtaXQub3duZXIsXG4gICAgICAgIHNwZW5kZXI6IHBlcm1pdC5zcGVuZGVyLFxuICAgICAgICB2YWx1ZTogQmlnTnVtYmVyLmZyb20ocGVybWl0LnZhbHVlKS50b1N0cmluZygpLFxuICAgICAgICBub25jZTogQmlnTnVtYmVyLmZyb20ocGVybWl0Lm5vbmNlKS50b1N0cmluZygpLFxuICAgICAgICBkZWFkbGluZTogQmlnTnVtYmVyLmZyb20ocGVybWl0LmRlYWRsaW5lKS50b1N0cmluZygpLFxuICAgICAgICByLFxuICAgICAgICBzLFxuICAgICAgICB2XG4gICAgICB9O1xuICAgICAgc2lnbmF0dXJlID0gc2lnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNpZ25hdHVyZTogc2lnXG4gICAgICB9ID0gYXdhaXQgc2lnblR5cGVkRGF0YUludGVybmFsKHNpZ25lciwgZG9tYWluLCB0eXBlcywgbWVzc2FnZSk7XG4gICAgICBzaWduYXR1cmUgPSBzaWc7XG4gICAgfVxuICAgIGxldCBtZXNzYWdlVHlwZSA9IFwiZm9yd2FyZFwiO1xuXG4gICAgLy8gaWYgaGFzIG93bmVyIHByb3BlcnR5IHRoZW4gaXQncyBwZXJtaXQgOilcbiAgICBpZiAobWVzc2FnZT8ub3duZXIpIHtcbiAgICAgIG1lc3NhZ2VUeXBlID0gXCJwZXJtaXRcIjtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHJlcXVlc3Q6IG1lc3NhZ2UsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICBmb3J3YXJkZXJBZGRyZXNzLFxuICAgICAgdHlwZTogbWVzc2FnZVR5cGVcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoRXZlbnRUeXBlLlNpZ25hdHVyZSwge1xuICAgICAgc3RhdHVzOiBcImNvbXBsZXRlZFwiLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gkMSh0aGlzLm9wdGlvbnMuZ2FzbGVzcy5vcGVuemVwcGVsaW4ucmVsYXllclVybCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHlcbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBpZiAoIXJlc3AucmVzdWx0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVsYXkgdHJhbnNhY3Rpb24gZmFpbGVkOiAke3Jlc3AubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UocmVzcC5yZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdC50eEhhc2g7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgcmVsYXkgdHJhbnNhY3Rpb24gZmFpbGVkIHdpdGggc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c30gKCR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0pYCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNOYXRpdmVUb2tlbih0b2tlbkFkZHJlc3MpIHtcbiAgcmV0dXJuIHRva2VuQWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBOQVRJVkVfVE9LRU5fQUREUkVTUyB8fCB0b2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gY29uc3RhbnRzLkFkZHJlc3NaZXJvO1xufVxuZnVuY3Rpb24gY2xlYW5DdXJyZW5jeUFkZHJlc3MoY3VycmVuY3lBZGRyZXNzKSB7XG4gIGlmIChpc05hdGl2ZVRva2VuKGN1cnJlbmN5QWRkcmVzcykpIHtcbiAgICByZXR1cm4gTkFUSVZFX1RPS0VOX0FERFJFU1M7XG4gIH1cbiAgcmV0dXJuIGN1cnJlbmN5QWRkcmVzcztcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHByb3ZpZGVyXG4gKiBAcGFyYW0gaW5wdXRQcmljZVxuICogQHBhcmFtIGN1cnJlbmN5QWRkcmVzc1xuICogQHJldHVybnNcbiAqIEBpbnRlcm5hbFxuICovXG5hc3luYyBmdW5jdGlvbiBub3JtYWxpemVQcmljZVZhbHVlKHByb3ZpZGVyLCBpbnB1dFByaWNlLCBjdXJyZW5jeUFkZHJlc3MpIHtcbiAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBmZXRjaEN1cnJlbmN5TWV0YWRhdGEocHJvdmlkZXIsIGN1cnJlbmN5QWRkcmVzcyk7XG4gIHJldHVybiB1dGlscy5wYXJzZVVuaXRzKEFtb3VudFNjaGVtYS5wYXJzZShpbnB1dFByaWNlKSwgbWV0YWRhdGEuZGVjaW1hbHMpO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gcHJvdmlkZXJcbiAqIEBwYXJhbSBhc3NldFxuICogQHJldHVybnNcbiAqIEBpbnRlcm5hbFxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaEN1cnJlbmN5TWV0YWRhdGEocHJvdmlkZXIsIGFzc2V0KSB7XG4gIGlmIChpc05hdGl2ZVRva2VuKGFzc2V0KSkge1xuICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBwcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgY29uc3QgbmF0aXZlVG9rZW4gPSBnZXROYXRpdmVUb2tlbkJ5Q2hhaW5JZChuZXR3b3JrLmNoYWluSWQpO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYXRpdmVUb2tlbi5uYW1lLFxuICAgICAgc3ltYm9sOiBuYXRpdmVUb2tlbi5zeW1ib2wsXG4gICAgICBkZWNpbWFsczogbmF0aXZlVG9rZW4uZGVjaW1hbHNcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGVyYzIwID0gbmV3IENvbnRyYWN0KGFzc2V0LCBFUkMyME1ldGFkYXRhQWJpLCBwcm92aWRlcik7XG4gICAgY29uc3QgW25hbWUsIHN5bWJvbCwgZGVjaW1hbHNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW2VyYzIwLm5hbWUoKSwgZXJjMjAuc3ltYm9sKCksIGVyYzIwLmRlY2ltYWxzKCldKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZSxcbiAgICAgIHN5bWJvbCxcbiAgICAgIGRlY2ltYWxzXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gcHJvdmlkZXJPclNpZ25lclxuICogQHBhcmFtIGFzc2V0XG4gKiBAcGFyYW0gcHJpY2VcbiAqIEByZXR1cm5zXG4gKiBAaW50ZXJuYWxcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hDdXJyZW5jeVZhbHVlKHByb3ZpZGVyT3JTaWduZXIsIGFzc2V0LCBwcmljZSkge1xuICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGZldGNoQ3VycmVuY3lNZXRhZGF0YShwcm92aWRlck9yU2lnbmVyLCBhc3NldCk7XG4gIHJldHVybiB7XG4gICAgLi4ubWV0YWRhdGEsXG4gICAgdmFsdWU6IEJpZ051bWJlci5mcm9tKHByaWNlKSxcbiAgICBkaXNwbGF5VmFsdWU6IHV0aWxzLmZvcm1hdFVuaXRzKHByaWNlLCBtZXRhZGF0YS5kZWNpbWFscylcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNldEVyYzIwQWxsb3dhbmNlKGNvbnRyYWN0VG9BcHByb3ZlLCB2YWx1ZSwgY3VycmVuY3lBZGRyZXNzLCBvdmVycmlkZXMpIHtcbiAgaWYgKGlzTmF0aXZlVG9rZW4oY3VycmVuY3lBZGRyZXNzKSkge1xuICAgIG92ZXJyaWRlc1tcInZhbHVlXCJdID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc2lnbmVyID0gY29udHJhY3RUb0FwcHJvdmUuZ2V0U2lnbmVyKCk7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBjb250cmFjdFRvQXBwcm92ZS5nZXRQcm92aWRlcigpO1xuICAgIGNvbnN0IGVyYzIwID0gbmV3IENvbnRyYWN0V3JhcHBlcihzaWduZXIgfHwgcHJvdmlkZXIsIGN1cnJlbmN5QWRkcmVzcywgRVJDMjBBYmksIHt9KTtcbiAgICBjb25zdCBvd25lciA9IGF3YWl0IGNvbnRyYWN0VG9BcHByb3ZlLmdldFNpZ25lckFkZHJlc3MoKTtcbiAgICBjb25zdCBzcGVuZGVyID0gY29udHJhY3RUb0FwcHJvdmUucmVhZENvbnRyYWN0LmFkZHJlc3M7XG4gICAgY29uc3QgYWxsb3dhbmNlID0gYXdhaXQgZXJjMjAucmVhZENvbnRyYWN0LmFsbG93YW5jZShvd25lciwgc3BlbmRlcik7XG4gICAgaWYgKGFsbG93YW5jZS5sdCh2YWx1ZSkpIHtcbiAgICAgIC8vIGFwcHJvdmUgb3ZlcnJpZGVzIHRoZSBwcmV2aW91cyBhbGxvd2FuY2UsIHNldCBpdCB0byB0aGUgbWluaW11bSByZXF1aXJlZCBmb3IgdGhpcyB0eFxuICAgICAgYXdhaXQgZXJjMjAuc2VuZFRyYW5zYWN0aW9uKFwiYXBwcm92ZVwiLCBbc3BlbmRlciwgdmFsdWVdKTtcbiAgICB9XG4gICAgcmV0dXJuIG92ZXJyaWRlcztcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gYXBwcm92ZUVyYzIwQWxsb3dhbmNlKGNvbnRyYWN0VG9BcHByb3ZlLCBjdXJyZW5jeUFkZHJlc3MsIHByaWNlLCBxdWFudGl0eSwgdG9rZW5EZWNpbWFscykge1xuICBjb25zdCBzaWduZXIgPSBjb250cmFjdFRvQXBwcm92ZS5nZXRTaWduZXIoKTtcbiAgY29uc3QgcHJvdmlkZXIgPSBjb250cmFjdFRvQXBwcm92ZS5nZXRQcm92aWRlcigpO1xuICBjb25zdCBlcmMyMCA9IG5ldyBDb250cmFjdFdyYXBwZXIoc2lnbmVyIHx8IHByb3ZpZGVyLCBjdXJyZW5jeUFkZHJlc3MsIEVSQzIwQWJpLCB7fSk7XG4gIGNvbnN0IG93bmVyID0gYXdhaXQgY29udHJhY3RUb0FwcHJvdmUuZ2V0U2lnbmVyQWRkcmVzcygpO1xuICBjb25zdCBzcGVuZGVyID0gY29udHJhY3RUb0FwcHJvdmUucmVhZENvbnRyYWN0LmFkZHJlc3M7XG4gIGNvbnN0IGFsbG93YW5jZSA9IGF3YWl0IGVyYzIwLnJlYWRDb250cmFjdC5hbGxvd2FuY2Uob3duZXIsIHNwZW5kZXIpO1xuICBjb25zdCB0b3RhbFByaWNlID0gQmlnTnVtYmVyLmZyb20ocHJpY2UpLm11bChCaWdOdW1iZXIuZnJvbShxdWFudGl0eSkpLmRpdihldGhlcnMudXRpbHMucGFyc2VVbml0cyhcIjFcIiwgdG9rZW5EZWNpbWFscykpO1xuICBpZiAoYWxsb3dhbmNlLmx0KHRvdGFsUHJpY2UpKSB7XG4gICAgYXdhaXQgZXJjMjAuc2VuZFRyYW5zYWN0aW9uKFwiYXBwcm92ZVwiLCBbc3BlbmRlciwgYWxsb3dhbmNlLmFkZCh0b3RhbFByaWNlKV0pO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBoYXNFUkMyMEFsbG93YW5jZShjb250cmFjdFRvQXBwcm92ZSwgY3VycmVuY3lBZGRyZXNzLCB2YWx1ZSkge1xuICBjb25zdCBwcm92aWRlciA9IGNvbnRyYWN0VG9BcHByb3ZlLmdldFByb3ZpZGVyKCk7XG4gIGNvbnN0IGVyYzIwID0gbmV3IENvbnRyYWN0V3JhcHBlcihwcm92aWRlciwgY3VycmVuY3lBZGRyZXNzLCBFUkMyMEFiaSwge30pO1xuICBjb25zdCBvd25lciA9IGF3YWl0IGNvbnRyYWN0VG9BcHByb3ZlLmdldFNpZ25lckFkZHJlc3MoKTtcbiAgY29uc3Qgc3BlbmRlciA9IGNvbnRyYWN0VG9BcHByb3ZlLnJlYWRDb250cmFjdC5hZGRyZXNzO1xuICBjb25zdCBhbGxvd2FuY2UgPSBhd2FpdCBlcmMyMC5yZWFkQ29udHJhY3QuYWxsb3dhbmNlKG93bmVyLCBzcGVuZGVyKTtcbiAgcmV0dXJuIGFsbG93YW5jZS5ndGUodmFsdWUpO1xufVxuXG4vKipcbiAqIFJldHVybnMgcHJvb2ZzIGFuZCB0aGUgb3ZlcnJpZGVzIHJlcXVpcmVkIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gKiBAaW50ZXJuYWxcbiAqIEByZXR1cm5zIC0gYG92ZXJyaWRlc2AgYW5kIGBwcm9vZnNgIGFzIGFuIG9iamVjdC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHJlcGFyZUNsYWltKGFkZHJlc3NUb0NsYWltLCBxdWFudGl0eSwgYWN0aXZlQ2xhaW1Db25kaXRpb24sIG1lcmtsZU1ldGFkYXRhRmV0Y2hlciwgdG9rZW5EZWNpbWFscywgY29udHJhY3RXcmFwcGVyLCBzdG9yYWdlLCBjaGVja0VSQzIwQWxsb3dhbmNlLCBzbmFwc2hvdEZvcm1hdFZlcnNpb24pIHtcbiAgbGV0IG1heENsYWltYWJsZSA9IGNvbnZlcnRRdWFudGl0eVRvQmlnTnVtYmVyKGFjdGl2ZUNsYWltQ29uZGl0aW9uLm1heENsYWltYWJsZVBlcldhbGxldCwgdG9rZW5EZWNpbWFscyk7XG4gIGxldCBwcm9vZnMgPSBbdXRpbHMuaGV4WmVyb1BhZChbMF0sIDMyKV07XG4gIGxldCBwcmljZUluUHJvb2YgPSBhY3RpdmVDbGFpbUNvbmRpdGlvbi5wcmljZTsgLy8gdGhlIHByaWNlIHRvIHNlbmQgdG8gdGhlIGNvbnRyYWN0IGluIGNsYWltIHByb29mc1xuICBsZXQgY3VycmVuY3lBZGRyZXNzSW5Qcm9vZiA9IGFjdGl2ZUNsYWltQ29uZGl0aW9uLmN1cnJlbmN5QWRkcmVzcztcbiAgdHJ5IHtcbiAgICBpZiAoIWFjdGl2ZUNsYWltQ29uZGl0aW9uLm1lcmtsZVJvb3RIYXNoLnRvU3RyaW5nKCkuc3RhcnRzV2l0aChjb25zdGFudHMuQWRkcmVzc1plcm8pKSB7XG4gICAgICBjb25zdCBzbmFwc2hvdEVudHJ5ID0gYXdhaXQgZmV0Y2hTbmFwc2hvdEVudHJ5Rm9yQWRkcmVzcyhhZGRyZXNzVG9DbGFpbSwgYWN0aXZlQ2xhaW1Db25kaXRpb24ubWVya2xlUm9vdEhhc2gudG9TdHJpbmcoKSwgYXdhaXQgbWVya2xlTWV0YWRhdGFGZXRjaGVyKCksIGNvbnRyYWN0V3JhcHBlci5nZXRQcm92aWRlcigpLCBzdG9yYWdlLCBzbmFwc2hvdEZvcm1hdFZlcnNpb24pO1xuICAgICAgaWYgKHNuYXBzaG90RW50cnkpIHtcbiAgICAgICAgcHJvb2ZzID0gc25hcHNob3RFbnRyeS5wcm9vZjtcbiAgICAgICAgLy8gb3ZlcnJpZGUgb25seSBpZiBub3QgZGVmYXVsdCB2YWx1ZXMgKHVubGltaXRlZCBmb3IgcXVhbnRpdHksIHplcm8gYWRkciBmb3IgY3VycmVuY3kpXG4gICAgICAgIG1heENsYWltYWJsZSA9IHNuYXBzaG90RW50cnkubWF4Q2xhaW1hYmxlID09PSBcInVubGltaXRlZFwiID8gZXRoZXJzLmNvbnN0YW50cy5NYXhVaW50MjU2IDogZXRoZXJzLnV0aWxzLnBhcnNlVW5pdHMoc25hcHNob3RFbnRyeS5tYXhDbGFpbWFibGUsIHRva2VuRGVjaW1hbHMpO1xuICAgICAgICBwcmljZUluUHJvb2YgPSBzbmFwc2hvdEVudHJ5LnByaWNlID09PSB1bmRlZmluZWQgfHwgc25hcHNob3RFbnRyeS5wcmljZSA9PT0gXCJ1bmxpbWl0ZWRcIiA/IGV0aGVycy5jb25zdGFudHMuTWF4VWludDI1NiA6IGF3YWl0IG5vcm1hbGl6ZVByaWNlVmFsdWUoY29udHJhY3RXcmFwcGVyLmdldFByb3ZpZGVyKCksIHNuYXBzaG90RW50cnkucHJpY2UsIHNuYXBzaG90RW50cnkuY3VycmVuY3lBZGRyZXNzIHx8IGV0aGVycy5jb25zdGFudHMuQWRkcmVzc1plcm8pO1xuICAgICAgICBjdXJyZW5jeUFkZHJlc3NJblByb29mID0gc25hcHNob3RFbnRyeS5jdXJyZW5jeUFkZHJlc3MgfHwgZXRoZXJzLmNvbnN0YW50cy5BZGRyZXNzWmVybztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIG5vIHNuYXBzaG90IGVudHJ5LCBhbmQgaXQncyBhIHYxIGZvcm1hdCAoZXhjbHVzaXZlIGFsbG93bGlzdCkgdGhlbiBhZGRyZXNzIGNhbid0IGNsYWltXG4gICAgICAgIGlmIChzbmFwc2hvdEZvcm1hdFZlcnNpb24gPT09IFNuYXBzaG90Rm9ybWF0VmVyc2lvbi5WMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNsYWltIGZvdW5kIGZvciB0aGlzIGFkZHJlc3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnV0IGlmIGl0cyBzbmFwc2hvdCB2MiAob3ZlcnJpZGUgbGlzdCBiZWhhdmlvcikgdGhlbiBhZGRyZXNzIGNhbiBzdGlsbCBjbGFpbSB3aXRoIGRlZmF1bHQgc2V0dGluZ3NcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBoYXZlIHRvIGhhbmRsZSB0aGUgdmFsaWQgZXJyb3IgY2FzZSB0aGF0IHdlICpkbyogd2FudCB0byB0aHJvdyBvblxuICAgIGlmIChlPy5tZXNzYWdlID09PSBcIk5vIGNsYWltIGZvdW5kIGZvciB0aGlzIGFkZHJlc3NcIikge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgLy8gb3RoZXIgZXJyb3JzIHdlIHdhbm5hIGlnbm9yZSBhbmQgdHJ5IHRvIGNvbnRpbnVlXG4gICAgY29uc29sZS53YXJuKFwiZmFpbGVkIHRvIGNoZWNrIGNsYWltIGNvbmRpdGlvbiBtZXJrbGUgcm9vdCBoYXNoLCBjb250aW51aW5nIGFueXdheXNcIiwgZSk7XG4gIH1cbiAgY29uc3Qgb3ZlcnJpZGVzID0gKGF3YWl0IGNvbnRyYWN0V3JhcHBlci5nZXRDYWxsT3ZlcnJpZGVzKCkpIHx8IHt9O1xuICAvLyB0aGUgYWN0dWFsIHByaWNlIHRvIGNoZWNrIGFsbG93YW5jZSBhZ2FpbnN0XG4gIC8vIGlmIHByb29mIHByaWNlIGlzIHVubGltaXRlZCwgdGhlbiB3ZSB1c2UgdGhlIHByaWNlIGZyb20gdGhlIGNsYWltIGNvbmRpdGlvblxuICAvLyB0aGlzIG1pbWljcyB0aGUgY29udHJhY3QgYmVoYXZpb3JcbiAgY29uc3QgcHJpY2VQZXJUb2tlbiA9IHByaWNlSW5Qcm9vZi50b1N0cmluZygpICE9PSBldGhlcnMuY29uc3RhbnRzLk1heFVpbnQyNTYudG9TdHJpbmcoKSA/IHByaWNlSW5Qcm9vZiA6IGFjdGl2ZUNsYWltQ29uZGl0aW9uLnByaWNlO1xuICAvLyBzYW1lIGZvciBjdXJyZW5jeSBhZGRyZXNzXG4gIGNvbnN0IGN1cnJlbmN5QWRkcmVzcyA9IGN1cnJlbmN5QWRkcmVzc0luUHJvb2YgIT09IGV0aGVycy5jb25zdGFudHMuQWRkcmVzc1plcm8gPyBjdXJyZW5jeUFkZHJlc3NJblByb29mIDogYWN0aXZlQ2xhaW1Db25kaXRpb24uY3VycmVuY3lBZGRyZXNzO1xuICBpZiAocHJpY2VQZXJUb2tlbi5ndCgwKSkge1xuICAgIGlmIChpc05hdGl2ZVRva2VuKGN1cnJlbmN5QWRkcmVzcykpIHtcbiAgICAgIG92ZXJyaWRlc1tcInZhbHVlXCJdID0gQmlnTnVtYmVyLmZyb20ocHJpY2VQZXJUb2tlbikubXVsKHF1YW50aXR5KS5kaXYoZXRoZXJzLnV0aWxzLnBhcnNlVW5pdHMoXCIxXCIsIHRva2VuRGVjaW1hbHMpKTtcbiAgICB9IGVsc2UgaWYgKGNoZWNrRVJDMjBBbGxvd2FuY2UpIHtcbiAgICAgIGF3YWl0IGFwcHJvdmVFcmMyMEFsbG93YW5jZShjb250cmFjdFdyYXBwZXIsIGN1cnJlbmN5QWRkcmVzcywgcHJpY2VQZXJUb2tlbiwgcXVhbnRpdHksIHRva2VuRGVjaW1hbHMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG92ZXJyaWRlcyxcbiAgICBwcm9vZnMsXG4gICAgbWF4Q2xhaW1hYmxlLFxuICAgIHByaWNlOiBwcmljZVBlclRva2VuLFxuICAgIGN1cnJlbmN5QWRkcmVzczogY3VycmVuY3lBZGRyZXNzLFxuICAgIHByaWNlSW5Qcm9vZixcbiAgICBjdXJyZW5jeUFkZHJlc3NJblByb29mXG4gIH07XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gbWVya2xlUm9vdFxuICogQHBhcmFtIG1lcmtsZU1ldGFkYXRhXG4gKiBAcGFyYW0gc3RvcmFnZVxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaFNuYXBzaG90KG1lcmtsZVJvb3QsIG1lcmtsZU1ldGFkYXRhLCBzdG9yYWdlKSB7XG4gIGlmICghbWVya2xlTWV0YWRhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBzbmFwc2hvdFVyaSA9IG1lcmtsZU1ldGFkYXRhW21lcmtsZVJvb3RdO1xuICBpZiAoc25hcHNob3RVcmkpIHtcbiAgICBjb25zdCByYXcgPSBhd2FpdCBzdG9yYWdlLmRvd25sb2FkSlNPTihzbmFwc2hvdFVyaSk7XG4gICAgaWYgKHJhdy5pc1NoYXJkZWRNZXJrbGVUcmVlICYmIHJhdy5tZXJrbGVSb290ID09PSBtZXJrbGVSb290KSB7XG4gICAgICBjb25zdCBzbXQgPSBhd2FpdCBTaGFyZGVkTWVya2xlVHJlZS5mcm9tVXJpKHNuYXBzaG90VXJpLCBzdG9yYWdlKTtcbiAgICAgIHJldHVybiBzbXQ/LmdldEFsbEVudHJpZXMoKSB8fCBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzbmFwc2hvdERhdGEgPSBTbmFwc2hvdFNjaGVtYS5wYXJzZShyYXcpO1xuICAgICAgaWYgKG1lcmtsZVJvb3QgPT09IHNuYXBzaG90RGF0YS5tZXJrbGVSb290KSB7XG4gICAgICAgIHJldHVybiBzbmFwc2hvdERhdGEuY2xhaW1zLm1hcChjbGFpbSA9PiAoe1xuICAgICAgICAgIGFkZHJlc3M6IGNsYWltLmFkZHJlc3MsXG4gICAgICAgICAgbWF4Q2xhaW1hYmxlOiBjbGFpbS5tYXhDbGFpbWFibGUsXG4gICAgICAgICAgcHJpY2U6IGNsYWltLnByaWNlLFxuICAgICAgICAgIGN1cnJlbmN5QWRkcmVzczogY2xhaW0uY3VycmVuY3lBZGRyZXNzXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaFNuYXBzaG90RW50cnlGb3JBZGRyZXNzKGFkZHJlc3MsIG1lcmtsZVJvb3QsIG1lcmtsZU1ldGFkYXRhLCBwcm92aWRlciwgc3RvcmFnZSwgc25hcHNob3RGb3JtYXRWZXJzaW9uKSB7XG4gIGlmICghbWVya2xlTWV0YWRhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBzbmFwc2hvdFVyaSA9IG1lcmtsZU1ldGFkYXRhW21lcmtsZVJvb3RdO1xuICBpZiAoc25hcHNob3RVcmkpIHtcbiAgICBjb25zdCByYXcgPSBhd2FpdCBzdG9yYWdlLmRvd25sb2FkSlNPTihzbmFwc2hvdFVyaSk7XG4gICAgaWYgKHJhdy5pc1NoYXJkZWRNZXJrbGVUcmVlICYmIHJhdy5tZXJrbGVSb290ID09PSBtZXJrbGVSb290KSB7XG4gICAgICBjb25zdCBtZXJrbGVUcmVlID0gYXdhaXQgU2hhcmRlZE1lcmtsZVRyZWUuZnJvbVNoYXJkZWRNZXJrbGVUcmVlSW5mbyhyYXcsIHN0b3JhZ2UpO1xuICAgICAgcmV0dXJuIGF3YWl0IG1lcmtsZVRyZWUuZ2V0UHJvb2YoYWRkcmVzcywgcHJvdmlkZXIsIHNuYXBzaG90Rm9ybWF0VmVyc2lvbik7XG4gICAgfVxuICAgIC8vIGxlZ2FjeSBub24tc2hhcmRlZCwganVzdCBmZXRjaCBpdCBhbGwgYW5kIGZpbHRlciBvdXRcbiAgICBjb25zdCBzbmFwc2hvdERhdGEgPSBTbmFwc2hvdFNjaGVtYS5wYXJzZShyYXcpO1xuICAgIGlmIChtZXJrbGVSb290ID09PSBzbmFwc2hvdERhdGEubWVya2xlUm9vdCkge1xuICAgICAgcmV0dXJuIHNuYXBzaG90RGF0YS5jbGFpbXMuZmluZChjID0+IGMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpIHx8IG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGluZGV4XG4gKiBAcGFyYW0gY2xhaW1Db25kaXRpb25JbnB1dFxuICogQHBhcmFtIGV4aXN0aW5nQ29uZGl0aW9uc1xuICovXG5hc3luYyBmdW5jdGlvbiB1cGRhdGVFeGlzdGluZ0NsYWltQ29uZGl0aW9ucyhpbmRleCwgY2xhaW1Db25kaXRpb25JbnB1dCwgZXhpc3RpbmdDb25kaXRpb25zKSB7XG4gIGlmIChpbmRleCA+PSBleGlzdGluZ0NvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgRXJyb3IoYEluZGV4IG91dCBvZiBib3VuZHMgLSBnb3QgaW5kZXg6ICR7aW5kZXh9IHdpdGggJHtleGlzdGluZ0NvbmRpdGlvbnMubGVuZ3RofSBjb25kaXRpb25zYCk7XG4gIH1cbiAgLy8gbWVyZ2UgaW5wdXQgd2l0aCBleGlzdGluZyBjbGFpbSBjb25kaXRpb25cbiAgY29uc3QgcHJpY2VEZWNpbWFscyA9IGV4aXN0aW5nQ29uZGl0aW9uc1tpbmRleF0uY3VycmVuY3lNZXRhZGF0YS5kZWNpbWFscztcbiAgY29uc3QgcHJpY2VJbldlaSA9IGV4aXN0aW5nQ29uZGl0aW9uc1tpbmRleF0ucHJpY2U7XG4gIGNvbnN0IHByaWNlSW5Ub2tlbnMgPSBldGhlcnMudXRpbHMuZm9ybWF0VW5pdHMocHJpY2VJbldlaSwgcHJpY2VEZWNpbWFscyk7XG5cbiAgLy8gbWVyZ2UgZXhpc3RpbmcgKG91dHB1dCBmb3JtYXQpIHdpdGggaW5jb21pbmcgKGlucHV0IGZvcm1hdClcbiAgY29uc3QgbmV3Q29uZGl0aW9uUGFyc2VkID0gQ2xhaW1Db25kaXRpb25JbnB1dFNjaGVtYS5wYXJzZSh7XG4gICAgLi4uZXhpc3RpbmdDb25kaXRpb25zW2luZGV4XSxcbiAgICBwcmljZTogcHJpY2VJblRva2VucyxcbiAgICAuLi5jbGFpbUNvbmRpdGlvbklucHV0XG4gIH0pO1xuXG4gIC8vIGNvbnZlcnQgdG8gb3V0cHV0IGNsYWltIGNvbmRpdGlvblxuICBjb25zdCBtZXJnZWRDb25kaXRpb25PdXRwdXQgPSBDbGFpbUNvbmRpdGlvbk91dHB1dFNjaGVtYS5wYXJzZSh7XG4gICAgLi4ubmV3Q29uZGl0aW9uUGFyc2VkLFxuICAgIHByaWNlOiBwcmljZUluV2VpXG4gIH0pO1xuICByZXR1cm4gZXhpc3RpbmdDb25kaXRpb25zLm1hcCgoZXhpc3RpbmdPdXRwdXQsIGkpID0+IHtcbiAgICBsZXQgbmV3Q29uZGl0aW9uQXRJbmRleDtcbiAgICBpZiAoaSA9PT0gaW5kZXgpIHtcbiAgICAgIG5ld0NvbmRpdGlvbkF0SW5kZXggPSBtZXJnZWRDb25kaXRpb25PdXRwdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0NvbmRpdGlvbkF0SW5kZXggPSBleGlzdGluZ091dHB1dDtcbiAgICB9XG4gICAgY29uc3QgZm9ybWF0dGVkUHJpY2UgPSBldGhlcnMudXRpbHMuZm9ybWF0VW5pdHMobmV3Q29uZGl0aW9uQXRJbmRleC5wcmljZSwgcHJpY2VEZWNpbWFscyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLm5ld0NvbmRpdGlvbkF0SW5kZXgsXG4gICAgICBwcmljZTogZm9ybWF0dGVkUHJpY2UgLy8gbWFudWFsbHkgdHJhbnNmb3JtIGJhY2sgdG8gaW5wdXQgcHJpY2UgdHlwZVxuICAgIH07XG4gIH0pO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogRGVjb3JhdGVzIGNsYWltIGNvbmRpdGlvbnMgd2l0aCBtZXJrbGUgcm9vdHMgZnJvbSBzbmFwc2hvdHMgaWYgcHJlc2VudFxuICogQHBhcmFtIGNsYWltQ29uZGl0aW9uSW5wdXRzXG4gKiBAcGFyYW0gdG9rZW5EZWNpbWFsc1xuICogQHBhcmFtIHByb3ZpZGVyXG4gKiBAcGFyYW0gc3RvcmFnZVxuICogQHBhcmFtIHNuYXBzaG90Rm9ybWF0VmVyc2lvblxuICovXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzU25hcHNob3REYXRhKGNsYWltQ29uZGl0aW9uSW5wdXRzLCB0b2tlbkRlY2ltYWxzLCBwcm92aWRlciwgc3RvcmFnZSwgc25hcHNob3RGb3JtYXRWZXJzaW9uKSB7XG4gIGNvbnN0IHNuYXBzaG90SW5mb3MgPSBbXTtcbiAgY29uc3QgaW5wdXRzV2l0aFNuYXBzaG90cyA9IGF3YWl0IFByb21pc2UuYWxsKGNsYWltQ29uZGl0aW9uSW5wdXRzLm1hcChhc3luYyBjb25kaXRpb25JbnB1dCA9PiB7XG4gICAgLy8gY2hlY2sgc25hcHNob3RzIGFuZCB1cGxvYWQgaWYgcHJvdmlkZWRcbiAgICBpZiAoY29uZGl0aW9uSW5wdXQuc25hcHNob3QgJiYgY29uZGl0aW9uSW5wdXQuc25hcHNob3QubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc25hcHNob3RJbmZvID0gYXdhaXQgY3JlYXRlU25hcHNob3QoY29uZGl0aW9uSW5wdXQuc25hcHNob3QsIHRva2VuRGVjaW1hbHMsIHByb3ZpZGVyLCBzdG9yYWdlLCBzbmFwc2hvdEZvcm1hdFZlcnNpb24pO1xuICAgICAgc25hcHNob3RJbmZvcy5wdXNoKHNuYXBzaG90SW5mbyk7XG4gICAgICBjb25kaXRpb25JbnB1dC5tZXJrbGVSb290SGFzaCA9IHNuYXBzaG90SW5mby5tZXJrbGVSb290O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBubyBzbmFwc2hvdCBpcyBwYXNzZWQgb3IgZW1wdHksIHJlc2V0IHRoZSBtZXJrbGUgcm9vdFxuICAgICAgY29uZGl0aW9uSW5wdXQubWVya2xlUm9vdEhhc2ggPSB1dGlscy5oZXhaZXJvUGFkKFswXSwgMzIpO1xuICAgIH1cbiAgICAvLyBmaWxsIGNvbmRpdGlvbiB3aXRoIGRlZmF1bHRzIHZhbHVlcyBpZiBub3QgcHJvdmlkZWRcbiAgICByZXR1cm4gY29uZGl0aW9uSW5wdXQ7XG4gIH0pKTtcbiAgcmV0dXJuIHtcbiAgICBpbnB1dHNXaXRoU25hcHNob3RzLFxuICAgIHNuYXBzaG90SW5mb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBjb25zdCBsZWZ0ID0gQmlnTnVtYmVyLmZyb20oYSk7XG4gIGNvbnN0IHJpZ2h0ID0gQmlnTnVtYmVyLmZyb20oYik7XG4gIGlmIChsZWZ0LmVxKHJpZ2h0KSkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKGxlZnQuZ3QocmlnaHQpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuZCB1cGxvYWRzIHNuYXBzaG90cyArIGNvbnZlcnRzIGNsYWltIGNvbmRpdGlvbnMgdG8gY29udHJhY3QgZm9ybWF0XG4gKiBAcGFyYW0gY2xhaW1Db25kaXRpb25JbnB1dHNcbiAqIEBwYXJhbSB0b2tlbkRlY2ltYWxzXG4gKiBAcGFyYW0gcHJvdmlkZXJcbiAqIEBwYXJhbSBzdG9yYWdlXG4gKiBAcGFyYW0gc25hcHNob3RGb3JtYXRWZXJzaW9uXG4gKiBAaW50ZXJuYWxcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0NsYWltQ29uZGl0aW9uSW5wdXRzKGNsYWltQ29uZGl0aW9uSW5wdXRzLCB0b2tlbkRlY2ltYWxzLCBwcm92aWRlciwgc3RvcmFnZSwgc25hcHNob3RGb3JtYXRWZXJzaW9uKSB7XG4gIGNvbnN0IHtcbiAgICBpbnB1dHNXaXRoU25hcHNob3RzLFxuICAgIHNuYXBzaG90SW5mb3NcbiAgfSA9IGF3YWl0IHByb2Nlc3NTbmFwc2hvdERhdGEoY2xhaW1Db25kaXRpb25JbnB1dHMsIHRva2VuRGVjaW1hbHMsIHByb3ZpZGVyLCBzdG9yYWdlLCBzbmFwc2hvdEZvcm1hdFZlcnNpb24pO1xuICBjb25zdCBwYXJzZWRJbnB1dHMgPSBDbGFpbUNvbmRpdGlvbklucHV0QXJyYXkucGFyc2UoaW5wdXRzV2l0aFNuYXBzaG90cyk7XG4gIC8vIENvbnZlcnQgcHJvY2Vzc2VkIGlucHV0cyB0byB0aGUgZm9ybWF0IHRoZSBjb250cmFjdCBleHBlY3RzLCBhbmQgc29ydCBieSB0aW1lc3RhbXBcbiAgY29uc3Qgc29ydGVkQ29uZGl0aW9ucyA9IChhd2FpdCBQcm9taXNlLmFsbChwYXJzZWRJbnB1dHMubWFwKGMgPT4gY29udmVydFRvQ29udHJhY3RNb2RlbChjLCB0b2tlbkRlY2ltYWxzLCBwcm92aWRlciwgc3RvcmFnZSkpKSkuc29ydCgoYSwgYikgPT4ge1xuICAgIHJldHVybiBjb21wYXJlKGEuc3RhcnRUaW1lc3RhbXAsIGIuc3RhcnRUaW1lc3RhbXApO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzbmFwc2hvdEluZm9zLFxuICAgIHNvcnRlZENvbmRpdGlvbnNcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGxvY2FsIFNESyBtb2RlbCB0byBjb250cmFjdCBtb2RlbFxuICogQHBhcmFtIGNcbiAqIEBwYXJhbSB0b2tlbkRlY2ltYWxzXG4gKiBAcGFyYW0gcHJvdmlkZXJcbiAqIEBwYXJhbSBzdG9yYWdlXG4gKiBAaW50ZXJuYWxcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY29udmVydFRvQ29udHJhY3RNb2RlbChjLCB0b2tlbkRlY2ltYWxzLCBwcm92aWRlciwgc3RvcmFnZSkge1xuICBjb25zdCBjdXJyZW5jeSA9IGMuY3VycmVuY3lBZGRyZXNzID09PSBjb25zdGFudHMuQWRkcmVzc1plcm8gPyBOQVRJVkVfVE9LRU5fQUREUkVTUyA6IGMuY3VycmVuY3lBZGRyZXNzO1xuICBjb25zdCBtYXhDbGFpbWFibGVTdXBwbHkgPSBjb252ZXJ0UXVhbnRpdHlUb0JpZ051bWJlcihjLm1heENsYWltYWJsZVN1cHBseSwgdG9rZW5EZWNpbWFscyk7XG4gIGNvbnN0IG1heENsYWltYWJsZVBlcldhbGxldCA9IGNvbnZlcnRRdWFudGl0eVRvQmlnTnVtYmVyKGMubWF4Q2xhaW1hYmxlUGVyV2FsbGV0LCB0b2tlbkRlY2ltYWxzKTtcbiAgbGV0IG1ldGFkYXRhT3JVcmk7XG4gIGlmIChjLm1ldGFkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBjLm1ldGFkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtZXRhZGF0YU9yVXJpID0gYy5tZXRhZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWV0YWRhdGFPclVyaSA9IGF3YWl0IHN0b3JhZ2UudXBsb2FkKGMubWV0YWRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0VGltZXN0YW1wOiBjLnN0YXJ0VGltZSxcbiAgICBtYXhDbGFpbWFibGVTdXBwbHksXG4gICAgc3VwcGx5Q2xhaW1lZDogMCxcbiAgICBtYXhDbGFpbWFibGVQZXJXYWxsZXQsXG4gICAgcHJpY2VQZXJUb2tlbjogYXdhaXQgbm9ybWFsaXplUHJpY2VWYWx1ZShwcm92aWRlciwgYy5wcmljZSwgY3VycmVuY3kpLFxuICAgIGN1cnJlbmN5LFxuICAgIG1lcmtsZVJvb3Q6IGMubWVya2xlUm9vdEhhc2gudG9TdHJpbmcoKSxcbiAgICB3YWl0VGltZUluU2Vjb25kc0JldHdlZW5DbGFpbXM6IGMud2FpdEluU2Vjb25kcyB8fCAwLFxuICAgIG1ldGFkYXRhOiBtZXRhZGF0YU9yVXJpXG4gIH07XG59XG5mdW5jdGlvbiBhYnN0cmFjdENvbnRyYWN0TW9kZWxUb0xlZ2FjeShtb2RlbCkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0VGltZXN0YW1wOiBtb2RlbC5zdGFydFRpbWVzdGFtcCxcbiAgICBtYXhDbGFpbWFibGVTdXBwbHk6IG1vZGVsLm1heENsYWltYWJsZVN1cHBseSxcbiAgICBzdXBwbHlDbGFpbWVkOiBtb2RlbC5zdXBwbHlDbGFpbWVkLFxuICAgIG1lcmtsZVJvb3Q6IG1vZGVsLm1lcmtsZVJvb3QsXG4gICAgcHJpY2VQZXJUb2tlbjogbW9kZWwucHJpY2VQZXJUb2tlbixcbiAgICBjdXJyZW5jeTogbW9kZWwuY3VycmVuY3ksXG4gICAgcXVhbnRpdHlMaW1pdFBlclRyYW5zYWN0aW9uOiBtb2RlbC5tYXhDbGFpbWFibGVQZXJXYWxsZXQsXG4gICAgd2FpdFRpbWVJblNlY29uZHNCZXR3ZWVuQ2xhaW1zOiBtb2RlbC53YWl0VGltZUluU2Vjb25kc0JldHdlZW5DbGFpbXMgfHwgMFxuICB9O1xufVxuZnVuY3Rpb24gYWJzdHJhY3RDb250cmFjdE1vZGVsVG9OZXcobW9kZWwpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydFRpbWVzdGFtcDogbW9kZWwuc3RhcnRUaW1lc3RhbXAsXG4gICAgbWF4Q2xhaW1hYmxlU3VwcGx5OiBtb2RlbC5tYXhDbGFpbWFibGVTdXBwbHksXG4gICAgc3VwcGx5Q2xhaW1lZDogbW9kZWwuc3VwcGx5Q2xhaW1lZCxcbiAgICBtZXJrbGVSb290OiBtb2RlbC5tZXJrbGVSb290LFxuICAgIHByaWNlUGVyVG9rZW46IG1vZGVsLnByaWNlUGVyVG9rZW4sXG4gICAgY3VycmVuY3k6IG1vZGVsLmN1cnJlbmN5LFxuICAgIHF1YW50aXR5TGltaXRQZXJXYWxsZXQ6IG1vZGVsLm1heENsYWltYWJsZVBlcldhbGxldCxcbiAgICBtZXRhZGF0YTogbW9kZWwubWV0YWRhdGEgfHwgXCJcIlxuICB9O1xufVxuZnVuY3Rpb24gbGVnYWN5Q29udHJhY3RNb2RlbFRvQWJzdHJhY3QobW9kZWwpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydFRpbWVzdGFtcDogbW9kZWwuc3RhcnRUaW1lc3RhbXAsXG4gICAgbWF4Q2xhaW1hYmxlU3VwcGx5OiBtb2RlbC5tYXhDbGFpbWFibGVTdXBwbHksXG4gICAgc3VwcGx5Q2xhaW1lZDogbW9kZWwuc3VwcGx5Q2xhaW1lZCxcbiAgICBtZXJrbGVSb290OiBtb2RlbC5tZXJrbGVSb290LnRvU3RyaW5nKCksXG4gICAgcHJpY2VQZXJUb2tlbjogbW9kZWwucHJpY2VQZXJUb2tlbixcbiAgICBjdXJyZW5jeTogbW9kZWwuY3VycmVuY3ksXG4gICAgbWF4Q2xhaW1hYmxlUGVyV2FsbGV0OiBtb2RlbC5xdWFudGl0eUxpbWl0UGVyVHJhbnNhY3Rpb24sXG4gICAgd2FpdFRpbWVJblNlY29uZHNCZXR3ZWVuQ2xhaW1zOiBtb2RlbC53YWl0VGltZUluU2Vjb25kc0JldHdlZW5DbGFpbXNcbiAgfTtcbn1cbmZ1bmN0aW9uIG5ld0NvbnRyYWN0TW9kZWxUb0Fic3RyYWN0KG1vZGVsKSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnRUaW1lc3RhbXA6IG1vZGVsLnN0YXJ0VGltZXN0YW1wLFxuICAgIG1heENsYWltYWJsZVN1cHBseTogbW9kZWwubWF4Q2xhaW1hYmxlU3VwcGx5LFxuICAgIHN1cHBseUNsYWltZWQ6IG1vZGVsLnN1cHBseUNsYWltZWQsXG4gICAgbWVya2xlUm9vdDogbW9kZWwubWVya2xlUm9vdC50b1N0cmluZygpLFxuICAgIHByaWNlUGVyVG9rZW46IG1vZGVsLnByaWNlUGVyVG9rZW4sXG4gICAgY3VycmVuY3k6IG1vZGVsLmN1cnJlbmN5LFxuICAgIG1heENsYWltYWJsZVBlcldhbGxldDogbW9kZWwucXVhbnRpdHlMaW1pdFBlcldhbGxldCxcbiAgICB3YWl0VGltZUluU2Vjb25kc0JldHdlZW5DbGFpbXM6IDAsXG4gICAgbWV0YWRhdGE6IG1vZGVsLm1ldGFkYXRhXG4gIH07XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIGNvbnRyYWN0IG1vZGVsIHRvIGxvY2FsIG1vZGVsXG4gKiBAcGFyYW0gcG1cbiAqIEBwYXJhbSB0b2tlbkRlY2ltYWxzXG4gKiBAcGFyYW0gcHJvdmlkZXJcbiAqIEBwYXJhbSBtZXJrbGVNZXRhZGF0YVxuICogQHBhcmFtIHN0b3JhZ2VcbiAqIEBwYXJhbSBzaG91bGREb3dubG9hZFNuYXBzaG90XG4gKiBAaW50ZXJuYWxcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdHJhbnNmb3JtUmVzdWx0VG9DbGFpbUNvbmRpdGlvbihwbSwgdG9rZW5EZWNpbWFscywgcHJvdmlkZXIsIG1lcmtsZU1ldGFkYXRhLCBzdG9yYWdlLCBzaG91bGREb3dubG9hZFNuYXBzaG90KSB7XG4gIGNvbnN0IGN2ID0gYXdhaXQgZmV0Y2hDdXJyZW5jeVZhbHVlKHByb3ZpZGVyLCBwbS5jdXJyZW5jeSwgcG0ucHJpY2VQZXJUb2tlbik7XG4gIGNvbnN0IG1heENsYWltYWJsZVN1cHBseSA9IGNvbnZlcnRUb1JlYWRhYmxlUXVhbnRpdHkocG0ubWF4Q2xhaW1hYmxlU3VwcGx5LCB0b2tlbkRlY2ltYWxzKTtcbiAgY29uc3QgbWF4Q2xhaW1hYmxlUGVyV2FsbGV0ID0gY29udmVydFRvUmVhZGFibGVRdWFudGl0eShwbS5tYXhDbGFpbWFibGVQZXJXYWxsZXQsIHRva2VuRGVjaW1hbHMpO1xuICBjb25zdCBhdmFpbGFibGVTdXBwbHkgPSBjb252ZXJ0VG9SZWFkYWJsZVF1YW50aXR5KEJpZ051bWJlci5mcm9tKHBtLm1heENsYWltYWJsZVN1cHBseSkuc3ViKHBtLnN1cHBseUNsYWltZWQpLCB0b2tlbkRlY2ltYWxzKTtcbiAgY29uc3QgY3VycmVudE1pbnRTdXBwbHkgPSBjb252ZXJ0VG9SZWFkYWJsZVF1YW50aXR5KHBtLnN1cHBseUNsYWltZWQsIHRva2VuRGVjaW1hbHMpO1xuICBsZXQgcmVzb2x2ZWRNZXRhZGF0YTtcbiAgaWYgKHBtLm1ldGFkYXRhKSB7XG4gICAgcmVzb2x2ZWRNZXRhZGF0YSA9IGF3YWl0IHN0b3JhZ2UuZG93bmxvYWRKU09OKHBtLm1ldGFkYXRhKTtcbiAgfVxuICByZXR1cm4gQ2xhaW1Db25kaXRpb25PdXRwdXRTY2hlbWEucGFyc2Uoe1xuICAgIHN0YXJ0VGltZTogcG0uc3RhcnRUaW1lc3RhbXAsXG4gICAgbWF4Q2xhaW1hYmxlU3VwcGx5LFxuICAgIG1heENsYWltYWJsZVBlcldhbGxldCxcbiAgICBjdXJyZW50TWludFN1cHBseSxcbiAgICBhdmFpbGFibGVTdXBwbHksXG4gICAgd2FpdEluU2Vjb25kczogcG0ud2FpdFRpbWVJblNlY29uZHNCZXR3ZWVuQ2xhaW1zPy50b1N0cmluZygpLFxuICAgIHByaWNlOiBCaWdOdW1iZXIuZnJvbShwbS5wcmljZVBlclRva2VuKSxcbiAgICBjdXJyZW5jeTogcG0uY3VycmVuY3ksXG4gICAgY3VycmVuY3lBZGRyZXNzOiBwbS5jdXJyZW5jeSxcbiAgICBjdXJyZW5jeU1ldGFkYXRhOiBjdixcbiAgICBtZXJrbGVSb290SGFzaDogcG0ubWVya2xlUm9vdCxcbiAgICBzbmFwc2hvdDogc2hvdWxkRG93bmxvYWRTbmFwc2hvdCA/IGF3YWl0IGZldGNoU25hcHNob3QocG0ubWVya2xlUm9vdCwgbWVya2xlTWV0YWRhdGEsIHN0b3JhZ2UpIDogdW5kZWZpbmVkLFxuICAgIG1ldGFkYXRhOiByZXNvbHZlZE1ldGFkYXRhXG4gIH0pO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGJuXG4gKiBAcGFyYW0gdG9rZW5EZWNpbWFsc1xuICovXG5mdW5jdGlvbiBjb252ZXJ0VG9SZWFkYWJsZVF1YW50aXR5KGJuLCB0b2tlbkRlY2ltYWxzKSB7XG4gIGlmIChibi50b1N0cmluZygpID09PSBldGhlcnMuY29uc3RhbnRzLk1heFVpbnQyNTYudG9TdHJpbmcoKSkge1xuICAgIHJldHVybiBcInVubGltaXRlZFwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBldGhlcnMudXRpbHMuZm9ybWF0VW5pdHMoYm4sIHRva2VuRGVjaW1hbHMpO1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gcXVhbnRpdHlcbiAqIEBwYXJhbSB0b2tlbkRlY2ltYWxzXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRRdWFudGl0eVRvQmlnTnVtYmVyKHF1YW50aXR5LCB0b2tlbkRlY2ltYWxzKSB7XG4gIGlmIChxdWFudGl0eSA9PT0gXCJ1bmxpbWl0ZWRcIikge1xuICAgIHJldHVybiBldGhlcnMuY29uc3RhbnRzLk1heFVpbnQyNTY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV0aGVycy51dGlscy5wYXJzZVVuaXRzKHF1YW50aXR5LCB0b2tlbkRlY2ltYWxzKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlQ2xhaW1Db3N0KGNvbnRyYWN0V3JhcHBlciwgcHJpY2VQZXJUb2tlbiwgcXVhbnRpdHksIGN1cnJlbmN5QWRkcmVzcywgY2hlY2tFUkMyMEFsbG93YW5jZSkge1xuICBsZXQgb3ZlcnJpZGVzID0ge307XG4gIGNvbnN0IGN1cnJlbmN5ID0gY3VycmVuY3lBZGRyZXNzIHx8IE5BVElWRV9UT0tFTl9BRERSRVNTO1xuICBjb25zdCBub3JtYWxpemVkUHJpY2UgPSBhd2FpdCBub3JtYWxpemVQcmljZVZhbHVlKGNvbnRyYWN0V3JhcHBlci5nZXRQcm92aWRlcigpLCBwcmljZVBlclRva2VuLCBjdXJyZW5jeSk7XG4gIGNvbnN0IHRvdGFsQ29zdCA9IG5vcm1hbGl6ZWRQcmljZS5tdWwocXVhbnRpdHkpO1xuICBpZiAodG90YWxDb3N0Lmd0KDApKSB7XG4gICAgaWYgKGN1cnJlbmN5ID09PSBOQVRJVkVfVE9LRU5fQUREUkVTUykge1xuICAgICAgb3ZlcnJpZGVzID0ge1xuICAgICAgICB2YWx1ZTogdG90YWxDb3N0XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoY3VycmVuY3kgIT09IE5BVElWRV9UT0tFTl9BRERSRVNTICYmIGNoZWNrRVJDMjBBbGxvd2FuY2UpIHtcbiAgICAgIGF3YWl0IGFwcHJvdmVFcmMyMEFsbG93YW5jZShjb250cmFjdFdyYXBwZXIsIGN1cnJlbmN5LCB0b3RhbENvc3QsIHF1YW50aXR5LCAwKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG92ZXJyaWRlcztcbn1cblxuLy8gc2hhcmQgdXNpbmcgdGhlIGZpcnN0IDIgaGV4IGNoYXJhY3RlciBvZiB0aGUgYWRkcmVzc1xuLy8gdGhpcyBzcGxpdHMgdGhlIG1lcmtsZSB0cmVlIGludG8gMjU2IHNoYXJkc1xuLy8gc2hhcmQgZmlsZXMgd2lsbCBiZSAwMC5qc29uLCAwMS5qc29uLCAwMi5qc29uLCAuLi4sIGZmLmpzb25cbmNvbnN0IFNIQVJEX05ZQkJMRVMgPSAyO1xubGV0IFNuYXBzaG90Rm9ybWF0VmVyc2lvbjsgLy8gYWRkcmVzcywgbWF4Q2xhaW1hYmxlLCBwcmljZSwgY3VycmVuY3lBZGRyZXNzXG4oZnVuY3Rpb24gKFNuYXBzaG90Rm9ybWF0VmVyc2lvbikge1xuICBTbmFwc2hvdEZvcm1hdFZlcnNpb25bU25hcHNob3RGb3JtYXRWZXJzaW9uW1wiVjFcIl0gPSAxXSA9IFwiVjFcIjtcbiAgU25hcHNob3RGb3JtYXRWZXJzaW9uW1NuYXBzaG90Rm9ybWF0VmVyc2lvbltcIlYyXCJdID0gMl0gPSBcIlYyXCI7XG59KShTbmFwc2hvdEZvcm1hdFZlcnNpb24gfHwgKFNuYXBzaG90Rm9ybWF0VmVyc2lvbiA9IHt9KSk7XG5jbGFzcyBTaGFyZGVkTWVya2xlVHJlZSB7XG4gIGNvbnN0cnVjdG9yKHN0b3JhZ2UsIGJhc2VVcmksIG9yaWdpbmFsRW50cmllc1VyaSwgc2hhcmROeWJibGVzLCB0b2tlbkRlY2ltYWxzKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2hhcmROeWJibGVzXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2hhcmRzXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidHJlZXNcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yYWdlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYmFzZVVyaVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9yaWdpbmFsRW50cmllc1VyaVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRva2VuRGVjaW1hbHNcIiwgdm9pZCAwKTtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgIHRoaXMuc2hhcmROeWJibGVzID0gc2hhcmROeWJibGVzO1xuICAgIHRoaXMuYmFzZVVyaSA9IGJhc2VVcmk7XG4gICAgdGhpcy5vcmlnaW5hbEVudHJpZXNVcmkgPSBvcmlnaW5hbEVudHJpZXNVcmk7XG4gICAgdGhpcy50b2tlbkRlY2ltYWxzID0gdG9rZW5EZWNpbWFscztcbiAgICB0aGlzLnNoYXJkcyA9IHt9O1xuICAgIHRoaXMudHJlZXMgPSB7fTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbVVyaSh1cmksIHN0b3JhZ2UpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2hhcmRlZE1lcmtsZVRyZWVJbmZvID0gYXdhaXQgc3RvcmFnZS5kb3dubG9hZEpTT04odXJpKTtcbiAgICAgIGlmIChzaGFyZGVkTWVya2xlVHJlZUluZm8uaXNTaGFyZGVkTWVya2xlVHJlZSkge1xuICAgICAgICByZXR1cm4gU2hhcmRlZE1lcmtsZVRyZWUuZnJvbVNoYXJkZWRNZXJrbGVUcmVlSW5mbyhzaGFyZGVkTWVya2xlVHJlZUluZm8sIHN0b3JhZ2UpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tU2hhcmRlZE1lcmtsZVRyZWVJbmZvKGluZm8sIHN0b3JhZ2UpIHtcbiAgICByZXR1cm4gbmV3IFNoYXJkZWRNZXJrbGVUcmVlKHN0b3JhZ2UsIGluZm8uYmFzZVVyaSwgaW5mby5vcmlnaW5hbEVudHJpZXNVcmksIGluZm8uc2hhcmROeWJibGVzLCBpbmZvLnRva2VuRGVjaW1hbHMpO1xuICB9XG4gIHN0YXRpYyBoYXNoRW50cnkoZW50cnksIHRva2VuRGVjaW1hbHMsIGN1cnJlbmN5RGVjaW1hbHMsIHNuYXBzaG90Rm9ybWF0VmVyc2lvbikge1xuICAgIHN3aXRjaCAoc25hcHNob3RGb3JtYXRWZXJzaW9uKSB7XG4gICAgICBjYXNlIFNuYXBzaG90Rm9ybWF0VmVyc2lvbi5WMTpcbiAgICAgICAgcmV0dXJuIHV0aWxzLnNvbGlkaXR5S2VjY2FrMjU2KFtcImFkZHJlc3NcIiwgXCJ1aW50MjU2XCJdLCBbZW50cnkuYWRkcmVzcywgY29udmVydFF1YW50aXR5VG9CaWdOdW1iZXIoZW50cnkubWF4Q2xhaW1hYmxlLCB0b2tlbkRlY2ltYWxzKV0pO1xuICAgICAgY2FzZSBTbmFwc2hvdEZvcm1hdFZlcnNpb24uVjI6XG4gICAgICAgIHJldHVybiB1dGlscy5zb2xpZGl0eUtlY2NhazI1NihbXCJhZGRyZXNzXCIsIFwidWludDI1NlwiLCBcInVpbnQyNTZcIiwgXCJhZGRyZXNzXCJdLCBbZW50cnkuYWRkcmVzcywgY29udmVydFF1YW50aXR5VG9CaWdOdW1iZXIoZW50cnkubWF4Q2xhaW1hYmxlLCB0b2tlbkRlY2ltYWxzKSwgY29udmVydFF1YW50aXR5VG9CaWdOdW1iZXIoZW50cnkucHJpY2UgfHwgXCJ1bmxpbWl0ZWRcIiwgY3VycmVuY3lEZWNpbWFscyksIGVudHJ5LmN1cnJlbmN5QWRkcmVzcyB8fCBldGhlcnMuY29uc3RhbnRzLkFkZHJlc3NaZXJvXSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBhc3luYyBmZXRjaEFuZENhY2hlRGVjaW1hbHMoY2FjaGUsIHByb3ZpZGVyLCBjdXJyZW5jeUFkZHJlc3MpIHtcbiAgICBpZiAoIWN1cnJlbmN5QWRkcmVzcykge1xuICAgICAgcmV0dXJuIDE4O1xuICAgIH1cbiAgICAvLyBjYWNoZSBkZWNpbWFscyBmb3IgZWFjaCBjdXJyZW5jeSB0byBhdm9pZCByZWZldGNoaW5nIGZvciBldmVyeSBhZGRyZXNzXG4gICAgbGV0IGN1cnJlbmN5RGVjaW1hbHMgPSBjYWNoZVtjdXJyZW5jeUFkZHJlc3NdO1xuICAgIGlmIChjdXJyZW5jeURlY2ltYWxzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGN1cnJlbmN5TWV0YWRhdGEgPSBhd2FpdCBmZXRjaEN1cnJlbmN5TWV0YWRhdGEocHJvdmlkZXIsIGN1cnJlbmN5QWRkcmVzcyk7XG4gICAgICBjdXJyZW5jeURlY2ltYWxzID0gY3VycmVuY3lNZXRhZGF0YS5kZWNpbWFscztcbiAgICAgIGNhY2hlW2N1cnJlbmN5QWRkcmVzc10gPSBjdXJyZW5jeURlY2ltYWxzO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVuY3lEZWNpbWFscztcbiAgfVxuICBzdGF0aWMgYXN5bmMgYnVpbGRBbmRVcGxvYWQoc25hcHNob3RJbnB1dCwgdG9rZW5EZWNpbWFscywgcHJvdmlkZXIsIHN0b3JhZ2UsIHNuYXBzaG90Rm9ybWF0VmVyc2lvbikge1xuICAgIGxldCBzaGFyZE55YmJsZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IFNIQVJEX05ZQkJMRVM7XG4gICAgY29uc3QgaW5wdXRzID0gU25hcHNob3RJbnB1dFNjaGVtYS5wYXJzZShzbmFwc2hvdElucHV0KTtcbiAgICAvLyBUT0RPIENvdWxkIGFsc28gZGVyaXZlIHNoYXJkTnliYmxlcyBmcm9tIGlucHV0IHNpemVcbiAgICBjb25zdCBzaGFyZHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHNuYXBzaG90RW50cnkgb2YgaW5wdXRzKSB7XG4gICAgICBjb25zdCBzaGFyZCA9IHNuYXBzaG90RW50cnkuYWRkcmVzcy5zbGljZSgyLCAyICsgc2hhcmROeWJibGVzKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHNoYXJkc1tzaGFyZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzaGFyZHNbc2hhcmRdID0gW107XG4gICAgICB9XG4gICAgICBzaGFyZHNbc2hhcmRdLnB1c2goc25hcHNob3RFbnRyeSk7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbmN5RGVjaW1hbE1hcCA9IHt9O1xuICAgIC8vIGNyZWF0ZSBzaGFyZCA9PiBzdWJ0cmVlIHJvb3QgbWFwXG4gICAgY29uc3Qgc3ViVHJlZXMgPSBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyhzaGFyZHMpLm1hcChhc3luYyBfcmVmID0+IHtcbiAgICAgIGxldCBbc2hhcmQsIGVudHJpZXNdID0gX3JlZjtcbiAgICAgIHJldHVybiBbc2hhcmQsIG5ldyBNZXJrbGVUcmVlKGF3YWl0IFByb21pc2UuYWxsKGVudHJpZXMubWFwKGFzeW5jIGVudHJ5ID0+IHtcbiAgICAgICAgLy8gY2FjaGUgZGVjaW1hbHMgZm9yIGVhY2ggY3VycmVuY3kgdG8gYXZvaWQgcmVmZXRjaGluZyBmb3IgZXZlcnkgYWRkcmVzc1xuICAgICAgICBjb25zdCBjdXJyZW5jeURlY2ltYWxzID0gYXdhaXQgU2hhcmRlZE1lcmtsZVRyZWUuZmV0Y2hBbmRDYWNoZURlY2ltYWxzKGN1cnJlbmN5RGVjaW1hbE1hcCwgcHJvdmlkZXIsIGVudHJ5LmN1cnJlbmN5QWRkcmVzcyk7XG4gICAgICAgIHJldHVybiBTaGFyZGVkTWVya2xlVHJlZS5oYXNoRW50cnkoZW50cnksIHRva2VuRGVjaW1hbHMsIGN1cnJlbmN5RGVjaW1hbHMsIHNuYXBzaG90Rm9ybWF0VmVyc2lvbik7XG4gICAgICB9KSksIHV0aWxzLmtlY2NhazI1Niwge1xuICAgICAgICBzb3J0OiB0cnVlXG4gICAgICB9KS5nZXRIZXhSb290KCldO1xuICAgIH0pKTtcbiAgICBjb25zdCByb290cyA9IE9iamVjdC5mcm9tRW50cmllcyhzdWJUcmVlcyk7XG4gICAgLy8gY3JlYXRlIG1hc3RlciB0cmVlIGZyb20gc2hhcmQgPT4gc3VidHJlZSByb290IG1hcFxuICAgIGNvbnN0IHRyZWUgPSBuZXcgTWVya2xlVHJlZShPYmplY3QudmFsdWVzKHJvb3RzKSwgdXRpbHMua2VjY2FrMjU2LCB7XG4gICAgICBzb3J0OiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3Qgc2hhcmRzVG9VcGxvYWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtzaGFyZElkLCBlbnRyaWVzXSBvZiBPYmplY3QuZW50cmllcyhzaGFyZHMpKSB7XG4gICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICBwcm9vZnM6IHRyZWUuZ2V0UHJvb2Yocm9vdHNbc2hhcmRJZF0pLm1hcCh2YWx1ZSA9PiBcIjB4XCIgKyB2YWx1ZS5kYXRhLnRvU3RyaW5nKFwiaGV4XCIpKSxcbiAgICAgICAgZW50cmllc1xuICAgICAgfTtcbiAgICAgIHNoYXJkc1RvVXBsb2FkLnB1c2goe1xuICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgbmFtZTogYCR7c2hhcmRJZH0uanNvbmBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB1cmlzID0gYXdhaXQgc3RvcmFnZS51cGxvYWRCYXRjaChzaGFyZHNUb1VwbG9hZCk7XG4gICAgY29uc3QgYmFzZVVyaSA9IHVyaXNbMF0uc2xpY2UoMCwgdXJpc1swXS5sYXN0SW5kZXhPZihcIi9cIikpO1xuICAgIGNvbnN0IG9yaWdpbmFsRW50cmllc1VyaSA9IGF3YWl0IHN0b3JhZ2UudXBsb2FkKGlucHV0cyk7XG4gICAgY29uc3Qgc2hhcmRlZE1lcmtsZUluZm8gPSB7XG4gICAgICBtZXJrbGVSb290OiB0cmVlLmdldEhleFJvb3QoKSxcbiAgICAgIGJhc2VVcmksXG4gICAgICBvcmlnaW5hbEVudHJpZXNVcmksXG4gICAgICBzaGFyZE55YmJsZXMsXG4gICAgICB0b2tlbkRlY2ltYWxzLFxuICAgICAgaXNTaGFyZGVkTWVya2xlVHJlZTogdHJ1ZVxuICAgIH07XG4gICAgY29uc3QgbWFzdGVyVXJpID0gYXdhaXQgc3RvcmFnZS51cGxvYWQoc2hhcmRlZE1lcmtsZUluZm8pO1xuICAgIHJldHVybiB7XG4gICAgICBzaGFyZGVkTWVya2xlSW5mbyxcbiAgICAgIHVyaTogbWFzdGVyVXJpXG4gICAgfTtcbiAgfVxuICBhc3luYyBnZXRQcm9vZihhZGRyZXNzLCBwcm92aWRlciwgc25hcHNob3RGb3JtYXRWZXJzaW9uKSB7XG4gICAgY29uc3Qgc2hhcmRJZCA9IGFkZHJlc3Muc2xpY2UoMiwgMiArIHRoaXMuc2hhcmROeWJibGVzKS50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCBzaGFyZCA9IHRoaXMuc2hhcmRzW3NoYXJkSWRdO1xuICAgIGNvbnN0IGN1cnJlbmN5RGVjaW1hbE1hcCA9IHt9O1xuICAgIGlmIChzaGFyZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzaGFyZCA9IHRoaXMuc2hhcmRzW3NoYXJkSWRdID0gYXdhaXQgdGhpcy5zdG9yYWdlLmRvd25sb2FkSlNPTihgJHt0aGlzLmJhc2VVcml9LyR7c2hhcmRJZH0uanNvbmApO1xuICAgICAgICBjb25zdCBoYXNoZWRFbnRyaWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoc2hhcmQuZW50cmllcy5tYXAoYXN5bmMgZW50cnkgPT4ge1xuICAgICAgICAgIC8vIGNhY2hlIGRlY2ltYWxzIGZvciBlYWNoIGN1cnJlbmN5IHRvIGF2b2lkIHJlZmV0Y2hpbmcgZm9yIGV2ZXJ5IGFkZHJlc3NcbiAgICAgICAgICBjb25zdCBjdXJyZW5jeURlY2ltYWxzID0gYXdhaXQgU2hhcmRlZE1lcmtsZVRyZWUuZmV0Y2hBbmRDYWNoZURlY2ltYWxzKGN1cnJlbmN5RGVjaW1hbE1hcCwgcHJvdmlkZXIsIGVudHJ5LmN1cnJlbmN5QWRkcmVzcyk7XG4gICAgICAgICAgcmV0dXJuIFNoYXJkZWRNZXJrbGVUcmVlLmhhc2hFbnRyeShlbnRyeSwgdGhpcy50b2tlbkRlY2ltYWxzLCBjdXJyZW5jeURlY2ltYWxzLCBzbmFwc2hvdEZvcm1hdFZlcnNpb24pO1xuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMudHJlZXNbc2hhcmRJZF0gPSBuZXcgTWVya2xlVHJlZShoYXNoZWRFbnRyaWVzLCB1dGlscy5rZWNjYWsyNTYsIHtcbiAgICAgICAgICBzb3J0OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJObyBtZXJrbGUgZW50cnkgZm91bmQgZm9yIGFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlbnRyeSA9IHNoYXJkLmVudHJpZXMuZmluZChpID0+IGkuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW5jeURlY2ltYWxzID0gYXdhaXQgU2hhcmRlZE1lcmtsZVRyZWUuZmV0Y2hBbmRDYWNoZURlY2ltYWxzKGN1cnJlbmN5RGVjaW1hbE1hcCwgcHJvdmlkZXIsIGVudHJ5LmN1cnJlbmN5QWRkcmVzcyk7XG4gICAgY29uc3QgbGVhZiA9IFNoYXJkZWRNZXJrbGVUcmVlLmhhc2hFbnRyeShlbnRyeSwgdGhpcy50b2tlbkRlY2ltYWxzLCBjdXJyZW5jeURlY2ltYWxzLCBzbmFwc2hvdEZvcm1hdFZlcnNpb24pO1xuICAgIGNvbnN0IHByb29mID0gdGhpcy50cmVlc1tzaGFyZElkXS5nZXRQcm9vZihsZWFmKS5tYXAoaSA9PiBcIjB4XCIgKyBpLmRhdGEudG9TdHJpbmcoXCJoZXhcIikpO1xuICAgIHJldHVybiBTbmFwc2hvdEVudHJ5V2l0aFByb29mU2NoZW1hLnBhcnNlKHtcbiAgICAgIC4uLmVudHJ5LFxuICAgICAgcHJvb2Y6IHByb29mLmNvbmNhdChzaGFyZC5wcm9vZnMpXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0QWxsRW50cmllcygpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc3RvcmFnZS5kb3dubG9hZEpTT04odGhpcy5vcmlnaW5hbEVudHJpZXNVcmkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmZXRjaCBvcmlnaW5hbCBzbmFwc2hvdCBlbnRyaWVzXCIsIGUpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHNuYXBzaG90IChtZXJrbGUgdHJlZSkgZnJvbSBhIGxpc3Qgb2YgYWRkcmVzc2VzIGFuZCB1cGxvYWRzIGl0IHRvIElQRlNcbiAqIEBwYXJhbSBzbmFwc2hvdElucHV0IC0gdGhlIGxpc3Qgb2YgYWRkcmVzc2VzIHRvIGhhc2hcbiAqIEBwYXJhbSB0b2tlbkRlY2ltYWxzIC0gdGhlIHRva2VuIGRlY2ltYWxzXG4gKiBAcGFyYW0gcHJvdmlkZXJcbiAqIEBwYXJhbSBzdG9yYWdlIC0gdGhlIHN0b3JhZ2UgdG8gdXBsb2FkIHRvXG4gKiBAcGFyYW0gc25hcHNob3RGb3JtYXRWZXJzaW9uXG4gKiBAcmV0dXJucyB0aGUgZ2VuZXJhdGVkIHNuYXBzaG90IGFuZCBVUklcbiAqIEBpbnRlcm5hbFxuICovXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVTbmFwc2hvdChzbmFwc2hvdElucHV0LCB0b2tlbkRlY2ltYWxzLCBwcm92aWRlciwgc3RvcmFnZSwgc25hcHNob3RGb3JtYXRWZXJzaW9uKSB7XG4gIGNvbnN0IGlucHV0ID0gU25hcHNob3RJbnB1dFNjaGVtYS5wYXJzZShzbmFwc2hvdElucHV0KTtcbiAgY29uc3QgYWRkcmVzc2VzID0gaW5wdXQubWFwKGkgPT4gaS5hZGRyZXNzKTtcbiAgY29uc3QgaGFzRHVwbGljYXRlcyA9IG5ldyBTZXQoYWRkcmVzc2VzKS5zaXplIDwgYWRkcmVzc2VzLmxlbmd0aDtcbiAgaWYgKGhhc0R1cGxpY2F0ZXMpIHtcbiAgICB0aHJvdyBuZXcgRHVwbGljYXRlTGVhZnNFcnJvcigpO1xuICB9XG4gIGNvbnN0IHRyZWUgPSBhd2FpdCBTaGFyZGVkTWVya2xlVHJlZS5idWlsZEFuZFVwbG9hZChpbnB1dCwgdG9rZW5EZWNpbWFscywgcHJvdmlkZXIsIHN0b3JhZ2UsIHNuYXBzaG90Rm9ybWF0VmVyc2lvbik7XG4gIHJldHVybiB7XG4gICAgbWVya2xlUm9vdDogdHJlZS5zaGFyZGVkTWVya2xlSW5mby5tZXJrbGVSb290LFxuICAgIHNuYXBzaG90VXJpOiB0cmVlLnVyaVxuICB9O1xufVxuXG4vKipcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3Qgcm9sZU1hcCA9IHtcbiAgYWRtaW46IFwiXCIsXG4gIHRyYW5zZmVyOiBcIlRSQU5TRkVSX1JPTEVcIixcbiAgbWludGVyOiBcIk1JTlRFUl9ST0xFXCIsXG4gIHBhdXNlcjogXCJQQVVTRVJfUk9MRVwiLFxuICBsaXN0ZXI6IFwiTElTVEVSX1JPTEVcIixcbiAgYXNzZXQ6IFwiQVNTRVRfUk9MRVwiLFxuICB1bndyYXA6IFwiVU5XUkFQX1JPTEVcIixcbiAgZmFjdG9yeTogXCJGQUNUT1JZX1JPTEVcIlxufTtcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IEFMTF9ST0xFUyA9IE9iamVjdC5rZXlzKHJvbGVNYXApO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRSb2xlSGFzaChyb2xlKSB7XG4gIGlmIChyb2xlID09PSBcImFkbWluXCIpIHtcbiAgICByZXR1cm4gZXRoZXJzLnV0aWxzLmhleFplcm9QYWQoWzBdLCAzMik7XG4gIH1cbiAgcmV0dXJuIGV0aGVycy51dGlscy5pZChyb2xlTWFwW3JvbGVdKTtcbn1cblxuY29uc3QgRkVBVFVSRV9UT0tFTl9DTEFJTV9DT05ESVRJT05TX1YxID0ge1xuICBuYW1lOiBcIkVSQzIwQ2xhaW1Db25kaXRpb25zVjFcIixcbiAgbmFtZXNwYWNlOiBcInRva2VuLmRyb3AuY2xhaW1cIixcbiAgZG9jTGlua3M6IHtcbiAgICBzZGs6IFwic2RrLmVyYzIwZGNsYWltYWJsZVwiLFxuICAgIGNvbnRyYWN0czogXCJEcm9wU2luZ2xlUGhhc2VfVjFcIlxuICB9LFxuICBhYmlzOiBbRVJDMjBBYmksIElEcm9wU2luZ2xlUGhhc2VWMV0sXG4gIGZlYXR1cmVzOiB7fVxufTtcbmNvbnN0IEZFQVRVUkVfVE9LRU5fQ0xBSU1fQ09ORElUSU9OU19WMiA9IHtcbiAgbmFtZTogXCJFUkMyMENsYWltQ29uZGl0aW9uc1YyXCIsXG4gIG5hbWVzcGFjZTogXCJ0b2tlbi5kcm9wLmNsYWltXCIsXG4gIGRvY0xpbmtzOiB7XG4gICAgc2RrOiBcInNkay5lcmMyMGRjbGFpbWFibGVcIixcbiAgICBjb250cmFjdHM6IFwiRHJvcFNpbmdsZVBoYXNlXCJcbiAgfSxcbiAgYWJpczogW0VSQzIwQWJpLCBJRHJvcFNpbmdsZVBoYXNlXSxcbiAgZmVhdHVyZXM6IHt9XG59O1xuY29uc3QgRkVBVFVSRV9UT0tFTl9DTEFJTV9QSEFTRVNfVjIgPSB7XG4gIG5hbWU6IFwiRVJDMjBDbGFpbVBoYXNlc1YyXCIsXG4gIG5hbWVzcGFjZTogXCJ0b2tlbi5kcm9wLmNsYWltXCIsXG4gIGRvY0xpbmtzOiB7XG4gICAgc2RrOiBcInNkay5lcmMyMGRjbGFpbWFibGVcIixcbiAgICBjb250cmFjdHM6IFwiRHJvcFwiXG4gIH0sXG4gIGFiaXM6IFtFUkMyMEFiaSwgSURyb3BdLFxuICBmZWF0dXJlczoge31cbn07XG5jb25zdCBGRUFUVVJFX1RPS0VOX0NMQUlNX1BIQVNFU19WMSA9IHtcbiAgbmFtZTogXCJFUkMyMENsYWltUGhhc2VzVjFcIixcbiAgbmFtZXNwYWNlOiBcInRva2VuLmRyb3AuY2xhaW1cIixcbiAgZG9jTGlua3M6IHtcbiAgICBzZGs6IFwic2RrLmVyYzIwZGNsYWltYWJsZVwiLFxuICAgIGNvbnRyYWN0czogXCJEcm9wXCJcbiAgfSxcbiAgYWJpczogW0Ryb3BFUkMyMF9WMkFiaV0sXG4gIGZlYXR1cmVzOiB7fVxufTtcbmNvbnN0IEZFQVRVUkVfVE9LRU5fQlVSTkFCTEUgPSB7XG4gIG5hbWU6IFwiRVJDMjBCdXJuYWJsZVwiLFxuICBuYW1lc3BhY2U6IFwidG9rZW4uYnVyblwiLFxuICBkb2NMaW5rczoge1xuICAgIHNkazogXCJzZGsuZXJjMjBidXJuYWJsZVwiLFxuICAgIGNvbnRyYWN0czogXCJJQnVybmFibGVFUkMyMFwiXG4gIH0sXG4gIGFiaXM6IFtFUkMyMEFiaSwgSUJ1cm5hYmxlRVJDMjBBYmldLFxuICBmZWF0dXJlczoge31cbn07XG5jb25zdCBGRUFUVVJFX1RPS0VOX1NJR05BVFVSRV9NSU5UQUJMRSA9IHtcbiAgbmFtZTogXCJFUkMyMFNpZ25hdHVyZU1pbnRhYmxlXCIsXG4gIG5hbWVzcGFjZTogXCJ0b2tlbi5zaWduYXR1cmVcIixcbiAgZG9jTGlua3M6IHtcbiAgICBzZGs6IFwic2RrLmVyYzIwc2lnbmF0dXJlbWludGFibGVcIixcbiAgICBjb250cmFjdHM6IFwiSVNpZ25hdHVyZU1pbnRFUkMyMFwiXG4gIH0sXG4gIGFiaXM6IFtFUkMyMEFiaSwgSVNpZ25hdHVyZU1pbnRFUkMyMEFiaV0sXG4gIGZlYXR1cmVzOiB7fVxufTtcbmNvbnN0IEZFQVRVUkVfVE9LRU5fQkFUQ0hfTUlOVEFCTEUgPSB7XG4gIG5hbWU6IFwiRVJDMjBCYXRjaE1pbnRhYmxlXCIsXG4gIG5hbWVzcGFjZTogXCJ0b2tlbi5taW50LmJhdGNoXCIsXG4gIGRvY0xpbmtzOiB7XG4gICAgc2RrOiBcInNkay5lcmMyMGJhdGNobWludGFibGVcIixcbiAgICBjb250cmFjdHM6IFwiSU11bHRpY2FsbFwiXG4gIH0sXG4gIGFiaXM6IFtFUkMyMEFiaSwgSU1pbnRhYmxlRVJDMjBBYmksIE11bHRpY2FsbEFiaV0sXG4gIGZlYXR1cmVzOiB7fVxufTtcbmNvbnN0IEZFQVRVUkVfVE9LRU5fTUlOVEFCTEUgPSB7XG4gIG5hbWU6IFwiRVJDMjBNaW50YWJsZVwiLFxuICBuYW1lc3BhY2U6IFwidG9rZW4ubWludFwiLFxuICBkb2NMaW5rczoge1xuICAgIHNkazogXCJzZGsuZXJjMjBtaW50YWJsZVwiLFxuICAgIGNvbnRyYWN0czogXCJJTWludGFibGVFUkMyMFwiXG4gIH0sXG4gIGFiaXM6IFtFUkMyMEFiaSwgSU1pbnRhYmxlRVJDMjBBYmldLFxuICBmZWF0dXJlczoge1xuICAgIFtGRUFUVVJFX1RPS0VOX0JBVENIX01JTlRBQkxFLm5hbWVdOiBGRUFUVVJFX1RPS0VOX0JBVENIX01JTlRBQkxFXG4gIH1cbn07XG5jb25zdCBGRUFUVVJFX1RPS0VOID0ge1xuICBuYW1lOiBcIkVSQzIwXCIsXG4gIG5hbWVzcGFjZTogXCJ0b2tlblwiLFxuICBkb2NMaW5rczoge1xuICAgIHNkazogXCJzZGsuZXJjMjBcIixcbiAgICBjb250cmFjdHM6IFwiSUVSQzIwXCJcbiAgfSxcbiAgYWJpczogW0VSQzIwQWJpXSxcbiAgZmVhdHVyZXM6IHtcbiAgICBbRkVBVFVSRV9UT0tFTl9CVVJOQUJMRS5uYW1lXTogRkVBVFVSRV9UT0tFTl9CVVJOQUJMRSxcbiAgICBbRkVBVFVSRV9UT0tFTl9NSU5UQUJMRS5uYW1lXTogRkVBVFVSRV9UT0tFTl9NSU5UQUJMRSxcbiAgICBbRkVBVFVSRV9UT0tFTl9DTEFJTV9DT05ESVRJT05TX1YxLm5hbWVdOiBGRUFUVVJFX1RPS0VOX0NMQUlNX0NPTkRJVElPTlNfVjEsXG4gICAgW0ZFQVRVUkVfVE9LRU5fQ0xBSU1fQ09ORElUSU9OU19WMi5uYW1lXTogRkVBVFVSRV9UT0tFTl9DTEFJTV9DT05ESVRJT05TX1YyLFxuICAgIFtGRUFUVVJFX1RPS0VOX0NMQUlNX1BIQVNFU19WMS5uYW1lXTogRkVBVFVSRV9UT0tFTl9DTEFJTV9QSEFTRVNfVjEsXG4gICAgW0ZFQVRVUkVfVE9LRU5fQ0xBSU1fUEhBU0VTX1YyLm5hbWVdOiBGRUFUVVJFX1RPS0VOX0NMQUlNX1BIQVNFU19WMixcbiAgICBbRkVBVFVSRV9UT0tFTl9TSUdOQVRVUkVfTUlOVEFCTEUubmFtZV06IEZFQVRVUkVfVE9LRU5fU0lHTkFUVVJFX01JTlRBQkxFXG4gIH1cbn07XG5cbmNvbnN0IEZFQVRVUkVfTkZUX0JVUk5BQkxFID0ge1xuICBuYW1lOiBcIkVSQzcyMUJ1cm5hYmxlXCIsXG4gIG5hbWVzcGFjZTogXCJuZnQuYnVyblwiLFxuICBkb2NMaW5rczoge1xuICAgIHNkazogXCJzZGsuZXJjNzIxYnVybmFibGVcIixcbiAgICBjb250cmFjdHM6IFwiSUJ1cm5hYmxlRVJDNzIxXCJcbiAgfSxcbiAgYWJpczogW0VyYzcyMUFiaSwgSUJ1cm5hYmxlRVJDNzIxQWJpXSxcbiAgZmVhdHVyZXM6IHt9XG59O1xuY29uc3QgRkVBVFVSRV9ORlRfUkVWRUFMQUJMRSA9IHtcbiAgbmFtZTogXCJFUkM3MjFSZXZlYWxhYmxlXCIsXG4gIG5hbWVzcGFjZTogXCJuZnQuZHJvcC5yZXZlYWxlclwiLFxuICBkb2NMaW5rczoge1xuICAgIHNkazogXCJzZGsuZGVsYXllZHJldmVhbFwiLFxuICAgIGNvbnRyYWN0czogXCJEZWxheWVkUmV2ZWFsXCJcbiAgfSxcbiAgYWJpczogW0VyYzcyMUFiaSwgSUxhenlNaW50QWJpLCBEZWxheWVkUmV2ZWFsQWJpXSxcbiAgZmVhdHVyZXM6IHt9XG59O1xuY29uc3QgRkVBVFVSRV9ORlRfVElFUkVEX0RST1AgPSB7XG4gIG5hbWU6IFwiRVJDNzIxVGllcmVkRHJvcFwiLFxuICBuYW1lc3BhY2U6IFwibmZ0LnRpZXJlZERyb3BcIixcbiAgZG9jTGlua3M6IHtcbiAgICBzZGs6IFwic2RrLmVyYzcyMXRpZXJlZGRyb3BcIixcbiAgICBjb250cmFjdHM6IFwiVGllcmVkRHJvcFwiXG4gIH0sXG4gIGFiaXM6IFtFcmM3MjFBYmksIFRpZXJlZERyb3BBYmldLFxuICBmZWF0dXJlczoge31cbn07XG5jb25zdCBGRUFUVVJFX05GVF9DTEFJTV9DT05ESVRJT05TX1YxID0ge1xuICBuYW1lOiBcIkVSQzcyMUNsYWltQ29uZGl0aW9uc1YxXCIsXG4gIG5hbWVzcGFjZTogXCJuZnQuZHJvcC5jbGFpbVwiLFxuICBkb2NMaW5rczoge1xuICAgIHNkazogXCJzZGsuZXJjNzIxY2xhaW1hYmxlXCIsXG4gICAgY29udHJhY3RzOiBcIkRyb3BTaW5nbGVQaGFzZV9WMVwiXG4gIH0sXG4gIGFiaXM6IFtFcmM3MjFBYmksIElMYXp5TWludEFiaSwgSURyb3BTaW5nbGVQaGFzZVYxXSxcbiAgZmVhdHVyZXM6IHt9XG59O1xuY29uc3QgRkVBVFVSRV9ORlRfQ0xBSU1fQ09ORElUSU9OU19WMiA9IHtcbiAgbmFtZTogXCJFUkM3MjFDbGFpbUNvbmRpdGlvbnNWMlwiLFxuICBuYW1lc3BhY2U6IFwibmZ0LmRyb3AuY2xhaW1cIixcbiAgZG9jTGlua3M6IHtcbiAgICBzZGs6IFwic2RrLmVyYzcyMWNsYWltYWJsZVwiLFxuICAgIGNvbnRyYWN0czogXCJEcm9wU2luZ2xlUGhhc2VcIlxuICB9LFxuICBhYmlzOiBbRXJjNzIxQWJpLCBJTGF6eU1pbnRBYmksIElEcm9wU2luZ2xlUGhhc2VdLFxuICBmZWF0dXJlczoge31cbn07XG5jb25zdCBGRUFUVVJFX05GVF9DTEFJTV9QSEFTRVNfVjEgPSB7XG4gIG5hbWU6IFwiRVJDNzIxQ2xhaW1QaGFzZXNWMVwiLFxuICBuYW1lc3BhY2U6IFwibmZ0LmRyb3AuY2xhaW1cIixcbiAgZG9jTGlua3M6IHtcbiAgICBzZGs6IFwic2RrLmVyYzcyMWNsYWltYWJsZVwiLFxuICAgIGNvbnRyYWN0czogXCJEcm9wXCJcbiAgfSxcbiAgYWJpczogW0Ryb3BFUkM3MjFfVjNBYmldLFxuICBmZWF0dXJlczoge31cbn07XG5jb25zdCBGRUFUVVJFX05GVF9DTEFJTV9QSEFTRVNfVjIgPSB7XG4gIG5hbWU6IFwiRVJDNzIxQ2xhaW1QaGFzZXNWMlwiLFxuICBuYW1lc3BhY2U6IFwibmZ0LmRyb3AuY2xhaW1cIixcbiAgZG9jTGlua3M6IHtcbiAgICBzZGs6IFwic2RrLmVyYzcyMWNsYWltYWJsZVwiLFxuICAgIGNvbnRyYWN0czogXCJEcm9wXCJcbiAgfSxcbiAgYWJpczogW0VyYzcyMUFiaSwgSUxhenlNaW50QWJpLCBJRHJvcF0sXG4gIGZlYXR1cmVzOiB7fVxufTtcbmNvbnN0IEZFQVRVUkVfTkZUX0NMQUlNX0NVU1RPTSA9IHtcbiAgbmFtZTogXCJFUkM3MjFDbGFpbUN1c3RvbVwiLFxuICBuYW1lc3BhY2U6IFwibmZ0LmRyb3AuY2xhaW1cIixcbiAgZG9jTGlua3M6IHtcbiAgICBzZGs6IFwic2RrLmVyYzcyMWNsYWltYWJsZVwiLFxuICAgIGNvbnRyYWN0czogXCJJQ2xhaW1hYmxlRVJDNzIxXCJcbiAgfSxcbiAgYWJpczogW0VyYzcyMUFiaSwgSUxhenlNaW50QWJpLCBJQ2xhaW1hYmxlRVJDNzIxXSxcbiAgZmVhdHVyZXM6IHt9XG59O1xuY29uc3QgRkVBVFVSRV9ORlRfTEFaWV9NSU5UQUJMRSA9IHtcbiAgbmFtZTogXCJFUkM3MjFMYXp5TWludGFibGVcIixcbiAgbmFtZXNwYWNlOiBcIm5mdC5kcm9wXCIsXG4gIGRvY0xpbmtzOiB7XG4gICAgc2RrOiBcInNkay5lcmM3MjFsYXp5bWludGFibGVcIixcbiAgICBjb250cmFjdHM6IFwiTGF6eU1pbnRcIlxuICB9LFxuICBhYmlzOiBbRXJjNzIxQWJpLCBJTGF6eU1pbnRBYmldLFxuICBmZWF0dXJlczoge1xuICAgIFtGRUFUVVJFX05GVF9SRVZFQUxBQkxFLm5hbWVdOiBGRUFUVVJFX05GVF9SRVZFQUxBQkxFLFxuICAgIFtGRUFUVVJFX05GVF9DTEFJTV9DVVNUT00ubmFtZV06IEZFQVRVUkVfTkZUX0NMQUlNX0NVU1RPTSxcbiAgICBbRkVBVFVSRV9ORlRfQ0xBSU1fQ09ORElUSU9OU19WMS5uYW1lXTogRkVBVFVSRV9ORlRfQ0xBSU1fQ09ORElUSU9OU19WMSxcbiAgICBbRkVBVFVSRV9ORlRfQ0xBSU1fQ09ORElUSU9OU19WMi5uYW1lXTogRkVBVFVSRV9ORlRfQ0xBSU1fQ09ORElUSU9OU19WMixcbiAgICBbRkVBVFVSRV9ORlRfQ0xBSU1fUEhBU0VTX1YxLm5hbWVdOiBGRUFUVVJFX05GVF9DTEFJTV9QSEFTRVNfVjEsXG4gICAgW0ZFQVRVUkVfTkZUX0NMQUlNX1BIQVNFU19WMi5uYW1lXTogRkVBVFVSRV9ORlRfQ0xBSU1fUEhBU0VTX1YyXG4gIH1cbn07XG5jb25zdCBGRUFUVVJFX05GVF9CQVRDSF9NSU5UQUJMRSA9IHtcbiAgbmFtZTogXCJFUkM3MjFCYXRjaE1pbnRhYmxlXCIsXG4gIG5hbWVzcGFjZTogXCJuZnQubWludC5iYXRjaFwiLFxuICBkb2NMaW5rczoge1xuICAgIHNkazogXCJzZGsuZXJjNzIxYmF0Y2htaW50YWJsZVwiLFxuICAgIGNvbnRyYWN0czogXCJJTXVsdGljYWxsXCJcbiAgfSxcbiAgYWJpczogW0VyYzcyMUFiaSwgSU1pbnRhYmxlRVJDNzIxQWJpLCBNdWx0aWNhbGxBYmldLFxuICBmZWF0dXJlczoge31cbn07XG5jb25zdCBGRUFUVVJFX05GVF9NSU5UQUJMRSA9IHtcbiAgbmFtZTogXCJFUkM3MjFNaW50YWJsZVwiLFxuICBuYW1lc3BhY2U6IFwibmZ0Lm1pbnRcIixcbiAgZG9jTGlua3M6IHtcbiAgICBzZGs6IFwic2RrLmVyYzcyMW1pbnRhYmxlXCIsXG4gICAgY29udHJhY3RzOiBcIklNaW50YWJsZUVSQzcyMVwiXG4gIH0sXG4gIGFiaXM6IFtFcmM3MjFBYmksIElNaW50YWJsZUVSQzcyMUFiaV0sXG4gIGZlYXR1cmVzOiB7XG4gICAgW0ZFQVRVUkVfTkZUX0JBVENIX01JTlRBQkxFLm5hbWVdOiBGRUFUVVJFX05GVF9CQVRDSF9NSU5UQUJMRVxuICB9XG59O1xuY29uc3QgRkVBVFVSRV9ORlRfU0lHTkFUVVJFX01JTlRBQkxFX1YyID0ge1xuICBuYW1lOiBcIkVSQzcyMVNpZ25hdHVyZU1pbnRWMlwiLFxuICBuYW1lc3BhY2U6IFwibmZ0LnNpZ25hdHVyZVwiLFxuICBkb2NMaW5rczoge1xuICAgIHNkazogXCJzZGsuZXJjNzIxc2lnbmF0dXJlbWludFwiLFxuICAgIGNvbnRyYWN0czogXCJJU2lnbmF0dXJlTWludEVSQzcyMVwiXG4gIH0sXG4gIGFiaXM6IFtFcmM3MjFBYmksIFNpZ25hdHVyZU1pbnRFUkM3MjFBYmldLFxuICBmZWF0dXJlczoge31cbn07XG5jb25zdCBGRUFUVVJFX05GVF9TSUdOQVRVUkVfTUlOVEFCTEVfVjEgPSB7XG4gIG5hbWU6IFwiRVJDNzIxU2lnbmF0dXJlTWludFYxXCIsXG4gIG5hbWVzcGFjZTogXCJuZnQuc2lnbmF0dXJlXCIsXG4gIGRvY0xpbmtzOiB7XG4gICAgc2RrOiBcInNkay5lcmM3MjFzaWduYXR1cmVtaW50XCIsXG4gICAgY29udHJhY3RzOiBcIklTaWduYXR1cmVNaW50RVJDNzIxXCJcbiAgfSxcbiAgYWJpczogW1NpZ25hdHVyZU1pbnRFUkM3MjFfVjFBYmldLFxuICBmZWF0dXJlczoge31cbn07XG5jb25zdCBGRUFUVVJFX05GVF9FTlVNRVJBQkxFID0ge1xuICBuYW1lOiBcIkVSQzcyMUVudW1lcmFibGVcIixcbiAgbmFtZXNwYWNlOiBcIm5mdC5xdWVyeS5vd25lZFwiLFxuICBkb2NMaW5rczoge1xuICAgIHNkazogXCJzZGsuZXJjNzIxZW51bWVyYWJsZVwiLFxuICAgIGNvbnRyYWN0czogXCJJRVJDNzIxRW51bWVyYWJsZVwiXG4gIH0sXG4gIGFiaXM6IFtFcmM3MjFBYmksIEVyYzcyMUVudW1lcmFibGVBYmldLFxuICBmZWF0dXJlczoge31cbn07XG5jb25zdCBGRUFUVVJFX05GVF9TVVBQTFkgPSB7XG4gIG5hbWU6IFwiRVJDNzIxU3VwcGx5XCIsXG4gIG5hbWVzcGFjZTogXCJuZnQucXVlcnlcIixcbiAgZG9jTGlua3M6IHtcbiAgICBzZGs6IFwic2RrLmVyYzcyMXN1cHBseVwiLFxuICAgIGNvbnRyYWN0czogXCJJRVJDNzIxU3VwcGx5XCJcbiAgfSxcbiAgYWJpczogW0VyYzcyMUFiaSwgRXJjNzIxU3VwcGx5QWJpXSxcbiAgZmVhdHVyZXM6IHtcbiAgICBbRkVBVFVSRV9ORlRfRU5VTUVSQUJMRS5uYW1lXTogRkVBVFVSRV9ORlRfRU5VTUVSQUJMRVxuICB9XG59O1xuY29uc3QgRkVBVFVSRV9ORlQgPSB7XG4gIG5hbWU6IFwiRVJDNzIxXCIsXG4gIG5hbWVzcGFjZTogXCJuZnRcIixcbiAgZG9jTGlua3M6IHtcbiAgICBzZGs6IFwic2RrLmVyYzcyMVwiLFxuICAgIGNvbnRyYWN0czogXCJJRVJDNzIxXCJcbiAgfSxcbiAgYWJpczogW0VyYzcyMUFiaV0sXG4gIGZlYXR1cmVzOiB7XG4gICAgW0ZFQVRVUkVfTkZUX0JVUk5BQkxFLm5hbWVdOiBGRUFUVVJFX05GVF9CVVJOQUJMRSxcbiAgICBbRkVBVFVSRV9ORlRfU1VQUExZLm5hbWVdOiBGRUFUVVJFX05GVF9TVVBQTFksXG4gICAgW0ZFQVRVUkVfTkZUX01JTlRBQkxFLm5hbWVdOiBGRUFUVVJFX05GVF9NSU5UQUJMRSxcbiAgICBbRkVBVFVSRV9ORlRfTEFaWV9NSU5UQUJMRS5uYW1lXTogRkVBVFVSRV9ORlRfTEFaWV9NSU5UQUJMRSxcbiAgICBbRkVBVFVSRV9ORlRfU0lHTkFUVVJFX01JTlRBQkxFX1YxLm5hbWVdOiBGRUFUVVJFX05GVF9TSUdOQVRVUkVfTUlOVEFCTEVfVjEsXG4gICAgW0ZFQVRVUkVfTkZUX1NJR05BVFVSRV9NSU5UQUJMRV9WMi5uYW1lXTogRkVBVFVSRV9ORlRfU0lHTkFUVVJFX01JTlRBQkxFX1YyLFxuICAgIFtGRUFUVVJFX05GVF9USUVSRURfRFJPUC5uYW1lXTogRkVBVFVSRV9ORlRfVElFUkVEX0RST1BcbiAgfVxufTtcblxuY29uc3QgRkVBVFVSRV9FRElUSU9OX0JVUk5BQkxFID0ge1xuICBuYW1lOiBcIkVSQzExNTVCdXJuYWJsZVwiLFxuICBuYW1lc3BhY2U6IFwiZWRpdGlvbi5idXJuXCIsXG4gIGRvY0xpbmtzOiB7XG4gICAgc2RrOiBcInNkay5lcmMxMTU1YnVybmFibGVcIixcbiAgICBjb250cmFjdHM6IFwiSUJ1cm5hYmxlRVJDMTE1NVwiXG4gIH0sXG4gIGFiaXM6IFtFcmMxMTU1QWJpLCBJQnVybmFibGVFUkMxMTU1QWJpXSxcbiAgZmVhdHVyZXM6IHt9XG59O1xuY29uc3QgRkVBVFVSRV9FRElUSU9OX0NMQUlNX0NPTkRJVElPTlNfVjEgPSB7XG4gIG5hbWU6IFwiRVJDMTE1NUNsYWltQ29uZGl0aW9uc1YxXCIsXG4gIG5hbWVzcGFjZTogXCJlZGl0aW9uLmRyb3AuY2xhaW1cIixcbiAgZG9jTGlua3M6IHtcbiAgICBzZGs6IFwic2RrLmVyYzExNTVjbGFpbWFibGVcIixcbiAgICBjb250cmFjdHM6IFwiRHJvcFNpbmdsZVBoYXNlMTE1NVwiXG4gIH0sXG4gIGFiaXM6IFtFcmMxMTU1QWJpLCBJTGF6eU1pbnRBYmksIElEcm9wU2luZ2xlUGhhc2UxMTU1X1YxXSxcbiAgZmVhdHVyZXM6IHt9XG59O1xuY29uc3QgRkVBVFVSRV9FRElUSU9OX0NMQUlNX0NPTkRJVElPTlNfVjIgPSB7XG4gIG5hbWU6IFwiRVJDMTE1NUNsYWltQ29uZGl0aW9uc1YyXCIsXG4gIG5hbWVzcGFjZTogXCJlZGl0aW9uLmRyb3AuY2xhaW1cIixcbiAgZG9jTGlua3M6IHtcbiAgICBzZGs6IFwic2RrLmVyYzExNTVjbGFpbWFibGVcIixcbiAgICBjb250cmFjdHM6IFwiRHJvcFNpbmdsZVBoYXNlMTE1NVwiXG4gIH0sXG4gIGFiaXM6IFtFcmMxMTU1QWJpLCBJTGF6eU1pbnRBYmksIElEcm9wU2luZ2xlUGhhc2UxMTU1XSxcbiAgZmVhdHVyZXM6IHt9XG59O1xuY29uc3QgRkVBVFVSRV9FRElUSU9OX0NMQUlNX1BIQVNFU19WMiA9IHtcbiAgbmFtZTogXCJFUkMxMTU1Q2xhaW1QaGFzZXNWMlwiLFxuICBuYW1lc3BhY2U6IFwiZWRpdGlvbi5kcm9wLmNsYWltXCIsXG4gIGRvY0xpbmtzOiB7XG4gICAgc2RrOiBcInNkay5lcmMxMTU1Y2xhaW1hYmxlXCIsXG4gICAgY29udHJhY3RzOiBcIkRyb3AxMTU1XCJcbiAgfSxcbiAgYWJpczogW0VyYzExNTVBYmksIElMYXp5TWludEFiaSwgSURyb3BNdWx0aVBoYXNlMTE1NV0sXG4gIGZlYXR1cmVzOiB7fVxufTtcbmNvbnN0IEZFQVRVUkVfRURJVElPTl9DTEFJTV9QSEFTRVNfVjEgPSB7XG4gIG5hbWU6IFwiRVJDMTE1NUNsYWltUGhhc2VzVjFcIixcbiAgbmFtZXNwYWNlOiBcImVkaXRpb24uZHJvcC5jbGFpbVwiLFxuICBkb2NMaW5rczoge1xuICAgIHNkazogXCJzZGsuZXJjMTE1NWNsYWltYWJsZVwiLFxuICAgIGNvbnRyYWN0czogXCJEcm9wMTE1NVwiXG4gIH0sXG4gIGFiaXM6IFtEcm9wRVJDMTE1NV9WMkFiaV0sXG4gIGZlYXR1cmVzOiB7fVxufTtcbmNvbnN0IEZFQVRVUkVfRURJVElPTl9DTEFJTV9DVVNUT00gPSB7XG4gIG5hbWU6IFwiRVJDMTE1NUNsYWltQ3VzdG9tXCIsXG4gIG5hbWVzcGFjZTogXCJlZGl0aW9uLmRyb3AuY2xhaW1cIixcbiAgZG9jTGlua3M6IHtcbiAgICBzZGs6IFwic2RrLmVyYzExNTVjbGFpbWFibGVcIixcbiAgICBjb250cmFjdHM6IFwiSUNsYWltYWJsZUVSQzExNTVcIlxuICB9LFxuICBhYmlzOiBbRXJjMTE1NUFiaSwgSUxhenlNaW50QWJpLCBJQ2xhaW1hYmxlRVJDMTE1NV0sXG4gIGZlYXR1cmVzOiB7fVxufTtcbmNvbnN0IEZFQVRVUkVfRURJVElPTl9SRVZFQUxBQkxFID0ge1xuICBuYW1lOiBcIkVSQzExNTVSZXZlYWxhYmxlXCIsXG4gIG5hbWVzcGFjZTogXCJlZGl0aW9uLmRyb3AucmV2ZWFsZXJcIixcbiAgZG9jTGlua3M6IHtcbiAgICBzZGs6IFwic2RrLmRyb3AuZGVsYXllZHJldmVhbFwiLFxuICAgIGNvbnRyYWN0czogXCJEZWxheWVkUmV2ZWFsXCJcbiAgfSxcbiAgYWJpczogW0VyYzExNTVBYmksIElMYXp5TWludEFiaSwgRGVsYXllZFJldmVhbEFiaV0sXG4gIGZlYXR1cmVzOiB7fVxufTtcbmNvbnN0IEZFQVRVUkVfRURJVElPTl9MQVpZX01JTlRBQkxFX1YyID0ge1xuICBuYW1lOiBcIkVSQzExNTVMYXp5TWludGFibGVWMlwiLFxuICBuYW1lc3BhY2U6IFwiZWRpdGlvbi5kcm9wXCIsXG4gIGRvY0xpbmtzOiB7XG4gICAgc2RrOiBcInNkay5lcmMxMTU1ZHJvcHBhYmxlXCIsXG4gICAgY29udHJhY3RzOiBcIkxhenlNaW50XCJcbiAgfSxcbiAgYWJpczogW0VyYzExNTVBYmksIElMYXp5TWludEFiaV0sXG4gIGZlYXR1cmVzOiB7XG4gICAgW0ZFQVRVUkVfRURJVElPTl9SRVZFQUxBQkxFLm5hbWVdOiBGRUFUVVJFX0VESVRJT05fUkVWRUFMQUJMRSxcbiAgICBbRkVBVFVSRV9FRElUSU9OX0NMQUlNX0NVU1RPTS5uYW1lXTogRkVBVFVSRV9FRElUSU9OX0NMQUlNX0NVU1RPTSxcbiAgICBbRkVBVFVSRV9FRElUSU9OX0NMQUlNX0NPTkRJVElPTlNfVjEubmFtZV06IEZFQVRVUkVfRURJVElPTl9DTEFJTV9DT05ESVRJT05TX1YxLFxuICAgIFtGRUFUVVJFX0VESVRJT05fQ0xBSU1fQ09ORElUSU9OU19WMi5uYW1lXTogRkVBVFVSRV9FRElUSU9OX0NMQUlNX0NPTkRJVElPTlNfVjIsXG4gICAgW0ZFQVRVUkVfRURJVElPTl9DTEFJTV9QSEFTRVNfVjIubmFtZV06IEZFQVRVUkVfRURJVElPTl9DTEFJTV9QSEFTRVNfVjJcbiAgfVxufTtcbmNvbnN0IEZFQVRVUkVfRURJVElPTl9MQVpZX01JTlRBQkxFX1YxID0ge1xuICBuYW1lOiBcIkVSQzExNTVMYXp5TWludGFibGVWMVwiLFxuICBuYW1lc3BhY2U6IFwiZWRpdGlvbi5kcm9wXCIsXG4gIGRvY0xpbmtzOiB7XG4gICAgc2RrOiBcInNkay5lcmMxMTU1ZHJvcHBhYmxlXCIsXG4gICAgY29udHJhY3RzOiBcIkxhenlNaW50XCJcbiAgfSxcbiAgYWJpczogW0Ryb3BFUkMxMTU1X1YyQWJpXSxcbiAgZmVhdHVyZXM6IHtcbiAgICBbRkVBVFVSRV9FRElUSU9OX0NMQUlNX1BIQVNFU19WMS5uYW1lXTogRkVBVFVSRV9FRElUSU9OX0NMQUlNX1BIQVNFU19WMVxuICB9XG59O1xuY29uc3QgRkVBVFVSRV9FRElUSU9OX1NJR05BVFVSRV9NSU5UQUJMRSA9IHtcbiAgbmFtZTogXCJFUkMxMTU1U2lnbmF0dXJlTWludGFibGVcIixcbiAgbmFtZXNwYWNlOiBcImVkaXRpb24uc2lnbmF0dXJlXCIsXG4gIGRvY0xpbmtzOiB7XG4gICAgc2RrOiBcInNkay5lcmMxMTU1c2lnbmF0dXJlbWludGFibGVcIixcbiAgICBjb250cmFjdHM6IFwiSVNpZ25hdHVyZU1pbnRFUkMxMTU1XCJcbiAgfSxcbiAgYWJpczogW0VyYzExNTVBYmksIElTaWduYXR1cmVNaW50RVJDMTE1NUFiaV0sXG4gIGZlYXR1cmVzOiB7fVxufTtcbmNvbnN0IEZFQVRVUkVfRURJVElPTl9CQVRDSF9NSU5UQUJMRSA9IHtcbiAgbmFtZTogXCJFUkMxMTU1QmF0Y2hNaW50YWJsZVwiLFxuICBuYW1lc3BhY2U6IFwiZWRpdGlvbi5taW50LmJhdGNoXCIsXG4gIGRvY0xpbmtzOiB7XG4gICAgc2RrOiBcInNkay5lcmMxMTU1YmF0Y2htaW50YWJsZVwiLFxuICAgIGNvbnRyYWN0czogXCJJTXVsdGljYWxsXCJcbiAgfSxcbiAgYWJpczogW0VyYzExNTVBYmksIElNaW50YWJsZUVSQzExNTVBYmksIE11bHRpY2FsbEFiaV0sXG4gIGZlYXR1cmVzOiB7fVxufTtcbmNvbnN0IEZFQVRVUkVfRURJVElPTl9NSU5UQUJMRSA9IHtcbiAgbmFtZTogXCJFUkMxMTU1TWludGFibGVcIixcbiAgbmFtZXNwYWNlOiBcImVkaXRpb24ubWludFwiLFxuICBkb2NMaW5rczoge1xuICAgIHNkazogXCJzZGsuZXJjMTE1NW1pbnRhYmxlXCIsXG4gICAgY29udHJhY3RzOiBcIklNaW50YWJsZUVSQzExNTVcIlxuICB9LFxuICBhYmlzOiBbRXJjMTE1NUFiaSwgSU1pbnRhYmxlRVJDMTE1NUFiaV0sXG4gIGZlYXR1cmVzOiB7XG4gICAgW0ZFQVRVUkVfRURJVElPTl9CQVRDSF9NSU5UQUJMRS5uYW1lXTogRkVBVFVSRV9FRElUSU9OX0JBVENIX01JTlRBQkxFXG4gIH1cbn07XG5jb25zdCBGRUFUVVJFX0VESVRJT05fRU5VTUVSQUJMRSA9IHtcbiAgbmFtZTogXCJFUkMxMTU1RW51bWVyYWJsZVwiLFxuICBuYW1lc3BhY2U6IFwiZWRpdGlvbi5xdWVyeVwiLFxuICBkb2NMaW5rczoge1xuICAgIHNkazogXCJzZGsuZXJjMTE1NVwiLFxuICAgIGNvbnRyYWN0czogXCJJRVJDMTE1NVwiXG4gIH0sXG4gIGFiaXM6IFtFcmMxMTU1QWJpLCBFcmMxMTU1RW51bWVyYWJsZUFiaV0sXG4gIGZlYXR1cmVzOiB7fVxufTtcbmNvbnN0IEZFQVRVUkVfRURJVElPTiA9IHtcbiAgbmFtZTogXCJFUkMxMTU1XCIsXG4gIG5hbWVzcGFjZTogXCJlZGl0aW9uXCIsXG4gIGRvY0xpbmtzOiB7XG4gICAgc2RrOiBcInNkay5lcmMxMTU1ZW51bWVyYWJsZVwiLFxuICAgIGNvbnRyYWN0czogXCJJRVJDMTE1NUVudW1lcmFibGVcIlxuICB9LFxuICBhYmlzOiBbRXJjMTE1NUFiaV0sXG4gIGZlYXR1cmVzOiB7XG4gICAgW0ZFQVRVUkVfRURJVElPTl9CVVJOQUJMRS5uYW1lXTogRkVBVFVSRV9FRElUSU9OX0JVUk5BQkxFLFxuICAgIFtGRUFUVVJFX0VESVRJT05fRU5VTUVSQUJMRS5uYW1lXTogRkVBVFVSRV9FRElUSU9OX0VOVU1FUkFCTEUsXG4gICAgW0ZFQVRVUkVfRURJVElPTl9NSU5UQUJMRS5uYW1lXTogRkVBVFVSRV9FRElUSU9OX01JTlRBQkxFLFxuICAgIFtGRUFUVVJFX0VESVRJT05fTEFaWV9NSU5UQUJMRV9WMS5uYW1lXTogRkVBVFVSRV9FRElUSU9OX0xBWllfTUlOVEFCTEVfVjEsXG4gICAgW0ZFQVRVUkVfRURJVElPTl9MQVpZX01JTlRBQkxFX1YyLm5hbWVdOiBGRUFUVVJFX0VESVRJT05fTEFaWV9NSU5UQUJMRV9WMixcbiAgICBbRkVBVFVSRV9FRElUSU9OX1JFVkVBTEFCTEUubmFtZV06IEZFQVRVUkVfRURJVElPTl9SRVZFQUxBQkxFLFxuICAgIFtGRUFUVVJFX0VESVRJT05fU0lHTkFUVVJFX01JTlRBQkxFLm5hbWVdOiBGRUFUVVJFX0VESVRJT05fU0lHTkFUVVJFX01JTlRBQkxFXG4gIH1cbn07XG5cbmNvbnN0IEZFQVRVUkVfUk9ZQUxUWSA9IHtcbiAgbmFtZTogXCJSb3lhbHR5XCIsXG4gIG5hbWVzcGFjZTogXCJyb3lhbHR5XCIsXG4gIGRvY0xpbmtzOiB7XG4gICAgc2RrOiBcInNkay5jb250cmFjdHJveWFsdHlcIixcbiAgICBjb250cmFjdHM6IFwiUm95YWx0eVwiXG4gIH0sXG4gIGFiaXM6IFtJVGhpcmR3ZWJSb3lhbHR5QWJpXSxcbiAgZmVhdHVyZXM6IHt9XG59O1xuY29uc3QgRkVBVFVSRV9QUklNQVJZX1NBTEUgPSB7XG4gIG5hbWU6IFwiUHJpbWFyeVNhbGVcIixcbiAgbmFtZXNwYWNlOiBcInNhbGVzXCIsXG4gIGRvY0xpbmtzOiB7XG4gICAgc2RrOiBcInNkay5jb250cmFjdHByaW1hcnlzYWxlXCIsXG4gICAgY29udHJhY3RzOiBcIlByaW1hcnlTYWxlXCJcbiAgfSxcbiAgYWJpczogW0lUaGlyZHdlYlByaW1hcnlTYWxlQWJpXSxcbiAgZmVhdHVyZXM6IHt9XG59O1xuY29uc3QgRkVBVFVSRV9QTEFURk9STV9GRUUgPSB7XG4gIG5hbWU6IFwiUGxhdGZvcm1GZWVcIixcbiAgbmFtZXNwYWNlOiBcInBsYXRmb3JtRmVlXCIsXG4gIGRvY0xpbmtzOiB7XG4gICAgc2RrOiBcInNkay5wbGF0Zm9ybWZlZVwiLFxuICAgIGNvbnRyYWN0czogXCJQbGF0Zm9ybUZlZVwiXG4gIH0sXG4gIGFiaXM6IFtJVGhpcmR3ZWJQbGF0Zm9ybUZlZUFiaV0sXG4gIGZlYXR1cmVzOiB7fVxufTtcbmNvbnN0IEZFQVRVUkVfUEVSTUlTU0lPTlNfRU5VTUVSQUJMRSA9IHtcbiAgbmFtZTogXCJQZXJtaXNzaW9uc0VudW1lcmFibGVcIixcbiAgbmFtZXNwYWNlOiBcInJvbGVzXCIsXG4gIGRvY0xpbmtzOiB7XG4gICAgc2RrOiBcInNkay5jb250cmFjdHJvbGVzXCIsXG4gICAgY29udHJhY3RzOiBcIlBlcm1pc3Npb25zRW51bWVyYWJsZVwiXG4gIH0sXG4gIGFiaXM6IFtJUGVybWlzc2lvbnNFbnVtZXJhYmxlQWJpXSxcbiAgZmVhdHVyZXM6IHt9XG59O1xuY29uc3QgRkVBVFVSRV9QRVJNSVNTSU9OUyA9IHtcbiAgbmFtZTogXCJQZXJtaXNzaW9uc1wiLFxuICBuYW1lc3BhY2U6IFwicm9sZXNcIixcbiAgZG9jTGlua3M6IHtcbiAgICBzZGs6IFwic2RrLmNvbnRyYWN0cm9sZXNcIixcbiAgICBjb250cmFjdHM6IFwiUGVybWlzc2lvbnNcIlxuICB9LFxuICBhYmlzOiBbSVBlcm1pc3Npb25zQWJpXSxcbiAgZmVhdHVyZXM6IHtcbiAgICBbRkVBVFVSRV9QRVJNSVNTSU9OU19FTlVNRVJBQkxFLm5hbWVdOiBGRUFUVVJFX1BFUk1JU1NJT05TX0VOVU1FUkFCTEVcbiAgfVxufTtcbmNvbnN0IEZFQVRVUkVfTUVUQURBVEEgPSB7XG4gIG5hbWU6IFwiQ29udHJhY3RNZXRhZGF0YVwiLFxuICBuYW1lc3BhY2U6IFwibWV0YWRhdGFcIixcbiAgZG9jTGlua3M6IHtcbiAgICBzZGs6IFwic2RrLmNvbnRyYWN0bWV0YWRhdGFcIixcbiAgICBjb250cmFjdHM6IFwiQ29udHJhY3RNZXRhZGF0YVwiXG4gIH0sXG4gIGFiaXM6IFtJQ29udHJhY3RNZXRhZGF0YUFiaV0sXG4gIGZlYXR1cmVzOiB7fVxufTtcbmNvbnN0IEZFQVRVUkVfQVBQVVJJID0ge1xuICBuYW1lOiBcIkFwcFVSSVwiLFxuICBuYW1lc3BhY2U6IFwiYXBwVVJJXCIsXG4gIGRvY0xpbmtzOiB7XG4gICAgc2RrOiBcInNkay5hcHBVUklcIixcbiAgICBjb250cmFjdHM6IFwiQXBwVVJJXCJcbiAgfSxcbiAgYWJpczogW0lBcHBVUkldLFxuICBmZWF0dXJlczoge31cbn07XG5jb25zdCBGRUFUVVJFX09XTkVSID0ge1xuICBuYW1lOiBcIk93bmFibGVcIixcbiAgbmFtZXNwYWNlOiBcIm93bmVyXCIsXG4gIGRvY0xpbmtzOiB7XG4gICAgc2RrOiBcInNkay5vd25lclwiLFxuICAgIGNvbnRyYWN0czogXCJPd25hYmxlXCJcbiAgfSxcbiAgYWJpczogW0lPd25hYmxlQWJpXSxcbiAgZmVhdHVyZXM6IHt9XG59O1xuY29uc3QgRkVBVFVSRV9HQVNMRVNTID0ge1xuICBuYW1lOiBcIkdhc2xlc3NcIixcbiAgbmFtZXNwYWNlOiBcImdhc2xlc3NcIixcbiAgZG9jTGlua3M6IHtcbiAgICBzZGs6IFwic2RrLmdhc2xlc3N0cmFuc2FjdGlvblwiLFxuICAgIC8vIFRPRE8gYWRkIHRoZSBjb3JyZWN0IG5hbWUgZm9yIHRoaXMgb25jZSBpdCdzIGFkZGVkIHRvIHBvcnRhbFxuICAgIGNvbnRyYWN0czogXCJcIlxuICB9LFxuICBhYmlzOiBbSUVSQzI3NzFDb250ZXh0QWJpXSxcbiAgZmVhdHVyZXM6IHt9XG59O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNVUFBPUlRFRF9GRUFUVVJFUyA9IHtcbiAgW0ZFQVRVUkVfVE9LRU4ubmFtZV06IEZFQVRVUkVfVE9LRU4sXG4gIFtGRUFUVVJFX05GVC5uYW1lXTogRkVBVFVSRV9ORlQsXG4gIFtGRUFUVVJFX0VESVRJT04ubmFtZV06IEZFQVRVUkVfRURJVElPTixcbiAgW0ZFQVRVUkVfUk9ZQUxUWS5uYW1lXTogRkVBVFVSRV9ST1lBTFRZLFxuICBbRkVBVFVSRV9QTEFURk9STV9GRUUubmFtZV06IEZFQVRVUkVfUExBVEZPUk1fRkVFLFxuICBbRkVBVFVSRV9QUklNQVJZX1NBTEUubmFtZV06IEZFQVRVUkVfUFJJTUFSWV9TQUxFLFxuICBbRkVBVFVSRV9QRVJNSVNTSU9OUy5uYW1lXTogRkVBVFVSRV9QRVJNSVNTSU9OUyxcbiAgW0ZFQVRVUkVfTUVUQURBVEEubmFtZV06IEZFQVRVUkVfTUVUQURBVEEsXG4gIFtGRUFUVVJFX0FQUFVSSS5uYW1lXTogRkVBVFVSRV9BUFBVUkksXG4gIFtGRUFUVVJFX09XTkVSLm5hbWVdOiBGRUFUVVJFX09XTkVSLFxuICBbRkVBVFVSRV9HQVNMRVNTLm5hbWVdOiBGRUFUVVJFX0dBU0xFU1Ncbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xubGV0IGRlY29kZXI7XG50cnkge1xuICBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG59IGNhdGNoIChlcnJvcikge31cbmxldCBzcmM7XG5sZXQgc3JjRW5kO1xubGV0IHBvc2l0aW9uID0gMDtcbmNvbnN0IExFR0FDWV9SRUNPUkRfSU5MSU5FX0lEID0gMTA1O1xuY29uc3QgUkVDT1JEX0RFRklOSVRJT05TX0lEID0gMHhkZmZlO1xuY29uc3QgUkVDT1JEX0lOTElORV9JRCA9IDB4ZGZmZjsgLy8gdGVtcG9yYXJ5IGZpcnN0LWNvbWUgZmlyc3Qtc2VydmUgdGFnIC8vIHByb3Bvc2VkIHRhZzogMHg3MjY1IC8vICdyZSdcbmNvbnN0IEJVTkRMRURfU1RSSU5HU19JRCA9IDB4ZGZmOTtcbmNvbnN0IFBBQ0tFRF9SRUZFUkVOQ0VfVEFHX0lEID0gNjtcbmNvbnN0IFNUT1BfQ09ERSA9IHt9O1xubGV0IGN1cnJlbnREZWNvZGVyID0ge307XG5sZXQgY3VycmVudFN0cnVjdHVyZXM7XG5sZXQgc3JjU3RyaW5nO1xubGV0IHNyY1N0cmluZ1N0YXJ0ID0gMDtcbmxldCBzcmNTdHJpbmdFbmQgPSAwO1xubGV0IGJ1bmRsZWRTdHJpbmdzO1xubGV0IHJlZmVyZW5jZU1hcDtcbmxldCBjdXJyZW50RXh0ZW5zaW9ucyA9IFtdO1xubGV0IGN1cnJlbnRFeHRlbnNpb25SYW5nZXMgPSBbXTtcbmxldCBwYWNrZWRWYWx1ZXM7XG5sZXQgZGF0YVZpZXc7XG5sZXQgcmVzdG9yZU1hcHNBc09iamVjdDtcbmxldCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgdXNlUmVjb3JkczogZmFsc2UsXG4gIG1hcHNBc09iamVjdHM6IHRydWVcbn07XG5sZXQgc2VxdWVudGlhbE1vZGUgPSBmYWxzZTtcbmNsYXNzIERlY29kZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGlmICgob3B0aW9ucy5rZXlNYXAgfHwgb3B0aW9ucy5fa2V5TWFwKSAmJiAhb3B0aW9ucy51c2VSZWNvcmRzKSB7XG4gICAgICAgIG9wdGlvbnMudXNlUmVjb3JkcyA9IGZhbHNlO1xuICAgICAgICBvcHRpb25zLm1hcHNBc09iamVjdHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudXNlUmVjb3JkcyA9PT0gZmFsc2UgJiYgb3B0aW9ucy5tYXBzQXNPYmplY3RzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5tYXBzQXNPYmplY3RzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmdldFN0cnVjdHVyZXMpIHtcbiAgICAgICAgb3B0aW9ucy5nZXRTaGFyZWQgPSBvcHRpb25zLmdldFN0cnVjdHVyZXM7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5nZXRTaGFyZWQgJiYgIW9wdGlvbnMuc3RydWN0dXJlcykge1xuICAgICAgICAob3B0aW9ucy5zdHJ1Y3R1cmVzID0gW10pLnVuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgfSAvLyB0aGlzIGlzIHdoYXQgd2UgdXNlIHRvIGRlbm90ZSBhbiB1bmluaXRpYWxpemVkIHN0cnVjdHVyZXNcbiAgICAgIGlmIChvcHRpb25zLmtleU1hcCkge1xuICAgICAgICB0aGlzLm1hcEtleSA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMua2V5TWFwKSkge1xuICAgICAgICAgIHRoaXMubWFwS2V5LnNldCh2LCBrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIGRlY29kZUtleShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5rZXlNYXAgPyB0aGlzLm1hcEtleS5nZXQoa2V5KSB8fCBrZXkgOiBrZXk7XG4gIH1cbiAgZGVjb2RlKHNvdXJjZSwgZW5kKSB7XG4gICAgaWYgKHNyYykge1xuICAgICAgLy8gcmUtZW50cmFudCBleGVjdXRpb24sIHNhdmUgdGhlIHN0YXRlIGFuZCByZXN0b3JlIGl0IGFmdGVyIHdlIGRvIHRoaXMgZGVjb2RlXG4gICAgICByZXR1cm4gc2F2ZVN0YXRlKCgpID0+IHtcbiAgICAgICAgY2xlYXJTb3VyY2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMgPyB0aGlzLmRlY29kZShzb3VyY2UsIGVuZCkgOiBEZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUuY2FsbChkZWZhdWx0T3B0aW9ucywgc291cmNlLCBlbmQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHNyY0VuZCA9IGVuZCA+IC0xID8gZW5kIDogc291cmNlLmxlbmd0aDtcbiAgICBwb3NpdGlvbiA9IDA7XG4gICAgc3JjU3RyaW5nRW5kID0gMDtcbiAgICBzcmNTdHJpbmcgPSBudWxsO1xuICAgIGJ1bmRsZWRTdHJpbmdzID0gbnVsbDtcbiAgICBzcmMgPSBzb3VyY2U7XG4gICAgLy8gdGhpcyBwcm92aWRlcyBjYWNoZWQgYWNjZXNzIHRvIHRoZSBkYXRhIHZpZXcgZm9yIGEgYnVmZmVyIGlmIGl0IGlzIGdldHRpbmcgcmV1c2VkLCB3aGljaCBpcyBhIHJlY29tbWVuZFxuICAgIC8vIHRlY2huaXF1ZSBmb3IgZ2V0dGluZyBkYXRhIGZyb20gYSBkYXRhYmFzZSB3aGVyZSBpdCBjYW4gYmUgY29waWVkIGludG8gYW4gZXhpc3RpbmcgYnVmZmVyIGluc3RlYWQgb2YgY3JlYXRpbmdcbiAgICAvLyBuZXcgb25lc1xuICAgIHRyeSB7XG4gICAgICBkYXRhVmlldyA9IHNvdXJjZS5kYXRhVmlldyB8fCAoc291cmNlLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNvdXJjZS5idWZmZXIsIHNvdXJjZS5ieXRlT2Zmc2V0LCBzb3VyY2UuYnl0ZUxlbmd0aCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBpZiBpdCBkb2Vzbid0IGhhdmUgYSBidWZmZXIsIG1heWJlIGl0IGlzIHRoZSB3cm9uZyB0eXBlIG9mIG9iamVjdFxuICAgICAgc3JjID0gbnVsbDtcbiAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU291cmNlIG11c3QgYmUgYSBVaW50OEFycmF5IG9yIEJ1ZmZlciBidXQgd2FzIGEgXCIgKyAoc291cmNlICYmIHR5cGVvZiBzb3VyY2UgPT09IFwib2JqZWN0XCIgPyBzb3VyY2UuY29uc3RydWN0b3IubmFtZSA6IHR5cGVvZiBzb3VyY2UpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBEZWNvZGVyKSB7XG4gICAgICBjdXJyZW50RGVjb2RlciA9IHRoaXM7XG4gICAgICBwYWNrZWRWYWx1ZXMgPSB0aGlzLnNoYXJlZFZhbHVlcyAmJiAodGhpcy5wYWNrID8gbmV3IEFycmF5KHRoaXMubWF4UHJpdmF0ZVBhY2tlZFZhbHVlcyB8fCAxNikuY29uY2F0KHRoaXMuc2hhcmVkVmFsdWVzKSA6IHRoaXMuc2hhcmVkVmFsdWVzKTtcbiAgICAgIGlmICh0aGlzLnN0cnVjdHVyZXMpIHtcbiAgICAgICAgY3VycmVudFN0cnVjdHVyZXMgPSB0aGlzLnN0cnVjdHVyZXM7XG4gICAgICAgIHJldHVybiBjaGVja2VkUmVhZCgpO1xuICAgICAgfSBlbHNlIGlmICghY3VycmVudFN0cnVjdHVyZXMgfHwgY3VycmVudFN0cnVjdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjdXJyZW50U3RydWN0dXJlcyA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50RGVjb2RlciA9IGRlZmF1bHRPcHRpb25zO1xuICAgICAgaWYgKCFjdXJyZW50U3RydWN0dXJlcyB8fCBjdXJyZW50U3RydWN0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGN1cnJlbnRTdHJ1Y3R1cmVzID0gW107XG4gICAgICB9XG4gICAgICBwYWNrZWRWYWx1ZXMgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2tlZFJlYWQoKTtcbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tlZFJlYWQoKSB7XG4gIHRyeSB7XG4gICAgbGV0IHJlc3VsdCA9IHJlYWQoKTtcbiAgICBpZiAoYnVuZGxlZFN0cmluZ3MpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA+PSBidW5kbGVkU3RyaW5ncy5wb3N0QnVuZGxlUG9zaXRpb24pIHtcbiAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKFwiVW5leHBlY3RlZCBidW5kbGUgcG9zaXRpb25cIik7XG4gICAgICAgIGVycm9yLmluY29tcGxldGUgPSB0cnVlO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIC8vIGJ1bmRsZWQgc3RyaW5ncyB0byBza2lwIHBhc3RcbiAgICAgIHBvc2l0aW9uID0gYnVuZGxlZFN0cmluZ3MucG9zdEJ1bmRsZVBvc2l0aW9uO1xuICAgICAgYnVuZGxlZFN0cmluZ3MgPSBudWxsO1xuICAgIH1cbiAgICBpZiAocG9zaXRpb24gPT0gc3JjRW5kKSB7XG4gICAgICAvLyBmaW5pc2hlZCByZWFkaW5nIHRoaXMgc291cmNlLCBjbGVhbnVwIHJlZmVyZW5jZXNcbiAgICAgIGN1cnJlbnRTdHJ1Y3R1cmVzID0gbnVsbDtcbiAgICAgIHNyYyA9IG51bGw7XG4gICAgICBpZiAocmVmZXJlbmNlTWFwKSB7XG4gICAgICAgIHJlZmVyZW5jZU1hcCA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA+IHNyY0VuZCkge1xuICAgICAgLy8gb3ZlciByZWFkXG4gICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBDQk9SIGRhdGFcIik7XG4gICAgICBlcnJvci5pbmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZWxzZSBpZiAoIXNlcXVlbnRpYWxNb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIHJlYWQsIGJ1dCBlbmQgb2YgYnVmZmVyIG5vdCByZWFjaGVkXCIpO1xuICAgIH1cbiAgICAvLyBlbHNlIG1vcmUgdG8gcmVhZCwgYnV0IHdlIGFyZSByZWFkaW5nIHNlcXVlbnRpYWxseSwgc28gZG9uJ3QgY2xlYXIgc291cmNlIHlldFxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY2xlYXJTb3VyY2UoKTtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBSYW5nZUVycm9yIHx8IGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIlVuZXhwZWN0ZWQgZW5kIG9mIGJ1ZmZlclwiKSkge1xuICAgICAgZXJyb3IuaW5jb21wbGV0ZSA9IHRydWU7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5mdW5jdGlvbiByZWFkKCkge1xuICBsZXQgdG9rZW4gPSBzcmNbcG9zaXRpb24rK107XG4gIGxldCBtYWpvclR5cGUgPSB0b2tlbiA+PiA1O1xuICB0b2tlbiA9IHRva2VuICYgMHgxZjtcbiAgaWYgKHRva2VuID4gMHgxNykge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgMHgxODpcbiAgICAgICAgdG9rZW4gPSBzcmNbcG9zaXRpb24rK107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAweDE5OlxuICAgICAgICBpZiAobWFqb3JUeXBlID09IDcpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0RmxvYXQxNigpO1xuICAgICAgICB9XG4gICAgICAgIHRva2VuID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uKTtcbiAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDB4MWE6XG4gICAgICAgIGlmIChtYWpvclR5cGUgPT0gNykge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGRhdGFWaWV3LmdldEZsb2F0MzIocG9zaXRpb24pO1xuICAgICAgICAgIGlmIChjdXJyZW50RGVjb2Rlci51c2VGbG9hdDMyID4gMikge1xuICAgICAgICAgICAgLy8gdGhpcyBkb2VzIHJvdW5kaW5nIG9mIG51bWJlcnMgdGhhdCB3ZXJlIGVuY29kZWQgaW4gMzItYml0IGZsb2F0IHRvIG5lYXJlc3Qgc2lnbmlmaWNhbnQgZGVjaW1hbCBkaWdpdCB0aGF0IGNvdWxkIGJlIHByZXNlcnZlZFxuICAgICAgICAgICAgbGV0IG11bHRpcGxpZXIgPSBtdWx0MTBbKHNyY1twb3NpdGlvbl0gJiAweDdmKSA8PCAxIHwgc3JjW3Bvc2l0aW9uICsgMV0gPj4gN107XG4gICAgICAgICAgICBwb3NpdGlvbiArPSA0O1xuICAgICAgICAgICAgcmV0dXJuIChtdWx0aXBsaWVyICogdmFsdWUgKyAodmFsdWUgPiAwID8gMC41IDogLTAuNSkgPj4gMCkgLyBtdWx0aXBsaWVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3NpdGlvbiArPSA0O1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbiA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbik7XG4gICAgICAgIHBvc2l0aW9uICs9IDQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAweDFiOlxuICAgICAgICBpZiAobWFqb3JUeXBlID09IDcpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBkYXRhVmlldy5nZXRGbG9hdDY0KHBvc2l0aW9uKTtcbiAgICAgICAgICBwb3NpdGlvbiArPSA4O1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFqb3JUeXBlID4gMSkge1xuICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24pID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSmF2YVNjcmlwdCBkb2VzIG5vdCBzdXBwb3J0IGFycmF5cywgbWFwcywgb3Igc3RyaW5ncyB3aXRoIGxlbmd0aCBvdmVyIDQyOTQ5NjcyOTVcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRva2VuID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uICsgNCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudERlY29kZXIuaW50NjRBc051bWJlcikge1xuICAgICAgICAgIHRva2VuID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgICAgIHRva2VuICs9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbiArIDQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2VuID0gZGF0YVZpZXcuZ2V0QmlnVWludDY0KHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvbiArPSA4O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMHgxZjpcbiAgICAgICAgLy8gaW5kZWZpbml0ZSBsZW5ndGhcbiAgICAgICAgc3dpdGNoIChtYWpvclR5cGUpIHtcbiAgICAgICAgICBjYXNlIDI6IC8vIGJ5dGUgc3RyaW5nXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgLy8gdGV4dCBzdHJpbmdcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluZGVmaW5pdGUgbGVuZ3RoIG5vdCBzdXBwb3J0ZWQgZm9yIGJ5dGUgb3IgdGV4dCBzdHJpbmdzXCIpO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIC8vIGFycmF5XG4gICAgICAgICAgICBsZXQgYXJyYXkgPSBbXTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSxcbiAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoKHZhbHVlID0gcmVhZCgpKSAhPSBTVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgYXJyYXlbaSsrXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ham9yVHlwZSA9PSA0ID8gYXJyYXkgOiBtYWpvclR5cGUgPT0gMyA/IGFycmF5LmpvaW4oXCJcIikgOiBCdWZmZXIuY29uY2F0KGFycmF5KTtcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAvLyBtYXBcbiAgICAgICAgICAgIGxldCBrZXk7XG4gICAgICAgICAgICBpZiAoY3VycmVudERlY29kZXIubWFwc0FzT2JqZWN0cykge1xuICAgICAgICAgICAgICBsZXQgb2JqZWN0ID0ge307XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50RGVjb2Rlci5rZXlNYXApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGtleSA9IHJlYWQoKSkgIT0gU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICBvYmplY3Rbc2FmZUtleShjdXJyZW50RGVjb2Rlci5kZWNvZGVLZXkoa2V5KSldID0gcmVhZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGtleSA9IHJlYWQoKSkgIT0gU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICBvYmplY3Rbc2FmZUtleShrZXkpXSA9IHJlYWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChyZXN0b3JlTWFwc0FzT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgY3VycmVudERlY29kZXIubWFwc0FzT2JqZWN0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzdG9yZU1hcHNBc09iamVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50RGVjb2Rlci5rZXlNYXApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGtleSA9IHJlYWQoKSkgIT0gU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICBtYXAuc2V0KGN1cnJlbnREZWNvZGVyLmRlY29kZUtleShrZXkpLCByZWFkKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGtleSA9IHJlYWQoKSkgIT0gU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICBtYXAuc2V0KGtleSwgcmVhZCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gU1RPUF9DT0RFO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1ham9yIHR5cGUgZm9yIGluZGVmaW5pdGUgbGVuZ3RoIFwiICsgbWFqb3JUeXBlKTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0b2tlbiBcIiArIHRva2VuKTtcbiAgICB9XG4gIH1cbiAgc3dpdGNoIChtYWpvclR5cGUpIHtcbiAgICBjYXNlIDA6XG4gICAgICAvLyBwb3NpdGl2ZSBpbnRcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICBjYXNlIDE6XG4gICAgICAvLyBuZWdhdGl2ZSBpbnRcbiAgICAgIHJldHVybiB+dG9rZW47XG4gICAgY2FzZSAyOlxuICAgICAgLy8gYnVmZmVyXG4gICAgICByZXR1cm4gcmVhZEJpbih0b2tlbik7XG4gICAgY2FzZSAzOlxuICAgICAgLy8gc3RyaW5nXG4gICAgICBpZiAoc3JjU3RyaW5nRW5kID49IHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBzcmNTdHJpbmcuc2xpY2UocG9zaXRpb24gLSBzcmNTdHJpbmdTdGFydCwgKHBvc2l0aW9uICs9IHRva2VuKSAtIHNyY1N0cmluZ1N0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChzcmNTdHJpbmdFbmQgPT0gMCAmJiBzcmNFbmQgPCAxNDAgJiYgdG9rZW4gPCAzMikge1xuICAgICAgICAvLyBmb3Igc21hbGwgYmxvY2tzLCBhdm9pZGluZyB0aGUgb3ZlcmhlYWQgb2YgdGhlIGV4dHJhY3QgY2FsbCBpcyBoZWxwZnVsXG4gICAgICAgIGxldCBzdHJpbmcgPSB0b2tlbiA8IDE2ID8gc2hvcnRTdHJpbmdJbkpTKHRva2VuKSA6IGxvbmdTdHJpbmdJbkpTKHRva2VuKTtcbiAgICAgICAgaWYgKHN0cmluZyAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlYWRGaXhlZFN0cmluZyh0b2tlbik7XG4gICAgY2FzZSA0OlxuICAgICAgLy8gYXJyYXlcbiAgICAgIGxldCBhcnJheSA9IG5ldyBBcnJheSh0b2tlbik7XG4gICAgICAvL2lmIChjdXJyZW50RGVjb2Rlci5rZXlNYXApIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW47IGkrKykgYXJyYXlbaV0gPSBjdXJyZW50RGVjb2Rlci5kZWNvZGVLZXkocmVhZCgpKVxuICAgICAgLy9lbHNlXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaV0gPSByZWFkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgY2FzZSA1OlxuICAgICAgLy8gbWFwXG4gICAgICBpZiAoY3VycmVudERlY29kZXIubWFwc0FzT2JqZWN0cykge1xuICAgICAgICBsZXQgb2JqZWN0ID0ge307XG4gICAgICAgIGlmIChjdXJyZW50RGVjb2Rlci5rZXlNYXApIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuOyBpKyspIHtcbiAgICAgICAgICAgIG9iamVjdFtzYWZlS2V5KGN1cnJlbnREZWNvZGVyLmRlY29kZUtleShyZWFkKCkpKV0gPSByZWFkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW47IGkrKykge1xuICAgICAgICAgICAgb2JqZWN0W3NhZmVLZXkocmVhZCgpKV0gPSByZWFkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVzdG9yZU1hcHNBc09iamVjdCkge1xuICAgICAgICAgIGN1cnJlbnREZWNvZGVyLm1hcHNBc09iamVjdHMgPSB0cnVlO1xuICAgICAgICAgIHJlc3RvcmVNYXBzQXNPYmplY3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoY3VycmVudERlY29kZXIua2V5TWFwKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbjsgaSsrKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGN1cnJlbnREZWNvZGVyLmRlY29kZUtleShyZWFkKCkpLCByZWFkKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuOyBpKyspIHtcbiAgICAgICAgICAgIG1hcC5zZXQocmVhZCgpLCByZWFkKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgfVxuICAgIGNhc2UgNjpcbiAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgaWYgKHRva2VuID49IEJVTkRMRURfU1RSSU5HU19JRCkge1xuICAgICAgICBsZXQgc3RydWN0dXJlID0gY3VycmVudFN0cnVjdHVyZXNbdG9rZW4gJiAweDFmZmZdOyAvLyBjaGVjayByZWNvcmQgc3RydWN0dXJlcyBmaXJzdFxuICAgICAgICAvLyBBdCBzb21lIHBvaW50IHdlIG1heSBwcm92aWRlIGFuIG9wdGlvbiBmb3IgZHluYW1pYyB0YWcgYXNzaWdubWVudCB3aXRoIGEgcmFuZ2UgbGlrZSB0b2tlbiA+PSA4ICYmICh0b2tlbiA8IDE2IHx8ICh0b2tlbiA+IDB4ODAgJiYgdG9rZW4gPCAweGMwKSB8fCAodG9rZW4gPiAweDEzMCAmJiB0b2tlbiA8IDB4NDAwMCkpXG4gICAgICAgIGlmIChzdHJ1Y3R1cmUpIHtcbiAgICAgICAgICBpZiAoIXN0cnVjdHVyZS5yZWFkKSB7XG4gICAgICAgICAgICBzdHJ1Y3R1cmUucmVhZCA9IGNyZWF0ZVN0cnVjdHVyZVJlYWRlcihzdHJ1Y3R1cmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RydWN0dXJlLnJlYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4gPCAweDEwMDAwKSB7XG4gICAgICAgICAgaWYgKHRva2VuID09IFJFQ09SRF9JTkxJTkVfSUQpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvIGEgc3BlY2lhbCBjaGVjayBmb3IgdGhpcyBzbyB0aGF0IHdlIGNhbiBrZWVwIHRoZSBjdXJyZW50RXh0ZW5zaW9ucyBhcyBkZW5zZWx5IHN0b3JlZCBhcnJheSAodjggc3RvcmVzIGFycmF5cyBkZW5zZWx5IHVuZGVyIGFib3V0IDMwMDAgZWxlbWVudHMpXG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkRGVmaW5pdGlvbihyZWFkKCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4gPT0gUkVDT1JEX0RFRklOSVRJT05TX0lEKSB7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gcmVhZEp1c3RMZW5ndGgoKTtcbiAgICAgICAgICAgIGxldCBpZCA9IHJlYWQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgcmVjb3JkRGVmaW5pdGlvbihbaWQrKywgcmVhZCgpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVhZCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4gPT0gQlVORExFRF9TVFJJTkdTX0lEKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEJ1bmRsZUV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3VycmVudERlY29kZXIuZ2V0U2hhcmVkKSB7XG4gICAgICAgICAgICBsb2FkU2hhcmVkKCk7XG4gICAgICAgICAgICBzdHJ1Y3R1cmUgPSBjdXJyZW50U3RydWN0dXJlc1t0b2tlbiAmIDB4MWZmZl07XG4gICAgICAgICAgICBpZiAoc3RydWN0dXJlKSB7XG4gICAgICAgICAgICAgIGlmICghc3RydWN0dXJlLnJlYWQpIHtcbiAgICAgICAgICAgICAgICBzdHJ1Y3R1cmUucmVhZCA9IGNyZWF0ZVN0cnVjdHVyZVJlYWRlcihzdHJ1Y3R1cmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3R1cmUucmVhZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGV4dGVuc2lvbiA9IGN1cnJlbnRFeHRlbnNpb25zW3Rva2VuXTtcbiAgICAgIGlmIChleHRlbnNpb24pIHtcbiAgICAgICAgaWYgKGV4dGVuc2lvbi5oYW5kbGVzUmVhZCkge1xuICAgICAgICAgIHJldHVybiBleHRlbnNpb24ocmVhZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGV4dGVuc2lvbihyZWFkKCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgaW5wdXQgPSByZWFkKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudEV4dGVuc2lvblJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGN1cnJlbnRFeHRlbnNpb25SYW5nZXNbaV0odG9rZW4sIGlucHV0KTtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRhZyhpbnB1dCwgdG9rZW4pO1xuICAgICAgfVxuICAgIGNhc2UgNzpcbiAgICAgIC8vIGZpeGVkIHZhbHVlXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgMHgxNDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNhc2UgMHgxNTpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAweDE2OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDB4MTc6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyB1bmRlZmluZWRcbiAgICAgICAgY2FzZSAweDFmOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCBwYWNrZWRWYWx1ZSA9IChwYWNrZWRWYWx1ZXMgfHwgZ2V0UGFja2VkVmFsdWVzKCkpW3Rva2VuXTtcbiAgICAgICAgICBpZiAocGFja2VkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhY2tlZFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHRva2VuIFwiICsgdG9rZW4pO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBuZWdhdGl2ZSBpbnRcbiAgICAgIGlmIChpc05hTih0b2tlbikpIHtcbiAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2YgQ0JPUiBkYXRhXCIpO1xuICAgICAgICBlcnJvci5pbmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIENCT1IgdG9rZW4gXCIgKyB0b2tlbik7XG4gIH1cbn1cbmNvbnN0IHZhbGlkTmFtZSA9IC9eW2EtekEtWl8kXVthLXpBLVpcXGRfJF0qJC87XG5mdW5jdGlvbiBjcmVhdGVTdHJ1Y3R1cmVSZWFkZXIoc3RydWN0dXJlKSB7XG4gIGZ1bmN0aW9uIHJlYWRPYmplY3QoKSB7XG4gICAgLy8gZ2V0IHRoZSBhcnJheSBzaXplIGZyb20gdGhlIGhlYWRlclxuICAgIGxldCBsZW5ndGggPSBzcmNbcG9zaXRpb24rK107XG4gICAgLy9sZXQgbWFqb3JUeXBlID0gdG9rZW4gPj4gNVxuICAgIGxlbmd0aCA9IGxlbmd0aCAmIDB4MWY7XG4gICAgaWYgKGxlbmd0aCA+IDB4MTcpIHtcbiAgICAgIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMHgxODpcbiAgICAgICAgICBsZW5ndGggPSBzcmNbcG9zaXRpb24rK107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgxOTpcbiAgICAgICAgICBsZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pO1xuICAgICAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgxYTpcbiAgICAgICAgICBsZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24pO1xuICAgICAgICAgIHBvc2l0aW9uICs9IDQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYXJyYXkgaGVhZGVyLCBidXQgZ290IFwiICsgc3JjW3Bvc2l0aW9uIC0gMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGlzIGluaXRpYWwgZnVuY3Rpb24gaXMgcXVpY2sgdG8gaW5zdGFudGlhdGUsIGJ1dCBydW5zIHNsb3dlci4gQWZ0ZXIgc2V2ZXJhbCBpdGVyYXRpb25zIHBheSB0aGUgY29zdCB0byBidWlsZCB0aGUgZmFzdGVyIGZ1bmN0aW9uXG4gICAgbGV0IGNvbXBpbGVkUmVhZGVyID0gdGhpcy5jb21waWxlZFJlYWRlcjsgLy8gZmlyc3QgbG9vayB0byBzZWUgaWYgd2UgaGF2ZSB0aGUgZmFzdCBjb21waWxlZCBmdW5jdGlvblxuICAgIHdoaWxlIChjb21waWxlZFJlYWRlcikge1xuICAgICAgLy8gd2UgaGF2ZSBhIGZhc3QgY29tcGlsZWQgb2JqZWN0IGxpdGVyYWwgcmVhZGVyXG4gICAgICBpZiAoY29tcGlsZWRSZWFkZXIucHJvcGVydHlDb3VudCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjb21waWxlZFJlYWRlcihyZWFkKTtcbiAgICAgIH0gLy8gd2l0aCB0aGUgcmlnaHQgbGVuZ3RoLCBzbyB3ZSB1c2UgaXRcbiAgICAgIGNvbXBpbGVkUmVhZGVyID0gY29tcGlsZWRSZWFkZXIubmV4dDsgLy8gc2VlIGlmIHRoZXJlIGlzIGFub3RoZXIgcmVhZGVyIHdpdGggdGhlIHJpZ2h0IGxlbmd0aFxuICAgIH1cblxuICAgIGlmICh0aGlzLnNsb3dSZWFkcysrID49IDMpIHtcbiAgICAgIC8vIGNyZWF0ZSBhIGZhc3QgY29tcGlsZWQgcmVhZGVyXG4gICAgICBsZXQgYXJyYXkgPSB0aGlzLmxlbmd0aCA9PSBsZW5ndGggPyB0aGlzIDogdGhpcy5zbGljZSgwLCBsZW5ndGgpO1xuICAgICAgY29tcGlsZWRSZWFkZXIgPSBjdXJyZW50RGVjb2Rlci5rZXlNYXAgPyBuZXcgRnVuY3Rpb24oXCJyXCIsIFwicmV0dXJuIHtcIiArIGFycmF5Lm1hcChrID0+IGN1cnJlbnREZWNvZGVyLmRlY29kZUtleShrKSkubWFwKGsgPT4gdmFsaWROYW1lLnRlc3QoaykgPyBzYWZlS2V5KGspICsgXCI6cigpXCIgOiBcIltcIiArIEpTT04uc3RyaW5naWZ5KGspICsgXCJdOnIoKVwiKS5qb2luKFwiLFwiKSArIFwifVwiKSA6IG5ldyBGdW5jdGlvbihcInJcIiwgXCJyZXR1cm4ge1wiICsgYXJyYXkubWFwKGtleSA9PiB2YWxpZE5hbWUudGVzdChrZXkpID8gc2FmZUtleShrZXkpICsgXCI6cigpXCIgOiBcIltcIiArIEpTT04uc3RyaW5naWZ5KGtleSkgKyBcIl06cigpXCIpLmpvaW4oXCIsXCIpICsgXCJ9XCIpO1xuICAgICAgaWYgKHRoaXMuY29tcGlsZWRSZWFkZXIpIHtcbiAgICAgICAgY29tcGlsZWRSZWFkZXIubmV4dCA9IHRoaXMuY29tcGlsZWRSZWFkZXI7XG4gICAgICB9IC8vIGlmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIG9uZSwgd2Ugc3RvcmUgbXVsdGlwbGUgcmVhZGVycyBhcyBhIGxpbmtlZCBsaXN0IGJlY2F1c2UgaXQgaXMgdXN1YWxseSBwcmV0dHkgcmFyZSB0byBoYXZlIG11bHRpcGxlIHJlYWRlcnMgKG9mIGRpZmZlcmVudCBsZW5ndGgpIGZvciB0aGUgc2FtZSBzdHJ1Y3R1cmVcbiAgICAgIGNvbXBpbGVkUmVhZGVyLnByb3BlcnR5Q291bnQgPSBsZW5ndGg7XG4gICAgICB0aGlzLmNvbXBpbGVkUmVhZGVyID0gY29tcGlsZWRSZWFkZXI7XG4gICAgICByZXR1cm4gY29tcGlsZWRSZWFkZXIocmVhZCk7XG4gICAgfVxuICAgIGxldCBvYmplY3QgPSB7fTtcbiAgICBpZiAoY3VycmVudERlY29kZXIua2V5TWFwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG9iamVjdFtzYWZlS2V5KGN1cnJlbnREZWNvZGVyLmRlY29kZUtleSh0aGlzW2ldKSldID0gcmVhZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG9iamVjdFtzYWZlS2V5KHRoaXNbaV0pXSA9IHJlYWQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBzdHJ1Y3R1cmUuc2xvd1JlYWRzID0gMDtcbiAgcmV0dXJuIHJlYWRPYmplY3Q7XG59XG5mdW5jdGlvbiBzYWZlS2V5KGtleSkge1xuICByZXR1cm4ga2V5ID09PSBcIl9fcHJvdG9fX1wiID8gXCJfX3Byb3RvX1wiIDoga2V5O1xufVxubGV0IHJlYWRGaXhlZFN0cmluZyA9IHJlYWRTdHJpbmdKUztcbmZ1bmN0aW9uIHJlYWRTdHJpbmdKUyhsZW5ndGgpIHtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKGxlbmd0aCA8IDE2KSB7XG4gICAgaWYgKHJlc3VsdCA9IHNob3J0U3RyaW5nSW5KUyhsZW5ndGgpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICBpZiAobGVuZ3RoID4gNjQgJiYgZGVjb2Rlcikge1xuICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShzcmMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICs9IGxlbmd0aCkpO1xuICB9XG4gIGNvbnN0IGVuZCA9IHBvc2l0aW9uICsgbGVuZ3RoO1xuICBjb25zdCB1bml0cyA9IFtdO1xuICByZXN1bHQgPSBcIlwiO1xuICB3aGlsZSAocG9zaXRpb24gPCBlbmQpIHtcbiAgICBjb25zdCBieXRlMSA9IHNyY1twb3NpdGlvbisrXTtcbiAgICBpZiAoKGJ5dGUxICYgMHg4MCkgPT09IDApIHtcbiAgICAgIC8vIDEgYnl0ZVxuICAgICAgdW5pdHMucHVzaChieXRlMSk7XG4gICAgfSBlbHNlIGlmICgoYnl0ZTEgJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgLy8gMiBieXRlc1xuICAgICAgY29uc3QgYnl0ZTIgPSBzcmNbcG9zaXRpb24rK10gJiAweDNmO1xuICAgICAgdW5pdHMucHVzaCgoYnl0ZTEgJiAweDFmKSA8PCA2IHwgYnl0ZTIpO1xuICAgIH0gZWxzZSBpZiAoKGJ5dGUxICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgIC8vIDMgYnl0ZXNcbiAgICAgIGNvbnN0IGJ5dGUyID0gc3JjW3Bvc2l0aW9uKytdICYgMHgzZjtcbiAgICAgIGNvbnN0IGJ5dGUzID0gc3JjW3Bvc2l0aW9uKytdICYgMHgzZjtcbiAgICAgIHVuaXRzLnB1c2goKGJ5dGUxICYgMHgxZikgPDwgMTIgfCBieXRlMiA8PCA2IHwgYnl0ZTMpO1xuICAgIH0gZWxzZSBpZiAoKGJ5dGUxICYgMHhmOCkgPT09IDB4ZjApIHtcbiAgICAgIC8vIDQgYnl0ZXNcbiAgICAgIGNvbnN0IGJ5dGUyID0gc3JjW3Bvc2l0aW9uKytdICYgMHgzZjtcbiAgICAgIGNvbnN0IGJ5dGUzID0gc3JjW3Bvc2l0aW9uKytdICYgMHgzZjtcbiAgICAgIGNvbnN0IGJ5dGU0ID0gc3JjW3Bvc2l0aW9uKytdICYgMHgzZjtcbiAgICAgIGxldCB1bml0ID0gKGJ5dGUxICYgMHgwNykgPDwgMHgxMiB8IGJ5dGUyIDw8IDB4MGMgfCBieXRlMyA8PCAweDA2IHwgYnl0ZTQ7XG4gICAgICBpZiAodW5pdCA+IDB4ZmZmZikge1xuICAgICAgICB1bml0IC09IDB4MTAwMDA7XG4gICAgICAgIHVuaXRzLnB1c2godW5pdCA+Pj4gMTAgJiAweDNmZiB8IDB4ZDgwMCk7XG4gICAgICAgIHVuaXQgPSAweGRjMDAgfCB1bml0ICYgMHgzZmY7XG4gICAgICB9XG4gICAgICB1bml0cy5wdXNoKHVuaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bml0cy5wdXNoKGJ5dGUxKTtcbiAgICB9XG4gICAgaWYgKHVuaXRzLmxlbmd0aCA+PSAweDEwMDApIHtcbiAgICAgIHJlc3VsdCArPSBmcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCB1bml0cyk7XG4gICAgICB1bml0cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfVxuICBpZiAodW5pdHMubGVuZ3RoID4gMCkge1xuICAgIHJlc3VsdCArPSBmcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCB1bml0cyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmxldCBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuZnVuY3Rpb24gbG9uZ1N0cmluZ0luSlMobGVuZ3RoKSB7XG4gIGxldCBzdGFydCA9IHBvc2l0aW9uO1xuICBsZXQgYnl0ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGJ5dGUgPSBzcmNbcG9zaXRpb24rK107XG4gICAgaWYgKChieXRlICYgMHg4MCkgPiAwKSB7XG4gICAgICBwb3NpdGlvbiA9IHN0YXJ0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBieXRlc1tpXSA9IGJ5dGU7XG4gIH1cbiAgcmV0dXJuIGZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIHNob3J0U3RyaW5nSW5KUyhsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA8IDQpIHtcbiAgICBpZiAobGVuZ3RoIDwgMikge1xuICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBhID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgICAgICBpZiAoKGEgJiAweDgwKSA+IDEpIHtcbiAgICAgICAgICBwb3NpdGlvbiAtPSAxO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbUNoYXJDb2RlKGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgYSA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgIGxldCBiID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgICAgaWYgKChhICYgMHg4MCkgPiAwIHx8IChiICYgMHg4MCkgPiAwKSB7XG4gICAgICAgIHBvc2l0aW9uIC09IDI7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPCAzKSB7XG4gICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYik7XG4gICAgICB9XG4gICAgICBsZXQgYyA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgIGlmICgoYyAmIDB4ODApID4gMCkge1xuICAgICAgICBwb3NpdGlvbiAtPSAzO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgYSA9IHNyY1twb3NpdGlvbisrXTtcbiAgICBsZXQgYiA9IHNyY1twb3NpdGlvbisrXTtcbiAgICBsZXQgYyA9IHNyY1twb3NpdGlvbisrXTtcbiAgICBsZXQgZCA9IHNyY1twb3NpdGlvbisrXTtcbiAgICBpZiAoKGEgJiAweDgwKSA+IDAgfHwgKGIgJiAweDgwKSA+IDAgfHwgKGMgJiAweDgwKSA+IDAgfHwgKGQgJiAweDgwKSA+IDApIHtcbiAgICAgIHBvc2l0aW9uIC09IDQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCA2KSB7XG4gICAgICBpZiAobGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZSA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgICAgaWYgKChlICYgMHg4MCkgPiAwKSB7XG4gICAgICAgICAgcG9zaXRpb24gLT0gNTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxlbmd0aCA8IDgpIHtcbiAgICAgIGxldCBlID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgICAgbGV0IGYgPSBzcmNbcG9zaXRpb24rK107XG4gICAgICBpZiAoKGUgJiAweDgwKSA+IDAgfHwgKGYgJiAweDgwKSA+IDApIHtcbiAgICAgICAgcG9zaXRpb24gLT0gNjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA8IDcpIHtcbiAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICAgIH1cbiAgICAgIGxldCBnID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgICAgaWYgKChnICYgMHg4MCkgPiAwKSB7XG4gICAgICAgIHBvc2l0aW9uIC09IDc7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBlID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgICAgbGV0IGYgPSBzcmNbcG9zaXRpb24rK107XG4gICAgICBsZXQgZyA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgIGxldCBoID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgICAgaWYgKChlICYgMHg4MCkgPiAwIHx8IChmICYgMHg4MCkgPiAwIHx8IChnICYgMHg4MCkgPiAwIHx8IChoICYgMHg4MCkgPiAwKSB7XG4gICAgICAgIHBvc2l0aW9uIC09IDg7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPCAxMCkge1xuICAgICAgICBpZiAobGVuZ3RoID09PSA4KSB7XG4gICAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgaSA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgICAgICBpZiAoKGkgJiAweDgwKSA+IDApIHtcbiAgICAgICAgICAgIHBvc2l0aW9uIC09IDk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoIDwgMTIpIHtcbiAgICAgICAgbGV0IGkgPSBzcmNbcG9zaXRpb24rK107XG4gICAgICAgIGxldCBqID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgICAgICBpZiAoKGkgJiAweDgwKSA+IDAgfHwgKGogJiAweDgwKSA+IDApIHtcbiAgICAgICAgICBwb3NpdGlvbiAtPSAxMDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IDExKSB7XG4gICAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgayA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgICAgaWYgKChrICYgMHg4MCkgPiAwKSB7XG4gICAgICAgICAgcG9zaXRpb24gLT0gMTE7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgaSA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgICAgbGV0IGogPSBzcmNbcG9zaXRpb24rK107XG4gICAgICAgIGxldCBrID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgICAgICBsZXQgbCA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgICAgaWYgKChpICYgMHg4MCkgPiAwIHx8IChqICYgMHg4MCkgPiAwIHx8IChrICYgMHg4MCkgPiAwIHx8IChsICYgMHg4MCkgPiAwKSB7XG4gICAgICAgICAgcG9zaXRpb24gLT0gMTI7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCAxNCkge1xuICAgICAgICAgIGlmIChsZW5ndGggPT09IDEyKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbSA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgICAgICAgIGlmICgobSAmIDB4ODApID4gMCkge1xuICAgICAgICAgICAgICBwb3NpdGlvbiAtPSAxMztcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsLCBtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IG0gPSBzcmNbcG9zaXRpb24rK107XG4gICAgICAgICAgbGV0IG4gPSBzcmNbcG9zaXRpb24rK107XG4gICAgICAgICAgaWYgKChtICYgMHg4MCkgPiAwIHx8IChuICYgMHg4MCkgPiAwKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiAtPSAxNDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxlbmd0aCA8IDE1KSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwsIG0sIG4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgbyA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgICAgICBpZiAoKG8gJiAweDgwKSA+IDApIHtcbiAgICAgICAgICAgIHBvc2l0aW9uIC09IDE1O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwsIG0sIG4sIG8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZWFkQmluKGxlbmd0aCkge1xuICByZXR1cm4gY3VycmVudERlY29kZXIuY29weUJ1ZmZlcnMgP1xuICAvLyBzcGVjaWZpY2FsbHkgdXNlIHRoZSBjb3B5aW5nIHNsaWNlIChub3QgdGhlIG5vZGUgb25lKVxuICBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHNyYywgcG9zaXRpb24sIHBvc2l0aW9uICs9IGxlbmd0aCkgOiBzcmMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICs9IGxlbmd0aCk7XG59XG5sZXQgZjMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDEpO1xubGV0IHU4QXJyYXkgPSBuZXcgVWludDhBcnJheShmMzJBcnJheS5idWZmZXIsIDAsIDQpO1xuZnVuY3Rpb24gZ2V0RmxvYXQxNigpIHtcbiAgbGV0IGJ5dGUwID0gc3JjW3Bvc2l0aW9uKytdO1xuICBsZXQgYnl0ZTEgPSBzcmNbcG9zaXRpb24rK107XG4gIGxldCBleHBvbmVudCA9IChieXRlMCAmIDB4N2YpID4+IDI7XG4gIGlmIChleHBvbmVudCA9PT0gMHgxZikge1xuICAgIC8vIHNwZWNpYWxzXG4gICAgaWYgKGJ5dGUxIHx8IGJ5dGUwICYgMykge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGUwICYgMHg4MCA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICB9XG4gIGlmIChleHBvbmVudCA9PT0gMCkge1xuICAgIC8vIHN1Yi1ub3JtYWxzXG4gICAgLy8gc2lnbmlmaWNhbmQgd2l0aCAxMCBmcmFjdGlvbmFsIGJpdHMgYW5kIGRpdmlkZWQgYnkgMl4xNFxuICAgIGxldCBhYnMgPSAoKGJ5dGUwICYgMykgPDwgOCB8IGJ5dGUxKSAvICgxIDw8IDI0KTtcbiAgICByZXR1cm4gYnl0ZTAgJiAweDgwID8gLWFicyA6IGFicztcbiAgfVxuICB1OEFycmF5WzNdID0gYnl0ZTAgJiAweDgwIHxcbiAgLy8gc2lnbiBiaXRcbiAgKGV4cG9uZW50ID4+IDEpICsgNTY7IC8vIDQgb2YgNSBvZiB0aGUgZXhwb25lbnQgYml0cywgcmUtb2Zmc2V0LWVkXG4gIHU4QXJyYXlbMl0gPSAoYnl0ZTAgJiA3KSA8PCA1IHxcbiAgLy8gbGFzdCBleHBvbmVudCBiaXQgYW5kIGZpcnN0IHR3byBtYW50aXNzYSBiaXRzXG4gIGJ5dGUxID4+IDM7IC8vIG5leHQgNSBiaXRzIG9mIG1hbnRpc3NhXG4gIHU4QXJyYXlbMV0gPSBieXRlMSA8PCA1OyAvLyBsYXN0IHRocmVlIGJpdHMgb2YgbWFudGlzc2FcbiAgdThBcnJheVswXSA9IDA7XG4gIHJldHVybiBmMzJBcnJheVswXTtcbn1cbmNsYXNzIFRhZyB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCB0YWcpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy50YWcgPSB0YWc7XG4gIH1cbn1cbmN1cnJlbnRFeHRlbnNpb25zWzBdID0gZGF0ZVN0cmluZyA9PiB7XG4gIC8vIHN0cmluZyBkYXRlIGV4dGVuc2lvblxuICByZXR1cm4gbmV3IERhdGUoZGF0ZVN0cmluZyk7XG59O1xuY3VycmVudEV4dGVuc2lvbnNbMV0gPSBlcG9jaFNlYyA9PiB7XG4gIC8vIG51bWVyaWMgZGF0ZSBleHRlbnNpb25cbiAgcmV0dXJuIG5ldyBEYXRlKE1hdGgucm91bmQoZXBvY2hTZWMgKiAxMDAwKSk7XG59O1xuY3VycmVudEV4dGVuc2lvbnNbMl0gPSBidWZmZXIgPT4ge1xuICAvLyBiaWdpbnQgZXh0ZW5zaW9uXG4gIGxldCB2YWx1ZSA9IEJpZ0ludCgwKTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBidWZmZXIuYnl0ZUxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhbHVlID0gQmlnSW50KGJ1ZmZlcltpXSkgKyB2YWx1ZSA8PCBCaWdJbnQoOCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcbmN1cnJlbnRFeHRlbnNpb25zWzNdID0gYnVmZmVyID0+IHtcbiAgLy8gbmVnYXRpdmUgYmlnaW50IGV4dGVuc2lvblxuICByZXR1cm4gQmlnSW50KC0xKSAtIGN1cnJlbnRFeHRlbnNpb25zWzJdKGJ1ZmZlcik7XG59O1xuY3VycmVudEV4dGVuc2lvbnNbNF0gPSBmcmFjdGlvbiA9PiB7XG4gIC8vIGJlc3QgdG8gcmVwYXJzZSB0byBtYWludGFpbiBhY2N1cmFjeVxuICByZXR1cm4gTnVtYmVyKGZyYWN0aW9uWzFdICsgXCJlXCIgKyBmcmFjdGlvblswXSk7XG59O1xuY3VycmVudEV4dGVuc2lvbnNbNV0gPSBmcmFjdGlvbiA9PiB7XG4gIC8vIHByb2JhYmx5IG5vdCBzdWZmaWNpZW50bHkgYWNjdXJhdGVcbiAgcmV0dXJuIGZyYWN0aW9uWzFdICogTWF0aC5leHAoZnJhY3Rpb25bMF0gKiBNYXRoLmxvZygyKSk7XG59O1xuXG4vLyB0aGUgcmVnaXN0cmF0aW9uIG9mIHRoZSByZWNvcmQgZGVmaW5pdGlvbiBleHRlbnNpb25cbmNvbnN0IHJlY29yZERlZmluaXRpb24gPSBkZWZpbml0aW9uID0+IHtcbiAgbGV0IGlkID0gZGVmaW5pdGlvblswXSAtIDB4ZTAwMDtcbiAgbGV0IHN0cnVjdHVyZSA9IGRlZmluaXRpb25bMV07XG4gIGxldCBleGlzdGluZ1N0cnVjdHVyZSA9IGN1cnJlbnRTdHJ1Y3R1cmVzW2lkXTtcbiAgaWYgKGV4aXN0aW5nU3RydWN0dXJlICYmIGV4aXN0aW5nU3RydWN0dXJlLmlzU2hhcmVkKSB7XG4gICAgKGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzIHx8IChjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcyA9IFtdKSlbaWRdID0gZXhpc3RpbmdTdHJ1Y3R1cmU7XG4gIH1cbiAgY3VycmVudFN0cnVjdHVyZXNbaWRdID0gc3RydWN0dXJlO1xuICBzdHJ1Y3R1cmUucmVhZCA9IGNyZWF0ZVN0cnVjdHVyZVJlYWRlcihzdHJ1Y3R1cmUpO1xuICBsZXQgb2JqZWN0ID0ge307XG4gIGlmIChjdXJyZW50RGVjb2Rlci5rZXlNYXApIHtcbiAgICBmb3IgKGxldCBpID0gMiwgbCA9IGRlZmluaXRpb24ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZXQga2V5ID0gY3VycmVudERlY29kZXIuZGVjb2RlS2V5KHN0cnVjdHVyZVtpIC0gMl0pO1xuICAgICAgb2JqZWN0W3NhZmVLZXkoa2V5KV0gPSBkZWZpbml0aW9uW2ldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gMiwgbCA9IGRlZmluaXRpb24ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZXQga2V5ID0gc3RydWN0dXJlW2kgLSAyXTtcbiAgICAgIG9iamVjdFtzYWZlS2V5KGtleSldID0gZGVmaW5pdGlvbltpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn07XG5jdXJyZW50RXh0ZW5zaW9uc1tMRUdBQ1lfUkVDT1JEX0lOTElORV9JRF0gPSByZWNvcmREZWZpbml0aW9uO1xuY3VycmVudEV4dGVuc2lvbnNbMTRdID0gdmFsdWUgPT4ge1xuICBpZiAoYnVuZGxlZFN0cmluZ3MpIHtcbiAgICByZXR1cm4gYnVuZGxlZFN0cmluZ3NbMF0uc2xpY2UoYnVuZGxlZFN0cmluZ3MucG9zaXRpb24wLCBidW5kbGVkU3RyaW5ncy5wb3NpdGlvbjAgKz0gdmFsdWUpO1xuICB9XG4gIHJldHVybiBuZXcgVGFnKHZhbHVlLCAxNCk7XG59O1xuY3VycmVudEV4dGVuc2lvbnNbMTVdID0gdmFsdWUgPT4ge1xuICBpZiAoYnVuZGxlZFN0cmluZ3MpIHtcbiAgICByZXR1cm4gYnVuZGxlZFN0cmluZ3NbMV0uc2xpY2UoYnVuZGxlZFN0cmluZ3MucG9zaXRpb24xLCBidW5kbGVkU3RyaW5ncy5wb3NpdGlvbjEgKz0gdmFsdWUpO1xuICB9XG4gIHJldHVybiBuZXcgVGFnKHZhbHVlLCAxNSk7XG59O1xubGV0IGdsYmwgPSB7XG4gIEVycm9yLFxuICBSZWdFeHBcbn07XG5jdXJyZW50RXh0ZW5zaW9uc1syN10gPSBkYXRhID0+IHtcbiAgLy8gaHR0cDovL2Nib3Iuc2NobW9ycC5kZS9nZW5lcmljLW9iamVjdFxuICByZXR1cm4gKGdsYmxbZGF0YVswXV0gfHwgRXJyb3IpKGRhdGFbMV0sIGRhdGFbMl0pO1xufTtcbmNvbnN0IHBhY2tlZFRhYmxlID0gX3JlYWQgPT4ge1xuICBpZiAoc3JjW3Bvc2l0aW9uKytdICE9IDB4ODQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYWNrZWQgdmFsdWVzIHN0cnVjdHVyZSBtdXN0IGJlIGZvbGxvd2VkIGJ5IGEgNCBlbGVtZW50IGFycmF5XCIpO1xuICB9XG4gIGxldCBuZXdQYWNrZWRWYWx1ZXMgPSBfcmVhZCgpOyAvLyBwYWNrZWQgdmFsdWVzXG4gIHBhY2tlZFZhbHVlcyA9IHBhY2tlZFZhbHVlcyA/IG5ld1BhY2tlZFZhbHVlcy5jb25jYXQocGFja2VkVmFsdWVzLnNsaWNlKG5ld1BhY2tlZFZhbHVlcy5sZW5ndGgpKSA6IG5ld1BhY2tlZFZhbHVlcztcbiAgcGFja2VkVmFsdWVzLnByZWZpeGVzID0gX3JlYWQoKTtcbiAgcGFja2VkVmFsdWVzLnN1ZmZpeGVzID0gX3JlYWQoKTtcbiAgcmV0dXJuIF9yZWFkKCk7IC8vIHJlYWQgdGhlIHJ1bXBcbn07XG5cbnBhY2tlZFRhYmxlLmhhbmRsZXNSZWFkID0gdHJ1ZTtcbmN1cnJlbnRFeHRlbnNpb25zWzUxXSA9IHBhY2tlZFRhYmxlO1xuY3VycmVudEV4dGVuc2lvbnNbUEFDS0VEX1JFRkVSRU5DRV9UQUdfSURdID0gZGF0YSA9PiB7XG4gIC8vIHBhY2tlZCByZWZlcmVuY2VcbiAgaWYgKCFwYWNrZWRWYWx1ZXMpIHtcbiAgICBpZiAoY3VycmVudERlY29kZXIuZ2V0U2hhcmVkKSB7XG4gICAgICBsb2FkU2hhcmVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgVGFnKGRhdGEsIFBBQ0tFRF9SRUZFUkVOQ0VfVEFHX0lEKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHBhY2tlZFZhbHVlc1sxNiArIChkYXRhID49IDAgPyAyICogZGF0YSA6IC0yICogZGF0YSAtIDEpXTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdXBwb3J0IGZvciBub24taW50ZWdlciBwYWNrZWQgcmVmZXJlbmNlcyB5ZXRcIik7XG59O1xuY3VycmVudEV4dGVuc2lvbnNbMjVdID0gaWQgPT4ge1xuICByZXR1cm4gc3RyaW5nUmVmc1tpZF07XG59O1xuY3VycmVudEV4dGVuc2lvbnNbMjU2XSA9IF9yZWFkID0+IHtcbiAgc3RyaW5nUmVmcyA9IFtdO1xuICB0cnkge1xuICAgIHJldHVybiBfcmVhZCgpO1xuICB9IGZpbmFsbHkge1xuICAgIHN0cmluZ1JlZnMgPSBudWxsO1xuICB9XG59O1xuY3VycmVudEV4dGVuc2lvbnNbMjU2XS5oYW5kbGVzUmVhZCA9IHRydWU7XG5jdXJyZW50RXh0ZW5zaW9uc1syOF0gPSBfcmVhZCA9PiB7XG4gIC8vIHNoYXJlYWJsZSBodHRwOi8vY2Jvci5zY2htb3JwLmRlL3ZhbHVlLXNoYXJpbmcgKGZvciBzdHJ1Y3R1cmVkIGNsb25lcylcbiAgaWYgKCFyZWZlcmVuY2VNYXApIHtcbiAgICByZWZlcmVuY2VNYXAgPSBuZXcgTWFwKCk7XG4gICAgcmVmZXJlbmNlTWFwLmlkID0gMDtcbiAgfVxuICBsZXQgaWQgPSByZWZlcmVuY2VNYXAuaWQrKztcbiAgbGV0IHRva2VuID0gc3JjW3Bvc2l0aW9uXTtcbiAgbGV0IHRhcmdldDtcbiAgLy8gVE9ETzogaGFuZGxlIE1hcHMsIFNldHMsIGFuZCBvdGhlciB0eXBlcyB0aGF0IGNhbiBjeWNsZTsgdGhpcyBpcyBjb21wbGljYXRlZCwgYmVjYXVzZSB5b3UgcG90ZW50aWFsbHkgbmVlZCB0byByZWFkXG4gIC8vIGFoZWFkIHBhc3QgcmVmZXJlbmNlcyB0byByZWNvcmQgc3RydWN0dXJlIGRlZmluaXRpb25zXG4gIGlmICh0b2tlbiA+PiA1ID09IDQpIHtcbiAgICB0YXJnZXQgPSBbXTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSB7fTtcbiAgfVxuICBsZXQgcmVmRW50cnkgPSB7XG4gICAgdGFyZ2V0XG4gIH07IC8vIGEgcGxhY2Vob2xkZXIgb2JqZWN0XG4gIHJlZmVyZW5jZU1hcC5zZXQoaWQsIHJlZkVudHJ5KTtcbiAgbGV0IHRhcmdldFByb3BlcnRpZXMgPSBfcmVhZCgpOyAvLyByZWFkIHRoZSBuZXh0IHZhbHVlIGFzIHRoZSB0YXJnZXQgb2JqZWN0IHRvIGlkXG4gIGlmIChyZWZFbnRyeS51c2VkKSB7XG4gICAgLy8gdGhlcmUgaXMgYSBjeWNsZSwgc28gd2UgaGF2ZSB0byBhc3NpZ24gcHJvcGVydGllcyB0byBvcmlnaW5hbCB0YXJnZXRcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih0YXJnZXQsIHRhcmdldFByb3BlcnRpZXMpO1xuICB9XG4gIHJlZkVudHJ5LnRhcmdldCA9IHRhcmdldFByb3BlcnRpZXM7IC8vIHRoZSBwbGFjZWhvbGRlciB3YXNuJ3QgdXNlZCwgcmVwbGFjZSB3aXRoIHRoZSBkZXNlcmlhbGl6ZWQgb25lXG4gIHJldHVybiB0YXJnZXRQcm9wZXJ0aWVzOyAvLyBubyBjeWNsZSwgY2FuIGp1c3QgdXNlIHRoZSByZXR1cm5lZCByZWFkIG9iamVjdFxufTtcblxuY3VycmVudEV4dGVuc2lvbnNbMjhdLmhhbmRsZXNSZWFkID0gdHJ1ZTtcbmN1cnJlbnRFeHRlbnNpb25zWzI5XSA9IGlkID0+IHtcbiAgLy8gc2hhcmVkcmVmIGh0dHA6Ly9jYm9yLnNjaG1vcnAuZGUvdmFsdWUtc2hhcmluZyAoZm9yIHN0cnVjdHVyZWQgY2xvbmVzKVxuICBsZXQgcmVmRW50cnkgPSByZWZlcmVuY2VNYXAuZ2V0KGlkKTtcbiAgcmVmRW50cnkudXNlZCA9IHRydWU7XG4gIHJldHVybiByZWZFbnRyeS50YXJnZXQ7XG59O1xuY3VycmVudEV4dGVuc2lvbnNbMjU4XSA9IGFycmF5ID0+IG5ldyBTZXQoYXJyYXkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vaW5wdXQtb3V0cHV0LWhrL2Nib3Itc2V0cy1zcGVjL2Jsb2IvbWFzdGVyL0NCT1JfU0VUUy5tZFxuKGN1cnJlbnRFeHRlbnNpb25zWzI1OV0gPSBfcmVhZCA9PiB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaGFuZXdob2xsb3dheS9qcy1jYm9yLWNvZGVjL2Jsb2IvbWFzdGVyL2RvY3MvQ0JPUi0yNTktc3BlY1xuICAvLyBmb3IgZGVjb2RpbmcgYXMgYSBzdGFuZGFyZCBNYXBcbiAgaWYgKGN1cnJlbnREZWNvZGVyLm1hcHNBc09iamVjdHMpIHtcbiAgICBjdXJyZW50RGVjb2Rlci5tYXBzQXNPYmplY3RzID0gZmFsc2U7XG4gICAgcmVzdG9yZU1hcHNBc09iamVjdCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIF9yZWFkKCk7XG59KS5oYW5kbGVzUmVhZCA9IHRydWU7XG5mdW5jdGlvbiBjb21iaW5lKGEsIGIpIHtcbiAgaWYgKHR5cGVvZiBhID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGEgKyBiO1xuICB9XG4gIGlmIChhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGEsIGIpO1xufVxuZnVuY3Rpb24gZ2V0UGFja2VkVmFsdWVzKCkge1xuICBpZiAoIXBhY2tlZFZhbHVlcykge1xuICAgIGlmIChjdXJyZW50RGVjb2Rlci5nZXRTaGFyZWQpIHtcbiAgICAgIGxvYWRTaGFyZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcGFja2VkIHZhbHVlcyBhdmFpbGFibGVcIik7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYWNrZWRWYWx1ZXM7XG59XG5jb25zdCBTSEFSRURfREFUQV9UQUdfSUQgPSAweDUzNjg3MjY0OyAvLyBhc2NpaSAnU2hyZCdcbmN1cnJlbnRFeHRlbnNpb25SYW5nZXMucHVzaCgodGFnLCBpbnB1dCkgPT4ge1xuICBpZiAodGFnID49IDIyNSAmJiB0YWcgPD0gMjU1KSB7XG4gICAgcmV0dXJuIGNvbWJpbmUoZ2V0UGFja2VkVmFsdWVzKCkucHJlZml4ZXNbdGFnIC0gMjI0XSwgaW5wdXQpO1xuICB9XG4gIGlmICh0YWcgPj0gMjg3MDQgJiYgdGFnIDw9IDMyNzY3KSB7XG4gICAgcmV0dXJuIGNvbWJpbmUoZ2V0UGFja2VkVmFsdWVzKCkucHJlZml4ZXNbdGFnIC0gMjg2NzJdLCBpbnB1dCk7XG4gIH1cbiAgaWYgKHRhZyA+PSAxODc5MDUyMjg4ICYmIHRhZyA8PSAyMTQ3NDgzNjQ3KSB7XG4gICAgcmV0dXJuIGNvbWJpbmUoZ2V0UGFja2VkVmFsdWVzKCkucHJlZml4ZXNbdGFnIC0gMTg3OTA0ODE5Ml0sIGlucHV0KTtcbiAgfVxuICBpZiAodGFnID49IDIxNiAmJiB0YWcgPD0gMjIzKSB7XG4gICAgcmV0dXJuIGNvbWJpbmUoaW5wdXQsIGdldFBhY2tlZFZhbHVlcygpLnN1ZmZpeGVzW3RhZyAtIDIxNl0pO1xuICB9XG4gIGlmICh0YWcgPj0gMjc2NDcgJiYgdGFnIDw9IDI4NjcxKSB7XG4gICAgcmV0dXJuIGNvbWJpbmUoaW5wdXQsIGdldFBhY2tlZFZhbHVlcygpLnN1ZmZpeGVzW3RhZyAtIDI3NjM5XSk7XG4gIH1cbiAgaWYgKHRhZyA+PSAxODExOTQwMzUyICYmIHRhZyA8PSAxODc5MDQ4MTkxKSB7XG4gICAgcmV0dXJuIGNvbWJpbmUoaW5wdXQsIGdldFBhY2tlZFZhbHVlcygpLnN1ZmZpeGVzW3RhZyAtIDE4MTE5MzkzMjhdKTtcbiAgfVxuICBpZiAodGFnID09IFNIQVJFRF9EQVRBX1RBR19JRCkge1xuICAgIC8vIHdlIGRvIGEgc3BlY2lhbCBjaGVjayBmb3IgdGhpcyBzbyB0aGF0IHdlIGNhbiBrZWVwIHRoZSBjdXJyZW50RXh0ZW5zaW9ucyBhcyBkZW5zZWx5IHN0b3JlZCBhcnJheSAodjggc3RvcmVzIGFycmF5cyBkZW5zZWx5IHVuZGVyIGFib3V0IDMwMDAgZWxlbWVudHMpXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhY2tlZFZhbHVlczogcGFja2VkVmFsdWVzLFxuICAgICAgc3RydWN0dXJlczogY3VycmVudFN0cnVjdHVyZXMuc2xpY2UoMCksXG4gICAgICB2ZXJzaW9uOiBpbnB1dFxuICAgIH07XG4gIH1cbiAgaWYgKHRhZyA9PSA1NTc5OSkge1xuICAgIC8vIHNlbGYtZGVzY3JpcHRpdmUgQ0JPUiB0YWcsIGp1c3QgcmV0dXJuIGlucHV0IHZhbHVlXG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG59KTtcbmNvbnN0IGlzTGl0dGxlRW5kaWFuTWFjaGluZSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MTZBcnJheShbMV0pLmJ1ZmZlcilbMF0gPT0gMTtcbmNvbnN0IHR5cGVkQXJyYXlzID0gW1VpbnQ4QXJyYXldO1xuY29uc3QgdHlwZWRBcnJheVRhZ3MgPSBbNjRdO1xuZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlZEFycmF5cy5sZW5ndGg7IGkrKykge1xuICByZWdpc3RlclR5cGVkQXJyYXkodHlwZWRBcnJheXNbaV0sIHR5cGVkQXJyYXlUYWdzW2ldKTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyVHlwZWRBcnJheShUeXBlZEFycmF5LCB0YWcpIHtcbiAgbGV0IGR2TWV0aG9kID0gXCJnZXRcIiArIFR5cGVkQXJyYXkubmFtZS5zbGljZSgwLCAtNSk7XG4gIGlmICh0eXBlb2YgVHlwZWRBcnJheSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgVHlwZWRBcnJheSA9IG51bGw7XG4gIH1cbiAgbGV0IGJ5dGVzUGVyRWxlbWVudCA9IFR5cGVkQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gIGZvciAobGV0IGxpdHRsZUVuZGlhbiA9IDA7IGxpdHRsZUVuZGlhbiA8IDI7IGxpdHRsZUVuZGlhbisrKSB7XG4gICAgaWYgKCFsaXR0bGVFbmRpYW4gJiYgYnl0ZXNQZXJFbGVtZW50ID09IDEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgc2l6ZVNoaWZ0ID0gYnl0ZXNQZXJFbGVtZW50ID09IDIgPyAxIDogYnl0ZXNQZXJFbGVtZW50ID09IDQgPyAyIDogMztcbiAgICBjdXJyZW50RXh0ZW5zaW9uc1tsaXR0bGVFbmRpYW4gPyB0YWcgOiB0YWcgLSA0XSA9IGJ5dGVzUGVyRWxlbWVudCA9PSAxIHx8IGxpdHRsZUVuZGlhbiA9PSBpc0xpdHRsZUVuZGlhbk1hY2hpbmUgPyBidWZmZXIgPT4ge1xuICAgICAgaWYgKCFUeXBlZEFycmF5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHR5cGVkIGFycmF5IGZvciBjb2RlIFwiICsgdGFnKTtcbiAgICAgIH1cbiAgICAgIC8vIHdlIGhhdmUgdG8gYWx3YXlzIHNsaWNlL2NvcHkgaGVyZSB0byBnZXQgYSBuZXcgQXJyYXlCdWZmZXIgdGhhdCBpcyB3b3JkL2J5dGUgYWxpZ25lZFxuICAgICAgcmV0dXJuIG5ldyBUeXBlZEFycmF5KFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYnVmZmVyLCAwKS5idWZmZXIpO1xuICAgIH0gOiBidWZmZXIgPT4ge1xuICAgICAgaWYgKCFUeXBlZEFycmF5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHR5cGVkIGFycmF5IGZvciBjb2RlIFwiICsgdGFnKTtcbiAgICAgIH1cbiAgICAgIGxldCBkdiA9IG5ldyBEYXRhVmlldyhidWZmZXIuYnVmZmVyLCBidWZmZXIuYnl0ZU9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgbGV0IGVsZW1lbnRzID0gYnVmZmVyLmxlbmd0aCA+PiBzaXplU2hpZnQ7XG4gICAgICBsZXQgdGEgPSBuZXcgVHlwZWRBcnJheShlbGVtZW50cyk7XG4gICAgICBsZXQgbWV0aG9kID0gZHZbZHZNZXRob2RdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50czsgaSsrKSB7XG4gICAgICAgIHRhW2ldID0gbWV0aG9kLmNhbGwoZHYsIGkgPDwgc2l6ZVNoaWZ0LCBsaXR0bGVFbmRpYW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhO1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHJlYWRCdW5kbGVFeHQoKSB7XG4gIGxldCBsZW5ndGggPSByZWFkSnVzdExlbmd0aCgpO1xuICBsZXQgYnVuZGxlUG9zaXRpb24gPSBwb3NpdGlvbiArIHJlYWQoKTtcbiAgZm9yIChsZXQgaSA9IDI7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIC8vIHNraXAgcGFzdCBidW5kbGVzIHRoYXQgd2VyZSBhbHJlYWR5IHJlYWRcbiAgICBsZXQgYnVuZGxlTGVuZ3RoID0gcmVhZEp1c3RMZW5ndGgoKTsgLy8gdGhpcyB3aWxsIGluY3JlbWVudCBwb3NpdGlvbiwgc28gbXVzdCBhZGQgdG8gcG9zaXRpb24gYWZ0ZXJ3YXJkc1xuICAgIHBvc2l0aW9uICs9IGJ1bmRsZUxlbmd0aDtcbiAgfVxuICBsZXQgZGF0YVBvc2l0aW9uID0gcG9zaXRpb247XG4gIHBvc2l0aW9uID0gYnVuZGxlUG9zaXRpb247XG4gIGJ1bmRsZWRTdHJpbmdzID0gW3JlYWRTdHJpbmdKUyhyZWFkSnVzdExlbmd0aCgpKSwgcmVhZFN0cmluZ0pTKHJlYWRKdXN0TGVuZ3RoKCkpXTtcbiAgYnVuZGxlZFN0cmluZ3MucG9zaXRpb24wID0gMDtcbiAgYnVuZGxlZFN0cmluZ3MucG9zaXRpb24xID0gMDtcbiAgYnVuZGxlZFN0cmluZ3MucG9zdEJ1bmRsZVBvc2l0aW9uID0gcG9zaXRpb247XG4gIHBvc2l0aW9uID0gZGF0YVBvc2l0aW9uO1xuICByZXR1cm4gcmVhZCgpO1xufVxuZnVuY3Rpb24gcmVhZEp1c3RMZW5ndGgoKSB7XG4gIGxldCB0b2tlbiA9IHNyY1twb3NpdGlvbisrXSAmIDB4MWY7XG4gIGlmICh0b2tlbiA+IDB4MTcpIHtcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlIDB4MTg6XG4gICAgICAgIHRva2VuID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMHgxOTpcbiAgICAgICAgdG9rZW4gPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pO1xuICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMHgxYTpcbiAgICAgICAgdG9rZW4gPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24pO1xuICAgICAgICBwb3NpdGlvbiArPSA0O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRva2VuO1xufVxuZnVuY3Rpb24gbG9hZFNoYXJlZCgpIHtcbiAgaWYgKGN1cnJlbnREZWNvZGVyLmdldFNoYXJlZCkge1xuICAgIGxldCBzaGFyZWREYXRhID0gc2F2ZVN0YXRlKCgpID0+IHtcbiAgICAgIC8vIHNhdmUgdGhlIHN0YXRlIGluIGNhc2UgZ2V0U2hhcmVkIG1vZGlmaWVzIG91ciBidWZmZXJcbiAgICAgIHNyYyA9IG51bGw7XG4gICAgICByZXR1cm4gY3VycmVudERlY29kZXIuZ2V0U2hhcmVkKCk7XG4gICAgfSkgfHwge307XG4gICAgbGV0IHVwZGF0ZWRTdHJ1Y3R1cmVzID0gc2hhcmVkRGF0YS5zdHJ1Y3R1cmVzIHx8IFtdO1xuICAgIGN1cnJlbnREZWNvZGVyLnNoYXJlZFZlcnNpb24gPSBzaGFyZWREYXRhLnZlcnNpb247XG4gICAgcGFja2VkVmFsdWVzID0gY3VycmVudERlY29kZXIuc2hhcmVkVmFsdWVzID0gc2hhcmVkRGF0YS5wYWNrZWRWYWx1ZXM7XG4gICAgaWYgKGN1cnJlbnRTdHJ1Y3R1cmVzID09PSB0cnVlKSB7XG4gICAgICBjdXJyZW50RGVjb2Rlci5zdHJ1Y3R1cmVzID0gY3VycmVudFN0cnVjdHVyZXMgPSB1cGRhdGVkU3RydWN0dXJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFN0cnVjdHVyZXMuc3BsaWNlLmFwcGx5KGN1cnJlbnRTdHJ1Y3R1cmVzLCBbMCwgdXBkYXRlZFN0cnVjdHVyZXMubGVuZ3RoXS5jb25jYXQodXBkYXRlZFN0cnVjdHVyZXMpKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNhdmVTdGF0ZShjYWxsYmFjaykge1xuICBsZXQgc2F2ZWRTcmNFbmQgPSBzcmNFbmQ7XG4gIGxldCBzYXZlZFBvc2l0aW9uID0gcG9zaXRpb247XG4gIGxldCBzYXZlZFNyY1N0cmluZ1N0YXJ0ID0gc3JjU3RyaW5nU3RhcnQ7XG4gIGxldCBzYXZlZFNyY1N0cmluZ0VuZCA9IHNyY1N0cmluZ0VuZDtcbiAgbGV0IHNhdmVkU3JjU3RyaW5nID0gc3JjU3RyaW5nO1xuICBsZXQgc2F2ZWRSZWZlcmVuY2VNYXAgPSByZWZlcmVuY2VNYXA7XG4gIGxldCBzYXZlZEJ1bmRsZWRTdHJpbmdzID0gYnVuZGxlZFN0cmluZ3M7XG5cbiAgLy8gVE9ETzogV2UgbWF5IG5lZWQgdG8gcmV2aXNpdCB0aGlzIGlmIHdlIGRvIG1vcmUgZXh0ZXJuYWwgY2FsbHMgdG8gdXNlciBjb2RlIChzaW5jZSBpdCBjb3VsZCBiZSBzbG93KVxuICBsZXQgc2F2ZWRTcmMgPSBuZXcgVWludDhBcnJheShzcmMuc2xpY2UoMCwgc3JjRW5kKSk7IC8vIHdlIGNvcHkgdGhlIGRhdGEgaW4gY2FzZSBpdCBjaGFuZ2VzIHdoaWxlIGV4dGVybmFsIGRhdGEgaXMgcHJvY2Vzc2VkXG4gIGxldCBzYXZlZFN0cnVjdHVyZXMgPSBjdXJyZW50U3RydWN0dXJlcztcbiAgbGV0IHNhdmVkRGVjb2RlciA9IGN1cnJlbnREZWNvZGVyO1xuICBsZXQgc2F2ZWRTZXF1ZW50aWFsTW9kZSA9IHNlcXVlbnRpYWxNb2RlO1xuICBsZXQgdmFsdWUgPSBjYWxsYmFjaygpO1xuICBzcmNFbmQgPSBzYXZlZFNyY0VuZDtcbiAgcG9zaXRpb24gPSBzYXZlZFBvc2l0aW9uO1xuICBzcmNTdHJpbmdTdGFydCA9IHNhdmVkU3JjU3RyaW5nU3RhcnQ7XG4gIHNyY1N0cmluZ0VuZCA9IHNhdmVkU3JjU3RyaW5nRW5kO1xuICBzcmNTdHJpbmcgPSBzYXZlZFNyY1N0cmluZztcbiAgcmVmZXJlbmNlTWFwID0gc2F2ZWRSZWZlcmVuY2VNYXA7XG4gIGJ1bmRsZWRTdHJpbmdzID0gc2F2ZWRCdW5kbGVkU3RyaW5ncztcbiAgc3JjID0gc2F2ZWRTcmM7XG4gIHNlcXVlbnRpYWxNb2RlID0gc2F2ZWRTZXF1ZW50aWFsTW9kZTtcbiAgY3VycmVudFN0cnVjdHVyZXMgPSBzYXZlZFN0cnVjdHVyZXM7XG4gIGN1cnJlbnREZWNvZGVyID0gc2F2ZWREZWNvZGVyO1xuICBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCwgc3JjLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjbGVhclNvdXJjZSgpIHtcbiAgc3JjID0gbnVsbDtcbiAgcmVmZXJlbmNlTWFwID0gbnVsbDtcbiAgY3VycmVudFN0cnVjdHVyZXMgPSBudWxsO1xufVxuY29uc3QgbXVsdDEwID0gbmV3IEFycmF5KDE0Nyk7IC8vIHRoaXMgaXMgYSB0YWJsZSBtYXRjaGluZyBiaW5hcnkgZXhwb25lbnRzIHRvIHRoZSBtdWx0aXBsaWVyIHRvIGRldGVybWluZSBzaWduaWZpY2FudCBkaWdpdCByb3VuZGluZ1xuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICBtdWx0MTBbaV0gPSBOdW1iZXIoXCIxZVwiICsgTWF0aC5mbG9vcig0NS4xNSAtIGkgKiAwLjMwMTAzKSk7XG59XG5jb25zdCBkZWZhdWx0RGVjb2RlciA9IG5ldyBEZWNvZGVyKHtcbiAgdXNlUmVjb3JkczogZmFsc2Vcbn0pO1xuY29uc3QgZGVjb2RlID0gZGVmYXVsdERlY29kZXIuZGVjb2RlO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGFiaVxuICogQHBhcmFtIGZlYXR1cmVcbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc0FiaUludGVyZmFjZShhYmksIGZlYXR1cmUpIHtcbiAgLy8gcmV0dXJucyB0cnVlIGlmIGFsbCB0aGUgZnVuY3Rpb25zIGluIGBpbnRlcmZhY2VUb01hdGNoYCBhcmUgZm91bmQgaW4gYGNvbnRyYWN0YCAocmVtb3ZpbmcgYW55IGR1cGxpY2F0ZXMpXG4gIHJldHVybiBoYXNNYXRjaGluZ0FiaShhYmksIGZlYXR1cmUuYWJpcyk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gY29udHJhY3RXcmFwcGVyXG4gKiBAcGFyYW0gYWJpXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBtYXRjaGVzUHJlYnVpbHRBYmkoY29udHJhY3RXcmFwcGVyLCBhYmkpIHtcbiAgcmV0dXJuIGhhc01hdGNoaW5nQWJpKGNvbnRyYWN0V3JhcHBlci5hYmksIFthYmldKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBjb250cmFjdEFiaVxuICogQHBhcmFtIGZlYXR1cmVBYmlzXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBoYXNNYXRjaGluZ0FiaShjb250cmFjdEFiaSwgZmVhdHVyZUFiaXMpIHtcbiAgY29uc3QgY29udHJhY3RGbiA9IGV4dHJhY3RGdW5jdGlvbnNGcm9tQWJpKGNvbnRyYWN0QWJpKTtcbiAgY29uc3QgaW50ZXJmYWNlRm4gPSBmZWF0dXJlQWJpcy5mbGF0TWFwKGkgPT4gZXh0cmFjdEZ1bmN0aW9uc0Zyb21BYmkoaSkpO1xuICAvLyBtYXRjaCBldmVyeSBmdW5jdGlvbiBhbmQgdGhlaXIgYXJndW1lbnRzXG4gIGNvbnN0IGludGVyc2VjdGlvbiA9IGNvbnRyYWN0Rm4uZmlsdGVyKGZuID0+IHtcbiAgICBjb25zdCBtYXRjaCA9IGludGVyZmFjZUZuLmZpbmQoaUZuID0+IGlGbi5uYW1lID09PSBmbi5uYW1lICYmIGlGbi5pbnB1dHMubGVuZ3RoID09PSBmbi5pbnB1dHMubGVuZ3RoICYmIGlGbi5pbnB1dHMuZXZlcnkoKGksIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaS50eXBlID09PSBcInR1cGxlXCIgfHwgaS50eXBlID09PSBcInR1cGxlW11cIikge1xuICAgICAgICAvLyBjaGVjayB0aGF0IGFsbCBwcm9wZXJ0aWVzIGluIHRoZSB0dXBsZSBhcmUgdGhlIHNhbWUgdHlwZVxuICAgICAgICByZXR1cm4gaS50eXBlID09PSBmbi5pbnB1dHNbaW5kZXhdLnR5cGUgJiYgaS5jb21wb25lbnRzPy5ldmVyeSgoYywgY0luZGV4KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGMudHlwZSA9PT0gZm4uaW5wdXRzW2luZGV4XS5jb21wb25lbnRzPy5bY0luZGV4XT8udHlwZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaS50eXBlID09PSBmbi5pbnB1dHNbaW5kZXhdLnR5cGU7XG4gICAgfSkpO1xuICAgIHJldHVybiBtYXRjaCAhPT0gdW5kZWZpbmVkO1xuICB9KTtcbiAgcmV0dXJuIGludGVyc2VjdGlvbi5sZW5ndGggPT09IGludGVyZmFjZUZuLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdENvbnN0cnVjdG9yUGFyYW1zKHByZWRlcGxveU1ldGFkYXRhVXJpLCBzdG9yYWdlKSB7XG4gIGNvbnN0IG1ldGEgPSBhd2FpdCBmZXRjaFByZURlcGxveU1ldGFkYXRhKHByZWRlcGxveU1ldGFkYXRhVXJpLCBzdG9yYWdlKTtcbiAgcmV0dXJuIGV4dHJhY3RDb25zdHJ1Y3RvclBhcmFtc0Zyb21BYmkobWV0YS5hYmkpO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHByZWRlcGxveU1ldGFkYXRhVXJpXG4gKiBAcGFyYW0gc3RvcmFnZVxuICovXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0RnVuY3Rpb25zKHByZWRlcGxveU1ldGFkYXRhVXJpLCBzdG9yYWdlKSB7XG4gIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgZmV0Y2hQcmVEZXBsb3lNZXRhZGF0YShwcmVkZXBsb3lNZXRhZGF0YVVyaSwgc3RvcmFnZSk7XG4gIHJldHVybiBleHRyYWN0RnVuY3Rpb25zRnJvbUFiaShtZXRhZGF0YS5hYmksIG1ldGFkYXRhLm1ldGFkYXRhKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBuYW1lXG4gKiBAcGFyYW0gbWV0YWRhdGFcbiAqIEBwYXJhbSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21tZW50RnJvbU1ldGFkYXRhKG5hbWUsIG1ldGFkYXRhLCB0eXBlKSB7XG4gIHJldHVybiBtZXRhZGF0YT8ub3V0cHV0Py51c2VyZG9jPy5bdHlwZV0/LltPYmplY3Qua2V5cyhtZXRhZGF0YT8ub3V0cHV0Py51c2VyZG9jW3R5cGVdIHx8IHt9KS5maW5kKGZuID0+IGZuLmluY2x1ZGVzKG5hbWUgfHwgXCJ1bmtub3duXCIpKSB8fCBcIlwiXT8ubm90aWNlIHx8IG1ldGFkYXRhPy5vdXRwdXQ/LmRldmRvYz8uW3R5cGVdPy5bT2JqZWN0LmtleXMobWV0YWRhdGE/Lm91dHB1dD8uZGV2ZG9jW3R5cGVdIHx8IHt9KS5maW5kKGZuID0+IGZuLmluY2x1ZGVzKG5hbWUgfHwgXCJ1bmtub3duXCIpKSB8fCBcIlwiXT8uZGV0YWlscztcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGFiaVxuICogQHJldHVybnNcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29uc3RydWN0b3JQYXJhbXNGcm9tQWJpKGFiaSkge1xuICBmb3IgKGNvbnN0IGlucHV0IG9mIGFiaSkge1xuICAgIGlmIChpbnB1dC50eXBlID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgIHJldHVybiBpbnB1dC5pbnB1dHMgfHwgW107XG4gICAgfVxuICB9XG4gIHJldHVybiBbXTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGFiaVxuICogQHBhcmFtIGZ1bmN0aW9uTmFtZVxuICogQHJldHVybnNcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBleHRyYWN0RnVuY3Rpb25QYXJhbXNGcm9tQWJpKGFiaSwgZnVuY3Rpb25OYW1lKSB7XG4gIGZvciAoY29uc3QgaW5wdXQgb2YgYWJpKSB7XG4gICAgaWYgKGlucHV0LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJiBpbnB1dC5uYW1lID09PSBmdW5jdGlvbk5hbWUpIHtcbiAgICAgIHJldHVybiBpbnB1dC5pbnB1dHMgfHwgW107XG4gICAgfVxuICB9XG4gIHJldHVybiBbXTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBhYmlcbiAqIEBwYXJhbSBtZXRhZGF0YVxuICovXG5mdW5jdGlvbiBleHRyYWN0RnVuY3Rpb25zRnJvbUFiaShhYmksIG1ldGFkYXRhKSB7XG4gIGNvbnN0IGZ1bmN0aW9ucyA9IChhYmkgfHwgW10pLmZpbHRlcihlbCA9PiBlbC50eXBlID09PSBcImZ1bmN0aW9uXCIpO1xuICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgZm9yIChjb25zdCBmIG9mIGZ1bmN0aW9ucykge1xuICAgIGNvbnN0IGRvYyA9IGV4dHJhY3RDb21tZW50RnJvbU1ldGFkYXRhKGYubmFtZSwgbWV0YWRhdGEsIFwibWV0aG9kc1wiKTtcbiAgICBjb25zdCBhcmdzID0gZi5pbnB1dHM/Lm1hcChpID0+IGAke2kubmFtZSB8fCBcImtleVwifTogJHt0b0pTVHlwZShpKX1gKT8uam9pbihcIiwgXCIpIHx8IFwiXCI7XG4gICAgY29uc3QgZmFyZ3MgPSBhcmdzID8gYCwgJHthcmdzfWAgOiBcIlwiO1xuICAgIGNvbnN0IG91dCA9IGYub3V0cHV0cz8ubWFwKG8gPT4gdG9KU1R5cGUobywgdHJ1ZSkpPy5qb2luKFwiLCBcIik7XG4gICAgY29uc3QgcHJvbWlzZSA9IG91dCA/IGA6IFByb21pc2U8JHtvdXR9PmAgOiBgOiBQcm9taXNlPFRyYW5zYWN0aW9uUmVzdWx0PmA7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYGNvbnRyYWN0LmNhbGwoXCIke2YubmFtZX1cIiR7ZmFyZ3N9KSR7cHJvbWlzZX1gO1xuICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgIGlucHV0czogZi5pbnB1dHMgfHwgW10sXG4gICAgICBvdXRwdXRzOiBmLm91dHB1dHMgfHwgW10sXG4gICAgICBuYW1lOiBmLm5hbWUgfHwgXCJ1bmtub3duXCIsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IGYuc3RhdGVNdXRhYmlsaXR5IHx8IFwiXCIsXG4gICAgICBjb21tZW50OiBkb2NcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGFiaVxuICogQHBhcmFtIG1ldGFkYXRhXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHNGcm9tQWJpKGFiaSwgbWV0YWRhdGEpIHtcbiAgY29uc3QgZXZlbnRzID0gKGFiaSB8fCBbXSkuZmlsdGVyKGVsID0+IGVsLnR5cGUgPT09IFwiZXZlbnRcIik7XG4gIGNvbnN0IHBhcnNlZCA9IFtdO1xuICBmb3IgKGNvbnN0IGUgb2YgZXZlbnRzKSB7XG4gICAgY29uc3QgZG9jID0gZXh0cmFjdENvbW1lbnRGcm9tTWV0YWRhdGEoZS5uYW1lLCBtZXRhZGF0YSwgXCJldmVudHNcIik7XG4gICAgcGFyc2VkLnB1c2goe1xuICAgICAgaW5wdXRzOiBlLmlucHV0cyB8fCBbXSxcbiAgICAgIG91dHB1dHM6IGUub3V0cHV0cyB8fCBbXSxcbiAgICAgIG5hbWU6IGUubmFtZSB8fCBcInVua25vd25cIixcbiAgICAgIGNvbW1lbnQ6IGRvY1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG5mdW5jdGlvbiB0b0pTVHlwZShjb250cmFjdFR5cGUpIHtcbiAgbGV0IGlzUmV0dXJuVHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gIGxldCB3aXRoTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIGxldCBqc1R5cGUgPSBjb250cmFjdFR5cGUudHlwZTtcbiAgbGV0IGlzQXJyYXkgPSBmYWxzZTtcbiAgaWYgKGpzVHlwZS5lbmRzV2l0aChcIltdXCIpKSB7XG4gICAgaXNBcnJheSA9IHRydWU7XG4gICAganNUeXBlID0ganNUeXBlLnNsaWNlKDAsIC0yKTtcbiAgfVxuICBpZiAoanNUeXBlLnN0YXJ0c1dpdGgoXCJieXRlc1wiKSkge1xuICAgIGpzVHlwZSA9IFwiQnl0ZXNMaWtlXCI7XG4gIH1cbiAgaWYgKGpzVHlwZS5zdGFydHNXaXRoKFwidWludFwiKSB8fCBqc1R5cGUuc3RhcnRzV2l0aChcImludFwiKSkge1xuICAgIGpzVHlwZSA9IGlzUmV0dXJuVHlwZSA/IFwiQmlnTnVtYmVyXCIgOiBcIkJpZ051bWJlcmlzaFwiO1xuICB9XG4gIGlmIChqc1R5cGUuc3RhcnRzV2l0aChcImJvb2xcIikpIHtcbiAgICBqc1R5cGUgPSBcImJvb2xlYW5cIjtcbiAgfVxuICBpZiAoanNUeXBlID09PSBcImFkZHJlc3NcIikge1xuICAgIGpzVHlwZSA9IFwic3RyaW5nXCI7XG4gIH1cbiAgaWYgKGpzVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgaWYgKGNvbnRyYWN0VHlwZS5jb21wb25lbnRzKSB7XG4gICAgICBqc1R5cGUgPSBgeyAke2NvbnRyYWN0VHlwZS5jb21wb25lbnRzLm1hcChhID0+IHRvSlNUeXBlKGEsIGZhbHNlLCB0cnVlKSkuam9pbihcIiwgXCIpfSB9YDtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQXJyYXkpIHtcbiAgICBqc1R5cGUgKz0gXCJbXVwiO1xuICB9XG4gIGlmICh3aXRoTmFtZSkge1xuICAgIGpzVHlwZSA9IGAke2NvbnRyYWN0VHlwZS5uYW1lfTogJHtqc1R5cGV9YDtcbiAgfVxuICByZXR1cm4ganNUeXBlO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGJ5dGVjb2RlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RNaW5pbWFsUHJveHlJbXBsZW1lbnRhdGlvbkFkZHJlc3MoYnl0ZWNvZGUpIHtcbiAgLy8gRUlQLTExNjcgY2xvbmUgbWluaW1hbCBwcm94eSAtIGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTE2N1xuICBpZiAoYnl0ZWNvZGUuc3RhcnRzV2l0aChcIjB4MzYzZDNkMzczZDNkM2QzNjNkNzNcIikpIHtcbiAgICBjb25zdCBpbXBsZW1lbnRhdGlvbkFkZHJlc3MgPSBieXRlY29kZS5zbGljZSgyMiwgNjIpO1xuICAgIHJldHVybiBgMHgke2ltcGxlbWVudGF0aW9uQWRkcmVzc31gO1xuICB9XG5cbiAgLy8gTWluaW1hbCBQcm94eSB3aXRoIHJlY2VpdmUoKSBmcm9tIDB4U3BsaXRzIC0gaHR0cHM6Ly9naXRodWIuY29tLzB4U3BsaXRzL3NwbGl0cy1jb250cmFjdHMvYmxvYi9jN2I3NDE5MjZlYzk3NDYxODJkMGQxZTJjNGMyMDQ2MTAyZTVkMzM3L2NvbnRyYWN0cy9saWJyYXJpZXMvQ2xvbmVzLnNvbFxuICBpZiAoYnl0ZWNvZGUuc3RhcnRzV2l0aChcIjB4MzY2MDMwNTczNDNkNTIzMFwiKSkge1xuICAgIC8vICs0MCA9IHNpemUgb2YgYWRkclxuICAgIGNvbnN0IGltcGxlbWVudGF0aW9uQWRkcmVzcyA9IGJ5dGVjb2RlLnNsaWNlKDEyMiwgMTIyICsgNDApO1xuICAgIHJldHVybiBgMHgke2ltcGxlbWVudGF0aW9uQWRkcmVzc31gO1xuICB9XG5cbiAgLy8gMGFnZSdzIG1pbmltYWwgcHJveHkgLSBodHRwczovL21lZGl1bS5jb20vY29pbm1vbmtzL3RoZS1tb3JlLW1pbmltYWwtcHJveHktNTc1NmFlMDhlZTQ4XG4gIGlmIChieXRlY29kZS5zdGFydHNXaXRoKFwiMHgzZDNkM2QzZDM2M2QzZDM3MzYzZDczXCIpKSB7XG4gICAgLy8gKzQwID0gc2l6ZSBvZiBhZGRyXG4gICAgY29uc3QgaW1wbGVtZW50YXRpb25BZGRyZXNzID0gYnl0ZWNvZGUuc2xpY2UoMjQsIDI0ICsgNDApO1xuICAgIHJldHVybiBgMHgke2ltcGxlbWVudGF0aW9uQWRkcmVzc31gO1xuICB9XG5cbiAgLy8gdnlwZXIncyBtaW5pbWFsIHByb3h5ICh1bmlzd2FwIHYxKSAtIGh0dHBzOi8vZXRoZXJzY2FuLmlvL2FkZHJlc3MvMHgwOWNhYmVjMWVhZDFjMGJhMjU0YjA5ZWZiM2VlMTM4NDE3MTJiZTE0I2NvZGVcbiAgaWYgKGJ5dGVjb2RlLnN0YXJ0c1dpdGgoXCIweDM2NjAwMDYwMDAzNzYxMTAwMDYwMDAzNjYwMDA3M1wiKSkge1xuICAgIGNvbnN0IGltcGxlbWVudGF0aW9uQWRkcmVzcyA9IGJ5dGVjb2RlLnNsaWNlKDMyLCAzMiArIDQwKTtcbiAgICByZXR1cm4gYDB4JHtpbXBsZW1lbnRhdGlvbkFkZHJlc3N9YDtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGFkZHJlc3NcbiAqIEBwYXJhbSBwcm92aWRlclxuICovXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlQ29udHJhY3RVcmlGcm9tQWRkcmVzcyhhZGRyZXNzLCBwcm92aWRlcikge1xuICBjb25zdCBieXRlY29kZSA9IGF3YWl0IHByb3ZpZGVyLmdldENvZGUoYWRkcmVzcyk7XG4gIGlmIChieXRlY29kZSA9PT0gXCIweFwiKSB7XG4gICAgY29uc3QgY2hhaW4gPSBhd2FpdCBwcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb250cmFjdCBhdCAke2FkZHJlc3N9IGRvZXMgbm90IGV4aXN0IG9uIGNoYWluICcke2NoYWluLm5hbWV9JyAoY2hhaW5JZDogJHtjaGFpbi5jaGFpbklkfSlgKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGltcGxlbWVudGF0aW9uQWRkcmVzcyA9IGV4dHJhY3RNaW5pbWFsUHJveHlJbXBsZW1lbnRhdGlvbkFkZHJlc3MoYnl0ZWNvZGUpO1xuICAgIGlmIChpbXBsZW1lbnRhdGlvbkFkZHJlc3MpIHtcbiAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlQ29udHJhY3RVcmlGcm9tQWRkcmVzcyhpbXBsZW1lbnRhdGlvbkFkZHJlc3MsIHByb3ZpZGVyKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBpZ25vcmVcbiAgfVxuXG4gIC8vIEVJUC0xOTY3IHByb3h5IHN0b3JhZ2Ugc2xvdHMgLSBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTE5NjdcbiAgdHJ5IHtcbiAgICBjb25zdCBwcm94eVN0b3JhZ2UgPSBhd2FpdCBwcm92aWRlci5nZXRTdG9yYWdlQXQoYWRkcmVzcywgQmlnTnVtYmVyLmZyb20oXCIweDM2MDg5NGExM2JhMWEzMjEwNjY3YzgyODQ5MmRiOThkY2EzZTIwNzZjYzM3MzVhOTIwYTNjYTUwNWQzODJiYmNcIikpO1xuICAgIGNvbnN0IGltcGxlbWVudGF0aW9uQWRkcmVzcyA9IGV0aGVycy51dGlscy5oZXhTdHJpcFplcm9zKHByb3h5U3RvcmFnZSk7XG4gICAgaWYgKGltcGxlbWVudGF0aW9uQWRkcmVzcyAhPT0gXCIweFwiKSB7XG4gICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZUNvbnRyYWN0VXJpRnJvbUFkZHJlc3MoaW1wbGVtZW50YXRpb25BZGRyZXNzLCBwcm92aWRlcik7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gaWdub3JlXG4gIH1cbiAgLy8gVE9ETyBzdXBwb3J0IG90aGVyIHR5cGVzIG9mIHByb3hpZXNcbiAgcmV0dXJuIGF3YWl0IGV4dHJhY3RJUEZTSGFzaEZyb21CeXRlY29kZShieXRlY29kZSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gYnl0ZWNvZGVcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdElQRlNIYXNoRnJvbUJ5dGVjb2RlKGJ5dGVjb2RlKSB7XG4gIGNvbnN0IG51bWVyaWNCeXRlY29kZSA9IGhleFRvQnl0ZXMoYnl0ZWNvZGUpO1xuICBjb25zdCBjYm9yTGVuZ3RoID0gbnVtZXJpY0J5dGVjb2RlW251bWVyaWNCeXRlY29kZS5sZW5ndGggLSAyXSAqIDB4MTAwICsgbnVtZXJpY0J5dGVjb2RlW251bWVyaWNCeXRlY29kZS5sZW5ndGggLSAxXTtcbiAgY29uc3QgYnl0ZWNvZGVCdWZmZXIgPSBVaW50OEFycmF5LmZyb20obnVtZXJpY0J5dGVjb2RlLnNsaWNlKG51bWVyaWNCeXRlY29kZS5sZW5ndGggLSAyIC0gY2Jvckxlbmd0aCwgLTIpKTtcbiAgY29uc3QgY2JvckRhdGEgPSBkZWNvZGUoYnl0ZWNvZGVCdWZmZXIpO1xuICBpZiAoXCJpcGZzXCIgaW4gY2JvckRhdGEgJiYgY2JvckRhdGFbXCJpcGZzXCJdKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBgaXBmczovLyR7YnM1OC5lbmNvZGUoY2JvckRhdGFbXCJpcGZzXCJdKX1gO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcImZlYXR1cmUtZGV0ZWN0aW9uIGlwZnMgY2JvciBmYWlsZWRcIiwgZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gaGV4XG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gIGhleCA9IGhleC50b1N0cmluZygxNik7XG4gIGlmICghaGV4LnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgIGhleCA9IGAweCR7aGV4fWA7XG4gIH1cbiAgaWYgKCFpc0hleFN0cmljdChoZXgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBHaXZlbiB2YWx1ZSBcIiR7aGV4fVwiIGlzIG5vdCBhIHZhbGlkIGhleCBzdHJpbmcuYCk7XG4gIH1cbiAgaGV4ID0gaGV4LnJlcGxhY2UoL14weC9pLCBcIlwiKTtcbiAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgZm9yIChsZXQgYyA9IDA7IGMgPCBoZXgubGVuZ3RoOyBjICs9IDIpIHtcbiAgICBieXRlcy5wdXNoKHBhcnNlSW50KGhleC5zbGljZShjLCBjICsgMiksIDE2KSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGhleFxuICovXG5mdW5jdGlvbiBpc0hleFN0cmljdChoZXgpIHtcbiAgcmV0dXJuICh0eXBlb2YgaGV4ID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBoZXggPT09IFwibnVtYmVyXCIpICYmIC9eKC0pPzB4WzAtOWEtZl0qJC9pLnRlc3QoaGV4LnRvU3RyaW5nKCkpO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGFkZHJlc3NcbiAqIEBwYXJhbSBwcm92aWRlclxuICogQHBhcmFtIHN0b3JhZ2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hDb250cmFjdE1ldGFkYXRhRnJvbUFkZHJlc3MoYWRkcmVzcywgcHJvdmlkZXIsIHN0b3JhZ2UpIHtcbiAgY29uc3QgY29tcGlsZXJNZXRhZGF0YVVyaSA9IGF3YWl0IHJlc29sdmVDb250cmFjdFVyaUZyb21BZGRyZXNzKGFkZHJlc3MsIHByb3ZpZGVyKTtcbiAgaWYgKCFjb21waWxlck1ldGFkYXRhVXJpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcmVzb2x2ZSBtZXRhZGF0YSBmb3IgY29udHJhY3QgYXQgJHthZGRyZXNzfWApO1xuICB9XG4gIHJldHVybiBhd2FpdCBmZXRjaENvbnRyYWN0TWV0YWRhdGEoY29tcGlsZXJNZXRhZGF0YVVyaSwgc3RvcmFnZSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gY29tcGlsZXJNZXRhZGF0YVVyaVxuICogQHBhcmFtIHN0b3JhZ2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hDb250cmFjdE1ldGFkYXRhKGNvbXBpbGVyTWV0YWRhdGFVcmksIHN0b3JhZ2UpIHtcbiAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBzdG9yYWdlLmRvd25sb2FkSlNPTihjb21waWxlck1ldGFkYXRhVXJpKTtcbiAgY29uc3QgYWJpID0gQWJpU2NoZW1hLnBhcnNlKG1ldGFkYXRhLm91dHB1dC5hYmkpO1xuICBjb25zdCBjb21waWxhdGlvblRhcmdldCA9IG1ldGFkYXRhLnNldHRpbmdzLmNvbXBpbGF0aW9uVGFyZ2V0O1xuICBjb25zdCB0YXJnZXRzID0gT2JqZWN0LmtleXMoY29tcGlsYXRpb25UYXJnZXQpO1xuICBjb25zdCBuYW1lID0gY29tcGlsYXRpb25UYXJnZXRbdGFyZ2V0c1swXV07XG4gIGNvbnN0IGluZm8gPSBDb250cmFjdEluZm9TY2hlbWEucGFyc2Uoe1xuICAgIHRpdGxlOiBtZXRhZGF0YS5vdXRwdXQuZGV2ZG9jLnRpdGxlLFxuICAgIGF1dGhvcjogbWV0YWRhdGEub3V0cHV0LmRldmRvYy5hdXRob3IsXG4gICAgZGV0YWlsczogbWV0YWRhdGEub3V0cHV0LmRldmRvYy5kZXRhaWwsXG4gICAgbm90aWNlOiBtZXRhZGF0YS5vdXRwdXQudXNlcmRvYy5ub3RpY2VcbiAgfSk7XG4gIGNvbnN0IGxpY2Vuc2VzID0gWy4uLm5ldyBTZXQoT2JqZWN0LmVudHJpZXMobWV0YWRhdGEuc291cmNlcykubWFwKF9yZWYgPT4ge1xuICAgIGxldCBbLCBzcmNdID0gX3JlZjtcbiAgICByZXR1cm4gc3JjLmxpY2Vuc2U7XG4gIH0pKV07XG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBhYmksXG4gICAgbWV0YWRhdGEsXG4gICAgaW5mbyxcbiAgICBsaWNlbnNlc1xuICB9O1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHB1Ymxpc2hlZE1ldGFkYXRhXG4gKiBAcGFyYW0gc3RvcmFnZVxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaFNvdXJjZUZpbGVzRnJvbU1ldGFkYXRhKHB1Ymxpc2hlZE1ldGFkYXRhLCBzdG9yYWdlKSB7XG4gIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyhwdWJsaXNoZWRNZXRhZGF0YS5tZXRhZGF0YS5zb3VyY2VzKS5tYXAoYXN5bmMgX3JlZjIgPT4ge1xuICAgIGxldCBbcGF0aCwgaW5mb10gPSBfcmVmMjtcbiAgICBjb25zdCB1cmxzID0gaW5mby51cmxzO1xuICAgIGNvbnN0IGlwZnNMaW5rID0gdXJscyA/IHVybHMuZmluZCh1cmwgPT4gdXJsLmluY2x1ZGVzKFwiaXBmc1wiKSkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGlwZnNMaW5rKSB7XG4gICAgICBjb25zdCBpcGZzSGFzaCA9IGlwZnNMaW5rLnNwbGl0KFwiaXBmcy9cIilbMV07XG4gICAgICAvLyA1IHNlYyB0aW1lb3V0IGZvciBzb3VyY2VzIHRoYXQgaGF2ZW4ndCBiZWVuIHVwbG9hZGVkIHRvIGlwZnNcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBuZXcgUHJvbWlzZSgoX3IsIHJlaikgPT4gc2V0VGltZW91dCgoKSA9PiByZWooXCJ0aW1lb3V0XCIpLCA1MDAwKSk7XG4gICAgICBjb25zdCBzb3VyY2UgPSBhd2FpdCBQcm9taXNlLnJhY2UoWyhhd2FpdCBzdG9yYWdlLmRvd25sb2FkKGBpcGZzOi8vJHtpcGZzSGFzaH1gKSkudGV4dCgpLCB0aW1lb3V0XSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmaWxlbmFtZTogcGF0aCxcbiAgICAgICAgc291cmNlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmaWxlbmFtZTogcGF0aCxcbiAgICAgICAgc291cmNlOiBpbmZvLmNvbnRlbnQgfHwgXCJDb3VsZCBub3QgZmluZCBzb3VyY2UgZm9yIHRoaXMgY29udHJhY3RcIlxuICAgICAgfTtcbiAgICB9XG4gIH0pKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBwdWJsaXNoTWV0YWRhdGFVcmlcbiAqIEBwYXJhbSBzdG9yYWdlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoUmF3UHJlZGVwbG95TWV0YWRhdGEocHVibGlzaE1ldGFkYXRhVXJpLCBzdG9yYWdlKSB7XG4gIHJldHVybiBQcmVEZXBsb3lNZXRhZGF0YS5wYXJzZShKU09OLnBhcnNlKGF3YWl0IChhd2FpdCBzdG9yYWdlLmRvd25sb2FkKHB1Ymxpc2hNZXRhZGF0YVVyaSkpLnRleHQoKSkpO1xufVxuXG4vKipcbiAqIEZldGNoIHRoZSBtZXRhZGF0YSBjb21pbmcgZnJvbSBDTEksIHRoaXMgaXMgYmVmb3JlIGRlcGxveWluZyBvciByZWxlYXNpbmcgdGhlIGNvbnRyYWN0LlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gcHVibGlzaE1ldGFkYXRhVXJpXG4gKiBAcGFyYW0gc3RvcmFnZVxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaFByZURlcGxveU1ldGFkYXRhKHB1Ymxpc2hNZXRhZGF0YVVyaSwgc3RvcmFnZSkge1xuICBjb25zdCByYXdNZXRhID0gYXdhaXQgZmV0Y2hSYXdQcmVkZXBsb3lNZXRhZGF0YShwdWJsaXNoTWV0YWRhdGFVcmksIHN0b3JhZ2UpO1xuICBjb25zdCBkZXBsb3lCeXRlY29kZSA9IGF3YWl0IChhd2FpdCBzdG9yYWdlLmRvd25sb2FkKHJhd01ldGEuYnl0ZWNvZGVVcmkpKS50ZXh0KCk7XG4gIGNvbnN0IHBhcnNlZE1ldGEgPSBhd2FpdCBmZXRjaENvbnRyYWN0TWV0YWRhdGEocmF3TWV0YS5tZXRhZGF0YVVyaSwgc3RvcmFnZSk7XG4gIHJldHVybiBQcmVEZXBsb3lNZXRhZGF0YUZldGNoZWRTY2hlbWEucGFyc2Uoe1xuICAgIC4uLnJhd01ldGEsXG4gICAgLi4ucGFyc2VkTWV0YSxcbiAgICBieXRlY29kZTogZGVwbG95Qnl0ZWNvZGVcbiAgfSk7XG59XG5cbi8qKlxuICogRmV0Y2ggYW5kIHBhcnNlIHRoZSBmdWxsIG1ldGFkYXRhIEFGVEVSIGNyZWF0aW5nIGEgcmVsZWFzZSwgd2l0aCBhbGwgdGhlIGV4dHJhIGluZm9ybWF0aW9uICh2ZXJzaW9uLCByZWFkbWUsIGV0YylcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHB1Ymxpc2hNZXRhZGF0YVVyaVxuICogQHBhcmFtIHN0b3JhZ2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hFeHRlbmRlZFJlbGVhc2VNZXRhZGF0YShwdWJsaXNoTWV0YWRhdGFVcmksIHN0b3JhZ2UpIHtcbiAgY29uc3QgbWV0YSA9IGF3YWl0IChhd2FpdCBzdG9yYWdlLmRvd25sb2FkKHB1Ymxpc2hNZXRhZGF0YVVyaSkpLnRleHQoKTtcbiAgcmV0dXJuIEZ1bGxQdWJsaXNoTWV0YWRhdGFTY2hlbWFPdXRwdXQucGFyc2UoSlNPTi5wYXJzZShtZXRhKSk7XG59XG5cbi8qKlxuICogUHJvY2Vzc2VzIEFMTCBzdXBwb3J0ZWQgZmVhdHVyZXMgYW5kIHNldHMgd2hldGhlciB0aGUgcGFzc2VkIGluIGFiaSBzdXBwb3J0cyBlYWNoIGluZGl2aWR1YWwgZmVhdHVyZVxuICogQGludGVybmFsXG4gKiBAcGFyYW0gYWJpXG4gKiBAcGFyYW0gZmVhdHVyZXNcbiAqIEByZXR1cm5zIHRoZSBuZXN0ZWQgc3RydWN0IG9mIGFsbCBmZWF0dXJlcyBhbmQgd2hldGhlciB0aGV5J3JlIGRldGVjdGVkIGluIHRoZSBhYmlcbiAqL1xuZnVuY3Rpb24gZGV0ZWN0RmVhdHVyZXMoYWJpKSB7XG4gIGxldCBmZWF0dXJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogU1VQUE9SVEVEX0ZFQVRVUkVTO1xuICBjb25zdCByZXN1bHRzID0ge307XG4gIGZvciAoY29uc3QgZmVhdHVyZUtleSBpbiBmZWF0dXJlcykge1xuICAgIGNvbnN0IGZlYXR1cmUgPSBmZWF0dXJlc1tmZWF0dXJlS2V5XTtcbiAgICBjb25zdCBlbmFibGVkID0gbWF0Y2hlc0FiaUludGVyZmFjZShhYmksIGZlYXR1cmUpO1xuICAgIGNvbnN0IGNoaWxkUmVzdWx0cyA9IGRldGVjdEZlYXR1cmVzKGFiaSwgZmVhdHVyZS5mZWF0dXJlcyk7XG4gICAgcmVzdWx0c1tmZWF0dXJlS2V5XSA9IHtcbiAgICAgIC4uLmZlYXR1cmUsXG4gICAgICBmZWF0dXJlczogY2hpbGRSZXN1bHRzLFxuICAgICAgZW5hYmxlZFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5mdW5jdGlvbiBleHRyYWN0RmVhdHVyZXMoaW5wdXQsIGVuYWJsZWRFeHRlbnNpb25zKSB7XG4gIGlmICghaW5wdXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChjb25zdCBleHRlbnNpb25LZXkgaW4gaW5wdXQpIHtcbiAgICBjb25zdCBleHRlbnNpb24gPSBpbnB1dFtleHRlbnNpb25LZXldO1xuICAgIC8vIGlmIGV4dGVuc2lvbiBpcyBlbmFibGVkLCB0aGVuIGFkZCBpdCB0byBlbmFibGVkRmVhdHVyZXNcbiAgICBpZiAoZXh0ZW5zaW9uLmVuYWJsZWQpIHtcbiAgICAgIGVuYWJsZWRFeHRlbnNpb25zLnB1c2goZXh0ZW5zaW9uKTtcbiAgICB9XG4gICAgLy8gcmVjdXJzZVxuICAgIGV4dHJhY3RGZWF0dXJlcyhleHRlbnNpb24uZmVhdHVyZXMsIGVuYWJsZWRFeHRlbnNpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiBhbGwgdGhlIGRldGVjdGVkIGZlYXR1cmVzIGluIHRoZSBhYmlcbiAqIEBwYXJhbSBhYmkgLSBwYXJzZWQgYXJyYXkgb2YgYWJpIGVudHJpZXNcbiAqIEByZXR1cm5zIGFycmF5IG9mIGFsbCBkZXRlY3RlZCBleHRlbnNpb25zIHdpdGggZnVsbCBpbmZvcm1hdGlvbiBvbiBlYWNoIGZlYXR1cmVcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZ2V0QWxsRGV0ZWN0ZWRGZWF0dXJlcyhhYmkpIHtcbiAgY29uc3QgZmVhdHVyZXMgPSBbXTtcbiAgZXh0cmFjdEZlYXR1cmVzKGRldGVjdEZlYXR1cmVzKGFiaSksIGZlYXR1cmVzKTtcbiAgcmV0dXJuIGZlYXR1cmVzO1xufVxuXG4vKipcbiAqIFJldHVybiBhbGwgdGhlIGRldGVjdGVkIGZlYXR1cmVzIG5hbWVzIGluIHRoZSBhYmlcbiAqIEBwYXJhbSBhYmkgLSBwYXJzZWQgYXJyYXkgb2YgYWJpIGVudHJpZXNcbiAqIEByZXR1cm5zIGFycmF5IG9mIGFsbCBkZXRlY3RlZCBmZWF0dXJlcyBuYW1lc1xuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBnZXRBbGxEZXRlY3RlZEZlYXR1cmVOYW1lcyhhYmkpIHtcbiAgY29uc3QgZmVhdHVyZXMgPSBbXTtcbiAgZXh0cmFjdEZlYXR1cmVzKGRldGVjdEZlYXR1cmVzKGFiaSksIGZlYXR1cmVzKTtcbiAgcmV0dXJuIGZlYXR1cmVzLm1hcChmID0+IGYubmFtZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIEFCSSBzdXBwb3J0cyBhIGdpdmVuIGZlYXR1cmVcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGFiaVxuICogQHBhcmFtIGZlYXR1cmVOYW1lXG4gKi9cbmZ1bmN0aW9uIGlzRmVhdHVyZUVuYWJsZWQoYWJpLCBmZWF0dXJlTmFtZSkge1xuICBjb25zdCBmZWF0dXJlcyA9IGRldGVjdEZlYXR1cmVzKGFiaSk7XG4gIHJldHVybiBfZmVhdHVyZUVuYWJsZWQoZmVhdHVyZXMsIGZlYXR1cmVOYW1lKTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gRGV0ZWN0YWJsZUZlYXR1cmUgaXMgZGVmaW5lZFxuICogQGludGVybmFsXG4gKiBAcGFyYW0gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2UgdG8gY2hlY2tcbiAqIEBwYXJhbSBmZWF0dXJlIFRoZSBjb3JyZXNwb25kaW5nIGZlYXR1cmVcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0RW5hYmxlZChuYW1lc3BhY2UsIGZlYXR1cmUpIHtcbiAgaWYgKCFuYW1lc3BhY2UpIHtcbiAgICB0aHJvdyBuZXcgRXh0ZW5zaW9uTm90SW1wbGVtZW50ZWRFcnJvcihmZWF0dXJlKTtcbiAgfVxuICByZXR1cm4gbmFtZXNwYWNlO1xufVxuXG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIGNvbnRyYWN0V3JhcHBlcnMgZGVwZW5kaW5nIG9uIHBhc3NlZCBmZWF0dXJlIG5hbWVcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGNvbnRyYWN0V3JhcHBlclxuICogQHBhcmFtIGZlYXR1cmVOYW1lXG4gKi9cbmZ1bmN0aW9uIGRldGVjdENvbnRyYWN0RmVhdHVyZShjb250cmFjdFdyYXBwZXIsIGZlYXR1cmVOYW1lKSB7XG4gIHJldHVybiBpc0ZlYXR1cmVFbmFibGVkKEFiaVNjaGVtYS5wYXJzZShjb250cmFjdFdyYXBwZXIuYWJpKSwgZmVhdHVyZU5hbWUpO1xufVxuXG4vKipcbiAqIFNlYXJjaGVzIHRoZSBmZWF0dXJlIG1hcCBmb3IgZmVhdHVyZU5hbWUgYW5kIHJldHVybnMgd2hldGhlciBpdHMgZW5hYmxlZFxuICogQGludGVybmFsXG4gKiBAcGFyYW0gZmVhdHVyZXNcbiAqIEBwYXJhbSBmZWF0dXJlTmFtZVxuICovXG5mdW5jdGlvbiBfZmVhdHVyZUVuYWJsZWQoZmVhdHVyZXMsIGZlYXR1cmVOYW1lKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmZWF0dXJlcyk7XG4gIGlmICgha2V5cy5pbmNsdWRlcyhmZWF0dXJlTmFtZSkpIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBjb25zdCBmID0gZmVhdHVyZXNba2V5XTtcbiAgICAgIGZvdW5kID0gX2ZlYXR1cmVFbmFibGVkKGYuZmVhdHVyZXMsIGZlYXR1cmVOYW1lKTtcbiAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9XG4gIGNvbnN0IGZlYXR1cmUgPSBmZWF0dXJlc1tmZWF0dXJlTmFtZV07XG4gIHJldHVybiBmZWF0dXJlLmVuYWJsZWQ7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gY29udHJhY3RXcmFwcGVyXG4gKiBAcGFyYW0gZnVuY3Rpb25OYW1lXG4gKi9cbmZ1bmN0aW9uIGhhc0Z1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgY29udHJhY3RXcmFwcGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgaW4gY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5mdW5jdGlvbnM7XG59XG5cbmNvbnN0IE1BWF9MRU5HVEggPSAyNTY7XG5jb25zdCBOVU1FUklDX0lERU5USUZJRVIgPSBcIjB8WzEtOV1cXFxcZCpcIjtcbmNvbnN0IE1BSU5fVkVSU0lPTl9JREVOVElGSUVSID0gYCgke05VTUVSSUNfSURFTlRJRklFUn0pXFxcXC4oJHtOVU1FUklDX0lERU5USUZJRVJ9KVxcXFwuKCR7TlVNRVJJQ19JREVOVElGSUVSfSlgO1xuY29uc3QgUkVHRVhfTUFJTl9WRVJTSU9OID0gbmV3IFJlZ0V4cChNQUlOX1ZFUlNJT05fSURFTlRJRklFUik7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB2ZXJzaW9uXG4gKi9cbmZ1bmN0aW9uIHRvU2VtdmVyKHZlcnNpb24pIHtcbiAgaWYgKHZlcnNpb24ubGVuZ3RoID4gTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgdmVyc2lvbiBpcyBsb25nZXIgdGhhbiAke01BWF9MRU5HVEh9IGNoYXJhY3RlcnNgKTtcbiAgfVxuICBjb25zdCBtYXRjaGVzID0gdmVyc2lvbi50cmltKCkubWF0Y2goUkVHRVhfTUFJTl9WRVJTSU9OKTtcbiAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXM/Lmxlbmd0aCAhPT0gNCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt2ZXJzaW9ufSBpcyBub3QgYSB2YWxpZCBzZW1hbnRpYyB2ZXJzaW9uLiBTaG91bGQgYmUgaW4gdGhlIGZvcm1hdCBvZiBtYWpvci5taW5vci5wYXRjaC4gRXg6IDAuNC4xYCk7XG4gIH1cbiAgY29uc3QgbWFqb3IgPSBOdW1iZXIobWF0Y2hlc1sxXSk7XG4gIGNvbnN0IG1pbm9yID0gTnVtYmVyKG1hdGNoZXNbMl0pO1xuICBjb25zdCBwYXRjaCA9IE51bWJlcihtYXRjaGVzWzNdKTtcbiAgY29uc3QgdmVyc2lvblN0cmluZyA9IFttYWpvciwgbWlub3IsIHBhdGNoXS5qb2luKFwiLlwiKTtcbiAgcmV0dXJuIHtcbiAgICBtYWpvcixcbiAgICBtaW5vcixcbiAgICBwYXRjaCxcbiAgICB2ZXJzaW9uU3RyaW5nXG4gIH07XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gY3VycmVudFxuICogQHBhcmFtIG5leHRcbiAqL1xuZnVuY3Rpb24gaXNJbmNyZW1lbnRhbFZlcnNpb24oY3VycmVudCwgbmV4dCkge1xuICBjb25zdCBjdXJyZW50U2VtdmVyID0gdG9TZW12ZXIoY3VycmVudCk7XG4gIGNvbnN0IG5leHRTZW12ZXIgPSB0b1NlbXZlcihuZXh0KTtcbiAgaWYgKG5leHRTZW12ZXIubWFqb3IgPiBjdXJyZW50U2VtdmVyLm1ham9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgZXFNYWpvciA9IG5leHRTZW12ZXIubWFqb3IgPT09IGN1cnJlbnRTZW12ZXIubWFqb3I7XG4gIGlmIChlcU1ham9yICYmIG5leHRTZW12ZXIubWlub3IgPiBjdXJyZW50U2VtdmVyLm1pbm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgZXFNaW5vciA9IG5leHRTZW12ZXIubWlub3IgPT09IGN1cnJlbnRTZW12ZXIubWlub3I7XG4gIHJldHVybiBlcU1ham9yICYmIGVxTWlub3IgJiYgbmV4dFNlbXZlci5wYXRjaCA+IGN1cnJlbnRTZW12ZXIucGF0Y2g7XG59XG5mdW5jdGlvbiBpc0Rvd25ncmFkZVZlcnNpb24oY3VycmVudCwgbmV4dCkge1xuICBjb25zdCBjdXJyZW50U2VtdmVyID0gdG9TZW12ZXIoY3VycmVudCk7XG4gIGNvbnN0IG5leHRTZW12ZXIgPSB0b1NlbXZlcihuZXh0KTtcbiAgaWYgKG5leHRTZW12ZXIubWFqb3IgPCBjdXJyZW50U2VtdmVyLm1ham9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgZXFNYWpvciA9IG5leHRTZW12ZXIubWFqb3IgPT09IGN1cnJlbnRTZW12ZXIubWFqb3I7XG4gIGlmIChlcU1ham9yICYmIG5leHRTZW12ZXIubWlub3IgPCBjdXJyZW50U2VtdmVyLm1pbm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgZXFNaW5vciA9IG5leHRTZW12ZXIubWlub3IgPT09IGN1cnJlbnRTZW12ZXIubWlub3I7XG4gIHJldHVybiBlcU1ham9yICYmIGVxTWlub3IgJiYgbmV4dFNlbXZlci5wYXRjaCA8IGN1cnJlbnRTZW12ZXIucGF0Y2g7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEJZT0NDb250cmFjdE1ldGFkYXRhU2NoZW1hID0gQ29tbW9uQ29udHJhY3RTY2hlbWEuY2F0Y2hhbGwoei51bmlvbihbQmlnTnVtYmVyVHJhbnNmb3JtU2NoZW1hLCB6LnVua25vd24oKV0pKTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBDdXN0b21Db250cmFjdElucHV0ID0gQllPQ0NvbnRyYWN0TWV0YWRhdGFTY2hlbWEubWVyZ2UoQ29tbW9uUm95YWx0eVNjaGVtYS5tZXJnZShNZXJrbGVTY2hlbWEpLm1lcmdlKENvbW1vblN5bWJvbFNjaGVtYSkucGFydGlhbCgpKTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQ3VzdG9tQ29udHJhY3RPdXRwdXQgPSBDb21tb25Db250cmFjdE91dHB1dFNjaGVtYS5tZXJnZShDb21tb25Sb3lhbHR5U2NoZW1hLm1lcmdlKE1lcmtsZVNjaGVtYSkubWVyZ2UoQ29tbW9uU3ltYm9sU2NoZW1hKS5wYXJ0aWFsKCkpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBDdXN0b21Db250cmFjdERlcGxveSA9IEN1c3RvbUNvbnRyYWN0SW5wdXQubWVyZ2UoQ29tbW9uUGxhdGZvcm1GZWVTY2hlbWEubWVyZ2UoQ29tbW9uUHJpbWFyeVNhbGVTY2hlbWEpLm1lcmdlKENvbW1vblRydXN0ZWRGb3J3YXJkZXJTY2hlbWEpLnBhcnRpYWwoKSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEN1c3RvbUNvbnRyYWN0U2NoZW1hID0ge1xuICBkZXBsb3k6IEN1c3RvbUNvbnRyYWN0RGVwbG95LFxuICBvdXRwdXQ6IEN1c3RvbUNvbnRyYWN0T3V0cHV0LFxuICBpbnB1dDogQ3VzdG9tQ29udHJhY3RJbnB1dFxufTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQWJpVHlwZUJhc2VTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHR5cGU6IHouc3RyaW5nKCksXG4gIG5hbWU6IHouc3RyaW5nKClcbn0pLmNhdGNoYWxsKHouYW55KCkpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBBYmlUeXBlU2NoZW1hID0gQWJpVHlwZUJhc2VTY2hlbWEuZXh0ZW5kKHtcbiAgc3RhdGVNdXRhYmlsaXR5OiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGNvbXBvbmVudHM6IHouYXJyYXkoQWJpVHlwZUJhc2VTY2hlbWEpLm9wdGlvbmFsKClcbn0pLmNhdGNoYWxsKHouYW55KCkpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBBYmlPYmplY3RTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHR5cGU6IHouc3RyaW5nKCksXG4gIG5hbWU6IHouc3RyaW5nKCkuZGVmYXVsdChcIlwiKSxcbiAgaW5wdXRzOiB6LmFycmF5KEFiaVR5cGVTY2hlbWEpLmRlZmF1bHQoW10pLFxuICBvdXRwdXRzOiB6LmFycmF5KEFiaVR5cGVTY2hlbWEpLmRlZmF1bHQoW10pXG59KS5jYXRjaGFsbCh6LmFueSgpKTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQWJpU2NoZW1hID0gei5hcnJheShBYmlPYmplY3RTY2hlbWEpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUHJlRGVwbG95TWV0YWRhdGEgPSB6Lm9iamVjdCh7XG4gIG5hbWU6IHouc3RyaW5nKCksXG4gIG1ldGFkYXRhVXJpOiB6LnN0cmluZygpLFxuICBieXRlY29kZVVyaTogei5zdHJpbmcoKSxcbiAgYW5hbHl0aWNzOiB6LmFueSgpLm9wdGlvbmFsKClcbn0pLmNhdGNoYWxsKHouYW55KCkpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBDaGFpbklkVG9BZGRyZXNzU2NoZW1hID0gei5yZWNvcmQoei5zdHJpbmcoKSwgei5zdHJpbmcoKSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEZhY3RvcnlEZXBsb3ltZW50U2NoZW1hID0gei5vYmplY3Qoe1xuICBpbXBsZW1lbnRhdGlvbkFkZHJlc3NlczogQ2hhaW5JZFRvQWRkcmVzc1NjaGVtYSxcbiAgaW1wbGVtZW50YXRpb25Jbml0aWFsaXplckZ1bmN0aW9uOiB6LnN0cmluZygpLmRlZmF1bHQoXCJpbml0aWFsaXplXCIpLFxuICBmYWN0b3J5QWRkcmVzc2VzOiBDaGFpbklkVG9BZGRyZXNzU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBFeHRyYVB1Ymxpc2hNZXRhZGF0YVNjaGVtYUlucHV0ID0gei5vYmplY3Qoe1xuICB2ZXJzaW9uOiB6LnN0cmluZygpLnJlZmluZSh2ID0+IHtcbiAgICB0cnkge1xuICAgICAgdG9TZW12ZXIodik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCBvdXQgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlOiBgJyR7b3V0fScgaXMgbm90IGEgdmFsaWQgc2VtYW50aWMgdmVyc2lvbi4gU2hvdWxkIGJlIGluIHRoZSBmb3JtYXQgb2YgbWFqb3IubWlub3IucGF0Y2guIEV4OiAwLjQuMWBcbiAgICB9O1xuICB9KSxcbiAgZGlzcGxheU5hbWU6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgZGVzY3JpcHRpb246IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgcmVhZG1lOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGxpY2Vuc2U6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgY2hhbmdlbG9nOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIHRhZ3M6IHouYXJyYXkoei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgYXVkaXQ6IEZpbGVPckJ1ZmZlck9yU3RyaW5nU2NoZW1hLm51bGxhYmxlKCkub3B0aW9uYWwoKSxcbiAgbG9nbzogRmlsZU9yQnVmZmVyT3JTdHJpbmdTY2hlbWEubnVsbGFibGUoKS5vcHRpb25hbCgpLFxuICBpc0RlcGxveWFibGVWaWFGYWN0b3J5OiB6LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICBpc0RlcGxveWFibGVWaWFQcm94eTogei5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgZmFjdG9yeURlcGxveW1lbnREYXRhOiBGYWN0b3J5RGVwbG95bWVudFNjaGVtYS5vcHRpb25hbCgpLFxuICBjb25zdHJ1Y3RvclBhcmFtczogei5yZWNvcmQoei5zdHJpbmcoKSwgei5vYmplY3Qoe1xuICAgIGRpc3BsYXlOYW1lOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgZGVzY3JpcHRpb246IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBkZWZhdWx0VmFsdWU6IHouc3RyaW5nKCkub3B0aW9uYWwoKVxuICB9KS5jYXRjaGFsbCh6LmFueSgpKSkub3B0aW9uYWwoKVxufSkuY2F0Y2hhbGwoei5hbnkoKSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEV4dHJhUHVibGlzaE1ldGFkYXRhU2NoZW1hT3V0cHV0ID0gRXh0cmFQdWJsaXNoTWV0YWRhdGFTY2hlbWFJbnB1dC5leHRlbmQoe1xuICBhdWRpdDogei5zdHJpbmcoKS5udWxsYWJsZSgpLm9wdGlvbmFsKCksXG4gIGxvZ286IHouc3RyaW5nKCkubnVsbGFibGUoKS5vcHRpb25hbCgpXG59KTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEZ1bGxQdWJsaXNoTWV0YWRhdGFTY2hlbWFJbnB1dCA9IFByZURlcGxveU1ldGFkYXRhLm1lcmdlKEV4dHJhUHVibGlzaE1ldGFkYXRhU2NoZW1hSW5wdXQpLmV4dGVuZCh7XG4gIHB1Ymxpc2hlcjogQWRkcmVzc1NjaGVtYS5vcHRpb25hbCgpXG59KTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEZ1bGxQdWJsaXNoTWV0YWRhdGFTY2hlbWFPdXRwdXQgPSBQcmVEZXBsb3lNZXRhZGF0YS5tZXJnZShFeHRyYVB1Ymxpc2hNZXRhZGF0YVNjaGVtYU91dHB1dCkuZXh0ZW5kKHtcbiAgcHVibGlzaGVyOiBBZGRyZXNzU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUHJvZmlsZVNjaGVtYUlucHV0ID0gei5vYmplY3Qoe1xuICBuYW1lOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGJpbzogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBhdmF0YXI6IEZpbGVPckJ1ZmZlck9yU3RyaW5nU2NoZW1hLm51bGxhYmxlKCkub3B0aW9uYWwoKSxcbiAgd2Vic2l0ZTogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICB0d2l0dGVyOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIHRlbGVncmFtOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGZhY2Vib29rOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGdpdGh1Yjogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBtZWRpdW06IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgbGlua2VkaW46IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgcmVkZGl0OiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGRpc2NvcmQ6IHouc3RyaW5nKCkub3B0aW9uYWwoKVxufSk7XG5jb25zdCBQcm9maWxlU2NoZW1hT3V0cHV0ID0gUHJvZmlsZVNjaGVtYUlucHV0LmV4dGVuZCh7XG4gIGF2YXRhcjogei5zdHJpbmcoKS5udWxsYWJsZSgpLm9wdGlvbmFsKClcbn0pO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUHVibGlzaGVkQ29udHJhY3RTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGlkOiB6LnN0cmluZygpLFxuICB0aW1lc3RhbXA6IEJpZ051bWJlcmlzaFNjaGVtYSxcbiAgbWV0YWRhdGFVcmk6IHouc3RyaW5nKClcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogRm9sbG93cyBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi92MC44LjE1L25hdHNwZWMtZm9ybWF0Lmh0bWxcbiAqL1xuY29uc3QgQ29udHJhY3RJbmZvU2NoZW1hID0gei5vYmplY3Qoe1xuICB0aXRsZTogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBhdXRob3I6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgZGV0YWlsczogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBub3RpY2U6IHouc3RyaW5nKCkub3B0aW9uYWwoKVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IENvbXBpbGVyTWV0YWRhdGFGZXRjaGVkU2NoZW1hID0gei5vYmplY3Qoe1xuICBuYW1lOiB6LnN0cmluZygpLFxuICBhYmk6IEFiaVNjaGVtYSxcbiAgbWV0YWRhdGE6IHoucmVjb3JkKHouc3RyaW5nKCksIHouYW55KCkpLFxuICBpbmZvOiBDb250cmFjdEluZm9TY2hlbWEsXG4gIGxpY2Vuc2VzOiB6LmFycmF5KHouc3RyaW5nKCkub3B0aW9uYWwoKSkuZGVmYXVsdChbXSkudHJhbnNmb3JtKHYgPT4ge1xuICAgIHJldHVybiB2LmZpbHRlcihsaWNlbnNlID0+IGxpY2Vuc2UgIT09IHVuZGVmaW5lZCk7XG4gIH0pXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUHJlRGVwbG95TWV0YWRhdGFGZXRjaGVkU2NoZW1hID0gUHJlRGVwbG95TWV0YWRhdGEubWVyZ2UoQ29tcGlsZXJNZXRhZGF0YUZldGNoZWRTY2hlbWEpLmV4dGVuZCh7XG4gIGJ5dGVjb2RlOiB6LnN0cmluZygpXG59KTtcblxuLyoqXG4gKiBXYWxsZXQgQXV0aGVudGljYXRvclxuICogQHJlbWFya3MgVGhlIHdhbGxldCBhdXRoZW50aWNhdG9yIGVuYWJsZXMgc2VydmVyLXNpZGUgYXBwbGljYXRpb25zIHRvIHNlY3VyZWx5IGlkZW50aWZ5IHRoZVxuICogY29ubmVjdGVkIHdhbGxldCBhZGRyZXNzIG9mIHVzZXJzIG9uIHRoZSBjbGllbnQtc2lkZSwgYW5kIGFsc28gZW5hYmxlcyB1c2VycyB0byBhdXRoZW50aWNhdGVcbiAqIHRvIGFueSBiYWNrZW5kIHVzaW5nIGp1c3QgdGhlaXIgd2FsbGV0LiBJdCBpbXBsZW1lbnRzIHRoZSBKU09OIFdlYiBUb2tlbiAoSldUKSBhdXRoZW50aWNhdGlvblxuICogc3RhbmRhcmQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFdlIHNwZWNpZnkgdGhlIGRvbWFpbiBvZiB0aGUgYXBwbGljYXRpb24gdG8gYXV0aGVudGljYXRlIHRvXG4gKiBjb25zdCBkb21haW4gPSBcImV4YW1wbGUuY29tXCJcbiAqXG4gKiAvLyBPbiB0aGUgY2xpZW50IHNpZGUsIHdlIGNhbiBnZW5lcmF0ZSBhIHBheWxvYWQgZm9yIHRoZSBjb25uZWN0ZWQgd2FsbGV0IHRvIGxvZ2luXG4gKiBjb25zdCBsb2dpblBheWxvYWQgPSBhd2FpdCBzZGsuYXV0aC5sb2dpbihkb21haW4pO1xuICpcbiAqIC8vIFRoZW4gb24gdGhlIHNlcnZlciBzaWRlLCB3ZSBjYW4gc2VjdXJlbHkgdmVyaWZ5IHRoZSBjb25uZWN0ZWQgY2xpZW50LXNpZGUgYWRkcmVzc1xuICogY29uc3QgYWRkcmVzcyA9IHNkay5hdXRoLnZlcmlmeShkb21haW4sIGxvZ2luUGF5bG9hZCk7XG4gKlxuICogLy8gQW5kIHdlIGNhbiBhbHNvIGdlbmVyYXRlIGFuIGF1dGhlbnRpY2F0aW9uIHRva2VuIHRvIHNlbmQgdG8gdGhlIGNsaWVudFxuICogY29uc3QgdG9rZW4gPSBzZGsuYXV0aC5nZW5lcmF0ZShkb21haW4sIGxvZ2luUGF5bG9hZCk7XG4gKlxuICogLy8gRmluYWxseSwgdGhlIHRva2VuIGNhbiBiZSBzZW5kIGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHRvIG1ha2UgYXV0aGVudGljYXRlZCByZXF1ZXN0c1xuICogLy8gQW5kIHRoZSBzZXJ2ZXIgY2FuIHVzZSB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uIHRvIGF1dGhlbnRpY2F0ZSBhIHRva2VuIGFuZCB2ZXJpZnkgdGhlIGFzc29jaWF0ZWQgYWRkcmVzc1xuICogY29uc3QgYWRkcmVzcyA9IHNkay5hdXRoLmF1dGhlbnRpY2F0ZShkb21haW4sIHRva2VuKTtcbiAqIGBgYFxuICogQHB1YmxpY1xuICovXG5jbGFzcyBXYWxsZXRBdXRoZW50aWNhdG9yIGV4dGVuZHMgUlBDQ29ubmVjdGlvbkhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihuZXR3b3JrLCB3YWxsZXQsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3YWxsZXRcIiwgdm9pZCAwKTtcbiAgICB0aGlzLndhbGxldCA9IHdhbGxldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dpbiBXaXRoIENvbm5lY3RlZCBXYWxsZXRcbiAgICogQHJlbWFya3MgQ2xpZW50LXNpZGUgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGNvbm5lY3RlZCB3YWxsZXQgdG8gbG9naW4gdG8gYSBzZXJ2ZXItc2lkZSBhcHBsaWNhdGlvbi5cbiAgICogR2VuZXJhdGVzIGEgbG9naW4gcGF5bG9hZCB0aGF0IGNhbiBiZSBzZW50IHRvIHRoZSBzZXJ2ZXItc2lkZSBmb3IgdmVyaWZpY2F0aW9uIG9yIGF1dGhlbnRpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gZG9tYWluIC0gVGhlIGRvbWFpbiBvZiB0aGUgc2VydmVyLXNpZGUgYXBwbGljYXRpb24gdG8gbG9naW4gdG9cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBsb2dpbiByZXF1ZXN0XG4gICAqIEByZXR1cm5zIExvZ2luIHBheWxvYWQgdGhhdCBjYW4gYmUgdXNlZCBvbiB0aGUgc2VydmVyLXNpZGUgdG8gdmVyaWZ5IHRoZSBsb2dpbiByZXF1ZXN0IG9yIGF1dGhlbnRpY2F0ZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIEFkZCB0aGUgZG9tYWluIG9mIHRoZSBhcHBsaWNhdGlvbiB1c2VycyB3aWxsIGxvZ2luIHRvLCB0aGlzIHdpbGwgYmUgdXNlZCB0aHJvdWdob3V0IHRoZSBsb2dpbiBwcm9jZXNzXG4gICAqIGNvbnN0IGRvbWFpbiA9IFwiZXhhbXBsZS5jb21cIjtcbiAgICogLy8gR2VuZXJhdGUgYSBzaWduZWQgbG9naW4gcGF5bG9hZCBmb3IgdGhlIGNvbm5lY3RlZCB3YWxsZXQgdG8gYXV0aGVudGljYXRlIHdpdGhcbiAgICogY29uc3QgbG9naW5QYXlsb2FkID0gYXdhaXQgc2RrLmF1dGgubG9naW4oZG9tYWluKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBsb2dpbihkb21haW4sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwYXJzZWRPcHRpb25zID0gTG9naW5PcHRpb25zU2NoZW1hLnBhcnNlKG9wdGlvbnMpO1xuICAgIGNvbnN0IHNpZ25lckFkZHJlc3MgPSBhd2FpdCB0aGlzLndhbGxldC5nZXRBZGRyZXNzKCk7XG4gICAgY29uc3QgZXhwaXJhdGlvblRpbWUgPSBwYXJzZWRPcHRpb25zPy5leHBpcmF0aW9uVGltZSB8fCBuZXcgRGF0ZShEYXRlLm5vdygpICsgMTAwMCAqIDYwICogNSk7XG4gICAgY29uc3QgcGF5bG9hZERhdGEgPSBMb2dpblBheWxvYWREYXRhU2NoZW1hLnBhcnNlKHtcbiAgICAgIGRvbWFpbixcbiAgICAgIGFkZHJlc3M6IHNpZ25lckFkZHJlc3MsXG4gICAgICBub25jZTogcGFyc2VkT3B0aW9ucz8ubm9uY2UsXG4gICAgICBleHBpcmF0aW9uX3RpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgY2hhaW5faWQ6IHBhcnNlZE9wdGlvbnM/LmNoYWluSWRcbiAgICB9KTtcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5nZW5lcmF0ZU1lc3NhZ2UocGF5bG9hZERhdGEpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMud2FsbGV0LnNpZ24obWVzc2FnZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBheWxvYWQ6IHBheWxvYWREYXRhLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgTG9nZ2VkIEluIEFkZHJlc3NcbiAgICogQHJlbWFya3MgU2VydmVyLXNpZGUgZnVuY3Rpb24gdG8gc2VjdXJlbHkgdmVyaWZ5IHRoZSBhZGRyZXNzIG9mIHRoZSBsb2dnZWQgaW4gY2xpZW50LXNpZGUgd2FsbGV0XG4gICAqIGJ5IHZhbGlkYXRpbmcgdGhlIHByb3ZpZGVkIGNsaWVudC1zaWRlIGxvZ2luIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBkb21haW4gLSBUaGUgZG9tYWluIG9mIHRoZSBzZXJ2ZXItc2lkZSBhcHBsaWNhdGlvbiB0byB2ZXJpZnkgdGhlIGxvZ2luIHJlcXVlc3QgZm9yXG4gICAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIGxvZ2luIHBheWxvYWQgdG8gdmVyaWZ5XG4gICAqIEByZXR1cm5zIEFkZHJlc3Mgb2YgdGhlIGxvZ2dlZCBpbiB3YWxsZXRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBkb21haW4gPSBcImV4YW1wbGUuY29tXCI7XG4gICAqIGNvbnN0IGxvZ2luUGF5bG9hZCA9IGF3YWl0IHNkay5hdXRoLmxvZ2luKGRvbWFpbik7XG4gICAqXG4gICAqIC8vIFZlcmlmeSB0aGUgbG9naW4gcmVxdWVzdFxuICAgKiBjb25zdCBhZGRyZXNzID0gc2RrLmF1dGgudmVyaWZ5KGRvbWFpbiwgbG9naW5QYXlsb2FkKTtcbiAgICogYGBgXG4gICAqL1xuICB2ZXJpZnkoZG9tYWluLCBwYXlsb2FkLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcGFyc2VkT3B0aW9ucyA9IFZlcmlmeU9wdGlvbnNTY2hlbWEucGFyc2Uob3B0aW9ucyk7XG5cbiAgICAvLyBDaGVjayB0aGF0IHRoZSBpbnRlbmRlZCBkb21haW4gbWF0Y2hlcyB0aGUgZG9tYWluIG9mIHRoZSBwYXlsb2FkXG4gICAgaWYgKHBheWxvYWQucGF5bG9hZC5kb21haW4gIT09IGRvbWFpbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBkb21haW4gJyR7ZG9tYWlufScgZG9lcyBub3QgbWF0Y2ggZG9tYWluIG9uIHBheWxvYWQgJyR7cGF5bG9hZC5wYXlsb2FkLmRvbWFpbn0nYCk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgcGF5bG9hZCBoYXNuJ3QgZXhwaXJlZFxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICBpZiAoY3VycmVudFRpbWUgPiBuZXcgRGF0ZShwYXlsb2FkLnBheWxvYWQuZXhwaXJhdGlvbl90aW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBMb2dpbiByZXF1ZXN0IGhhcyBleHBpcmVkYCk7XG4gICAgfVxuXG4gICAgLy8gSWYgY2hhaW4gSUQgaXMgc3BlY2lmaWVkLCBjaGVjayB0aGF0IGl0IG1hdGNoZXMgdGhlIGNoYWluIElEIG9mIHRoZSBzaWduYXR1cmVcbiAgICBpZiAocGFyc2VkT3B0aW9ucz8uY2hhaW5JZCAhPT0gdW5kZWZpbmVkICYmIHBhcnNlZE9wdGlvbnMuY2hhaW5JZCAhPT0gcGF5bG9hZC5wYXlsb2FkLmNoYWluX2lkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENoYWluIElEICcke3BhcnNlZE9wdGlvbnMuY2hhaW5JZH0nIGRvZXMgbm90IG1hdGNoIHBheWxvYWQgY2hhaW4gSUQgJyR7cGF5bG9hZC5wYXlsb2FkLmNoYWluX2lkfSdgKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGF0IHRoZSBzaWduaW5nIGFkZHJlc3MgaXMgdGhlIGNsYWltZWQgd2FsbGV0IGFkZHJlc3NcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5nZW5lcmF0ZU1lc3NhZ2UocGF5bG9hZC5wYXlsb2FkKTtcbiAgICBjb25zdCB1c2VyQWRkcmVzcyA9IHRoaXMud2FsbGV0LnJlY292ZXJBZGRyZXNzKG1lc3NhZ2UsIHBheWxvYWQuc2lnbmF0dXJlKTtcbiAgICBpZiAodXNlckFkZHJlc3MudG9Mb3dlckNhc2UoKSAhPT0gcGF5bG9hZC5wYXlsb2FkLmFkZHJlc3MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaWduZXIgYWRkcmVzcyAnJHt1c2VyQWRkcmVzcy50b0xvd2VyQ2FzZSgpfScgZG9lcyBub3QgbWF0Y2ggcGF5bG9hZCBhZGRyZXNzICcke3BheWxvYWQucGF5bG9hZC5hZGRyZXNzLnRvTG93ZXJDYXNlKCl9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gdXNlckFkZHJlc3M7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgQXV0aGVudGljYXRpb24gVG9rZW5cbiAgICogQHJlbWFya3MgU2VydmVyLXNpZGUgZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgYSBKV1QgdG9rZW4gZnJvbSB0aGUgcHJvdmlkZWQgbG9naW4gcmVxdWVzdCB0aGF0IHRoZVxuICAgKiBjbGllbnQtc2lkZSB3YWxsZXQgY2FuIHVzZSB0byBhdXRoZW50aWNhdGUgdG8gdGhlIHNlcnZlci1zaWRlIGFwcGxpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gZG9tYWluIC0gVGhlIGRvbWFpbiBvZiB0aGUgc2VydmVyLXNpZGUgYXBwbGljYXRpb24gdG8gYXV0aGVudGljYXRlIHRvXG4gICAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIGxvZ2luIHBheWxvYWQgdG8gYXV0aGVudGljYXRlIHdpdGhcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBhdXRoZW50aWNhdGlvbiByZXF1ZXN0XG4gICAqIEByZXR1cm5zIEEgYXV0aGVudGljYXRpb24gdG9rZW4gdGhhdCBjYW4gYmUgdXNlZCBieSB0aGUgY2xpZW50IHRvIG1ha2UgYXV0aGVudGljYXRlZCByZXF1ZXN0c1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IGRvbWFpbiA9IFwiZXhhbXBsZS5jb21cIjtcbiAgICogY29uc3QgbG9naW5QYXlsb2FkID0gYXdhaXQgc2RrLmF1dGgubG9naW4oZG9tYWluKTtcbiAgICpcbiAgICogLy8gR2VuZXJhdGUgYSBKV1QgdG9rZW4gdGhhdCBjYW4gYmUgc2VudCB0byB0aGUgY2xpZW50LXNpZGUgd2FsbGV0IGFuZCB1c2VkIGZvciBhdXRoZW50aWNhdGlvblxuICAgKiBjb25zdCB0b2tlbiA9IGF3YWl0IHNkay5hdXRoLmdlbmVyYXRlQXV0aFRva2VuKGRvbWFpbiwgbG9naW5QYXlsb2FkKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZUF1dGhUb2tlbihkb21haW4sIHBheWxvYWQsIG9wdGlvbnMpIHtcbiAgICBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkF1dGhlbnRpY2F0aW9uIHRva2VucyBzaG91bGQgbm90IGJlIGdlbmVyYXRlZCBpbiB0aGUgYnJvd3NlciwgYXMgdGhleSBtdXN0IGJlIHNpZ25lZCBieSBhIHNlcnZlci1zaWRlIGFkbWluIHdhbGxldC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZE9wdGlvbnMgPSBBdXRoZW50aWNhdGlvbk9wdGlvbnNTY2hlbWEucGFyc2Uob3B0aW9ucyk7XG4gICAgY29uc3QgdXNlckFkZHJlc3MgPSB0aGlzLnZlcmlmeShkb21haW4sIHBheWxvYWQpO1xuICAgIGNvbnN0IGFkbWluQWRkcmVzcyA9IGF3YWl0IHRoaXMud2FsbGV0LmdldEFkZHJlc3MoKTtcbiAgICBjb25zdCBwYXlsb2FkRGF0YSA9IEF1dGhlbnRpY2F0aW9uUGF5bG9hZERhdGFTY2hlbWEucGFyc2Uoe1xuICAgICAgaXNzOiBhZG1pbkFkZHJlc3MsXG4gICAgICBzdWI6IHVzZXJBZGRyZXNzLFxuICAgICAgYXVkOiBkb21haW4sXG4gICAgICBuYmY6IHBhcnNlZE9wdGlvbnM/LmludmFsaWRCZWZvcmUgfHwgbmV3IERhdGUoKSxcbiAgICAgIGV4cDogcGFyc2VkT3B0aW9ucz8uZXhwaXJhdGlvblRpbWUgfHwgbmV3IERhdGUoRGF0ZS5ub3coKSArIDEwMDAgKiA2MCAqIDYwICogNSksXG4gICAgICBpYXQ6IG5ldyBEYXRlKClcbiAgICB9KTtcbiAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZERhdGEpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMud2FsbGV0LnNpZ24obWVzc2FnZSk7XG5cbiAgICAvLyBIZWFkZXIgdXNlZCBmb3IgSldUIHRva2VuIHNwZWNpZnlpbmcgaGFzaCBhbGdvcml0aG1cbiAgICBjb25zdCBoZWFkZXIgPSB7XG4gICAgICAvLyBTcGVjaWZ5IEVDRFNBIHdpdGggU0hBLTI1NiBmb3IgaGFzaGluZyBhbGdvcml0aG1cbiAgICAgIGFsZzogXCJFUzI1NlwiLFxuICAgICAgdHlwOiBcIkpXVFwiXG4gICAgfTtcbiAgICBjb25zdCBlbmNvZGVkSGVhZGVyID0gQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgY29uc3QgZW5jb2RlZERhdGEgPSBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShwYXlsb2FkRGF0YSkpLnRvU3RyaW5nKFwiYmFzZTY0XCIpLnJlcGxhY2UoLz0vZywgXCJcIik7XG4gICAgY29uc3QgZW5jb2RlZFNpZ25hdHVyZSA9IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG5cbiAgICAvLyBHZW5lcmF0ZSBhIEpXVCB0b2tlbiB3aXRoIGJhc2U2NCBlbmNvZGVkIGhlYWRlciwgcGF5bG9hZCwgYW5kIHNpZ25hdHVyZVxuICAgIGNvbnN0IHRva2VuID0gYCR7ZW5jb2RlZEhlYWRlcn0uJHtlbmNvZGVkRGF0YX0uJHtlbmNvZGVkU2lnbmF0dXJlfWA7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgLyoqXG4gICAqIEF1dGhlbnRpY2F0ZSBXaXRoIFRva2VuXG4gICAqIEByZW1hcmtzIFNlcnZlci1zaWRlIGZ1bmN0aW9uIHRoYXQgYXV0aGVudGljYXRlcyB0aGUgcHJvdmlkZWQgSldUIHRva2VuLiBUaGlzIGZ1bmN0aW9uIHZlcmlmaWVzIHRoYXRcbiAgICogdGhlIHByb3ZpZGVkIGF1dGhlbnRpY2F0aW9uIHRva2VuIGlzIHZhbGlkIGFuZCByZXR1cm5zIHRoZSBhZGRyZXNzIG9mIHRoZSBhdXRoZW50aWNhdGVkIHdhbGxldC5cbiAgICpcbiAgICogQHBhcmFtIGRvbWFpbiAtIFRoZSBkb21haW4gb2YgdGhlIHNlcnZlci1zaWRlIGFwcGxpY2F0aW9uIGRvaW5nIGF1dGhlbnRpY2F0aW9uXG4gICAqIEBwYXJhbSB0b2tlbiAtIFRoZSBhdXRoZW50aWNhdGlvbiB0b2tlbiBiZWluZyB1c2VkXG4gICAqIEByZXR1cm5zIFRoZSBhZGRyZXNzIG9mIHRoZSBhdXRoZW50aWNhdGVkIHdhbGxldFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IGRvbWFpbiA9IFwiZXhhbXBsZS5jb21cIjtcbiAgICogY29uc3QgbG9naW5QYXlsb2FkID0gYXdhaXQgc2RrLmF1dGgubG9naW4oZG9tYWluKTtcbiAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBzZGsuYXV0aC5nZW5lcmF0ZUF1dGhUb2tlbihkb21haW4sIGxvZ2luUGF5bG9hZCk7XG4gICAqXG4gICAqIC8vIEF1dGhlbnRpY2F0ZSB0aGUgdG9rZW4gYW5kIGdldCB0aGUgYWRkcmVzcyBvZiBhdXRoZW50aWNhdGluZyB1c2VycyB3YWxsZXRcbiAgICogY29uc3QgYWRkcmVzcyA9IHNkay5hdXRoLmF1dGhlbnRpY2F0ZShkb21haW4sIHRva2VuKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBhdXRoZW50aWNhdGUoZG9tYWluLCB0b2tlbikge1xuICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkIG5vdCBhdXRoZW50aWNhdGUgdG9rZW5zIGluIHRoZSBicm93c2VyLCBhcyB0aGV5IG11c3QgYmUgdmVyaWZpZWQgYnkgdGhlIHNlcnZlci1zaWRlIGFkbWluIHdhbGxldC5cIik7XG4gICAgfVxuICAgIGNvbnN0IGVuY29kZWRQYXlsb2FkID0gdG9rZW4uc3BsaXQoXCIuXCIpWzFdO1xuICAgIGNvbnN0IGVuY29kZWRTaWduYXR1cmUgPSB0b2tlbi5zcGxpdChcIi5cIilbMl07XG4gICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoQnVmZmVyLmZyb20oZW5jb2RlZFBheWxvYWQsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCkpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IEJ1ZmZlci5mcm9tKGVuY29kZWRTaWduYXR1cmUsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCk7XG5cbiAgICAvLyBDaGVjayB0aGF0IHRoZSB0b2tlbiBhdWRpZW5jZSBtYXRjaGVzIHRoZSBkb21haW5cbiAgICBpZiAocGF5bG9hZC5hdWQgIT09IGRvbWFpbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB0b2tlbiB0byBiZSBmb3IgdGhlIGRvbWFpbiAnJHtkb21haW59JywgYnV0IGZvdW5kIHRva2VuIHdpdGggZG9tYWluICcke3BheWxvYWQuYXVkfSdgKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGF0IHRoZSB0b2tlbiBpcyBwYXN0IHRoZSBpbnZhbGlkIGJlZm9yZSB0aW1lXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgaWYgKGN1cnJlbnRUaW1lIDwgcGF5bG9hZC5uYmYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyB0b2tlbiBpcyBpbnZhbGlkIGJlZm9yZSBlcG9jaCB0aW1lICcke3BheWxvYWQubmJmfScsIGN1cnJlbnQgZXBvY2ggdGltZSBpcyAnJHtjdXJyZW50VGltZX0nYCk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgdG9rZW4gaGFzbid0IGV4cGlyZWRcbiAgICBpZiAoY3VycmVudFRpbWUgPiBwYXlsb2FkLmV4cCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIHRva2VuIGV4cGlyZWQgYXQgZXBvY2ggdGltZSAnJHtwYXlsb2FkLmV4cH0nLCBjdXJyZW50IGVwb2NoIHRpbWUgaXMgJyR7Y3VycmVudFRpbWV9J2ApO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRoYXQgdGhlIGNvbm5lY3RlZCB3YWxsZXQgbWF0Y2hlcyB0aGUgdG9rZW4gaXNzdWVyXG4gICAgY29uc3QgY29ubmVjdGVkQWRkcmVzcyA9IGF3YWl0IHRoaXMud2FsbGV0LmdldEFkZHJlc3MoKTtcbiAgICBpZiAoY29ubmVjdGVkQWRkcmVzcy50b0xvd2VyQ2FzZSgpICE9PSBwYXlsb2FkLmlzcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHRoZSBjb25uZWN0ZWQgd2FsbGV0IGFkZHJlc3MgJyR7Y29ubmVjdGVkQWRkcmVzc30nIHRvIG1hdGNoIHRoZSB0b2tlbiBpc3N1ZXIgYWRkcmVzcyAnJHtwYXlsb2FkLmlzc30nYCk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgY29ubmVjdGVkIHdhbGxldCBzaWduZWQgdGhlIHRva2VuXG4gICAgY29uc3QgYWRtaW5BZGRyZXNzID0gdGhpcy53YWxsZXQucmVjb3ZlckFkZHJlc3MoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksIHNpZ25hdHVyZSk7XG4gICAgaWYgKGNvbm5lY3RlZEFkZHJlc3MudG9Mb3dlckNhc2UoKSAhPT0gYWRtaW5BZGRyZXNzLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGNvbm5lY3RlZCB3YWxsZXQgYWRkcmVzcyAnJHtjb25uZWN0ZWRBZGRyZXNzfScgZGlkIG5vdCBzaWduIHRoZSB0b2tlbmApO1xuICAgIH1cbiAgICByZXR1cm4gcGF5bG9hZC5zdWI7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgRUlQLTQzNjEgY29tcGxpYW50IG1lc3NhZ2UgdG8gc2lnbiBiYXNlZCBvbiB0aGUgbG9naW4gcGF5bG9hZFxuICAgKi9cbiAgZ2VuZXJhdGVNZXNzYWdlKHBheWxvYWQpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGBgO1xuXG4gICAgLy8gQWRkIHRoZSBkb21haW4gYW5kIGxvZ2luIGFkZHJlc3MgZm9yIHRyYW5zcGFyZW5jeVxuICAgIG1lc3NhZ2UgKz0gYCR7cGF5bG9hZC5kb21haW59IHdhbnRzIHlvdSB0byBzaWduIGluIHdpdGggeW91ciBhY2NvdW50OlxcbiR7cGF5bG9hZC5hZGRyZXNzfVxcblxcbmA7XG5cbiAgICAvLyBQcm9tcHQgdXNlciB0byBtYWtlIHN1cmUgZG9tYWluIGlzIGNvcnJlY3QgdG8gcHJldmVudCBwaGlzaGluZyBhdHRhY2tzXG4gICAgbWVzc2FnZSArPSBgTWFrZSBzdXJlIHRoYXQgdGhlIHJlcXVlc3RpbmcgZG9tYWluIGFib3ZlIG1hdGNoZXMgdGhlIFVSTCBvZiB0aGUgY3VycmVudCB3ZWJzaXRlLlxcblxcbmA7XG5cbiAgICAvLyBBZGQgZGF0YSBmaWVsZHMgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBFSVAtNDM2MSBzdGFuZGFyZFxuICAgIGlmIChwYXlsb2FkLmNoYWluX2lkKSB7XG4gICAgICBtZXNzYWdlICs9IGBDaGFpbiBJRDogJHtwYXlsb2FkLmNoYWluX2lkfVxcbmA7XG4gICAgfVxuICAgIG1lc3NhZ2UgKz0gYE5vbmNlOiAke3BheWxvYWQubm9uY2V9XFxuYDtcbiAgICBtZXNzYWdlICs9IGBFeHBpcmF0aW9uIFRpbWU6ICR7cGF5bG9hZC5leHBpcmF0aW9uX3RpbWV9XFxuYDtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuY29kZXMgYW5kIGRlY29kZXMgQ29udHJhY3QgZnVuY3Rpb25zXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIENvbnRyYWN0RW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRyYWN0V3JhcHBlcikge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRyYWN0V3JhcHBlclwiLCB2b2lkIDApO1xuICAgIHRoaXMuY29udHJhY3RXcmFwcGVyID0gY29udHJhY3RXcmFwcGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZXMgdGhlIGdpdmVuIGNvbnRyYWN0IGZ1bmN0aW9uIHdpdGggYXJndW1lbnRcbiAgICogQHJldHVybnMgdGhlIGVuY29kZWQgZGF0YVxuICAgKi9cbiAgZW5jb2RlKGZuLCBhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKGZuLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgZW5jb2RlZCBjYWxsIGRhdGEgZm9yIGEgZ2l2ZW4gZnVuY3Rpb25cbiAgICogQHBhcmFtIGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlY29kZVxuICAgKiBAcGFyYW0gZW5jb2RlZEFyZ3MgLSB0aGUgZW5jb2RlZCBhcmd1bWVudHNcbiAgICovXG4gIGRlY29kZShmbiwgZW5jb2RlZEFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVGdW5jdGlvbkRhdGEoZm4sIGVuY29kZWRBcmdzKTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZXMgbWV0YWRhdGEgZm9yIGEgQ29udHJhY3RcbiAqIEByZW1hcmtzIFJlYWQgYW5kIHVwZGF0ZSBtZXRhZGF0YSBmb3IgdGhpcyBjb250cmFjdFxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgc2RrLmdldENvbnRyYWN0KFwie3tjb250cmFjdF9hZGRyZXNzfX1cIik7XG4gKiBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGNvbnRyYWN0Lm1ldGFkYXRhLmdldCgpO1xuICogYXdhaXQgY29udHJhY3QubWV0YWRhdGEuc2V0KHtcbiAqICAgbmFtZTogXCJNeSBDb250cmFjdFwiLFxuICogICBkZXNjcmlwdGlvbjogXCJNeSBjb250cmFjdCBkZXNjcmlwdGlvblwiXG4gKiB9KVxuICogYGBgXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIENvbnRyYWN0TWV0YWRhdGEge1xuICBjb25zdHJ1Y3Rvcihjb250cmFjdFdyYXBwZXIsIHNjaGVtYSwgc3RvcmFnZSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZlYXR1cmVOYW1lXCIsIEZFQVRVUkVfTUVUQURBVEEubmFtZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2NoZW1hXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcmFnZVwiLCB2b2lkIDApO1xuICAgIHRoaXMuY29udHJhY3RXcmFwcGVyID0gY29udHJhY3RXcmFwcGVyO1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcGFyc2VPdXRwdXRNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgIHJldHVybiB0aGlzLnNjaGVtYS5vdXRwdXQucGFyc2UobWV0YWRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcGFyc2VJbnB1dE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NoZW1hLmlucHV0LnBhcnNlKG1ldGFkYXRhKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtZXRhZGF0YSBvZiBhIGNvbnRyYWN0XG4gICAqIEByZW1hcmtzIEdldCB0aGUgbWV0YWRhdGEgb2YgYSBjb250cmFjdFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgY29udHJhY3QubWV0YWRhdGEuZ2V0KCk7XG4gICAqIGBgYFxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHRoZSBtZXRhZGF0YSBvZiB0aGUgZ2l2ZW4gY29udHJhY3RcbiAgICogQHR3ZmVhdHVyZSBDb250cmFjdE1ldGFkYXRhXG4gICAqL1xuICBhc3luYyBnZXQoKSB7XG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNDb250cmFjdE1ldGFkYXRhKHRoaXMuY29udHJhY3RXcmFwcGVyKSkge1xuICAgICAgY29uc3QgdXJpID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmNvbnRyYWN0VVJJKCk7XG4gICAgICBpZiAodXJpICYmIHVyaS5pbmNsdWRlcyhcIjovL1wiKSkge1xuICAgICAgICBkYXRhID0gYXdhaXQgdGhpcy5zdG9yYWdlLmRvd25sb2FkSlNPTih1cmkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIHRyeSBmZXRjaGluZyBtZXRhZGF0YSBmcm9tIGJ5dGVjb2RlIGFuZCAvIG9yIGNvbnRyYWN0IGl0c2VsZlxuICAgICAgICBsZXQgY29udHJhY3ROYW1lO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChoYXNGdW5jdGlvbihcIm5hbWVcIiwgdGhpcy5jb250cmFjdFdyYXBwZXIpKSB7XG4gICAgICAgICAgICBjb250cmFjdE5hbWUgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QubmFtZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gbm8tb3BcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwdWJsaXNoZWRNZXRhZGF0YSA9IGF3YWl0IGZldGNoQ29udHJhY3RNZXRhZGF0YUZyb21BZGRyZXNzKHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5hZGRyZXNzLCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRQcm92aWRlcigpLCB0aGlzLnN0b3JhZ2UpO1xuICAgICAgICBkYXRhID0ge1xuICAgICAgICAgIG5hbWU6IGNvbnRyYWN0TmFtZSB8fCBwdWJsaXNoZWRNZXRhZGF0YS5uYW1lLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBwdWJsaXNoZWRNZXRhZGF0YS5pbmZvLnRpdGxlXG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmZXRjaCBjb250cmFjdCBtZXRhZGF0YVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VPdXRwdXRNZXRhZGF0YShkYXRhKTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBtZXRhZGF0YSBvZiBhIGNvbnRyYWN0XG4gICAqIEByZW1hcmtzIE9WRVJXUklURSB0aGUgbWV0YWRhdGEgb2YgYSBjb250cmFjdFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGF3YWl0IGNvbnRyYWN0Lm1ldGFkYXRhLnNldCh7XG4gICAqICBuYW1lOiBcIk15IENvbnRyYWN0XCIsXG4gICAqICBkZXNjcmlwdGlvbjogXCJNeSBjb250cmFjdCBkZXNjcmlwdGlvblwiXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSBtZXRhZGF0YSAtIHRoZSBtZXRhZGF0YSB0byBzZXRcbiAgICogQHR3ZmVhdHVyZSBDb250cmFjdE1ldGFkYXRhXG4gICAqL1xuICBhc3luYyBzZXQobWV0YWRhdGEpIHtcbiAgICBjb25zdCB1cmkgPSBhd2FpdCB0aGlzLl9wYXJzZUFuZFVwbG9hZE1ldGFkYXRhKG1ldGFkYXRhKTtcbiAgICBjb25zdCB3cmFwcGVyID0gdGhpcy5jb250cmFjdFdyYXBwZXI7XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNDb250cmFjdE1ldGFkYXRhKHdyYXBwZXIpKSB7XG4gICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgd3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJzZXRDb250cmFjdFVSSVwiLCBbdXJpXSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWNlaXB0LFxuICAgICAgICBkYXRhOiB0aGlzLmdldFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEV4dGVuc2lvbk5vdEltcGxlbWVudGVkRXJyb3IoRkVBVFVSRV9NRVRBREFUQSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgbWV0YWRhdGEgb2YgYSBjb250cmFjdFxuICAgKiBAcmVtYXJrcyBVcGRhdGUgdGhlIG1ldGFkYXRhIG9mIGEgY29udHJhY3RcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBhd2FpdCBjb250cmFjdC5tZXRhZGF0YS51cGRhdGUoe1xuICAgKiAgIG5hbWU6IFwiTXkgQ29udHJhY3RcIixcbiAgICogICBkZXNjcmlwdGlvbjogXCJNeSBjb250cmFjdCBkZXNjcmlwdGlvblwiXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSBtZXRhZGF0YSAtIHRoZSBtZXRhZGF0YSB0byB1cGRhdGVcbiAgICogQHR3ZmVhdHVyZSBDb250cmFjdE1ldGFkYXRhXG4gICAqICovXG4gIGFzeW5jIHVwZGF0ZShtZXRhZGF0YSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNldCh7XG4gICAgICAuLi4oYXdhaXQgdGhpcy5nZXQoKSksXG4gICAgICAuLi5tZXRhZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0gbWV0YWRhdGEgLSB0aGUgbWV0YWRhdGEgdG8gc2V0XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBfcGFyc2VBbmRVcGxvYWRNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgIGNvbnN0IHBhcnNlZE1ldGFkYXRhID0gdGhpcy5wYXJzZUlucHV0TWV0YWRhdGEobWV0YWRhdGEpO1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2UudXBsb2FkKHBhcnNlZE1ldGFkYXRhKTtcbiAgfVxuICBzdXBwb3J0c0NvbnRyYWN0TWV0YWRhdGEoY29udHJhY3RXcmFwcGVyKSB7XG4gICAgcmV0dXJuIGRldGVjdENvbnRyYWN0RmVhdHVyZShjb250cmFjdFdyYXBwZXIsIFwiQ29udHJhY3RNZXRhZGF0YVwiKTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBjb250cmFjdCBwZXJtaXNzaW9uc1xuICogQHJlbWFya3MgQ29uZmlndXJlIHJvbGVzIGFuZCBwZXJtaXNzaW9ucyBmb3IgYSBjb250cmFjdCwgdG8gcmVzdHJpY3QgY2VydGFpbiBhY3Rpb25zLlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgc2RrLmdldENvbnRyYWN0KFwie3tjb250cmFjdF9hZGRyZXNzfX1cIik7XG4gKiBjb25zdCByb2xlc0FuZE1lbWJlcnMgPSBhd2FpdCBjb250cmFjdC5yb2xlcy5nZXRBbGwoKTtcbiAqIGF3YWl0IGNvbnRyYWN0LnJvbGVzLmdyYW50Um9sZShcImFkbWluXCIsIFwiMHguLi5cIik7XG4gKiBgYGBcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgQ29udHJhY3RSb2xlcyB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHJlbWFya3MgVGhpcyBpcyB1c2VkIGZvciB0eXBpbmcgaW5zaWRlIHJlYWN0IGhvb2tzIHdoaWNoIGlzIHdoeSBpdCBoYXMgdG8gYmUgcHVibGljLlxuICAgKi9cblxuICBjb25zdHJ1Y3Rvcihjb250cmFjdFdyYXBwZXIsIHJvbGVzKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZmVhdHVyZU5hbWVcIiwgRkVBVFVSRV9QRVJNSVNTSU9OUy5uYW1lKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250cmFjdFdyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb2xlc1wiLCB2b2lkIDApO1xuICAgIHRoaXMuY29udHJhY3RXcmFwcGVyID0gY29udHJhY3RXcmFwcGVyO1xuICAgIHRoaXMucm9sZXMgPSByb2xlcztcbiAgfVxuXG4gIC8qKiAqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBSRUFEIEZVTkNUSU9OU1xuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKipcbiAgICogQ2FsbCB0aGlzIHRvIGdldCBnZXQgYSBsaXN0IG9mIGFkZHJlc3NlcyBmb3IgYWxsIHN1cHBvcnRlZCByb2xlcyBvbiB0aGUgY29udHJhY3QuXG4gICAqIEByZW1hcmtzIFNlZSB7QGxpbmsgQ29udHJhY3RSb2xlcy5nZXR9IHRvIGdldCBhIGxpc3Qgb2YgYWRkcmVzc2VzIHRoYXQgYXJlIG1lbWJlcnMgb2YgYSBzcGVjaWZpYyByb2xlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IHJvbGVzQW5kTWVtYmVycyA9IGF3YWl0IGNvbnRyYWN0LnJvbGVzLmdldEFsbCgpO1xuICAgKiBgYGBcbiAgICogQHJldHVybnMgQSByZWNvcmQgb2Yge0BsaW5rIFJvbGV9cyB0byBsaXN0cyBvZiBhZGRyZXNzZXMgdGhhdCBhcmUgbWVtYmVycyBvZiB0aGUgZ2l2ZW4gcm9sZS5cbiAgICogQHRocm93cyBJZiB0aGUgY29udHJhY3QgZG9lcyBub3Qgc3VwcG9ydCByb2xlcyB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQHR3ZmVhdHVyZSBQZXJtaXNzaW9uc1xuICAgKi9cbiAgYXN5bmMgZ2V0QWxsKCkge1xuICAgIGludmFyaWFudCh0aGlzLnJvbGVzLmxlbmd0aCwgXCJ0aGlzIGNvbnRyYWN0IGhhcyBubyBzdXBwb3J0IGZvciByb2xlc1wiKTtcbiAgICBjb25zdCByb2xlcyA9IHt9O1xuICAgIGZvciAoY29uc3Qgcm9sZSBvZiB0aGlzLnJvbGVzKSB7XG4gICAgICByb2xlc1tyb2xlXSA9IGF3YWl0IHRoaXMuZ2V0KHJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gcm9sZXM7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCB0aGlzIHRvIGdldCBhIGxpc3Qgb2YgYWRkcmVzc2VzIHRoYXQgYXJlIG1lbWJlcnMgb2YgYSBzcGVjaWZpYyByb2xlLlxuICAgKiBAcmVtYXJrcyBTZWUge0BsaW5rIENvbnRyYWN0Um9sZXMuZ2V0QWxsfSB0byBnZXQgZ2V0IGEgbGlzdCBvZiBhZGRyZXNzZXMgZm9yIGFsbCBzdXBwb3J0ZWQgcm9sZXMgb24gdGhlIGNvbnRyYWN0LlxuICAgKiBAcGFyYW0gcm9sZSAtIFRoZSBSb2xlIHRvIHRvIGdldCBhIG1lbWJlcmxpc3QgZm9yLlxuICAgKiBAcmV0dXJucyBUaGUgbGlzdCBvZiBhZGRyZXNzZXMgdGhhdCBhcmUgbWVtYmVycyBvZiB0aGUgc3BlY2lmaWMgcm9sZS5cbiAgICogQHRocm93cyBJZiB5b3UgYXJlIHJlcXVlc3Rpb25nIGEgcm9sZSB0aGF0IGRvZXMgbm90IGV4aXN0IG9uIHRoZSBjb250cmFjdCB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAqXG4gICAqIEBleGFtcGxlIFNheSB5b3Ugd2FudCB0byBnZXQgdGhlIGxpc3Qgb2YgYWRkcmVzc2VzIHRoYXQgYXJlIG1lbWJlcnMgb2YgdGhlIG1pbnRlciByb2xlLlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IG1pbnRlckFkZHJlc3NlcyA9IGF3YWl0IGNvbnRyYWN0LnJvbGVzLmdldChcIm1pbnRlclwiKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQHR3ZmVhdHVyZSBQZXJtaXNzaW9uc1xuICAgKi9cbiAgYXN5bmMgZ2V0KHJvbGUpIHtcbiAgICBpbnZhcmlhbnQodGhpcy5yb2xlcy5pbmNsdWRlcyhyb2xlKSwgYHRoaXMgY29udHJhY3QgZG9lcyBub3Qgc3VwcG9ydCB0aGUgXCIke3JvbGV9XCIgcm9sZWApO1xuICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLmNvbnRyYWN0V3JhcHBlcjtcbiAgICBpZiAoaGFzRnVuY3Rpb24oXCJnZXRSb2xlTWVtYmVyQ291bnRcIiwgd3JhcHBlcikgJiYgaGFzRnVuY3Rpb24oXCJnZXRSb2xlTWVtYmVyXCIsIHdyYXBwZXIpKSB7XG4gICAgICBjb25zdCByb2xlSGFzaCA9IGdldFJvbGVIYXNoKHJvbGUpO1xuICAgICAgY29uc3QgY291bnQgPSAoYXdhaXQgd3JhcHBlci5yZWFkQ29udHJhY3QuZ2V0Um9sZU1lbWJlckNvdW50KHJvbGVIYXNoKSkudG9OdW1iZXIoKTtcbiAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChBcnJheS5mcm9tKEFycmF5KGNvdW50KS5rZXlzKCkpLm1hcChpID0+IHdyYXBwZXIucmVhZENvbnRyYWN0LmdldFJvbGVNZW1iZXIocm9sZUhhc2gsIGkpKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRyYWN0IGRvZXMgbm90IHN1cHBvcnQgZW51bWVyYXRpbmcgcm9sZXMuIFBsZWFzZSBpbXBsZW1lbnQgSVBlcm1pc3Npb25zRW51bWVyYWJsZSB0byB1bmxvY2sgdGhpcyBmdW5jdGlvbmFsaXR5LlwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgdG8gT1ZFUldSSVRFIHRoZSBsaXN0IG9mIGFkZHJlc3NlcyB0aGF0IGFyZSBtZW1iZXJzIG9mIHNwZWNpZmljIHJvbGVzLlxuICAgKlxuICAgKiBFdmVyeSByb2xlIGluIHRoZSBsaXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgbmV3IGxpc3Qgb2YgYWRkcmVzc2VzIHByb3ZpZGVkIHdpdGggdGhlbS5cbiAgICogSWYgeW91IHdhbnQgdG8gYWRkIG9yIHJlbW92ZSBhZGRyZXNzZXMgZm9yIGEgc2luZ2xlIGFkZHJlc3MgdXNlIHtAbGluayBDb250cmFjdFJvbGVzLmdyYW50fSBhbmQge0BsaW5rIENvbnRyYWN0Um9sZXMucmV2b2tlfSByZXNwZWN0aXZlbHkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHJvbGVzV2l0aEFkZHJlc3NlcyAtIEEgcmVjb3JkIG9mIHtAbGluayBSb2xlfXMgdG8gbGlzdHMgb2YgYWRkcmVzc2VzIHRoYXQgc2hvdWxkIGJlIG1lbWJlcnMgb2YgdGhlIGdpdmVuIHJvbGUuXG4gICAqIEB0aHJvd3MgSWYgeW91IGFyZSByZXF1ZXN0aW9uZyBhIHJvbGUgdGhhdCBkb2VzIG5vdCBleGlzdCBvbiB0aGUgY29udHJhY3QgdGhpcyB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgKiBAZXhhbXBsZSBTYXkgeW91IHdhbnQgdG8gb3ZlcndyaXRlIHRoZSBsaXN0IG9mIGFkZHJlc3NlcyB0aGF0IGFyZSBtZW1iZXJzIG9mIHRoZSBtaW50ZXIgcm9sZS5cbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBtaW50ZXJBZGRyZXNzZXMgPSBhd2FpdCBjb250cmFjdC5yb2xlcy5nZXQoXCJtaW50ZXJcIik7XG4gICAqIGF3YWl0IGNvbnRyYWN0LnJvbGVzLnNldEFsbCh7XG4gICAqICBtaW50ZXI6IFtdXG4gICAqIH0pO1xuICAgKiBjb25zb2xlLmxvZyhhd2FpdCBjb250cmFjdC5yb2xlcy5nZXQoXCJtaW50ZXJcIikpOyAvLyBObyBtYXR0ZXIgd2hhdCBtZW1iZXJzIGhhZCB0aGUgcm9sZSBiZWZvcmUsIHRoZSBuZXcgbGlzdCB3aWxsIGJlIHNldCB0byBbXVxuICAgKiBgYGBcbiAgICogQHB1YmxpY1xuICAgKiBAdHdmZWF0dXJlIFBlcm1pc3Npb25zXG4gICAqXG4gICAqICovXG4gIGFzeW5jIHNldEFsbChyb2xlc1dpdGhBZGRyZXNzZXMpIHtcbiAgICBjb25zdCByb2xlcyA9IE9iamVjdC5rZXlzKHJvbGVzV2l0aEFkZHJlc3Nlcyk7XG4gICAgaW52YXJpYW50KHJvbGVzLmxlbmd0aCwgXCJ5b3UgbXVzdCBwcm92aWRlIGF0IGxlYXN0IG9uZSByb2xlIHRvIHNldFwiKTtcbiAgICBpbnZhcmlhbnQocm9sZXMuZXZlcnkocm9sZSA9PiB0aGlzLnJvbGVzLmluY2x1ZGVzKHJvbGUpKSwgXCJ0aGlzIGNvbnRyYWN0IGRvZXMgbm90IHN1cHBvcnQgdGhlIGdpdmVuIHJvbGVcIik7XG4gICAgY29uc3QgY3VycmVudFJvbGVzID0gYXdhaXQgdGhpcy5nZXRBbGwoKTtcbiAgICBjb25zdCBlbmNvZGVkID0gW107XG4gICAgLy8gYWRkIC8gcmVtb3ZlIGFkbWluIHJvbGUgYXQgdGhlIGVuZCBzbyB3ZSBkb24ndCByZXZva2UgYWRtaW4gdGhlbiBncmFudFxuICAgIGNvbnN0IHNvcnRlZFJvbGVzID0gcm9sZXMuc29ydChyb2xlID0+IHJvbGUgPT09IFwiYWRtaW5cIiA/IDEgOiAtMSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3J0ZWRSb2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgcm9sZSA9IHNvcnRlZFJvbGVzW2ldO1xuICAgICAgY29uc3QgYWRkcmVzc2VzID0gcm9sZXNXaXRoQWRkcmVzc2VzW3JvbGVdIHx8IFtdO1xuICAgICAgY29uc3QgY3VycmVudEFkZHJlc3NlcyA9IGN1cnJlbnRSb2xlc1tyb2xlXSB8fCBbXTtcbiAgICAgIGNvbnN0IHRvQWRkID0gYWRkcmVzc2VzLmZpbHRlcihhZGRyZXNzID0+ICFjdXJyZW50QWRkcmVzc2VzLmluY2x1ZGVzKGFkZHJlc3MpKTtcbiAgICAgIGNvbnN0IHRvUmVtb3ZlID0gY3VycmVudEFkZHJlc3Nlcy5maWx0ZXIoYWRkcmVzcyA9PiAhYWRkcmVzc2VzLmluY2x1ZGVzKGFkZHJlc3MpKTtcbiAgICAgIGlmICh0b0FkZC5sZW5ndGgpIHtcbiAgICAgICAgdG9BZGQuZm9yRWFjaChhZGRyZXNzID0+IHtcbiAgICAgICAgICBlbmNvZGVkLnB1c2godGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoXCJncmFudFJvbGVcIiwgW2dldFJvbGVIYXNoKHJvbGUpLCBhZGRyZXNzXSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0b1JlbW92ZS5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0b1JlbW92ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB0b1JlbW92ZVtqXTtcbiAgICAgICAgICBjb25zdCByZXZva2VGdW5jdGlvbk5hbWUgPSBhd2FpdCB0aGlzLmdldFJldm9rZVJvbGVGdW5jdGlvbk5hbWUoYWRkcmVzcyk7XG4gICAgICAgICAgZW5jb2RlZC5wdXNoKHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKHJldm9rZUZ1bmN0aW9uTmFtZSwgW2dldFJvbGVIYXNoKHJvbGUpLCBhZGRyZXNzXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWNlaXB0OiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5tdWx0aUNhbGwoZW5jb2RlZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRocm93cyBhbiBlcnJvciBpZiBhbiBhZGRyZXNzIGlzIG1pc3NpbmcgdGhlIHJvbGVzIHNwZWNpZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHJvbGVzIC0gVGhlIHJvbGVzIHRvIGNoZWNrXG4gICAqIEBwYXJhbSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gY2hlY2tcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyB2ZXJpZnkocm9sZXMsIGFkZHJlc3MpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChyb2xlcy5tYXAoYXN5bmMgcm9sZSA9PiB7XG4gICAgICBjb25zdCBtZW1iZXJzID0gYXdhaXQgdGhpcy5nZXQocm9sZSk7XG4gICAgICBpZiAoIW1lbWJlcnMubWFwKGEgPT4gYS50b0xvd2VyQ2FzZSgpKS5pbmNsdWRlcyhhZGRyZXNzLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBNaXNzaW5nUm9sZUVycm9yKGFkZHJlc3MsIHJvbGUpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKiAqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBXUklURSBGVU5DVElPTlNcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIENhbGwgdGhpcyB0byBncmFudCBhIHJvbGUgdG8gYSBzcGVjaWZpYyBhZGRyZXNzLlxuICAgKlxuICAgKiBAcmVtYXJrcyBNYWtlIHN1cmUgeW91IGFyZSBzdXJlIHlvdSB3YW50IHRvIGdyYW50IHRoZSByb2xlIHRvIHRoZSBhZGRyZXNzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGF3YWl0IGNvbnRyYWN0LnJvbGVzLmdyYW50KFwibWludGVyXCIsIFwiMHgxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwXCIpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHJvbGUgLSBUaGUge0BsaW5rIFJvbGV9IHRvIGdyYW50IHRvIHRoZSBhZGRyZXNzXG4gICAqIEBwYXJhbSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gZ3JhbnQgdGhlIHJvbGUgdG9cbiAgICogQHJldHVybnMgVGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRcbiAgICogQHRocm93cyBJZiB5b3UgYXJlIHRyeWluZyB0byBncmFudCBkb2VzIG5vdCBleGlzdCBvbiB0aGUgY29udHJhY3QgdGhpcyB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEB0d2ZlYXR1cmUgUGVybWlzc2lvbnNcbiAgICovXG4gIGFzeW5jIGdyYW50KHJvbGUsIGFkZHJlc3MpIHtcbiAgICBpbnZhcmlhbnQodGhpcy5yb2xlcy5pbmNsdWRlcyhyb2xlKSwgYHRoaXMgY29udHJhY3QgZG9lcyBub3Qgc3VwcG9ydCB0aGUgXCIke3JvbGV9XCIgcm9sZWApO1xuICAgIHJldHVybiB7XG4gICAgICByZWNlaXB0OiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJncmFudFJvbGVcIiwgW2dldFJvbGVIYXNoKHJvbGUpLCBhZGRyZXNzXSlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgdGhpcyB0byByZXZva2UgYSByb2xlIGZyb20gYSBzcGVjaWZpYyBhZGRyZXNzLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKlxuICAgKiAtLSBDYXV0aW9uIC0tXG4gICAqXG4gICAqIFRoaXMgd2lsbCBsZXQgeW91IHJlbW92ZSB5b3Vyc2VsZiBmcm9tIHRoZSByb2xlLCB0b28uXG4gICAqIElmIHlvdSByZW1vdmUgeW91cnNlbGYgZnJvbSB0aGUgYWRtaW4gcm9sZSwgeW91IHdpbGwgbm8gbG9uZ2VyIGJlIGFibGUgdG8gYWRtaW5pc3RlciB0aGUgY29udHJhY3QuXG4gICAqIFRoZXJlIGlzIG5vIHdheSB0byByZWNvdmVyIGZyb20gdGhpcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBhd2FpdCBjb250cmFjdC5yb2xlcy5yZXZva2UoXCJtaW50ZXJcIiwgXCIweDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBcIik7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gcm9sZSAtIFRoZSB7QGxpbmsgUm9sZX0gdG8gcmV2b2tlXG4gICAqIEBwYXJhbSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gcmV2b2tlIHRoZSByb2xlIGZyb21cbiAgICogQHJldHVybnMgVGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRcbiAgICogQHRocm93cyBJZiB5b3UgYXJlIHRyeWluZyB0byByZXZva2UgZG9lcyBub3QgZXhpc3Qgb24gdGhlIG1vZHVsZSB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQHR3ZmVhdHVyZSBQZXJtaXNzaW9uc1xuICAgKi9cbiAgYXN5bmMgcmV2b2tlKHJvbGUsIGFkZHJlc3MpIHtcbiAgICBpbnZhcmlhbnQodGhpcy5yb2xlcy5pbmNsdWRlcyhyb2xlKSwgYHRoaXMgY29udHJhY3QgZG9lcyBub3Qgc3VwcG9ydCB0aGUgXCIke3JvbGV9XCIgcm9sZWApO1xuICAgIGNvbnN0IHJldm9rZUZ1bmN0aW9uTmFtZSA9IGF3YWl0IHRoaXMuZ2V0UmV2b2tlUm9sZUZ1bmN0aW9uTmFtZShhZGRyZXNzKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjZWlwdDogYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuc2VuZFRyYW5zYWN0aW9uKHJldm9rZUZ1bmN0aW9uTmFtZSwgW2dldFJvbGVIYXNoKHJvbGUpLCBhZGRyZXNzXSlcbiAgICB9O1xuICB9XG5cbiAgLyoqICoqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIFBSSVZBVEUgRlVOQ1RJT05TXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIGFzeW5jIGdldFJldm9rZVJvbGVGdW5jdGlvbk5hbWUoYWRkcmVzcykge1xuICAgIGNvbnN0IHNpZ25lckFkZHJlc3MgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRTaWduZXJBZGRyZXNzKCk7XG4gICAgaWYgKHNpZ25lckFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICByZXR1cm4gXCJyZW5vdW5jZVJvbGVcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwicmV2b2tlUm9sZVwiO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIGNvbnRyYWN0IHJveWFsdGllc1xuICogQHJlbWFya3MgQ29uZmlndXJlIHJveWFsdGllcyBmb3IgYW4gZW50aXJlIGNvbnRyYWN0IG9yIGEgcGFydGljdWxhciB0b2tlbi5cbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBjb250cmFjdCA9IGF3YWl0IHNkay5nZXRDb250cmFjdChcInt7Y29udHJhY3RfYWRkcmVzc319XCIpO1xuICogY29uc3Qgcm95YWx0eUluZm8gPSBhd2FpdCBjb250cmFjdC5yb3lhbHRpZXMuZ2V0RGVmYXVsdFJveWFsdHlJbmZvKCk7XG4gKiBhd2FpdCBjb250cmFjdC5yb2xlcy5zZXRUb2tlblJveWFsdHlJbmZvKHRva2VuSWQsIHtcbiAqICAgc2VsbGVyX2ZlZV9iYXNpc19wb2ludHM6IDEwMCwgLy8gMSUgcm95YWx0eSBmZWVcbiAqICAgZmVlX3JlY2lwaWVudDogXCIweC4uLlwiLCAvLyB0aGUgZmVlIHJlY2lwaWVudFxuICogfSk7XG4gKiBgYGBcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgQ29udHJhY3RSb3lhbHR5IHtcbiAgY29uc3RydWN0b3IoY29udHJhY3RXcmFwcGVyLCBtZXRhZGF0YSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZlYXR1cmVOYW1lXCIsIEZFQVRVUkVfUk9ZQUxUWS5uYW1lKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250cmFjdFdyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB2b2lkIDApO1xuICAgIHRoaXMuY29udHJhY3RXcmFwcGVyID0gY29udHJhY3RXcmFwcGVyO1xuICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByb3lhbHR5IHJlY2lwaWVudCBhbmQgQlBTIChiYXNpcyBwb2ludHMpIG9mIHRoZSBjb250cmFjdFxuICAgKiBAcmV0dXJucyAtIFRoZSByb3lhbHR5IHJlY2lwaWVudCBhbmQgQlBTXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3Qgcm95YWx0eUluZm8gPSBhd2FpdCBjb250cmFjdC5yb3lhbHRpZXMuZ2V0RGVmYXVsdFJveWFsdHlJbmZvKCk7XG4gICAqIGBgYFxuICAgKiBAcHVibGljXG4gICAqIEB0d2ZlYXR1cmUgUm95YWx0eVxuICAgKi9cbiAgYXN5bmMgZ2V0RGVmYXVsdFJveWFsdHlJbmZvKCkge1xuICAgIGNvbnN0IFtyb3lhbHR5UmVjaXBpZW50LCByb3lhbHR5QnBzXSA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5nZXREZWZhdWx0Um95YWx0eUluZm8oKTtcbiAgICAvLyBwYXJzZSBpdCBvbiB0aGUgd2F5IG91dCB0byBtYWtlIHN1cmUgd2UgZGVmYXVsdCB0aGluZ3MgaWYgdGhleSBhcmUgbm90IHNldFxuICAgIHJldHVybiBDb21tb25Sb3lhbHR5U2NoZW1hLnBhcnNlKHtcbiAgICAgIGZlZV9yZWNpcGllbnQ6IHJveWFsdHlSZWNpcGllbnQsXG4gICAgICBzZWxsZXJfZmVlX2Jhc2lzX3BvaW50czogcm95YWx0eUJwc1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHJveWFsdHkgcmVjaXBpZW50IGFuZCBCUFMgKGJhc2lzIHBvaW50cykgb2YgYSBwYXJ0aWN1bGFyIHRva2VuXG4gICAqIEByZXR1cm5zIC0gVGhlIHJveWFsdHkgcmVjaXBpZW50IGFuZCBCUFNcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCByb3lhbHR5SW5mbyA9IGF3YWl0IGNvbnRyYWN0LnJveWFsdGllcy5nZXREZWZhdWx0Um95YWx0eUluZm8oKTtcbiAgICogYGBgXG4gICAqIEBwdWJsaWNcbiAgICogQHR3ZmVhdHVyZSBSb3lhbHR5XG4gICAqL1xuICBhc3luYyBnZXRUb2tlblJveWFsdHlJbmZvKHRva2VuSWQpIHtcbiAgICBjb25zdCBbcm95YWx0eVJlY2lwaWVudCwgcm95YWx0eUJwc10gPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuZ2V0Um95YWx0eUluZm9Gb3JUb2tlbih0b2tlbklkKTtcbiAgICByZXR1cm4gQ29tbW9uUm95YWx0eVNjaGVtYS5wYXJzZSh7XG4gICAgICBmZWVfcmVjaXBpZW50OiByb3lhbHR5UmVjaXBpZW50LFxuICAgICAgc2VsbGVyX2ZlZV9iYXNpc19wb2ludHM6IHJveWFsdHlCcHNcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJveWFsdHkgcmVjaXBpZW50IGFuZCBmZWUgZm9yIGEgY29udHJhY3RcbiAgICogQHBhcmFtIHJveWFsdHlEYXRhIC0gdGhlIHJveWFsdHkgcmVjaXBpZW50IGFuZCBmZWVcbiAgICogIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogYXdhaXQgY29udHJhY3Qucm9sZXMuc2V0RGVmYXVsdFJveWFsdHlJbmZvKHtcbiAgICogICBzZWxsZXJfZmVlX2Jhc2lzX3BvaW50czogMTAwLCAvLyAxJSByb3lhbHR5IGZlZVxuICAgKiAgIGZlZV9yZWNpcGllbnQ6IFwiMHguLi5cIiwgLy8gdGhlIGZlZSByZWNpcGllbnRcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAcHVibGljXG4gICAqIEB0d2ZlYXR1cmUgUm95YWx0eVxuICAgKi9cbiAgYXN5bmMgc2V0RGVmYXVsdFJveWFsdHlJbmZvKHJveWFsdHlEYXRhKSB7XG4gICAgLy8gcmVhZCB0aGUgbWV0YWRhdGEgZnJvbSB0aGUgY29udHJhY3RcbiAgICBjb25zdCBvbGRNZXRhZGF0YSA9IGF3YWl0IHRoaXMubWV0YWRhdGEuZ2V0KCk7XG5cbiAgICAvLyB1cGRhdGUgdGhlIG1ldGFkYXRhIHdpdGggdGhlIG5ldyByb3lhbHR5IGRhdGFcbiAgICAvLyBpZiBvbmUgb2YgdGhlIGtleXMgaXMgXCJ1bmRlZmluZWRcIiBpdCB3aWxsIGJlIGlnbm9yZWQgKHdoaWNoIGlzIHRoZSBkZXNpcmVkIGJlaGF2aW9yKVxuICAgIGNvbnN0IG1lcmdlZE1ldGFkYXRhID0gdGhpcy5tZXRhZGF0YS5wYXJzZUlucHV0TWV0YWRhdGEoe1xuICAgICAgLi4ub2xkTWV0YWRhdGEsXG4gICAgICAuLi5yb3lhbHR5RGF0YVxuICAgIH0pO1xuXG4gICAgLy8gd2h5IG5vdCB1c2UgdGhpcy5tZXRhZGF0YS5zZXQoKT8gLSBiZWNhdXNlIHRoYXQgd291bGQgZW5kIHVwIHNlbmRpbmcgaXQncyBvd24gc2VwYXJhdGUgdHJhbnNhY3Rpb24gdG8gYHNldENvbnRyYWN0VVJJYFxuICAgIC8vIGJ1dCB3ZSB3YW50IHRvIHNlbmQgYm90aCB0aGUgYHNldFJveWFsdHlJbmZvYCBhbmQgYHNldENvbnRyYWN0VVJJYCBpbiBvbmUgdHJhbnNhY3Rpb24hXG4gICAgY29uc3QgY29udHJhY3RVUkkgPSBhd2FpdCB0aGlzLm1ldGFkYXRhLl9wYXJzZUFuZFVwbG9hZE1ldGFkYXRhKG1lcmdlZE1ldGFkYXRhKTtcbiAgICBpZiAoaGFzRnVuY3Rpb24oXCJzZXRDb250cmFjdFVSSVwiLCB0aGlzLmNvbnRyYWN0V3JhcHBlcikpIHtcbiAgICAgIC8vIGVuY29kZSBib3RoIHRoZSBmdW5jdGlvbnMgd2Ugd2FudCB0byBzZW5kXG4gICAgICBjb25zdCBlbmNvZGVkID0gW3RoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKFwic2V0RGVmYXVsdFJveWFsdHlJbmZvXCIsIFttZXJnZWRNZXRhZGF0YS5mZWVfcmVjaXBpZW50LCBtZXJnZWRNZXRhZGF0YS5zZWxsZXJfZmVlX2Jhc2lzX3BvaW50c10pLCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShcInNldENvbnRyYWN0VVJJXCIsIFtjb250cmFjdFVSSV0pXTtcbiAgICAgIC8vIGFjdHVhbGx5IHNlbmQgdGhlIHRyYW5zYWN0aW9uIGFuZCByZXR1cm4gdGhlIHJlY2VpcHQgKyBhIHdheSB0byBnZXQgdGhlIG5ldyByb3lhbHR5IGluZm9cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLm11bHRpQ2FsbChlbmNvZGVkKSxcbiAgICAgICAgZGF0YTogKCkgPT4gdGhpcy5nZXREZWZhdWx0Um95YWx0eUluZm8oKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXBkYXRpbmcgcm95YWx0aWVzIHJlcXVpcmVzIGltcGxlbWVudGluZyBDb250cmFjdE1ldGFkYXRhIGluIHlvdXIgY29udHJhY3QgdG8gc3VwcG9ydCBtYXJrZXRwbGFjZXMgbGlrZSBPcGVuU2VhLlwiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSByb3lhbHR5IHJlY2lwaWVudCBhbmQgZmVlIGZvciBhIHBhcnRpY3VsYXIgdG9rZW5cbiAgICogQHBhcmFtIHRva2VuSWQgLSB0aGUgdG9rZW4gaWRcbiAgICogQHBhcmFtIHJveWFsdHlEYXRhIC0gdGhlIHJveWFsdHkgcmVjaXBpZW50IGFuZCBmZWVcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBhd2FpdCBjb250cmFjdC5yb2xlcy5zZXRUb2tlblJveWFsdHlJbmZvKHRva2VuSWQsIHtcbiAgICogICBzZWxsZXJfZmVlX2Jhc2lzX3BvaW50czogMTAwLCAvLyAxJSByb3lhbHR5IGZlZVxuICAgKiAgIGZlZV9yZWNpcGllbnQ6IFwiMHguLi5cIiwgLy8gdGhlIGZlZSByZWNpcGllbnRcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAcHVibGljXG4gICAqIEB0d2ZlYXR1cmUgUm95YWx0eVxuICAgKi9cbiAgYXN5bmMgc2V0VG9rZW5Sb3lhbHR5SW5mbyh0b2tlbklkLCByb3lhbHR5RGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICByZWNlaXB0OiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJzZXRSb3lhbHR5SW5mb0ZvclRva2VuXCIsIFt0b2tlbklkLCByb3lhbHR5RGF0YS5mZWVfcmVjaXBpZW50LCByb3lhbHR5RGF0YS5zZWxsZXJfZmVlX2Jhc2lzX3BvaW50c10pLFxuICAgICAgZGF0YTogKCkgPT4gdGhpcy5nZXREZWZhdWx0Um95YWx0eUluZm8oKVxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgcHJpbWFyeSBzYWxlcyByZWNpcGllbnRzXG4gKiBAcmVtYXJrcyBDb25maWd1cmUgcHJpbWFyeSBzYWxlIHJlY2lwaWVudHMgZm9yIGFuIGVudGlyZSBjb250cmFjdC5cbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBjb250cmFjdCA9IGF3YWl0IHNkay5nZXRDb250cmFjdChcInt7Y29udHJhY3RfYWRkcmVzc319XCIpO1xuICogY29uc3Qgc2FsZXNSZWNpcGllbnQgPSBhd2FpdCBjb250cmFjdC5zYWxlcy5nZXRSZWNpcGllbnQoKTtcbiAqIGF3YWl0IGNvbnRyYWN0LnNhbGVzLnNldFJlY2lwaWVudChyZWNpcGllbnRXYWxsZXRBZGRyZXNzKTtcbiAqIGBgYFxuICogQHB1YmxpY1xuICovXG5jbGFzcyBDb250cmFjdFByaW1hcnlTYWxlIHtcbiAgY29uc3RydWN0b3IoY29udHJhY3RXcmFwcGVyKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZmVhdHVyZU5hbWVcIiwgRkVBVFVSRV9QUklNQVJZX1NBTEUubmFtZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIgPSBjb250cmFjdFdyYXBwZXI7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwcmltYXJ5IHNhbGUgcmVjaXBpZW50LlxuICAgKiBAcmV0dXJucyB0aGUgd2FsbGV0IGFkZHJlc3MuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3Qgc2FsZXNSZWNpcGllbnQgPSBhd2FpdCBjb250cmFjdC5zYWxlcy5nZXRSZWNpcGllbnQoKTtcbiAgICogYGBgXG4gICAqIEBwdWJsaWNcbiAgICogQHR3ZmVhdHVyZSBQcmltYXJ5U2FsZVxuICAgKi9cbiAgYXN5bmMgZ2V0UmVjaXBpZW50KCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QucHJpbWFyeVNhbGVSZWNpcGllbnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHByaW1hcnkgc2FsZSByZWNpcGllbnRcbiAgICogQHBhcmFtIHJlY2lwaWVudCAtIHRoZSB3YWxsZXQgYWRkcmVzc1xuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGF3YWl0IGNvbnRyYWN0LnNhbGVzLnNldFJlY2lwaWVudChyZWNpcGllbnRXYWxsZXRBZGRyZXNzKTtcbiAgICogYGBgXG4gICAqIEBwdWJsaWNcbiAgICogQHR3ZmVhdHVyZSBQcmltYXJ5U2FsZVxuICAgKi9cbiAgYXN5bmMgc2V0UmVjaXBpZW50KHJlY2lwaWVudCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWNlaXB0OiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJzZXRQcmltYXJ5U2FsZVJlY2lwaWVudFwiLCBbcmVjaXBpZW50XSlcbiAgICB9O1xuICB9XG59XG5cbmNvbnN0IEZBTExCQUNLX01FVEFEQVRBID0ge1xuICBuYW1lOiBcIkZhaWxlZCB0byBsb2FkIE5GVCBtZXRhZGF0YVwiXG59O1xuXG4vKipcbiAqIGZldGNoZXMgdGhlIHRva2VuIG1ldGFkYXRhXG4gKiBAcGFyYW0gdG9rZW5JZCAtIHRoZSBpZCAodG8gZ2V0IGl0IGJhY2sgaW4gdGhlIG91dHB1dClcbiAqIEBwYXJhbSB0b2tlblVyaSAtIHRoZSB1cmkgdG8gZmV0Y2hcbiAqIEBwYXJhbSBzdG9yYWdlIC0gd2hpY2ggc3RvcmFnZSB0byBmZXRjaCBmcm9tXG4gKlxuICogQGludGVybmFsXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoVG9rZW5NZXRhZGF0YSh0b2tlbklkLCB0b2tlblVyaSwgc3RvcmFnZSkge1xuICBjb25zdCBwYXJzZWRVcmkgPSB0b2tlblVyaS5yZXBsYWNlKFwie2lkfVwiLCBldGhlcnMudXRpbHMuaGV4WmVyb1BhZChCaWdOdW1iZXIuZnJvbSh0b2tlbklkKS50b0hleFN0cmluZygpLCAzMikuc2xpY2UoMikpO1xuICBsZXQganNvbk1ldGFkYXRhO1xuICB0cnkge1xuICAgIGpzb25NZXRhZGF0YSA9IGF3YWl0IHN0b3JhZ2UuZG93bmxvYWRKU09OKHBhcnNlZFVyaSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnN0IHVucGFyc2VkVG9rZW5JZFVyaSA9IHRva2VuVXJpLnJlcGxhY2UoXCJ7aWR9XCIsIEJpZ051bWJlci5mcm9tKHRva2VuSWQpLnRvU3RyaW5nKCkpO1xuICAgIHRyeSB7XG4gICAgICBqc29uTWV0YWRhdGEgPSBhd2FpdCBzdG9yYWdlLmRvd25sb2FkSlNPTih1bnBhcnNlZFRva2VuSWRVcmkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihgZmFpbGVkIHRvIGdldCB0b2tlbiBtZXRhZGF0YTogJHtKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHRva2VuSWQ6IHRva2VuSWQudG9TdHJpbmcoKSxcbiAgICAgICAgdG9rZW5VcmlcbiAgICAgIH0pfSAtLSBmYWxsaW5nIGJhY2sgdG8gZGVmYXVsdCBtZXRhZGF0YWApO1xuICAgICAganNvbk1ldGFkYXRhID0gRkFMTEJBQ0tfTUVUQURBVEE7XG4gICAgfVxuICB9XG4gIHJldHVybiBDb21tb25ORlRPdXRwdXQucGFyc2Uoe1xuICAgIC4uLmpzb25NZXRhZGF0YSxcbiAgICBpZDogQmlnTnVtYmVyLmZyb20odG9rZW5JZCkudG9TdHJpbmcoKSxcbiAgICB1cmk6IHRva2VuVXJpXG4gIH0pO1xufVxuXG4vLyBVc2VkIGZvciBtYXJrZXRwbGFjZSB0byBmZXRjaCBORlQgbWV0YWRhdGEgZnJvbSBjb250cmFjdCBhZGRyZXNzICsgdG9rZW5JZFxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3NcbiAqIEBwYXJhbSBwcm92aWRlclxuICogQHBhcmFtIHRva2VuSWRcbiAqIEBwYXJhbSBzdG9yYWdlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoVG9rZW5NZXRhZGF0YUZvckNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgcHJvdmlkZXIsIHRva2VuSWQsIHN0b3JhZ2UpIHtcbiAgbGV0IHVyaTtcbiAgY29uc3QgZXJjMTY1ID0gbmV3IENvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgRVJDMTY1QWJpLCBwcm92aWRlcik7XG4gIGNvbnN0IGlzRVJDNzIxID0gYXdhaXQgZXJjMTY1LnN1cHBvcnRzSW50ZXJmYWNlKEludGVyZmFjZUlkX0lFUkM3MjEpO1xuICBjb25zdCBpc0VSQzExNTUgPSBhd2FpdCBlcmMxNjUuc3VwcG9ydHNJbnRlcmZhY2UoSW50ZXJmYWNlSWRfSUVSQzExNTUpO1xuICBpZiAoaXNFUkM3MjEpIHtcbiAgICBjb25zdCBlcmM3MjEgPSBuZXcgQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBFUkM3MjFNZXRhZGF0YUFiaSwgcHJvdmlkZXIpO1xuICAgIHVyaSA9IGF3YWl0IGVyYzcyMS50b2tlblVSSSh0b2tlbklkKTtcbiAgfSBlbHNlIGlmIChpc0VSQzExNTUpIHtcbiAgICBjb25zdCBlcmMxMTU1ID0gbmV3IENvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgRVJDMTE1NU1ldGFkYXRhQWJpLCBwcm92aWRlcik7XG4gICAgdXJpID0gYXdhaXQgZXJjMTE1NS51cmkodG9rZW5JZCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoXCJDb250cmFjdCBtdXN0IGltcGxlbWVudCBFUkMgMTE1NSBvciBFUkMgNzIxLlwiKTtcbiAgfVxuICBpZiAoIXVyaSkge1xuICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKCk7XG4gIH1cbiAgcmV0dXJuIGZldGNoVG9rZW5NZXRhZGF0YSh0b2tlbklkLCB1cmksIHN0b3JhZ2UpO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIG1ldGFkYXRhXG4gKiBAcGFyYW0gc3RvcmFnZVxuICovXG5hc3luYyBmdW5jdGlvbiB1cGxvYWRPckV4dHJhY3RVUkkobWV0YWRhdGEsIHN0b3JhZ2UpIHtcbiAgaWYgKHR5cGVvZiBtZXRhZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXdhaXQgc3RvcmFnZS51cGxvYWQoQ29tbW9uTkZUSW5wdXQucGFyc2UobWV0YWRhdGEpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIG1ldGFkYXRhc1xuICogQHBhcmFtIHN0b3JhZ2VcbiAqIEBwYXJhbSBzdGFydE51bWJlclxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzc1xuICogQHBhcmFtIHNpZ25lckFkZHJlc3NcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZE9yRXh0cmFjdFVSSXMobWV0YWRhdGFzLCBzdG9yYWdlLCBzdGFydE51bWJlciwgb3B0aW9ucykge1xuICBpZiAoaXNVcmlMaXN0KG1ldGFkYXRhcykpIHtcbiAgICByZXR1cm4gbWV0YWRhdGFzO1xuICB9IGVsc2UgaWYgKGlzTWV0YWRhdGFMaXN0KG1ldGFkYXRhcykpIHtcbiAgICBjb25zdCB1cmlzID0gYXdhaXQgc3RvcmFnZS51cGxvYWRCYXRjaChtZXRhZGF0YXMubWFwKG0gPT4gQ29tbW9uTkZUSW5wdXQucGFyc2UobSkpLCB7XG4gICAgICByZXdyaXRlRmlsZU5hbWVzOiB7XG4gICAgICAgIGZpbGVTdGFydE51bWJlcjogc3RhcnROdW1iZXIgfHwgMFxuICAgICAgfSxcbiAgICAgIG9uUHJvZ3Jlc3M6IG9wdGlvbnM/Lm9uUHJvZ3Jlc3NcbiAgICB9KTtcbiAgICByZXR1cm4gdXJpcztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJORlQgbWV0YWRhdGFzIG11c3QgYWxsIGJlIG9mIHRoZSBzYW1lIHR5cGUgKGFsbCBVUkkgb3IgYWxsIE5GVE1ldGFkYXRhSW5wdXQpXCIpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRCYXNlVXJpRnJvbUJhdGNoKHVyaXMpIHtcbiAgY29uc3QgYmFzZVVyaSA9IHVyaXNbMF0uc3Vic3RyaW5nKDAsIHVyaXNbMF0ubGFzdEluZGV4T2YoXCIvXCIpKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdXJpID0gdXJpc1tpXS5zdWJzdHJpbmcoMCwgdXJpc1tpXS5sYXN0SW5kZXhPZihcIi9cIikpO1xuICAgIGlmIChiYXNlVXJpICE9PSB1cmkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuIG9ubHkgY3JlYXRlIGJhdGNoZXMgd2l0aCB0aGUgc2FtZSBiYXNlIFVSSSBmb3IgZXZlcnkgZW50cnkgaW4gdGhlIGJhdGNoLiBFeHBlY3RlZCAnJHtiYXNlVXJpfScgYnV0IGdvdCAnJHt1cml9J2ApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVuc3VyZSB0aGF0IGJhc2VVcmkgZW5kcyB3aXRoIHRyYWlsaW5nIHNsYXNoXG4gIHJldHVybiBiYXNlVXJpLnJlcGxhY2UoL1xcLyQvLCBcIlwiKSArIFwiL1wiO1xufVxuZnVuY3Rpb24gaXNVcmlMaXN0KG1ldGFkYXRhcykge1xuICByZXR1cm4gbWV0YWRhdGFzLmZpbmQobSA9PiB0eXBlb2YgbSAhPT0gXCJzdHJpbmdcIikgPT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzTWV0YWRhdGFMaXN0KG1ldGFkYXRhcykge1xuICByZXR1cm4gbWV0YWRhdGFzLmZpbmQobSA9PiB0eXBlb2YgbSAhPT0gXCJvYmplY3RcIikgPT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGRlbGF5ZWQgcmV2ZWFsIGxvZ2ljXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIERlbGF5ZWRSZXZlYWwge1xuICBjb25zdHJ1Y3Rvcihjb250cmFjdFdyYXBwZXIsIHN0b3JhZ2UsIGZldHVyZU5hbWUsIG5leHRUb2tlbklkVG9NaW50Rm4pIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmZWF0dXJlTmFtZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRyYWN0V3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3JhZ2VcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJuZXh0VG9rZW5JZFRvTWludEZuXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5mZWF0dXJlTmFtZSA9IGZldHVyZU5hbWU7XG4gICAgdGhpcy5uZXh0VG9rZW5JZFRvTWludEZuID0gbmV4dFRva2VuSWRUb01pbnRGbjtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlciA9IGNvbnRyYWN0V3JhcHBlcjtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGJhdGNoIG9mIGVuY3J5cHRlZCBORlRzIHRoYXQgY2FuIGJlIHJldmVhbGVkIGF0IGEgbGF0ZXIgdGltZS5cbiAgICogQHJlbWFya3MgQ3JlYXRlIGEgYmF0Y2ggb2YgZW5jcnlwdGVkIE5GVHMgdGhhdCBjYW4gYmUgcmV2ZWFsZWQgYXQgYSBsYXRlciB0aW1lLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIHRoZSByZWFsIE5GVHMsIHRoZXNlIHdpbGwgYmUgZW5jcnlwdGVkIHVudGlsIHlvdXIgcmV2ZWFsIHRoZW0hXG4gICAqIGNvbnN0IHJlYWxORlRzID0gW3tcbiAgICogICBuYW1lOiBcIkNvbW1vbiBORlQgIzFcIixcbiAgICogICBkZXNjcmlwdGlvbjogXCJDb21tb24gTkZULCBvbmUgb2YgbWFueS5cIixcbiAgICogICBpbWFnZTogZnMucmVhZEZpbGVTeW5jKFwicGF0aC90by9pbWFnZS5wbmdcIiksXG4gICAqIH0sIHtcbiAgICogICBuYW1lOiBcIlN1cGVyIFJhcmUgTkZUICMyXCIsXG4gICAqICAgZGVzY3JpcHRpb246IFwiWW91IGdvdCBhIFN1cGVyIFJhcmUgTkZUIVwiLFxuICAgKiAgIGltYWdlOiBmcy5yZWFkRmlsZVN5bmMoXCJwYXRoL3RvL2ltYWdlLnBuZ1wiKSxcbiAgICogfV07XG4gICAqIC8vIEEgcGxhY2Vob2xkZXIgTkZUIHRoYXQgcGVvcGxlIHdpbGwgZ2V0IGltbWVkaWF0ZWx5IGluIHRoZWlyIHdhbGxldCwgdW50aWwgdGhlIHJldmVhbCBoYXBwZW5zIVxuICAgKiBjb25zdCBwbGFjZWhvbGRlck5GVCA9IHtcbiAgICogICBuYW1lOiBcIkhpZGRlbiBORlRcIixcbiAgICogICBkZXNjcmlwdGlvbjogXCJXaWxsIGJlIHJldmVhbGVkIG5leHQgd2VlayFcIlxuICAgKiB9O1xuICAgKiAvLyBDcmVhdGUgYW5kIGVuY3J5cHQgdGhlIE5GVHNcbiAgICogYXdhaXQgY29udHJhY3QucmV2ZWFsZXIuY3JlYXRlRGVsYXllZFJldmVhbEJhdGNoKFxuICAgKiAgIHBsYWNlaG9sZGVyTkZULFxuICAgKiAgIHJlYWxORlRzLFxuICAgKiAgIFwibXkgc2VjcmV0IHBhc3N3b3JkXCIsXG4gICAqICk7XG4gICAqIGBgYFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSBwbGFjZWhvbGRlciAtIHRoZSBwbGFjZWhvbGRlciBORlQgdG8gc2hvdyBiZWZvcmUgdGhlIHJldmVhbFxuICAgKiBAcGFyYW0gbWV0YWRhdGFzIC0gdGhlIGZpbmFsIE5GVHMgdGhhdCB3aWxsIGJlIGhpZGRlblxuICAgKiBAcGFyYW0gcGFzc3dvcmQgLSB0aGUgcGFzc3dvcmQgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmV2ZWFsIHRoZXNlIE5GVHNcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBhZGRpdGlvbmFsIG9wdGlvbnMgbGlrZSB1cGxvYWQgcHJvZ3Jlc3NcbiAgICovXG4gIGFzeW5jIGNyZWF0ZURlbGF5ZWRSZXZlYWxCYXRjaChwbGFjZWhvbGRlciwgbWV0YWRhdGFzLCBwYXNzd29yZCwgb3B0aW9ucykge1xuICAgIGlmICghcGFzc3dvcmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhc3N3b3JkIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBwbGFjZWhvbGRlclVyaXMgPSBhd2FpdCB0aGlzLnN0b3JhZ2UudXBsb2FkQmF0Y2goW0NvbW1vbk5GVElucHV0LnBhcnNlKHBsYWNlaG9sZGVyKV0sIHtcbiAgICAgIHJld3JpdGVGaWxlTmFtZXM6IHtcbiAgICAgICAgZmlsZVN0YXJ0TnVtYmVyOiAwXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgcGxhY2Vob2xkZXJVcmkgPSBnZXRCYXNlVXJpRnJvbUJhdGNoKHBsYWNlaG9sZGVyVXJpcyk7XG4gICAgY29uc3Qgc3RhcnRGaWxlTnVtYmVyID0gYXdhaXQgdGhpcy5uZXh0VG9rZW5JZFRvTWludEZuKCk7XG4gICAgY29uc3QgdXJpcyA9IGF3YWl0IHRoaXMuc3RvcmFnZS51cGxvYWRCYXRjaChtZXRhZGF0YXMubWFwKG0gPT4gQ29tbW9uTkZUSW5wdXQucGFyc2UobSkpLCB7XG4gICAgICBvblByb2dyZXNzOiBvcHRpb25zPy5vblByb2dyZXNzLFxuICAgICAgcmV3cml0ZUZpbGVOYW1lczoge1xuICAgICAgICBmaWxlU3RhcnROdW1iZXI6IHN0YXJ0RmlsZU51bWJlci50b051bWJlcigpXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgYmFzZVVyaSA9IGdldEJhc2VVcmlGcm9tQmF0Y2godXJpcyk7XG4gICAgY29uc3QgYmFzZVVyaUlkID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmdldEJhc2VVUklDb3VudCgpO1xuICAgIGNvbnN0IGhhc2hlZFBhc3N3b3JkID0gYXdhaXQgdGhpcy5oYXNoRGVsYXlSZXZlYWxQYXN3b3JkKGJhc2VVcmlJZCwgcGFzc3dvcmQpO1xuICAgIGNvbnN0IGVuY3J5cHRlZEJhc2VVcmkgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuZW5jcnlwdERlY3J5cHQoZXRoZXJzLnV0aWxzLnRvVXRmOEJ5dGVzKGJhc2VVcmkpLCBoYXNoZWRQYXNzd29yZCk7XG4gICAgbGV0IGRhdGE7XG4gICAgY29uc3QgbGVnYWN5Q29udHJhY3QgPSBhd2FpdCB0aGlzLmlzTGVnYWN5Q29udHJhY3QoKTtcbiAgICBpZiAobGVnYWN5Q29udHJhY3QpIHtcbiAgICAgIGRhdGEgPSBlbmNyeXB0ZWRCYXNlVXJpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0Q2hhaW5JRCgpO1xuICAgICAgY29uc3QgcHJvdmVuYW5jZUhhc2ggPSBldGhlcnMudXRpbHMuc29saWRpdHlLZWNjYWsyNTYoW1wiYnl0ZXNcIiwgXCJieXRlc1wiLCBcInVpbnQyNTZcIl0sIFtldGhlcnMudXRpbHMudG9VdGY4Qnl0ZXMoYmFzZVVyaSksIGhhc2hlZFBhc3N3b3JkLCBjaGFpbklkXSk7XG4gICAgICBkYXRhID0gZXRoZXJzLnV0aWxzLmRlZmF1bHRBYmlDb2Rlci5lbmNvZGUoW1wiYnl0ZXNcIiwgXCJieXRlczMyXCJdLCBbZW5jcnlwdGVkQmFzZVVyaSwgcHJvdmVuYW5jZUhhc2hdKTtcbiAgICB9XG4gICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNlbmRUcmFuc2FjdGlvbihcImxhenlNaW50XCIsIFt1cmlzLmxlbmd0aCwgcGxhY2Vob2xkZXJVcmkuZW5kc1dpdGgoXCIvXCIpID8gcGxhY2Vob2xkZXJVcmkgOiBgJHtwbGFjZWhvbGRlclVyaX0vYCwgZGF0YV0pO1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuY29udHJhY3RXcmFwcGVyLnBhcnNlTG9ncyhcIlRva2Vuc0xhenlNaW50ZWRcIiwgcmVjZWlwdD8ubG9ncyk7XG4gICAgY29uc3Qgc3RhcnRpbmdJbmRleCA9IGV2ZW50c1swXS5hcmdzLnN0YXJ0VG9rZW5JZDtcbiAgICBjb25zdCBlbmRpbmdJbmRleCA9IGV2ZW50c1swXS5hcmdzLmVuZFRva2VuSWQ7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAobGV0IGlkID0gc3RhcnRpbmdJbmRleDsgaWQubHRlKGVuZGluZ0luZGV4KTsgaWQgPSBpZC5hZGQoMSkpIHtcbiAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgIGlkLFxuICAgICAgICByZWNlaXB0XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogUmV2ZWFsIGEgYmF0Y2ggb2YgaGlkZGVuIE5GVHNcbiAgICogQHJlbWFya3MgUmV2ZWFsIHRoZSBORlRzIG9mIGEgYmF0Y2ggdXNpbmcgdGhlIHBhc3N3b3JkLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIHRoZSBiYXRjaCB0byByZXZlYWxcbiAgICogY29uc3QgYmF0Y2hJZCA9IDA7XG4gICAqIC8vIHJldmVhbCB0aGUgYmF0Y2hcbiAgICogYXdhaXQgY29udHJhY3QucmV2ZWFsZXIucmV2ZWFsKGJhdGNoSWQsIFwibXkgc2VjcmV0IHBhc3N3b3JkXCIpO1xuICAgKiBgYGBcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gYmF0Y2hJZCAtIHRoZSBpZCBvZiB0aGUgYmF0Y2ggdG8gcmV2ZWFsXG4gICAqIEBwYXJhbSBwYXNzd29yZCAtIHRoZSBwYXNzd29yZFxuICAgKi9cbiAgYXN5bmMgcmV2ZWFsKGJhdGNoSWQsIHBhc3N3b3JkKSB7XG4gICAgaWYgKCFwYXNzd29yZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFzc3dvcmQgaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGF3YWl0IHRoaXMuaGFzaERlbGF5UmV2ZWFsUGFzd29yZChiYXRjaElkLCBwYXNzd29yZCk7XG4gICAgLy8gcGVyZm9ybWluZyB0aGUgcmV2ZWFsIGxvY2FsbHkgdG8gbWFrZSBzdXJlIGl0J2Qgc3VjY2VlZCBiZWZvcmUgc2VuZGluZyB0aGUgdHJhbnNhY3Rpb25cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGVjcnlwdGVkVXJpID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuY2FsbFN0YXRpYygpLnJldmVhbChiYXRjaElkLCBrZXkpO1xuICAgICAgLy8gYmFzaWMgc2FuaXR5IGNoZWNrIGZvciBtYWtpbmcgc3VyZSBkZWNyeXB0ZWRVcmkgaXMgdmFsaWRcbiAgICAgIC8vIHRoaXMgaXMgb3B0aW9uYWwgYmVjYXVzZSBpbnZhbGlkIGRlY3J5cHRpb24ga2V5IHdvdWxkIHJlc3VsdCBpbiBub24tdXRmOCBieXRlcyBhbmRcbiAgICAgIC8vIGV0aGVycyB3b3VsZCB0aHJvdyB3aGVuIHRyeWluZyB0byBkZWNvZGUgaXRcbiAgICAgIGlmICghZGVjcnlwdGVkVXJpLmluY2x1ZGVzKFwiOi8vXCIpIHx8ICFkZWNyeXB0ZWRVcmkuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGFzc3dvcmRcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXNzd29yZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNlbmRUcmFuc2FjdGlvbihcInJldmVhbFwiLCBbYmF0Y2hJZCwga2V5XSlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGxpc3Qgb2YgdW5yZXZlYWxlZCBORlQgYmF0Y2hlcy5cbiAgICogQHJlbWFya3MgR2V0cyB0aGUgbGlzdCBvZiB1bnJldmVhbGVkIE5GVCBiYXRjaGVzLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IGJhdGNoZXMgPSBhd2FpdCBjb250cmFjdC5yZXZlYWxlci5nZXRCYXRjaGVzVG9SZXZlYWwoKTtcbiAgICogYGBgXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFzeW5jIGdldEJhdGNoZXNUb1JldmVhbCgpIHtcbiAgICBjb25zdCBjb3VudCA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5nZXRCYXNlVVJJQ291bnQoKTtcbiAgICBpZiAoY291bnQuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgY291bnRSYW5nZUFycmF5ID0gQXJyYXkuZnJvbShBcnJheShjb3VudC50b051bWJlcigpKS5rZXlzKCkpO1xuICAgIC8vIG1hcCBvdmVyIHRvIGdldCB0aGUgYmFzZSB1cmkgaW5kaWNlcywgd2hpY2ggc2hvdWxkIGJlIHRoZSBlbmQgdG9rZW4gaWQgb2YgZXZlcnkgYmF0Y2hcbiAgICBjb25zdCB1cmlJbmRpY2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoY291bnRSYW5nZUFycmF5Lm1hcChpID0+IHtcbiAgICAgIGlmIChoYXNGdW5jdGlvbihcImdldEJhdGNoSWRBdEluZGV4XCIsIHRoaXMuY29udHJhY3RXcmFwcGVyKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmdldEJhdGNoSWRBdEluZGV4KGkpO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0Z1bmN0aW9uKFwiYmFzZVVSSUluZGljZXNcIiwgdGhpcy5jb250cmFjdFdyYXBwZXIpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuYmFzZVVSSUluZGljZXMoaSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250cmFjdCBkb2VzIG5vdCBoYXZlIGdldEJhdGNoSWRBdEluZGV4IG9yIGJhc2VVUklJbmRpY2VzLlwiKTtcbiAgICB9KSk7XG5cbiAgICAvLyBmaXJzdCBiYXRjaCBhbHdheXMgc3RhcnQgZnJvbSAwLiBkb24ndCBuZWVkIHRvIGZldGNoIHRoZSBsYXN0IGJhdGNoIHNvIHBvcCBpdCBmcm9tIHRoZSByYW5nZSBhcnJheVxuICAgIGNvbnN0IHVyaUluZGljZXNXaXRoWmVyb1N0YXJ0ID0gdXJpSW5kaWNlcy5zbGljZSgwLCB1cmlJbmRpY2VzLmxlbmd0aCAtIDEpO1xuXG4gICAgLy8gcmV0dXJucyB0aGUgdG9rZW4gdXJpIGZvciBlYWNoIGJhdGNoZXMuIGZpcnN0IGJhdGNoIGFsd2F5cyBzdGFydHMgZnJvbSB0b2tlbiBpZCAwLlxuICAgIGNvbnN0IHRva2VuTWV0YWRhdGFzID0gYXdhaXQgUHJvbWlzZS5hbGwoQXJyYXkuZnJvbShbMCwgLi4udXJpSW5kaWNlc1dpdGhaZXJvU3RhcnRdKS5tYXAoaSA9PiB0aGlzLmdldE5mdE1ldGFkYXRhKGkudG9TdHJpbmcoKSkpKTtcblxuICAgIC8vIGluZGV4IGlzIHRoZSB1cmkgaW5kaWNlcywgd2hpY2ggaXMgZW5kIHRva2VuIGlkLiBkaWZmZXJlbnQgZnJvbSB1cmlzXG4gICAgY29uc3QgbGVnYWN5Q29udHJhY3QgPSBhd2FpdCB0aGlzLmlzTGVnYWN5Q29udHJhY3QoKTtcbiAgICBjb25zdCBlbmNyeXB0ZWRVcmlEYXRhID0gYXdhaXQgUHJvbWlzZS5hbGwoQXJyYXkuZnJvbShbLi4udXJpSW5kaWNlc10pLm1hcChpID0+IGxlZ2FjeUNvbnRyYWN0ID8gdGhpcy5nZXRMZWdhY3lFbmNyeXB0ZWREYXRhKGkpIDogdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmVuY3J5cHRlZERhdGEoaSkpKTtcbiAgICBjb25zdCBlbmNyeXB0ZWRCYXNlVXJpcyA9IGVuY3J5cHRlZFVyaURhdGEubWFwKGRhdGEgPT4ge1xuICAgICAgaWYgKGV0aGVycy51dGlscy5oZXhEYXRhTGVuZ3RoKGRhdGEpID4gMCkge1xuICAgICAgICBpZiAobGVnYWN5Q29udHJhY3QpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBldGhlcnMudXRpbHMuZGVmYXVsdEFiaUNvZGVyLmRlY29kZShbXCJieXRlc1wiLCBcImJ5dGVzMzJcIl0sIGRhdGEpO1xuICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRva2VuTWV0YWRhdGFzLm1hcCgobWV0YSwgaW5kZXgpID0+ICh7XG4gICAgICBiYXRjaElkOiBCaWdOdW1iZXIuZnJvbShpbmRleCksXG4gICAgICBiYXRjaFVyaTogbWV0YS51cmksXG4gICAgICBwbGFjZWhvbGRlck1ldGFkYXRhOiBtZXRhXG4gICAgfSkpLmZpbHRlcigoXywgaW5kZXgpID0+IGV0aGVycy51dGlscy5oZXhEYXRhTGVuZ3RoKGVuY3J5cHRlZEJhc2VVcmlzW2luZGV4XSkgPiAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGdvcml0aG0gdG8gaGFzaCBkZWxheSByZXZlYWwgcGFzc3dvcmQsIHNvIHdlIGRvbid0IGJyb2FkY2FzdCB0aGUgaW5wdXQgcGFzc3dvcmQgb24tY2hhaW4uXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgaGFzaERlbGF5UmV2ZWFsUGFzd29yZChiYXRjaFRva2VuSW5kZXgsIHBhc3N3b3JkKSB7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLmdldENoYWluSUQoKTtcbiAgICBjb25zdCBjb250cmFjdEFkZHJlc3MgPSB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuYWRkcmVzcztcbiAgICByZXR1cm4gZXRoZXJzLnV0aWxzLnNvbGlkaXR5S2VjY2FrMjU2KFtcInN0cmluZ1wiLCBcInVpbnQyNTZcIiwgXCJ1aW50MjU2XCIsIFwiYWRkcmVzc1wiXSwgW3Bhc3N3b3JkLCBjaGFpbklkLCBiYXRjaFRva2VuSW5kZXgsIGNvbnRyYWN0QWRkcmVzc10pO1xuICB9XG4gIGFzeW5jIGdldE5mdE1ldGFkYXRhKHRva2VuSWQpIHtcbiAgICByZXR1cm4gZmV0Y2hUb2tlbk1ldGFkYXRhRm9yQ29udHJhY3QodGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmFkZHJlc3MsIHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFByb3ZpZGVyKCksIHRva2VuSWQsIHRoaXMuc3RvcmFnZSk7XG4gIH1cbiAgYXN5bmMgaXNMZWdhY3lDb250cmFjdCgpIHtcbiAgICBpZiAoaGFzRnVuY3Rpb24oXCJjb250cmFjdFZlcnNpb25cIiwgdGhpcy5jb250cmFjdFdyYXBwZXIpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmNvbnRyYWN0VmVyc2lvbigpO1xuICAgICAgICByZXR1cm4gdmVyc2lvbiA8PSAyO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyBnZXRMZWdhY3lFbmNyeXB0ZWREYXRhKGluZGV4KSB7XG4gICAgY29uc3QgbGVnYWN5ID0gbmV3IGV0aGVycy5Db250cmFjdCh0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuYWRkcmVzcywgRGVwcmVjYXRlZEFiaSwgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJvdmlkZXIoKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbGVnYWN5LmZ1bmN0aW9uc1tcImVuY3J5cHRlZEJhc2VVUklcIl0oaW5kZXgpO1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiMHhcIjtcbiAgICB9XG4gIH1cbn1cblxubGV0IExpc3RpbmdUeXBlO1xuKGZ1bmN0aW9uIChMaXN0aW5nVHlwZSkge1xuICBMaXN0aW5nVHlwZVtMaXN0aW5nVHlwZVtcIkRpcmVjdFwiXSA9IDBdID0gXCJEaXJlY3RcIjtcbiAgTGlzdGluZ1R5cGVbTGlzdGluZ1R5cGVbXCJBdWN0aW9uXCJdID0gMV0gPSBcIkF1Y3Rpb25cIjtcbn0pKExpc3RpbmdUeXBlIHx8IChMaXN0aW5nVHlwZSA9IHt9KSk7XG5cbmxldCBQcm9wb3NhbFN0YXRlO1xuKGZ1bmN0aW9uIChQcm9wb3NhbFN0YXRlKSB7XG4gIFByb3Bvc2FsU3RhdGVbUHJvcG9zYWxTdGF0ZVtcIlBlbmRpbmdcIl0gPSAwXSA9IFwiUGVuZGluZ1wiO1xuICBQcm9wb3NhbFN0YXRlW1Byb3Bvc2FsU3RhdGVbXCJBY3RpdmVcIl0gPSAxXSA9IFwiQWN0aXZlXCI7XG4gIFByb3Bvc2FsU3RhdGVbUHJvcG9zYWxTdGF0ZVtcIkNhbmNlbGVkXCJdID0gMl0gPSBcIkNhbmNlbGVkXCI7XG4gIFByb3Bvc2FsU3RhdGVbUHJvcG9zYWxTdGF0ZVtcIkRlZmVhdGVkXCJdID0gM10gPSBcIkRlZmVhdGVkXCI7XG4gIFByb3Bvc2FsU3RhdGVbUHJvcG9zYWxTdGF0ZVtcIlN1Y2NlZWRlZFwiXSA9IDRdID0gXCJTdWNjZWVkZWRcIjtcbiAgUHJvcG9zYWxTdGF0ZVtQcm9wb3NhbFN0YXRlW1wiUXVldWVkXCJdID0gNV0gPSBcIlF1ZXVlZFwiO1xuICBQcm9wb3NhbFN0YXRlW1Byb3Bvc2FsU3RhdGVbXCJFeHBpcmVkXCJdID0gNl0gPSBcIkV4cGlyZWRcIjtcbiAgUHJvcG9zYWxTdGF0ZVtQcm9wb3NhbFN0YXRlW1wiRXhlY3V0ZWRcIl0gPSA3XSA9IFwiRXhlY3V0ZWRcIjtcbn0pKFByb3Bvc2FsU3RhdGUgfHwgKFByb3Bvc2FsU3RhdGUgPSB7fSkpO1xuXG5sZXQgVm90ZVR5cGU7XG4oZnVuY3Rpb24gKFZvdGVUeXBlKSB7XG4gIFZvdGVUeXBlW1ZvdGVUeXBlW1wiQWdhaW5zdFwiXSA9IDBdID0gXCJBZ2FpbnN0XCI7XG4gIFZvdGVUeXBlW1ZvdGVUeXBlW1wiRm9yXCJdID0gMV0gPSBcIkZvclwiO1xuICBWb3RlVHlwZVtWb3RlVHlwZVtcIkFic3RhaW5cIl0gPSAyXSA9IFwiQWJzdGFpblwiO1xufSkoVm90ZVR5cGUgfHwgKFZvdGVUeXBlID0ge30pKTtcblxubGV0IENsYWltRWxpZ2liaWxpdHk7XG4oZnVuY3Rpb24gKENsYWltRWxpZ2liaWxpdHkpIHtcbiAgQ2xhaW1FbGlnaWJpbGl0eVtcIk5vdEVub3VnaFN1cHBseVwiXSA9IFwiVGhlcmUgaXMgbm90IGVub3VnaCBzdXBwbHkgdG8gY2xhaW0uXCI7XG4gIENsYWltRWxpZ2liaWxpdHlbXCJBZGRyZXNzTm90QWxsb3dlZFwiXSA9IFwiVGhpcyBhZGRyZXNzIGlzIG5vdCBvbiB0aGUgYWxsb3dsaXN0LlwiO1xuICBDbGFpbUVsaWdpYmlsaXR5W1wiV2FpdEJlZm9yZU5leHRDbGFpbVRyYW5zYWN0aW9uXCJdID0gXCJOb3QgZW5vdWdoIHRpbWUgc2luY2UgbGFzdCBjbGFpbSB0cmFuc2FjdGlvbi4gUGxlYXNlIHdhaXQuXCI7XG4gIENsYWltRWxpZ2liaWxpdHlbXCJBbHJlYWR5Q2xhaW1lZFwiXSA9IFwiWW91IGhhdmUgYWxyZWFkeSBjbGFpbWVkIHRoZSB0b2tlbi5cIjtcbiAgQ2xhaW1FbGlnaWJpbGl0eVtcIk5vdEVub3VnaFRva2Vuc1wiXSA9IFwiVGhlcmUgYXJlIG5vdCBlbm91Z2ggdG9rZW5zIGluIHRoZSB3YWxsZXQgdG8gcGF5IGZvciB0aGUgY2xhaW0uXCI7XG4gIENsYWltRWxpZ2liaWxpdHlbXCJOb0FjdGl2ZUNsYWltUGhhc2VcIl0gPSBcIlRoZXJlIGlzIG5vIGFjdGl2ZSBjbGFpbSBwaGFzZSBhdCB0aGUgbW9tZW50LiBQbGVhc2UgY2hlY2sgYmFjayBpbiBsYXRlci5cIjtcbiAgQ2xhaW1FbGlnaWJpbGl0eVtcIk5vQ2xhaW1Db25kaXRpb25TZXRcIl0gPSBcIlRoZXJlIGlzIG5vIGNsYWltIGNvbmRpdGlvbiBzZXQuXCI7XG4gIENsYWltRWxpZ2liaWxpdHlbXCJOb1dhbGxldFwiXSA9IFwiTm8gd2FsbGV0IGNvbm5lY3RlZC5cIjtcbiAgQ2xhaW1FbGlnaWJpbGl0eVtcIlVua25vd25cIl0gPSBcIk5vIGNsYWltIGNvbmRpdGlvbnMgZm91bmQuXCI7XG59KShDbGFpbUVsaWdpYmlsaXR5IHx8IChDbGFpbUVsaWdpYmlsaXR5ID0ge30pKTtcblxuLyoqXG4gKiBFc3RpbWF0ZXMgdGhlIGdhcyBjb3N0IG9mIENvbnRyYWN0IGNhbGxzXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEdhc0Nvc3RFc3RpbWF0b3Ige1xuICBjb25zdHJ1Y3Rvcihjb250cmFjdFdyYXBwZXIpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250cmFjdFdyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlciA9IGNvbnRyYWN0V3JhcHBlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFc3RpbWF0ZXMgdGhlIGNvc3Qgb2YgZ2FzIGluIG5hdGl2ZSB0b2tlbiBvZiB0aGUgY3VycmVudCBjaGFpblxuICAgKiBQYXNzIGluIHRoZSBzYW1lIHBhcmFtZXRlcnMgYXMgdGhlIGNvbnRyYWN0J3MgZnVuY3Rpb24uXG4gICAqIEByZW1hcmtzIEVzdGltYXRlIHRoZSBjb3N0IG9mIGdhcyBpbiBuYXRpdmUgdG9rZW4gb2YgdGhlIGN1cnJlbnQgY2hhaW5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBjb3N0T2ZDbGFpbSA9IGF3YWl0IG5mdERyb3A/LmVzdGltYXRvci5nYXNDb3N0T2YoXCJjbGFpbVwiLCBbXG4gICAqICAgXCIweC4uLlwiLCAvLyByZWNlaXZlclxuICAgKiAgIDEsIC8vIHF1YW50aXR5XG4gICAqICAgXCIweC4uLlwiLCAvLyBjdXJyZW5jeVxuICAgKiAgIDEsIC8vIHByaWNlIHBlciB0b2tlblxuICAgKiAgIFtdLCAvLyBwcm9vZnNcbiAgICogICAxLCAvLyBwcm9vZiBtYXggcXVhbnRpdHkgcGVyIHRyYW5zYWN0aW9uXG4gICAqIF0pO1xuICAgKiBgYGBcbiAgICogQHJldHVybnMgdGhlIGVzdGltYXRlZCBwcmljZSBpbiBuYXRpdmUgY3VycmVuY3kgKEVUSCwgTUFUSUMsIGV0Yykgb2YgY2FsbGluZyB0aGlzIGZ1bmN0aW9uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFzeW5jIGdhc0Nvc3RPZihmbiwgYXJncykge1xuICAgIGNvbnN0IHByaWNlID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJlZmVycmVkR2FzUHJpY2UoKTtcbiAgICBjb25zdCBnYXNVbml0cyA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLmVzdGltYXRlR2FzKGZuLCBhcmdzKTtcbiAgICByZXR1cm4gZXRoZXJzLnV0aWxzLmZvcm1hdEV0aGVyKGdhc1VuaXRzLm11bChwcmljZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVzdGltYXRlcyB0aGUgZ2FzIGxpbWl0IG9mIGEgdHJhbnNhY3Rpb25cbiAgICogUGFzcyBpbiB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIHRoZSBjb250cmFjdCdzIGZ1bmN0aW9uLlxuICAgKiBAcmVtYXJrcyBFc3RpbWF0ZXMgdGhlIGdhcyBsaW1pdCBvZiBhIHRyYW5zYWN0aW9uXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgZ2FzTGltaXRPZkNsYWltID0gYXdhaXQgbmZ0RHJvcD8uZXN0aW1hdG9yLmdhc0xpbWl0T2YoXCJjbGFpbVwiLCBbXG4gICAqICAgXCIweC4uLlwiLCAvLyByZWNlaXZlclxuICAgKiAgIDEsIC8vIHF1YW50aXR5XG4gICAqICAgXCIweC4uLlwiLCAvLyBjdXJyZW5jeVxuICAgKiAgIDEsIC8vIHByaWNlIHBlciB0b2tlblxuICAgKiAgIFtdLCAvLyBwcm9vZnNcbiAgICogICAxLCAvLyBwcm9vZiBtYXggcXVhbnRpdHkgcGVyIHRyYW5zYWN0aW9uXG4gICAqIF0pO1xuICAgKiBgYGBcbiAgICogQHJldHVybnMgdGhlIGVzdGltYXRlZCBnYXMgbGltaXQgb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFzeW5jIGdhc0xpbWl0T2YoZm4sIGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cmFjdFdyYXBwZXIuZXN0aW1hdGVHYXMoZm4sIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgZ2FzIHByaWNlIGluIGd3ZWlcbiAgICogQHJlbWFya3MgR2V0IHRoZSBjdXJyZW50IGdhcyBwcmljZSBpbiBnd2VpXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgZ2FzQ29zdEluR3dlaSA9IGF3YWl0IGNvbnRyYWN0LmVzdGltYXRvci5jdXJyZW50R2FzUHJpY2VJbkd3ZWkoKTtcbiAgICogYGBgXG4gICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IGdhcyBwcmljZSBpbiBnd2VpXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFzeW5jIGN1cnJlbnRHYXNQcmljZUluR3dlaSgpIHtcbiAgICBjb25zdCBwcmljZSA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFByb3ZpZGVyKCkuZ2V0R2FzUHJpY2UoKTtcbiAgICByZXR1cm4gZXRoZXJzLnV0aWxzLmZvcm1hdFVuaXRzKHByaWNlLCBcImd3ZWlcIik7XG4gIH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIFJlcHJlc2VudHMgYSB0cmFuc2FjdGlvbiB0byBiZSBleGVjdXRlZCBhbmQgY2FuIGJlIGN1c3RvbWl6ZWQuXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uVGFzayB7XG4gIHN0YXRpYyBtYWtlKHRhc2tBcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvblRhc2sodGFza0FyZ3MpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHRhc2tBcmdzKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZnVuY3Rpb25OYW1lXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJnc1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm92ZXJyaWRlc1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVuY29kZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlc3RpbWF0b3JcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlciA9IHRhc2tBcmdzLmNvbnRyYWN0V3JhcHBlcjtcbiAgICB0aGlzLmZ1bmN0aW9uTmFtZSA9IHRhc2tBcmdzLmZ1bmN0aW9uTmFtZTtcbiAgICB0aGlzLmFyZ3MgPSB0YXNrQXJncy5hcmdzIHx8IFtdO1xuICAgIHRoaXMub3ZlcnJpZGVzID0gdGFza0FyZ3Mub3ZlcnJpZGVzO1xuICAgIHRoaXMuZW5jb2RlciA9IG5ldyBDb250cmFjdEVuY29kZXIodGhpcy5jb250cmFjdFdyYXBwZXIpO1xuICAgIHRoaXMuZXN0aW1hdG9yID0gbmV3IEdhc0Nvc3RFc3RpbWF0b3IodGhpcy5jb250cmFjdFdyYXBwZXIpO1xuICB9XG5cbiAgLy8gLy8vLy8vLy8vLy8vLy8gT3ZlcnJpZGVzIC8vLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIGdhcyBsaW1pdCBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIGdhc0xpbWl0XG4gICAqL1xuICBvdmVycmlkZUdhc0xpbWl0KGdhc0xpbWl0KSB7XG4gICAgdGhpcy5vdmVycmlkZXMgPSB7XG4gICAgICAuLi50aGlzLm92ZXJyaWRlcyxcbiAgICAgIGdhc0xpbWl0XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgZ2FzIHByaWNlIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0gZ2FzUHJpY2VcbiAgICovXG4gIG92ZXJyaWRlR2FzUHJpY2UoZ2FzUHJpY2UpIHtcbiAgICB0aGlzLm92ZXJyaWRlcyA9IHtcbiAgICAgIC4uLnRoaXMub3ZlcnJpZGVzLFxuICAgICAgZ2FzUHJpY2VcbiAgICB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSBub25jZSBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIG5vbmNlXG4gICAqL1xuICBvdmVycmlkZU5vbmNlKG5vbmNlKSB7XG4gICAgdGhpcy5vdmVycmlkZXMgPSB7XG4gICAgICAuLi50aGlzLm92ZXJyaWRlcyxcbiAgICAgIG5vbmNlXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgdmFsdWUgc2VudCB3aXRoIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKi9cbiAgb3ZlcnJpZGVWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMub3ZlcnJpZGVzID0ge1xuICAgICAgLi4udGhpcy5vdmVycmlkZXMsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyAvLy8vLy8vLy8vLy8vLyBFc3RpbWF0ZXMgLy8vLy8vLy8vLy8vLy8vL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnYXMgbGltaXQgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdvdWxkIGNvbnN1bWUgaWYgZXhlY3V0ZWQuXG4gICAqIEByZXR1cm5zIHRoZSBnYXMgbGltaXQgaW4gZ2FzIHVuaXRzXG4gICAqL1xuICBhc3luYyBlc3RpbWF0ZUdhc0xpbWl0KCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmVzdGltYXRvci5nYXNMaW1pdE9mKHRoaXMuZnVuY3Rpb25OYW1lLCB0aGlzLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRvdGFsIGdhcyBjb3N0IG9mIHRoaXMgdHJhbnNhY3Rpb24gaWYgZXhlY3V0ZWQuXG4gICAqIEByZXR1cm5zIHRoZSBnYXMgY29zdCBpbiBldGhlclxuICAgKi9cbiAgYXN5bmMgZXN0aW1hdGVHYXNDb3N0SW5FdGhlcigpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5lc3RpbWF0b3IuZ2FzQ29zdE9mKHRoaXMuZnVuY3Rpb25OYW1lLCB0aGlzLmFyZ3MpO1xuICB9XG5cbiAgLy8gLy8vLy8vLy8vLy8vLy8gQWN0aW9ucyAvLy8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVuY29kZWQgZnVuY3Rpb24gZGF0YSBvZiB0aGlzIHRyYW5zYWN0aW9uIGlmIGV4ZWN1dGVkLlxuICAgKi9cbiAgYXN5bmMgZW5jb2RlRnVuY3Rpb25EYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmVuY29kZXIuZW5jb2RlKHRoaXMuZnVuY3Rpb25OYW1lLCB0aGlzLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1Ym1pdHMgdGhpcyB0cmFuc2FjdGlvbiB0byB0aGUgbmV0d29yay4gRG9lcyBub3Qgd2FpdCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGJlIG1pbmVkLlxuICAgKiBUbyB3YWl0IGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgbWluZWQsIHlvdSBjYW4gY2FsbCBgLndhaXQoKWAgb24gdGhlIHJlc3VsdCBvZiB0aGlzIGZ1bmN0aW9uLlxuICAgKi9cbiAgYXN5bmMgc3VibWl0KCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb25CeUZ1bmN0aW9uKHRoaXMuZnVuY3Rpb25OYW1lLCB0aGlzLmFyZ3MsIHRoaXMub3ZlcnJpZGVzIHx8IHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJtaXRzIHRoaXMgdHJhbnNhY3Rpb24gdG8gdGhlIG5ldHdvcmsgYW5kIHdhaXRzIGZvciBpdCB0byBiZSBtaW5lZC5cbiAgICovXG4gIGFzeW5jIGV4ZWN1dGUoKSB7XG4gICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNlbmRUcmFuc2FjdGlvbih0aGlzLmZ1bmN0aW9uTmFtZSwgdGhpcy5hcmdzLCB0aGlzLm92ZXJyaWRlcyB8fCB7fSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHRcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogTWFuYWdlcyBjbGFpbSBjb25kaXRpb25zIGZvciBORlQgRHJvcCBjb250cmFjdHNcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgRHJvcENsYWltQ29uZGl0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKGNvbnRyYWN0V3JhcHBlciwgbWV0YWRhdGEsIHN0b3JhZ2UpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250cmFjdFdyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3JhZ2VcIiwgdm9pZCAwKTtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgIHRoaXMuY29udHJhY3RXcmFwcGVyID0gY29udHJhY3RXcmFwcGVyO1xuICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgfVxuXG4gIC8qKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICogUkVBRCBGVU5DVElPTlNcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgY2xhaW0gY29uZGl0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBjbGFpbSBjb25kaXRpb24gbWV0YWRhdGFcbiAgICovXG4gIGFzeW5jIGdldEFjdGl2ZShvcHRpb25zKSB7XG4gICAgY29uc3QgY2MgPSBhd2FpdCB0aGlzLmdldCgpO1xuICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5tZXRhZGF0YS5nZXQoKTtcbiAgICByZXR1cm4gYXdhaXQgdHJhbnNmb3JtUmVzdWx0VG9DbGFpbUNvbmRpdGlvbihjYywgYXdhaXQgdGhpcy5nZXRUb2tlbkRlY2ltYWxzKCksIHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFByb3ZpZGVyKCksIG1ldGFkYXRhLm1lcmtsZSB8fCB7fSwgdGhpcy5zdG9yYWdlLCBvcHRpb25zPy53aXRoQWxsb3dMaXN0IHx8IGZhbHNlKTtcbiAgfVxuICBhc3luYyBnZXQoY29uZGl0aW9uSWQpIHtcbiAgICBpZiAodGhpcy5pc0xlZ2FjeVNpbmdsZVBoYXNlRHJvcCh0aGlzLmNvbnRyYWN0V3JhcHBlcikpIHtcbiAgICAgIGNvbnN0IGNvbnRyYWN0TW9kZWwgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuY2xhaW1Db25kaXRpb24oKTtcbiAgICAgIHJldHVybiBsZWdhY3lDb250cmFjdE1vZGVsVG9BYnN0cmFjdChjb250cmFjdE1vZGVsKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNMZWdhY3lNdWx0aVBoYXNlRHJvcCh0aGlzLmNvbnRyYWN0V3JhcHBlcikpIHtcbiAgICAgIGNvbnN0IGlkID0gY29uZGl0aW9uSWQgIT09IHVuZGVmaW5lZCA/IGNvbmRpdGlvbklkIDogYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmdldEFjdGl2ZUNsYWltQ29uZGl0aW9uSWQoKTtcbiAgICAgIGNvbnN0IGNvbnRyYWN0TW9kZWwgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuZ2V0Q2xhaW1Db25kaXRpb25CeUlkKGlkKTtcbiAgICAgIHJldHVybiBsZWdhY3lDb250cmFjdE1vZGVsVG9BYnN0cmFjdChjb250cmFjdE1vZGVsKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNOZXdTaW5nbGVQaGFzZURyb3AodGhpcy5jb250cmFjdFdyYXBwZXIpKSB7XG4gICAgICBjb25zdCBjb250cmFjdE1vZGVsID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmNsYWltQ29uZGl0aW9uKCk7XG4gICAgICByZXR1cm4gbmV3Q29udHJhY3RNb2RlbFRvQWJzdHJhY3QoY29udHJhY3RNb2RlbCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzTmV3TXVsdGlwaGFzZURyb3AodGhpcy5jb250cmFjdFdyYXBwZXIpKSB7XG4gICAgICBjb25zdCBpZCA9IGNvbmRpdGlvbklkICE9PSB1bmRlZmluZWQgPyBjb25kaXRpb25JZCA6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5nZXRBY3RpdmVDbGFpbUNvbmRpdGlvbklkKCk7XG4gICAgICBjb25zdCBjb250cmFjdE1vZGVsID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmdldENsYWltQ29uZGl0aW9uQnlJZChpZCk7XG4gICAgICByZXR1cm4gbmV3Q29udHJhY3RNb2RlbFRvQWJzdHJhY3QoY29udHJhY3RNb2RlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRyYWN0IGRvZXMgbm90IHN1cHBvcnQgY2xhaW0gY29uZGl0aW9uc1wiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCB0aGUgY2xhaW0gY29uZGl0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgY2xhaW0gY29uZGl0aW9ucyBtZXRhZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0QWxsKG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5pc0xlZ2FjeU11bHRpUGhhc2VEcm9wKHRoaXMuY29udHJhY3RXcmFwcGVyKSB8fCB0aGlzLmlzTmV3TXVsdGlwaGFzZURyb3AodGhpcy5jb250cmFjdFdyYXBwZXIpKSB7XG4gICAgICBjb25zdCBjbGFpbUNvbmRpdGlvbiA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5jbGFpbUNvbmRpdGlvbigpO1xuICAgICAgY29uc3Qgc3RhcnRJZCA9IGNsYWltQ29uZGl0aW9uLmN1cnJlbnRTdGFydElkLnRvTnVtYmVyKCk7XG4gICAgICBjb25zdCBjb3VudCA9IGNsYWltQ29uZGl0aW9uLmNvdW50LnRvTnVtYmVyKCk7XG4gICAgICBjb25zdCBjb25kaXRpb25zID0gW107XG4gICAgICBmb3IgKGxldCBpID0gc3RhcnRJZDsgaSA8IHN0YXJ0SWQgKyBjb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbmRpdGlvbnMucHVzaChhd2FpdCB0aGlzLmdldChpKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMubWV0YWRhdGEuZ2V0KCk7XG4gICAgICBjb25zdCBkZWNpbWFscyA9IGF3YWl0IHRoaXMuZ2V0VG9rZW5EZWNpbWFscygpO1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGNvbmRpdGlvbnMubWFwKGMgPT4gdHJhbnNmb3JtUmVzdWx0VG9DbGFpbUNvbmRpdGlvbihjLCBkZWNpbWFscywgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJvdmlkZXIoKSwgbWV0YWRhdGEubWVya2xlLCB0aGlzLnN0b3JhZ2UsIG9wdGlvbnM/LndpdGhBbGxvd0xpc3QgfHwgZmFsc2UpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbYXdhaXQgdGhpcy5nZXRBY3RpdmUob3B0aW9ucyldO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYW4gQ2xhaW1cbiAgICpcbiAgICogQHJlbWFya3MgQ2hlY2sgaWYgdGhlIGRyb3AgY2FuIGN1cnJlbnRseSBiZSBjbGFpbWVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIFF1YW50aXR5IG9mIHRva2VucyB0byBjaGVjayBjbGFpbWFiaWxpdHkgb2ZcbiAgICogY29uc3QgcXVhbnRpdHkgPSAxO1xuICAgKiBjb25zdCBjYW5DbGFpbSA9IGF3YWl0IGNvbnRyYWN0LmNhbkNsYWltKHF1YW50aXR5KTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBjYW5DbGFpbShxdWFudGl0eSwgYWRkcmVzc1RvQ2hlY2spIHtcbiAgICAvLyBUT0RPIHN3aXRjaCB0byB1c2UgdmVyaWZ5Q2xhaW1cbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0Q2xhaW1JbmVsaWdpYmlsaXR5UmVhc29ucyhxdWFudGl0eSwgYWRkcmVzc1RvQ2hlY2spKS5sZW5ndGggPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogRm9yIGFueSBjbGFpbSBjb25kaXRpb25zIHRoYXQgYSBwYXJ0aWN1bGFyIHdhbGxldCBpcyB2aW9sYXRpbmcsXG4gICAqIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBodW1hbiByZWFkYWJsZSBpbmZvcm1hdGlvbiBhYm91dCB0aGVcbiAgICogYnJlYWtzIGluIHRoZSBjb25kaXRpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBpbmZvcm0gdGhlIHVzZXIuXG4gICAqXG4gICAqIEBwYXJhbSBxdWFudGl0eSAtIFRoZSBkZXNpcmVkIHF1YW50aXR5IHRoYXQgd291bGQgYmUgY2xhaW1lZC5cbiAgICogQHBhcmFtIGFkZHJlc3NUb0NoZWNrIC0gVGhlIHdhbGxldCBhZGRyZXNzLCBkZWZhdWx0cyB0byB0aGUgY29ubmVjdGVkIHdhbGxldC5cbiAgICpcbiAgICovXG4gIGFzeW5jIGdldENsYWltSW5lbGlnaWJpbGl0eVJlYXNvbnMocXVhbnRpdHksIGFkZHJlc3NUb0NoZWNrKSB7XG4gICAgY29uc3QgcmVhc29ucyA9IFtdO1xuICAgIGxldCBhY3RpdmVDb25kaXRpb25JbmRleDtcbiAgICBsZXQgY2xhaW1Db25kaXRpb247XG4gICAgY29uc3QgZGVjaW1hbHMgPSBhd2FpdCB0aGlzLmdldFRva2VuRGVjaW1hbHMoKTtcbiAgICBjb25zdCBxdWFudGl0eVdpdGhEZWNpbWFscyA9IGV0aGVycy51dGlscy5wYXJzZVVuaXRzKEFtb3VudFNjaGVtYS5wYXJzZShxdWFudGl0eSksIGRlY2ltYWxzKTtcbiAgICBpZiAoYWRkcmVzc1RvQ2hlY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWRkcmVzc1RvQ2hlY2sgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRTaWduZXJBZGRyZXNzKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiZmFpbGVkIHRvIGdldCBzaWduZXIgYWRkcmVzc1wiLCBlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgYmVlbiB1bmFibGUgdG8gZ2V0IGEgc2lnbmVyIGFkZHJlc3MsIHdlIGNhbid0IGNoZWNrIGVsaWdpYmlsaXR5LCBzbyByZXR1cm4gYSBOb1dhbGxldCBlcnJvciByZWFzb25cbiAgICBpZiAoIWFkZHJlc3NUb0NoZWNrKSB7XG4gICAgICByZXR1cm4gW0NsYWltRWxpZ2liaWxpdHkuTm9XYWxsZXRdO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY2xhaW1Db25kaXRpb24gPSBhd2FpdCB0aGlzLmdldEFjdGl2ZSgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGluY2x1ZGVzRXJyb3JNZXNzYWdlKGVyciwgXCIhQ09ORElUSU9OXCIpIHx8IGluY2x1ZGVzRXJyb3JNZXNzYWdlKGVyciwgXCJubyBhY3RpdmUgbWludCBjb25kaXRpb25cIikpIHtcbiAgICAgICAgcmVhc29ucy5wdXNoKENsYWltRWxpZ2liaWxpdHkuTm9DbGFpbUNvbmRpdGlvblNldCk7XG4gICAgICAgIHJldHVybiByZWFzb25zO1xuICAgICAgfVxuICAgICAgY29uc29sZS53YXJuKFwiZmFpbGVkIHRvIGdldCBhY3RpdmUgY2xhaW0gY29uZGl0aW9uXCIsIGVycik7XG4gICAgICByZWFzb25zLnB1c2goQ2xhaW1FbGlnaWJpbGl0eS5Vbmtub3duKTtcbiAgICAgIHJldHVybiByZWFzb25zO1xuICAgIH1cbiAgICBpZiAoY2xhaW1Db25kaXRpb24uYXZhaWxhYmxlU3VwcGx5ICE9PSBcInVubGltaXRlZFwiKSB7XG4gICAgICBjb25zdCBzdXBwbHlXaXRoRGVjaW1hbHMgPSBldGhlcnMudXRpbHMucGFyc2VVbml0cyhjbGFpbUNvbmRpdGlvbi5hdmFpbGFibGVTdXBwbHksIGRlY2ltYWxzKTtcbiAgICAgIGlmIChzdXBwbHlXaXRoRGVjaW1hbHMubHQocXVhbnRpdHlXaXRoRGVjaW1hbHMpKSB7XG4gICAgICAgIHJlYXNvbnMucHVzaChDbGFpbUVsaWdpYmlsaXR5Lk5vdEVub3VnaFN1cHBseSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIG1lcmtsZSByb290IGluY2x1c2lvblxuICAgIGNvbnN0IG1lcmtsZVJvb3RBcnJheSA9IGV0aGVycy51dGlscy5zdHJpcFplcm9zKGNsYWltQ29uZGl0aW9uLm1lcmtsZVJvb3RIYXNoKTtcbiAgICBjb25zdCBoYXNBbGxvd0xpc3QgPSBtZXJrbGVSb290QXJyYXkubGVuZ3RoID4gMDtcbiAgICBsZXQgYWxsb3dMaXN0RW50cnkgPSBudWxsO1xuICAgIGlmIChoYXNBbGxvd0xpc3QpIHtcbiAgICAgIGFsbG93TGlzdEVudHJ5ID0gYXdhaXQgdGhpcy5nZXRDbGFpbWVyUHJvb2ZzKGFkZHJlc3NUb0NoZWNrKTtcbiAgICAgIGlmICghYWxsb3dMaXN0RW50cnkgJiYgKHRoaXMuaXNMZWdhY3lTaW5nbGVQaGFzZURyb3AodGhpcy5jb250cmFjdFdyYXBwZXIpIHx8IHRoaXMuaXNMZWdhY3lNdWx0aVBoYXNlRHJvcCh0aGlzLmNvbnRyYWN0V3JhcHBlcikpKSB7XG4gICAgICAgIC8vIGV4Y2x1c2l2ZSBhbGxvd2xpc3QgYmVoYXZpb3JcbiAgICAgICAgcmVhc29ucy5wdXNoKENsYWltRWxpZ2liaWxpdHkuQWRkcmVzc05vdEFsbG93ZWQpO1xuICAgICAgICByZXR1cm4gcmVhc29ucztcbiAgICAgIH1cbiAgICAgIGlmIChhbGxvd0xpc3RFbnRyeSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNsYWltVmVyaWZpY2F0aW9uID0gYXdhaXQgdGhpcy5wcmVwYXJlQ2xhaW0ocXVhbnRpdHksIGZhbHNlLCBkZWNpbWFscywgYWRkcmVzc1RvQ2hlY2spO1xuICAgICAgICAgIGxldCB2YWxpZE1lcmtsZVByb29mO1xuICAgICAgICAgIGlmICh0aGlzLmlzTGVnYWN5TXVsdGlQaGFzZURyb3AodGhpcy5jb250cmFjdFdyYXBwZXIpKSB7XG4gICAgICAgICAgICBhY3RpdmVDb25kaXRpb25JbmRleCA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5nZXRBY3RpdmVDbGFpbUNvbmRpdGlvbklkKCk7XG4gICAgICAgICAgICAvLyBsZWdhY3kgdmVyaWZ5Q2xhaW1lck1lcmtsZVByb29mcyBmdW5jdGlvblxuICAgICAgICAgICAgW3ZhbGlkTWVya2xlUHJvb2ZdID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LnZlcmlmeUNsYWltTWVya2xlUHJvb2YoYWN0aXZlQ29uZGl0aW9uSW5kZXgsIGFkZHJlc3NUb0NoZWNrLCBxdWFudGl0eSwgY2xhaW1WZXJpZmljYXRpb24ucHJvb2ZzLCBjbGFpbVZlcmlmaWNhdGlvbi5tYXhDbGFpbWFibGUpO1xuICAgICAgICAgICAgaWYgKCF2YWxpZE1lcmtsZVByb29mKSB7XG4gICAgICAgICAgICAgIHJlYXNvbnMucHVzaChDbGFpbUVsaWdpYmlsaXR5LkFkZHJlc3NOb3RBbGxvd2VkKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYXNvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzTGVnYWN5U2luZ2xlUGhhc2VEcm9wKHRoaXMuY29udHJhY3RXcmFwcGVyKSkge1xuICAgICAgICAgICAgW3ZhbGlkTWVya2xlUHJvb2ZdID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LnZlcmlmeUNsYWltTWVya2xlUHJvb2YoYWRkcmVzc1RvQ2hlY2ssIHF1YW50aXR5LCB7XG4gICAgICAgICAgICAgIHByb29mOiBjbGFpbVZlcmlmaWNhdGlvbi5wcm9vZnMsXG4gICAgICAgICAgICAgIG1heFF1YW50aXR5SW5BbGxvd2xpc3Q6IGNsYWltVmVyaWZpY2F0aW9uLm1heENsYWltYWJsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXZhbGlkTWVya2xlUHJvb2YpIHtcbiAgICAgICAgICAgICAgcmVhc29ucy5wdXNoKENsYWltRWxpZ2liaWxpdHkuQWRkcmVzc05vdEFsbG93ZWQpO1xuICAgICAgICAgICAgICByZXR1cm4gcmVhc29ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNOZXdTaW5nbGVQaGFzZURyb3AodGhpcy5jb250cmFjdFdyYXBwZXIpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QudmVyaWZ5Q2xhaW0oYWRkcmVzc1RvQ2hlY2ssIHF1YW50aXR5LCBjbGFpbVZlcmlmaWNhdGlvbi5jdXJyZW5jeUFkZHJlc3MsIGNsYWltVmVyaWZpY2F0aW9uLnByaWNlLCB7XG4gICAgICAgICAgICAgIHByb29mOiBjbGFpbVZlcmlmaWNhdGlvbi5wcm9vZnMsXG4gICAgICAgICAgICAgIHF1YW50aXR5TGltaXRQZXJXYWxsZXQ6IGNsYWltVmVyaWZpY2F0aW9uLm1heENsYWltYWJsZSxcbiAgICAgICAgICAgICAgY3VycmVuY3k6IGNsYWltVmVyaWZpY2F0aW9uLmN1cnJlbmN5QWRkcmVzc0luUHJvb2YsXG4gICAgICAgICAgICAgIHByaWNlUGVyVG9rZW46IGNsYWltVmVyaWZpY2F0aW9uLnByaWNlSW5Qcm9vZlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY29udmVydFF1YW50aXR5VG9CaWdOdW1iZXIoY2xhaW1Db25kaXRpb24ubWF4Q2xhaW1hYmxlUGVyV2FsbGV0LCBkZWNpbWFscykuZXEoMCkgJiYgY2xhaW1WZXJpZmljYXRpb24ubWF4Q2xhaW1hYmxlID09PSBldGhlcnMuY29uc3RhbnRzLk1heFVpbnQyNTYgfHwgY2xhaW1WZXJpZmljYXRpb24ubWF4Q2xhaW1hYmxlID09PSBCaWdOdW1iZXIuZnJvbSgwKSkge1xuICAgICAgICAgICAgICByZWFzb25zLnB1c2goQ2xhaW1FbGlnaWJpbGl0eS5BZGRyZXNzTm90QWxsb3dlZCk7XG4gICAgICAgICAgICAgIHJldHVybiByZWFzb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc05ld011bHRpcGhhc2VEcm9wKHRoaXMuY29udHJhY3RXcmFwcGVyKSkge1xuICAgICAgICAgICAgYWN0aXZlQ29uZGl0aW9uSW5kZXggPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuZ2V0QWN0aXZlQ2xhaW1Db25kaXRpb25JZCgpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LnZlcmlmeUNsYWltKGFjdGl2ZUNvbmRpdGlvbkluZGV4LCBhZGRyZXNzVG9DaGVjaywgcXVhbnRpdHksIGNsYWltVmVyaWZpY2F0aW9uLmN1cnJlbmN5QWRkcmVzcywgY2xhaW1WZXJpZmljYXRpb24ucHJpY2UsIHtcbiAgICAgICAgICAgICAgcHJvb2Y6IGNsYWltVmVyaWZpY2F0aW9uLnByb29mcyxcbiAgICAgICAgICAgICAgcXVhbnRpdHlMaW1pdFBlcldhbGxldDogY2xhaW1WZXJpZmljYXRpb24ubWF4Q2xhaW1hYmxlLFxuICAgICAgICAgICAgICBjdXJyZW5jeTogY2xhaW1WZXJpZmljYXRpb24uY3VycmVuY3lBZGRyZXNzSW5Qcm9vZixcbiAgICAgICAgICAgICAgcHJpY2VQZXJUb2tlbjogY2xhaW1WZXJpZmljYXRpb24ucHJpY2VJblByb29mXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb252ZXJ0UXVhbnRpdHlUb0JpZ051bWJlcihjbGFpbUNvbmRpdGlvbi5tYXhDbGFpbWFibGVQZXJXYWxsZXQsIGRlY2ltYWxzKS5lcSgwKSAmJiBjbGFpbVZlcmlmaWNhdGlvbi5tYXhDbGFpbWFibGUgPT09IGV0aGVycy5jb25zdGFudHMuTWF4VWludDI1NiB8fCBjbGFpbVZlcmlmaWNhdGlvbi5tYXhDbGFpbWFibGUgPT09IEJpZ051bWJlci5mcm9tKDApKSB7XG4gICAgICAgICAgICAgIHJlYXNvbnMucHVzaChDbGFpbUVsaWdpYmlsaXR5LkFkZHJlc3NOb3RBbGxvd2VkKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYXNvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiTWVya2xlIHByb29mIHZlcmlmaWNhdGlvbiBmYWlsZWQ6XCIsIFwicmVhc29uXCIgaW4gZSA/IGUucmVhc29uIDogZSk7XG4gICAgICAgICAgcmVhc29ucy5wdXNoKENsYWltRWxpZ2liaWxpdHkuQWRkcmVzc05vdEFsbG93ZWQpO1xuICAgICAgICAgIHJldHVybiByZWFzb25zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETyAoY2MpIGNoZWNrIGZvciBtYXggY2xhaW1hYmxlIHBlciB3YWxsZXQgYW5kIGhvdyBtdWNoIGVhY2ggd2FsbGV0IGhhcyBjbGFpbWVkXG4gICAgaWYgKHRoaXMuaXNOZXdTaW5nbGVQaGFzZURyb3AodGhpcy5jb250cmFjdFdyYXBwZXIpIHx8IHRoaXMuaXNOZXdNdWx0aXBoYXNlRHJvcCh0aGlzLmNvbnRyYWN0V3JhcHBlcikpIHtcbiAgICAgIGlmICghaGFzQWxsb3dMaXN0IHx8IGhhc0FsbG93TGlzdCAmJiAhYWxsb3dMaXN0RW50cnkpIHtcbiAgICAgICAgaWYgKGNvbnZlcnRRdWFudGl0eVRvQmlnTnVtYmVyKGNsYWltQ29uZGl0aW9uLm1heENsYWltYWJsZVBlcldhbGxldCwgZGVjaW1hbHMpLmVxKDApKSB7XG4gICAgICAgICAgcmVhc29ucy5wdXNoKENsYWltRWxpZ2liaWxpdHkuQWRkcmVzc05vdEFsbG93ZWQpO1xuICAgICAgICAgIHJldHVybiByZWFzb25zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIGNsYWltIHRpbWVzdGFtcCBiZXR3ZWVuIGNsYWltcyAoT05MWSBGT1IgTEVHQUNZKVxuICAgIGlmICh0aGlzLmlzTGVnYWN5U2luZ2xlUGhhc2VEcm9wKHRoaXMuY29udHJhY3RXcmFwcGVyKSB8fCB0aGlzLmlzTGVnYWN5TXVsdGlQaGFzZURyb3AodGhpcy5jb250cmFjdFdyYXBwZXIpKSB7XG4gICAgICBsZXQgW2xhc3RDbGFpbWVkVGltZXN0YW1wLCB0aW1lc3RhbXBGb3JOZXh0Q2xhaW1dID0gW0JpZ051bWJlci5mcm9tKDApLCBCaWdOdW1iZXIuZnJvbSgwKV07XG4gICAgICBpZiAodGhpcy5pc0xlZ2FjeU11bHRpUGhhc2VEcm9wKHRoaXMuY29udHJhY3RXcmFwcGVyKSkge1xuICAgICAgICBhY3RpdmVDb25kaXRpb25JbmRleCA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5nZXRBY3RpdmVDbGFpbUNvbmRpdGlvbklkKCk7XG4gICAgICAgIFtsYXN0Q2xhaW1lZFRpbWVzdGFtcCwgdGltZXN0YW1wRm9yTmV4dENsYWltXSA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5nZXRDbGFpbVRpbWVzdGFtcChhY3RpdmVDb25kaXRpb25JbmRleCwgYWRkcmVzc1RvQ2hlY2spO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzTGVnYWN5U2luZ2xlUGhhc2VEcm9wKHRoaXMuY29udHJhY3RXcmFwcGVyKSkge1xuICAgICAgICAvLyBjaGVjayBmb3IgY2xhaW0gdGltZXN0YW1wIGJldHdlZW4gY2xhaW1zXG4gICAgICAgIFtsYXN0Q2xhaW1lZFRpbWVzdGFtcCwgdGltZXN0YW1wRm9yTmV4dENsYWltXSA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5nZXRDbGFpbVRpbWVzdGFtcChhZGRyZXNzVG9DaGVjayk7XG4gICAgICB9XG4gICAgICBjb25zdCBub3cgPSBCaWdOdW1iZXIuZnJvbShEYXRlLm5vdygpKS5kaXYoMTAwMCk7XG4gICAgICBpZiAobGFzdENsYWltZWRUaW1lc3RhbXAuZ3QoMCkgJiYgbm93Lmx0KHRpbWVzdGFtcEZvck5leHRDbGFpbSkpIHtcbiAgICAgICAgLy8gY29udHJhY3Qgd2lsbCByZXR1cm4gTWF4VWludDI1NiBpZiB1c2VyIGhhcyBhbHJlYWR5IGNsYWltZWQgYW5kIGNhbm5vdCBjbGFpbSBhZ2FpblxuICAgICAgICBpZiAodGltZXN0YW1wRm9yTmV4dENsYWltLmVxKGNvbnN0YW50cy5NYXhVaW50MjU2KSkge1xuICAgICAgICAgIHJlYXNvbnMucHVzaChDbGFpbUVsaWdpYmlsaXR5LkFscmVhZHlDbGFpbWVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWFzb25zLnB1c2goQ2xhaW1FbGlnaWJpbGl0eS5XYWl0QmVmb3JlTmV4dENsYWltVHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgbm90IHdpdGhpbiBhIGJyb3dzZXIgY29uZXRleHQsIGNoZWNrIGZvciB3YWxsZXQgYmFsYW5jZS5cbiAgICAvLyBJbiBicm93c2VyIGNvbnRleHQsIGxldCB0aGUgd2FsbGV0IGRvIHRoYXQgam9iXG4gICAgaWYgKGNsYWltQ29uZGl0aW9uLnByaWNlLmd0KDApICYmIGlzTm9kZSgpKSB7XG4gICAgICBjb25zdCB0b3RhbFByaWNlID0gY2xhaW1Db25kaXRpb24ucHJpY2UubXVsKEJpZ051bWJlci5mcm9tKHF1YW50aXR5KSk7XG4gICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFByb3ZpZGVyKCk7XG4gICAgICBpZiAoaXNOYXRpdmVUb2tlbihjbGFpbUNvbmRpdGlvbi5jdXJyZW5jeUFkZHJlc3MpKSB7XG4gICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBwcm92aWRlci5nZXRCYWxhbmNlKGFkZHJlc3NUb0NoZWNrKTtcbiAgICAgICAgaWYgKGJhbGFuY2UubHQodG90YWxQcmljZSkpIHtcbiAgICAgICAgICByZWFzb25zLnB1c2goQ2xhaW1FbGlnaWJpbGl0eS5Ob3RFbm91Z2hUb2tlbnMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlcmMyMCA9IG5ldyBDb250cmFjdFdyYXBwZXIocHJvdmlkZXIsIGNsYWltQ29uZGl0aW9uLmN1cnJlbmN5QWRkcmVzcywgRVJDMjBBYmksIHt9KTtcbiAgICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGVyYzIwLnJlYWRDb250cmFjdC5iYWxhbmNlT2YoYWRkcmVzc1RvQ2hlY2spO1xuICAgICAgICBpZiAoYmFsYW5jZS5sdCh0b3RhbFByaWNlKSkge1xuICAgICAgICAgIHJlYXNvbnMucHVzaChDbGFpbUVsaWdpYmlsaXR5Lk5vdEVub3VnaFRva2Vucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlYXNvbnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGxvdyBsaXN0IGluZm9ybWF0aW9uIGFuZCBtZXJrbGUgcHJvb2ZzIGZvciB0aGUgZ2l2ZW4gYWRkcmVzcy5cbiAgICogQHBhcmFtIGNsYWltZXJBZGRyZXNzIC0gdGhlIGNsYWltZXIgYWRkcmVzc1xuICAgKiBAcGFyYW0gY2xhaW1Db25kaXRpb25JZCAtIG9wdGlvbmFsIHRoZSBjbGFpbSBjb25kaXRpb24gaWQgdG8gZ2V0IHRoZSBwcm9vZnMgZm9yXG4gICAqL1xuICBhc3luYyBnZXRDbGFpbWVyUHJvb2ZzKGNsYWltZXJBZGRyZXNzLCBjbGFpbUNvbmRpdGlvbklkKSB7XG4gICAgY29uc3QgY2xhaW1Db25kaXRpb24gPSBhd2FpdCB0aGlzLmdldChjbGFpbUNvbmRpdGlvbklkKTtcbiAgICBjb25zdCBtZXJrbGVSb290ID0gY2xhaW1Db25kaXRpb24ubWVya2xlUm9vdDtcbiAgICBjb25zdCBtZXJrbGVSb290QXJyYXkgPSBldGhlcnMudXRpbHMuc3RyaXBaZXJvcyhtZXJrbGVSb290KTtcbiAgICBpZiAobWVya2xlUm9vdEFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5tZXRhZGF0YS5nZXQoKTtcbiAgICAgIHJldHVybiBhd2FpdCBmZXRjaFNuYXBzaG90RW50cnlGb3JBZGRyZXNzKGNsYWltZXJBZGRyZXNzLCBtZXJrbGVSb290LnRvU3RyaW5nKCksIG1ldGFkYXRhLm1lcmtsZSwgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJvdmlkZXIoKSwgdGhpcy5zdG9yYWdlLCB0aGlzLmdldFNuYXBzaG90Rm9ybWF0VmVyc2lvbigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBXUklURSBGVU5DVElPTlNcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiBTZXQgcHVibGljIG1pbnQgY29uZGl0aW9uc1xuICAgKlxuICAgKiBAcmVtYXJrcyBTZXRzIHRoZSBwdWJsaWMgbWludCBjb25kaXRpb25zIHRoYXQgbmVlZCB0byBiZSBmdWxsZmlsZWQgYnkgdXNlcnMgdG8gY2xhaW0gTkZUcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBwcmVzYWxlU3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICogY29uc3QgcHVibGljU2FsZVN0YXJ0VGltZSA9IG5ldyBEYXRlKERhdGUubm93KCkgKyA2MCAqIDYwICogMjQgKiAxMDAwKTtcbiAgICpcbiAgICogLy8gT3B0aW9uYWxseSBzcGVjaWZ5IGFkZHJlc3NlcyB0aGF0IGNhbiBjbGFpbVxuICAgKiBjb25zdCBzbmFwc2hvdHMgPSBbJzB4Li4uJywgJzB4Li4uJ11cbiAgICpcbiAgICogLy8gT3IgYWx0ZXJuYXRpdmVseSwgeW91IGNhbiBwYXNzIHNuYXBzaG90cyB3aXRoIHRoZSBtYXggbnVtYmVyIG9mIE5GVHMgZWFjaCBhZGRyZXNzIGNhbiBjbGFpbVxuICAgKiAvLyBjb25zdCBzbmFwc2hvdHMgPSBbeyBhZGRyZXNzOiAnMHguLi4nLCBtYXhDbGFpbWFibGU6IDEgfSwgeyBhZGRyZXNzOiAnMHguLi4nLCBtYXhDbGFpbWFibGU6IDIgfV1cbiAgICpcbiAgICogY29uc3QgY2xhaW1Db25kaXRpb25zID0gW1xuICAgKiAgIHtcbiAgICogICAgIHN0YXJ0VGltZTogcHJlc2FsZVN0YXJ0VGltZSwgLy8gc3RhcnQgdGhlIHByZXNhbGUgbm93XG4gICAqICAgICBtYXhRdWFudGl0eTogMiwgLy8gbGltaXQgaG93IG1hbnkgbWludHMgZm9yIHRoaXMgcHJlc2FsZVxuICAgKiAgICAgcHJpY2U6IDAuMDEsIC8vIHByZXNhbGUgcHJpY2VcbiAgICogICAgIHNuYXBzaG90OiBzbmFwc2hvdHMsIC8vIGxpbWl0IG1pbnRpbmcgdG8gb25seSBjZXJ0YWluIGFkZHJlc3Nlc1xuICAgKiAgIH0sXG4gICAqICAge1xuICAgKiAgICAgc3RhcnRUaW1lOiBwdWJsaWNTYWxlU3RhcnRUaW1lLCAvLyAyNGggYWZ0ZXIgcHJlc2FsZSwgc3RhcnQgcHVibGljIHNhbGVcbiAgICogICAgIHByaWNlOiAwLjA4LCAvLyBwdWJsaWMgc2FsZSBwcmljZVxuICAgKiAgIH1cbiAgICogXSk7XG4gICAqXG4gICAqIGF3YWl0IGRyb3BDb250cmFjdC5jbGFpbUNvbmRpdGlvbnMuc2V0KGNsYWltQ29uZGl0aW9ucyk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gY2xhaW1Db25kaXRpb25JbnB1dHMgLSBUaGUgY2xhaW0gY29uZGl0aW9uc1xuICAgKiBAcGFyYW0gcmVzZXRDbGFpbUVsaWdpYmlsaXR5Rm9yQWxsIC0gV2hldGhlciB0byByZXNldCB0aGUgc3RhdGUgb2Ygd2hvIGFscmVhZHkgY2xhaW1lZCBORlRzIHByZXZpb3VzbHlcbiAgICovXG4gIGFzeW5jIHNldChjbGFpbUNvbmRpdGlvbklucHV0cykge1xuICAgIGxldCByZXNldENsYWltRWxpZ2liaWxpdHlGb3JBbGwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIGxldCBjbGFpbUNvbmRpdGlvbnNQcm9jZXNzZWQgPSBjbGFpbUNvbmRpdGlvbklucHV0cztcbiAgICBpZiAodGhpcy5pc0xlZ2FjeVNpbmdsZVBoYXNlRHJvcCh0aGlzLmNvbnRyYWN0V3JhcHBlcikgfHwgdGhpcy5pc05ld1NpbmdsZVBoYXNlRHJvcCh0aGlzLmNvbnRyYWN0V3JhcHBlcikpIHtcbiAgICAgIHJlc2V0Q2xhaW1FbGlnaWJpbGl0eUZvckFsbCA9IHRydWU7XG4gICAgICBpZiAoY2xhaW1Db25kaXRpb25JbnB1dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNsYWltQ29uZGl0aW9uc1Byb2Nlc3NlZCA9IFt7XG4gICAgICAgICAgc3RhcnRUaW1lOiBuZXcgRGF0ZSgwKSxcbiAgICAgICAgICBjdXJyZW5jeUFkZHJlc3M6IGV0aGVycy5jb25zdGFudHMuQWRkcmVzc1plcm8sXG4gICAgICAgICAgcHJpY2U6IDAsXG4gICAgICAgICAgbWF4Q2xhaW1hYmxlU3VwcGx5OiAwLFxuICAgICAgICAgIG1heENsYWltYWJsZVBlcldhbGxldDogMCxcbiAgICAgICAgICB3YWl0SW5TZWNvbmRzOiAwLFxuICAgICAgICAgIG1lcmtsZVJvb3RIYXNoOiB1dGlscy5oZXhaZXJvUGFkKFswXSwgMzIpLFxuICAgICAgICAgIHNuYXBzaG90OiBbXVxuICAgICAgICB9XTtcbiAgICAgIH0gZWxzZSBpZiAoY2xhaW1Db25kaXRpb25JbnB1dHMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaW5nbGUgcGhhc2UgZHJvcCBjb250cmFjdCBjYW5ub3QgaGF2ZSBtdWx0aXBsZSBjbGFpbSBjb25kaXRpb25zLCBvbmx5IG9uZSBpcyBhbGxvd2VkXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHVzaW5nIG5ldyBzbmFwc2hvdCBmb3JtYXQsIG1ha2Ugc3VyZSB0aGF0IG1heENsYWltYWJsZVBlcldhbGxldCBpcyBzZXQgaWYgYWxsb3dsaXN0IGlzIHNldCBhcyB3ZWxsXG4gICAgaWYgKHRoaXMuaXNOZXdTaW5nbGVQaGFzZURyb3AodGhpcy5jb250cmFjdFdyYXBwZXIpIHx8IHRoaXMuaXNOZXdNdWx0aXBoYXNlRHJvcCh0aGlzLmNvbnRyYWN0V3JhcHBlcikpIHtcbiAgICAgIGNsYWltQ29uZGl0aW9uc1Byb2Nlc3NlZC5mb3JFYWNoKGNjID0+IHtcbiAgICAgICAgaWYgKGNjLnNuYXBzaG90ICYmIGNjLnNuYXBzaG90Lmxlbmd0aCA+IDAgJiYgKGNjLm1heENsYWltYWJsZVBlcldhbGxldCA9PT0gdW5kZWZpbmVkIHx8IGNjLm1heENsYWltYWJsZVBlcldhbGxldCA9PT0gXCJ1bmxpbWl0ZWRcIikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXhDbGFpbWFibGVQZXJXYWxsZXQgbXVzdCBiZSBzZXQgdG8gYSBzcGVjaWZpYyB2YWx1ZSB3aGVuIGFuIGFsbG93bGlzdCBpcyBzZXQuXFxuXCIgKyBcIkV4YW1wbGU6IFNldCBpdCB0byAwIHRvIG9ubHkgYWxsb3cgYWRkcmVzc2VzIGluIHRoZSBhbGxvd2xpc3QgdG8gY2xhaW0gdGhlIGFtb3VudCBzcGVjaWZpZWQgaW4gdGhlIGFsbG93bGlzdC5cXG5cIiArIFwiY29udHJhY3QuY2xhaW1Db25kaXRpb25zLnNldChbeyBzbmFwc2hvdDogW3sgYWRkcmVzczogJzB4Li4uJywgbWF4Q2xhaW1hYmxlOiAxIH1dLCBtYXhDbGFpbWFibGVQZXJXYWxsZXQ6IDAgfV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYy5zbmFwc2hvdCAmJiBjYy5zbmFwc2hvdC5sZW5ndGggPiAwICYmIGNjLm1heENsYWltYWJsZVBlcldhbGxldD8udG9TdHJpbmcoKSA9PT0gXCIwXCIgJiYgY2Muc25hcHNob3QubWFwKHMgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIocy5tYXhDbGFpbWFibGU/LnRvU3RyaW5nKCkgfHwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5yZWR1Y2UoKGFjYywgY3VycmVudCkgPT4ge1xuICAgICAgICAgIHJldHVybiBhY2MgKyBjdXJyZW50O1xuICAgICAgICB9LCAwKSA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1heENsYWltYWJsZVBlcldhbGxldCBpcyBzZXQgdG8gMCwgYW5kIGFsbCBhZGRyZXNzZXMgaW4gdGhlIGFsbG93bGlzdCBoYXZlIG1heCBjbGFpbWFibGUgMC4gVGhpcyBtZWFucyB0aGF0IG5vIG9uZSBjYW4gY2xhaW0uXCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBwcm9jZXNzIGlucHV0c1xuICAgIGNvbnN0IHtcbiAgICAgIHNuYXBzaG90SW5mb3MsXG4gICAgICBzb3J0ZWRDb25kaXRpb25zXG4gICAgfSA9IGF3YWl0IHByb2Nlc3NDbGFpbUNvbmRpdGlvbklucHV0cyhjbGFpbUNvbmRpdGlvbnNQcm9jZXNzZWQsIGF3YWl0IHRoaXMuZ2V0VG9rZW5EZWNpbWFscygpLCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRQcm92aWRlcigpLCB0aGlzLnN0b3JhZ2UsIHRoaXMuZ2V0U25hcHNob3RGb3JtYXRWZXJzaW9uKCkpO1xuICAgIGNvbnN0IG1lcmtsZUluZm8gPSB7fTtcbiAgICBzbmFwc2hvdEluZm9zLmZvckVhY2gocyA9PiB7XG4gICAgICBtZXJrbGVJbmZvW3MubWVya2xlUm9vdF0gPSBzLnNuYXBzaG90VXJpO1xuICAgIH0pO1xuICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5tZXRhZGF0YS5nZXQoKTtcbiAgICBjb25zdCBlbmNvZGVkID0gW107XG5cbiAgICAvLyB1cGxvYWQgbmV3IG1lcmtsZSByb290cyB0byBzbmFwc2hvdCBVUklzIGlmIHVwZGF0ZWRcbiAgICBpZiAoIWRlZXBFcXVhbChtZXRhZGF0YS5tZXJrbGUsIG1lcmtsZUluZm8pKSB7XG4gICAgICBjb25zdCBtZXJnZWRNZXRhZGF0YSA9IHRoaXMubWV0YWRhdGEucGFyc2VJbnB1dE1ldGFkYXRhKHtcbiAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgIG1lcmtsZTogbWVya2xlSW5mb1xuICAgICAgfSk7XG4gICAgICAvLyB1c2luZyBpbnRlcm5hbCBtZXRob2QgdG8ganVzdCB1cGxvYWQsIGF2b2lkcyBvbmUgY29udHJhY3QgY2FsbFxuICAgICAgY29uc3QgY29udHJhY3RVUkkgPSBhd2FpdCB0aGlzLm1ldGFkYXRhLl9wYXJzZUFuZFVwbG9hZE1ldGFkYXRhKG1lcmdlZE1ldGFkYXRhKTtcblxuICAgICAgLy8gVE9ETyAoY2MpIHdlIGNvdWxkIHdyaXRlIHRoZSBtZXJrbGUgdHJlZSBpbmZvIG9uIHRoZSBjbGFpbSBjb25kaXRpb24gbWV0YWRhdGEgaW5zdGVhZFxuICAgICAgLy8gVE9ETyAoY2MpIGJ1dCB3ZSBzdGlsbCBuZWVkIHRvIG1haW50YWluIHRoZSBiZWhhdmlvciBoZXJlIGZvciBvbGRlciBjb250cmFjdHNcbiAgICAgIGlmIChoYXNGdW5jdGlvbihcInNldENvbnRyYWN0VVJJXCIsIHRoaXMuY29udHJhY3RXcmFwcGVyKSkge1xuICAgICAgICBlbmNvZGVkLnB1c2godGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoXCJzZXRDb250cmFjdFVSSVwiLCBbY29udHJhY3RVUkldKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXR0aW5nIGEgbWVya2xlIHJvb3QgcmVxdWlyZXMgaW1wbGVtZW50aW5nIENvbnRyYWN0TWV0YWRhdGEgaW4geW91ciBjb250cmFjdCB0byBzdXBwb3J0IHN0b3JpbmcgYSBtZXJrbGUgcm9vdC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGN3ID0gdGhpcy5jb250cmFjdFdyYXBwZXI7XG4gICAgaWYgKHRoaXMuaXNMZWdhY3lTaW5nbGVQaGFzZURyb3AoY3cpKSB7XG4gICAgICBlbmNvZGVkLnB1c2goY3cucmVhZENvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoXCJzZXRDbGFpbUNvbmRpdGlvbnNcIiwgW2Fic3RyYWN0Q29udHJhY3RNb2RlbFRvTGVnYWN5KHNvcnRlZENvbmRpdGlvbnNbMF0pLCByZXNldENsYWltRWxpZ2liaWxpdHlGb3JBbGxdKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzTGVnYWN5TXVsdGlQaGFzZURyb3AoY3cpKSB7XG4gICAgICBlbmNvZGVkLnB1c2goY3cucmVhZENvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoXCJzZXRDbGFpbUNvbmRpdGlvbnNcIiwgW3NvcnRlZENvbmRpdGlvbnMubWFwKGFic3RyYWN0Q29udHJhY3RNb2RlbFRvTGVnYWN5KSwgcmVzZXRDbGFpbUVsaWdpYmlsaXR5Rm9yQWxsXSkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc05ld1NpbmdsZVBoYXNlRHJvcChjdykpIHtcbiAgICAgIGVuY29kZWQucHVzaChjdy5yZWFkQ29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShcInNldENsYWltQ29uZGl0aW9uc1wiLCBbYWJzdHJhY3RDb250cmFjdE1vZGVsVG9OZXcoc29ydGVkQ29uZGl0aW9uc1swXSksIHJlc2V0Q2xhaW1FbGlnaWJpbGl0eUZvckFsbF0pKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNOZXdNdWx0aXBoYXNlRHJvcChjdykpIHtcbiAgICAgIGVuY29kZWQucHVzaChjdy5yZWFkQ29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShcInNldENsYWltQ29uZGl0aW9uc1wiLCBbc29ydGVkQ29uZGl0aW9ucy5tYXAoYWJzdHJhY3RDb250cmFjdE1vZGVsVG9OZXcpLCByZXNldENsYWltRWxpZ2liaWxpdHlGb3JBbGxdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRyYWN0IGRvZXMgbm90IHN1cHBvcnQgY2xhaW0gY29uZGl0aW9uc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLm11bHRpQ2FsbChlbmNvZGVkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGEgc2luZ2xlIGNsYWltIGNvbmRpdGlvbiB3aXRoIG5ldyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gaW5kZXggLSB0aGUgaW5kZXggb2YgdGhlIGNsYWltIGNvbmRpdGlvbiB0byB1cGRhdGUsIGFzIGdpdmVuIGJ5IHRoZSBpbmRleCBmcm9tIHRoZSByZXN1bHQgb2YgYGdldEFsbCgpYFxuICAgKiBAcGFyYW0gY2xhaW1Db25kaXRpb25JbnB1dCAtIHRoZSBuZXcgZGF0YSB0byB1cGRhdGUsIHByZXZpb3VzIGRhdGEgd2lsbCBiZSByZXRhaW5lZFxuICAgKi9cbiAgYXN5bmMgdXBkYXRlKGluZGV4LCBjbGFpbUNvbmRpdGlvbklucHV0KSB7XG4gICAgY29uc3QgZXhpc3RpbmdDb25kaXRpb25zID0gYXdhaXQgdGhpcy5nZXRBbGwoKTtcbiAgICBjb25zdCBuZXdDb25kaXRpb25JbnB1dHMgPSBhd2FpdCB1cGRhdGVFeGlzdGluZ0NsYWltQ29uZGl0aW9ucyhpbmRleCwgY2xhaW1Db25kaXRpb25JbnB1dCwgZXhpc3RpbmdDb25kaXRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXQobmV3Q29uZGl0aW9uSW5wdXRzKTtcbiAgfVxuXG4gIC8qKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICogUFJJVkFURSBGVU5DVElPTlNcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIGFzeW5jIGdldFRva2VuRGVjaW1hbHMoKSB7XG4gICAgaWYgKGRldGVjdENvbnRyYWN0RmVhdHVyZSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgXCJFUkMyMFwiKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5kZWNpbWFscygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKDApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHByb29mcyBhbmQgdGhlIG92ZXJyaWRlcyByZXF1aXJlZCBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyAtIGBvdmVycmlkZXNgIGFuZCBgcHJvb2ZzYCBhcyBhbiBvYmplY3QuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgcHJlcGFyZUNsYWltKHF1YW50aXR5LCBjaGVja0VSQzIwQWxsb3dhbmNlKSB7XG4gICAgbGV0IGRlY2ltYWxzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgIGxldCBhZGRyZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgYWRkcmVzc1RvQ2xhaW0gPSBhZGRyZXNzID8gYWRkcmVzcyA6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFNpZ25lckFkZHJlc3MoKTtcbiAgICByZXR1cm4gcHJlcGFyZUNsYWltKGFkZHJlc3NUb0NsYWltLCBxdWFudGl0eSwgYXdhaXQgdGhpcy5nZXRBY3RpdmUoKSwgYXN5bmMgKCkgPT4gKGF3YWl0IHRoaXMubWV0YWRhdGEuZ2V0KCkpLm1lcmtsZSwgZGVjaW1hbHMsIHRoaXMuY29udHJhY3RXcmFwcGVyLCB0aGlzLnN0b3JhZ2UsIGNoZWNrRVJDMjBBbGxvd2FuY2UsIHRoaXMuZ2V0U25hcHNob3RGb3JtYXRWZXJzaW9uKCkpO1xuICB9XG4gIGFzeW5jIGdldENsYWltQXJndW1lbnRzKGRlc3RpbmF0aW9uQWRkcmVzcywgcXVhbnRpdHksIGNsYWltVmVyaWZpY2F0aW9uKSB7XG4gICAgaWYgKHRoaXMuaXNMZWdhY3lNdWx0aVBoYXNlRHJvcCh0aGlzLmNvbnRyYWN0V3JhcHBlcikpIHtcbiAgICAgIHJldHVybiBbZGVzdGluYXRpb25BZGRyZXNzLCBxdWFudGl0eSwgY2xhaW1WZXJpZmljYXRpb24uY3VycmVuY3lBZGRyZXNzLCBjbGFpbVZlcmlmaWNhdGlvbi5wcmljZSwgY2xhaW1WZXJpZmljYXRpb24ucHJvb2ZzLCBjbGFpbVZlcmlmaWNhdGlvbi5tYXhDbGFpbWFibGVdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0xlZ2FjeVNpbmdsZVBoYXNlRHJvcCh0aGlzLmNvbnRyYWN0V3JhcHBlcikpIHtcbiAgICAgIHJldHVybiBbZGVzdGluYXRpb25BZGRyZXNzLCBxdWFudGl0eSwgY2xhaW1WZXJpZmljYXRpb24uY3VycmVuY3lBZGRyZXNzLCBjbGFpbVZlcmlmaWNhdGlvbi5wcmljZSwge1xuICAgICAgICBwcm9vZjogY2xhaW1WZXJpZmljYXRpb24ucHJvb2ZzLFxuICAgICAgICBtYXhRdWFudGl0eUluQWxsb3dsaXN0OiBjbGFpbVZlcmlmaWNhdGlvbi5tYXhDbGFpbWFibGVcbiAgICAgIH0sIGV0aGVycy51dGlscy50b1V0ZjhCeXRlcyhcIlwiKV07XG4gICAgfVxuICAgIHJldHVybiBbZGVzdGluYXRpb25BZGRyZXNzLCBxdWFudGl0eSwgY2xhaW1WZXJpZmljYXRpb24uY3VycmVuY3lBZGRyZXNzLCBjbGFpbVZlcmlmaWNhdGlvbi5wcmljZSwge1xuICAgICAgcHJvb2Y6IGNsYWltVmVyaWZpY2F0aW9uLnByb29mcyxcbiAgICAgIHF1YW50aXR5TGltaXRQZXJXYWxsZXQ6IGNsYWltVmVyaWZpY2F0aW9uLm1heENsYWltYWJsZSxcbiAgICAgIHByaWNlUGVyVG9rZW46IGNsYWltVmVyaWZpY2F0aW9uLnByaWNlSW5Qcm9vZixcbiAgICAgIGN1cnJlbmN5OiBjbGFpbVZlcmlmaWNhdGlvbi5jdXJyZW5jeUFkZHJlc3NJblByb29mXG4gICAgfSwgZXRoZXJzLnV0aWxzLnRvVXRmOEJ5dGVzKFwiXCIpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBjbGFpbSB0cmFuc2FjdGlvbiB3aXRob3V0IGV4ZWN1dGluZyBpdC5cbiAgICogVGhpcyBpcyB1c2VmdWwgZm9yIGVzdGltYXRpbmcgdGhlIGdhcyBjb3N0IG9mIGEgY2xhaW0gdHJhbnNhY3Rpb24sIG92ZXJyaWRpbmcgdHJhbnNhY3Rpb24gb3B0aW9ucyBhbmQgaGF2aW5nIGZpbmUgZ3JhaW5lZCBjb250cm9sIG92ZXIgdGhlIHRyYW5zYWN0aW9uIGV4ZWN1dGlvbi5cbiAgICogQHBhcmFtIGRlc3RpbmF0aW9uQWRkcmVzc1xuICAgKiBAcGFyYW0gcXVhbnRpdHlcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIGFzeW5jIGdldENsYWltVHJhbnNhY3Rpb24oZGVzdGluYXRpb25BZGRyZXNzLCBxdWFudGl0eSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zPy5wcmljZVBlclRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcmljZSBwZXIgdG9rZW4gaXMgYmUgc2V0IHZpYSBjbGFpbSBjb25kaXRpb25zIGJ5IGNhbGxpbmcgYGNvbnRyYWN0LmVyYzcyMS5jbGFpbUNvbmRpdGlvbnMuc2V0KClgXCIpO1xuICAgIH1cbiAgICBjb25zdCBjbGFpbVZlcmlmaWNhdGlvbiA9IGF3YWl0IHRoaXMucHJlcGFyZUNsYWltKHF1YW50aXR5LCBvcHRpb25zPy5jaGVja0VSQzIwQWxsb3dhbmNlID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5jaGVja0VSQzIwQWxsb3dhbmNlLCBhd2FpdCB0aGlzLmdldFRva2VuRGVjaW1hbHMoKSk7XG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uVGFzay5tYWtlKHtcbiAgICAgIGNvbnRyYWN0V3JhcHBlcjogdGhpcy5jb250cmFjdFdyYXBwZXIsXG4gICAgICBmdW5jdGlvbk5hbWU6IFwiY2xhaW1cIixcbiAgICAgIGFyZ3M6IGF3YWl0IHRoaXMuZ2V0Q2xhaW1Bcmd1bWVudHMoZGVzdGluYXRpb25BZGRyZXNzLCBxdWFudGl0eSwgY2xhaW1WZXJpZmljYXRpb24pLFxuICAgICAgb3ZlcnJpZGVzOiBjbGFpbVZlcmlmaWNhdGlvbi5vdmVycmlkZXNcbiAgICB9KTtcbiAgfVxuICBpc05ld1NpbmdsZVBoYXNlRHJvcChjb250cmFjdFdyYXBwZXIpIHtcbiAgICByZXR1cm4gZGV0ZWN0Q29udHJhY3RGZWF0dXJlKGNvbnRyYWN0V3JhcHBlciwgXCJFUkM3MjFDbGFpbUNvbmRpdGlvbnNWMlwiKSB8fCBkZXRlY3RDb250cmFjdEZlYXR1cmUoY29udHJhY3RXcmFwcGVyLCBcIkVSQzIwQ2xhaW1Db25kaXRpb25zVjJcIik7XG4gIH1cbiAgaXNOZXdNdWx0aXBoYXNlRHJvcChjb250cmFjdFdyYXBwZXIpIHtcbiAgICByZXR1cm4gZGV0ZWN0Q29udHJhY3RGZWF0dXJlKGNvbnRyYWN0V3JhcHBlciwgXCJFUkM3MjFDbGFpbVBoYXNlc1YyXCIpIHx8IGRldGVjdENvbnRyYWN0RmVhdHVyZShjb250cmFjdFdyYXBwZXIsIFwiRVJDMjBDbGFpbVBoYXNlc1YyXCIpO1xuICB9XG4gIGlzTGVnYWN5U2luZ2xlUGhhc2VEcm9wKGNvbnRyYWN0V3JhcHBlcikge1xuICAgIHJldHVybiBkZXRlY3RDb250cmFjdEZlYXR1cmUoY29udHJhY3RXcmFwcGVyLCBcIkVSQzcyMUNsYWltQ29uZGl0aW9uc1YxXCIpIHx8IGRldGVjdENvbnRyYWN0RmVhdHVyZShjb250cmFjdFdyYXBwZXIsIFwiRVJDMjBDbGFpbUNvbmRpdGlvbnNWMVwiKTtcbiAgfVxuICBpc0xlZ2FjeU11bHRpUGhhc2VEcm9wKGNvbnRyYWN0V3JhcHBlcikge1xuICAgIHJldHVybiBkZXRlY3RDb250cmFjdEZlYXR1cmUoY29udHJhY3RXcmFwcGVyLCBcIkVSQzcyMUNsYWltUGhhc2VzVjFcIikgfHwgZGV0ZWN0Q29udHJhY3RGZWF0dXJlKGNvbnRyYWN0V3JhcHBlciwgXCJFUkMyMENsYWltUGhhc2VzVjFcIik7XG4gIH1cbiAgZ2V0U25hcHNob3RGb3JtYXRWZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzTGVnYWN5TXVsdGlQaGFzZURyb3AodGhpcy5jb250cmFjdFdyYXBwZXIpIHx8IHRoaXMuaXNMZWdhY3lTaW5nbGVQaGFzZURyb3AodGhpcy5jb250cmFjdFdyYXBwZXIpID8gU25hcHNob3RGb3JtYXRWZXJzaW9uLlYxIDogU25hcHNob3RGb3JtYXRWZXJzaW9uLlYyO1xuICB9XG59XG5cbi8qKlxuICogTWFuYWdlcyBjbGFpbSBjb25kaXRpb25zIGZvciBFZGl0aW9uIERyb3AgY29udHJhY3RzXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIERyb3BFcmMxMTU1Q2xhaW1Db25kaXRpb25zIHtcbiAgY29uc3RydWN0b3IoY29udHJhY3RXcmFwcGVyLCBtZXRhZGF0YSwgc3RvcmFnZSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRyYWN0V3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFkYXRhXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcmFnZVwiLCB2b2lkIDApO1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIgPSBjb250cmFjdFdyYXBwZXI7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICB9XG5cbiAgLyoqICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBSRUFEIEZVTkNUSU9OU1xuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudGx5IGFjdGl2ZSBjbGFpbSBjb25kaXRpb25cbiAgICpcbiAgICogQHJldHVybnMgdGhlIGNsYWltIGNvbmRpdGlvbiBtZXRhZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0QWN0aXZlKHRva2VuSWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtYyA9IGF3YWl0IHRoaXMuZ2V0KHRva2VuSWQpO1xuICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5tZXRhZGF0YS5nZXQoKTtcbiAgICByZXR1cm4gYXdhaXQgdHJhbnNmb3JtUmVzdWx0VG9DbGFpbUNvbmRpdGlvbihtYywgMCwgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJvdmlkZXIoKSwgbWV0YWRhdGEubWVya2xlLCB0aGlzLnN0b3JhZ2UsIG9wdGlvbnM/LndpdGhBbGxvd0xpc3QgfHwgZmFsc2UpO1xuICB9XG4gIGFzeW5jIGdldCh0b2tlbklkLCBjb25kaXRpb25JZCkge1xuICAgIGlmICh0aGlzLmlzTGVnYWN5U2luZ2xlUGhhc2VEcm9wKHRoaXMuY29udHJhY3RXcmFwcGVyKSkge1xuICAgICAgY29uc3QgY29udHJhY3RNb2RlbCA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5jbGFpbUNvbmRpdGlvbih0b2tlbklkKTtcbiAgICAgIHJldHVybiBsZWdhY3lDb250cmFjdE1vZGVsVG9BYnN0cmFjdChjb250cmFjdE1vZGVsKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNMZWdhY3lNdWx0aVBoYXNlRHJvcCh0aGlzLmNvbnRyYWN0V3JhcHBlcikpIHtcbiAgICAgIGNvbnN0IGlkID0gY29uZGl0aW9uSWQgIT09IHVuZGVmaW5lZCA/IGNvbmRpdGlvbklkIDogYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmdldEFjdGl2ZUNsYWltQ29uZGl0aW9uSWQodG9rZW5JZCk7XG4gICAgICBjb25zdCBjb250cmFjdE1vZGVsID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmdldENsYWltQ29uZGl0aW9uQnlJZCh0b2tlbklkLCBpZCk7XG4gICAgICByZXR1cm4gbGVnYWN5Q29udHJhY3RNb2RlbFRvQWJzdHJhY3QoY29udHJhY3RNb2RlbCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzTmV3U2luZ2xlUGhhc2VEcm9wKHRoaXMuY29udHJhY3RXcmFwcGVyKSkge1xuICAgICAgY29uc3QgY29udHJhY3RNb2RlbCA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5jbGFpbUNvbmRpdGlvbih0b2tlbklkKTtcbiAgICAgIHJldHVybiBuZXdDb250cmFjdE1vZGVsVG9BYnN0cmFjdChjb250cmFjdE1vZGVsKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNOZXdNdWx0aXBoYXNlRHJvcCh0aGlzLmNvbnRyYWN0V3JhcHBlcikpIHtcbiAgICAgIGNvbnN0IGlkID0gY29uZGl0aW9uSWQgIT09IHVuZGVmaW5lZCA/IGNvbmRpdGlvbklkIDogYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmdldEFjdGl2ZUNsYWltQ29uZGl0aW9uSWQodG9rZW5JZCk7XG4gICAgICBjb25zdCBjb250cmFjdE1vZGVsID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmdldENsYWltQ29uZGl0aW9uQnlJZCh0b2tlbklkLCBpZCk7XG4gICAgICByZXR1cm4gbmV3Q29udHJhY3RNb2RlbFRvQWJzdHJhY3QoY29udHJhY3RNb2RlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRyYWN0IGRvZXMgbm90IHN1cHBvcnQgY2xhaW0gY29uZGl0aW9uc1wiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCB0aGUgY2xhaW0gY29uZGl0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgY2xhaW0gY29uZGl0aW9ucyBtZXRhZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0QWxsKHRva2VuSWQsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5pc0xlZ2FjeU11bHRpUGhhc2VEcm9wKHRoaXMuY29udHJhY3RXcmFwcGVyKSB8fCB0aGlzLmlzTmV3TXVsdGlwaGFzZURyb3AodGhpcy5jb250cmFjdFdyYXBwZXIpKSB7XG4gICAgICBjb25zdCBjbGFpbUNvbmRpdGlvbiA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5jbGFpbUNvbmRpdGlvbih0b2tlbklkKTtcbiAgICAgIGNvbnN0IHN0YXJ0SWQgPSBjbGFpbUNvbmRpdGlvbi5jdXJyZW50U3RhcnRJZC50b051bWJlcigpO1xuICAgICAgY29uc3QgY291bnQgPSBjbGFpbUNvbmRpdGlvbi5jb3VudC50b051bWJlcigpO1xuICAgICAgY29uc3QgY29uZGl0aW9ucyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SWQ7IGkgPCBzdGFydElkICsgY291bnQ7IGkrKykge1xuICAgICAgICBjb25kaXRpb25zLnB1c2goYXdhaXQgdGhpcy5nZXQodG9rZW5JZCwgaSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCB0aGlzLm1ldGFkYXRhLmdldCgpO1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGNvbmRpdGlvbnMubWFwKGMgPT4gdHJhbnNmb3JtUmVzdWx0VG9DbGFpbUNvbmRpdGlvbihjLCAwLCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRQcm92aWRlcigpLCBtZXRhZGF0YS5tZXJrbGUsIHRoaXMuc3RvcmFnZSwgb3B0aW9ucz8ud2l0aEFsbG93TGlzdCB8fCBmYWxzZSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFthd2FpdCB0aGlzLmdldEFjdGl2ZSh0b2tlbklkLCBvcHRpb25zKV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbiBDbGFpbVxuICAgKlxuICAgKiBAcmVtYXJrcyBDaGVjayBpZiBhIHBhcnRpY3VsYXIgTkZUIGNhbiBjdXJyZW50bHkgYmUgY2xhaW1lZCBieSBhIGdpdmVuIHVzZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gUXVhbnRpdHkgb2YgdG9rZW5zIHRvIGNoZWNrIGNsYWltYWJpbGl0eSBvZlxuICAgKiBjb25zdCBxdWFudGl0eSA9IDE7XG4gICAqIGNvbnN0IGNhbkNsYWltID0gYXdhaXQgY29udHJhY3QuY2FuQ2xhaW0ocXVhbnRpdHkpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGNhbkNsYWltKHRva2VuSWQsIHF1YW50aXR5LCBhZGRyZXNzVG9DaGVjaykge1xuICAgIC8vIFRPRE8gc3dpdGNoIHRvIHVzZSB2ZXJpZnlDbGFpbVxuICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXRDbGFpbUluZWxpZ2liaWxpdHlSZWFzb25zKHRva2VuSWQsIHF1YW50aXR5LCBhZGRyZXNzVG9DaGVjaykpLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgYW55IGNsYWltIGNvbmRpdGlvbnMgdGhhdCBhIHBhcnRpY3VsYXIgd2FsbGV0IGlzIHZpb2xhdGluZyxcbiAgICogdGhpcyBmdW5jdGlvbiByZXR1cm5zIGh1bWFuLXJlYWRhYmxlIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICAgKiBicmVha3MgaW4gdGhlIGNvbmRpdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGluZm9ybSB0aGUgdXNlci5cbiAgICpcbiAgICogQHBhcmFtIHRva2VuSWQgLSB0aGUgdG9rZW4gaWQgdG8gY2hlY2tcbiAgICogQHBhcmFtIHF1YW50aXR5IC0gVGhlIGRlc2lyZWQgcXVhbnRpdHkgdGhhdCB3b3VsZCBiZSBjbGFpbWVkLlxuICAgKiBAcGFyYW0gYWRkcmVzc1RvQ2hlY2sgLSBUaGUgd2FsbGV0IGFkZHJlc3MsIGRlZmF1bHRzIHRvIHRoZSBjb25uZWN0ZWQgd2FsbGV0LlxuICAgKlxuICAgKi9cbiAgYXN5bmMgZ2V0Q2xhaW1JbmVsaWdpYmlsaXR5UmVhc29ucyh0b2tlbklkLCBxdWFudGl0eSwgYWRkcmVzc1RvQ2hlY2spIHtcbiAgICBjb25zdCByZWFzb25zID0gW107XG4gICAgbGV0IGFjdGl2ZUNvbmRpdGlvbkluZGV4O1xuICAgIGxldCBjbGFpbUNvbmRpdGlvbjtcbiAgICBpZiAoYWRkcmVzc1RvQ2hlY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWRkcmVzc1RvQ2hlY2sgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRTaWduZXJBZGRyZXNzKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiZmFpbGVkIHRvIGdldCBzaWduZXIgYWRkcmVzc1wiLCBlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgYmVlbiB1bmFibGUgdG8gZ2V0IGEgc2lnbmVyIGFkZHJlc3MsIHdlIGNhbid0IGNoZWNrIGVsaWdpYmlsaXR5LCBzbyByZXR1cm4gYSBOb1dhbGxldCBlcnJvciByZWFzb25cbiAgICBpZiAoIWFkZHJlc3NUb0NoZWNrKSB7XG4gICAgICByZXR1cm4gW0NsYWltRWxpZ2liaWxpdHkuTm9XYWxsZXRdO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY2xhaW1Db25kaXRpb24gPSBhd2FpdCB0aGlzLmdldEFjdGl2ZSh0b2tlbklkKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChpbmNsdWRlc0Vycm9yTWVzc2FnZShlcnIsIFwiIUNPTkRJVElPTlwiKSB8fCBpbmNsdWRlc0Vycm9yTWVzc2FnZShlcnIsIFwibm8gYWN0aXZlIG1pbnQgY29uZGl0aW9uXCIpKSB7XG4gICAgICAgIHJlYXNvbnMucHVzaChDbGFpbUVsaWdpYmlsaXR5Lk5vQ2xhaW1Db25kaXRpb25TZXQpO1xuICAgICAgICByZXR1cm4gcmVhc29ucztcbiAgICAgIH1cbiAgICAgIHJlYXNvbnMucHVzaChDbGFpbUVsaWdpYmlsaXR5LlVua25vd24pO1xuICAgICAgcmV0dXJuIHJlYXNvbnM7XG4gICAgfVxuICAgIGlmIChjbGFpbUNvbmRpdGlvbi5hdmFpbGFibGVTdXBwbHkgIT09IFwidW5saW1pdGVkXCIpIHtcbiAgICAgIGlmIChCaWdOdW1iZXIuZnJvbShjbGFpbUNvbmRpdGlvbi5hdmFpbGFibGVTdXBwbHkpLmx0KHF1YW50aXR5KSkge1xuICAgICAgICByZWFzb25zLnB1c2goQ2xhaW1FbGlnaWJpbGl0eS5Ob3RFbm91Z2hTdXBwbHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBtZXJrbGUgcm9vdCBpbmNsdXNpb25cbiAgICBjb25zdCBtZXJrbGVSb290QXJyYXkgPSBldGhlcnMudXRpbHMuc3RyaXBaZXJvcyhjbGFpbUNvbmRpdGlvbi5tZXJrbGVSb290SGFzaCk7XG4gICAgY29uc3QgaGFzQWxsb3dMaXN0ID0gbWVya2xlUm9vdEFycmF5Lmxlbmd0aCA+IDA7XG4gICAgbGV0IGFsbG93TGlzdEVudHJ5ID0gbnVsbDtcbiAgICBpZiAoaGFzQWxsb3dMaXN0KSB7XG4gICAgICBhbGxvd0xpc3RFbnRyeSA9IGF3YWl0IHRoaXMuZ2V0Q2xhaW1lclByb29mcyh0b2tlbklkLCBhZGRyZXNzVG9DaGVjayk7XG4gICAgICBpZiAoIWFsbG93TGlzdEVudHJ5ICYmICh0aGlzLmlzTGVnYWN5U2luZ2xlUGhhc2VEcm9wKHRoaXMuY29udHJhY3RXcmFwcGVyKSB8fCB0aGlzLmlzTGVnYWN5TXVsdGlQaGFzZURyb3AodGhpcy5jb250cmFjdFdyYXBwZXIpKSkge1xuICAgICAgICAvLyBleGNsdXNpdmUgYWxsb3dsaXN0IGJlaGF2aW9yXG4gICAgICAgIHJlYXNvbnMucHVzaChDbGFpbUVsaWdpYmlsaXR5LkFkZHJlc3NOb3RBbGxvd2VkKTtcbiAgICAgICAgcmV0dXJuIHJlYXNvbnM7XG4gICAgICB9XG4gICAgICBpZiAoYWxsb3dMaXN0RW50cnkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjbGFpbVZlcmlmaWNhdGlvbiA9IGF3YWl0IHRoaXMucHJlcGFyZUNsYWltKHRva2VuSWQsIHF1YW50aXR5LCBmYWxzZSwgYWRkcmVzc1RvQ2hlY2spO1xuICAgICAgICAgIGxldCB2YWxpZE1lcmtsZVByb29mO1xuICAgICAgICAgIGlmICh0aGlzLmlzTGVnYWN5TXVsdGlQaGFzZURyb3AodGhpcy5jb250cmFjdFdyYXBwZXIpKSB7XG4gICAgICAgICAgICBhY3RpdmVDb25kaXRpb25JbmRleCA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5nZXRBY3RpdmVDbGFpbUNvbmRpdGlvbklkKHRva2VuSWQpO1xuICAgICAgICAgICAgLy8gbGVnYWN5IHZlcmlmeUNsYWltZXJNZXJrbGVQcm9vZnMgZnVuY3Rpb25cbiAgICAgICAgICAgIFt2YWxpZE1lcmtsZVByb29mXSA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC52ZXJpZnlDbGFpbU1lcmtsZVByb29mKGFjdGl2ZUNvbmRpdGlvbkluZGV4LCBhZGRyZXNzVG9DaGVjaywgdG9rZW5JZCwgcXVhbnRpdHksIGNsYWltVmVyaWZpY2F0aW9uLnByb29mcywgY2xhaW1WZXJpZmljYXRpb24ubWF4Q2xhaW1hYmxlKTtcbiAgICAgICAgICAgIGlmICghdmFsaWRNZXJrbGVQcm9vZikge1xuICAgICAgICAgICAgICByZWFzb25zLnB1c2goQ2xhaW1FbGlnaWJpbGl0eS5BZGRyZXNzTm90QWxsb3dlZCk7XG4gICAgICAgICAgICAgIHJldHVybiByZWFzb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0xlZ2FjeVNpbmdsZVBoYXNlRHJvcCh0aGlzLmNvbnRyYWN0V3JhcHBlcikpIHtcbiAgICAgICAgICAgIFt2YWxpZE1lcmtsZVByb29mXSA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC52ZXJpZnlDbGFpbU1lcmtsZVByb29mKHRva2VuSWQsIGFkZHJlc3NUb0NoZWNrLCBxdWFudGl0eSwge1xuICAgICAgICAgICAgICBwcm9vZjogY2xhaW1WZXJpZmljYXRpb24ucHJvb2ZzLFxuICAgICAgICAgICAgICBtYXhRdWFudGl0eUluQWxsb3dsaXN0OiBjbGFpbVZlcmlmaWNhdGlvbi5tYXhDbGFpbWFibGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCF2YWxpZE1lcmtsZVByb29mKSB7XG4gICAgICAgICAgICAgIHJlYXNvbnMucHVzaChDbGFpbUVsaWdpYmlsaXR5LkFkZHJlc3NOb3RBbGxvd2VkKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYXNvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzTmV3U2luZ2xlUGhhc2VEcm9wKHRoaXMuY29udHJhY3RXcmFwcGVyKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LnZlcmlmeUNsYWltKHRva2VuSWQsIGFkZHJlc3NUb0NoZWNrLCBxdWFudGl0eSwgY2xhaW1WZXJpZmljYXRpb24uY3VycmVuY3lBZGRyZXNzLCBjbGFpbVZlcmlmaWNhdGlvbi5wcmljZSwge1xuICAgICAgICAgICAgICBwcm9vZjogY2xhaW1WZXJpZmljYXRpb24ucHJvb2ZzLFxuICAgICAgICAgICAgICBxdWFudGl0eUxpbWl0UGVyV2FsbGV0OiBjbGFpbVZlcmlmaWNhdGlvbi5tYXhDbGFpbWFibGUsXG4gICAgICAgICAgICAgIGN1cnJlbmN5OiBjbGFpbVZlcmlmaWNhdGlvbi5jdXJyZW5jeUFkZHJlc3NJblByb29mLFxuICAgICAgICAgICAgICBwcmljZVBlclRva2VuOiBjbGFpbVZlcmlmaWNhdGlvbi5wcmljZUluUHJvb2ZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gVE9ETyAoY2MpIGluIG5ldyBvdmVycmlkZSBmb3JtYXQsIGFueW9uZSBjYW4gY2xhaW0gKG5vIGFsbG93IGxpc3QgcmVzdHJpY3Rpb24pXG4gICAgICAgICAgICAvLyBUT0RPIChjYykgaW5zdGVhZCBjaGVjayBpZiBtYXhDbGFpbWFibGVQZXJXYWxsZXQgaXMgMCBhbmQgdGhpcyBhZGRyZXNzIGhhcyBubyBvdmVycmlkZXNcbiAgICAgICAgICAgIC8vIFRPRE8gKGNjKSBtZWFuaW5nIHRoaXMgYWRkcmVzcyBpcyBub3QgYWxsb3dlZCB0byBjbGFpbVxuICAgICAgICAgICAgaWYgKGNsYWltQ29uZGl0aW9uLm1heENsYWltYWJsZVBlcldhbGxldCA9PT0gXCIwXCIgJiYgY2xhaW1WZXJpZmljYXRpb24ubWF4Q2xhaW1hYmxlID09PSBldGhlcnMuY29uc3RhbnRzLk1heFVpbnQyNTYgfHwgY2xhaW1WZXJpZmljYXRpb24ubWF4Q2xhaW1hYmxlID09PSBCaWdOdW1iZXIuZnJvbSgwKSkge1xuICAgICAgICAgICAgICByZWFzb25zLnB1c2goQ2xhaW1FbGlnaWJpbGl0eS5BZGRyZXNzTm90QWxsb3dlZCk7XG4gICAgICAgICAgICAgIHJldHVybiByZWFzb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc05ld011bHRpcGhhc2VEcm9wKHRoaXMuY29udHJhY3RXcmFwcGVyKSkge1xuICAgICAgICAgICAgYWN0aXZlQ29uZGl0aW9uSW5kZXggPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuZ2V0QWN0aXZlQ2xhaW1Db25kaXRpb25JZCh0b2tlbklkKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC52ZXJpZnlDbGFpbShhY3RpdmVDb25kaXRpb25JbmRleCwgYWRkcmVzc1RvQ2hlY2ssIHRva2VuSWQsIHF1YW50aXR5LCBjbGFpbVZlcmlmaWNhdGlvbi5jdXJyZW5jeUFkZHJlc3MsIGNsYWltVmVyaWZpY2F0aW9uLnByaWNlLCB7XG4gICAgICAgICAgICAgIHByb29mOiBjbGFpbVZlcmlmaWNhdGlvbi5wcm9vZnMsXG4gICAgICAgICAgICAgIHF1YW50aXR5TGltaXRQZXJXYWxsZXQ6IGNsYWltVmVyaWZpY2F0aW9uLm1heENsYWltYWJsZSxcbiAgICAgICAgICAgICAgY3VycmVuY3k6IGNsYWltVmVyaWZpY2F0aW9uLmN1cnJlbmN5QWRkcmVzc0luUHJvb2YsXG4gICAgICAgICAgICAgIHByaWNlUGVyVG9rZW46IGNsYWltVmVyaWZpY2F0aW9uLnByaWNlSW5Qcm9vZlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY2xhaW1Db25kaXRpb24ubWF4Q2xhaW1hYmxlUGVyV2FsbGV0ID09PSBcIjBcIiAmJiBjbGFpbVZlcmlmaWNhdGlvbi5tYXhDbGFpbWFibGUgPT09IGV0aGVycy5jb25zdGFudHMuTWF4VWludDI1NiB8fCBjbGFpbVZlcmlmaWNhdGlvbi5tYXhDbGFpbWFibGUgPT09IEJpZ051bWJlci5mcm9tKDApKSB7XG4gICAgICAgICAgICAgIHJlYXNvbnMucHVzaChDbGFpbUVsaWdpYmlsaXR5LkFkZHJlc3NOb3RBbGxvd2VkKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYXNvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiTWVya2xlIHByb29mIHZlcmlmaWNhdGlvbiBmYWlsZWQ6XCIsIFwicmVhc29uXCIgaW4gZSA/IGUucmVhc29uIDogZSk7XG4gICAgICAgICAgcmVhc29ucy5wdXNoKENsYWltRWxpZ2liaWxpdHkuQWRkcmVzc05vdEFsbG93ZWQpO1xuICAgICAgICAgIHJldHVybiByZWFzb25zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETyAoY2MpIGNoZWNrIGZvciBtYXggY2xhaW1hYmxlIHBlciB3YWxsZXQgYW5kIGhvdyBtdWNoIGVhY2ggd2FsbGV0IGhhcyBjbGFpbWVkXG4gICAgaWYgKHRoaXMuaXNOZXdTaW5nbGVQaGFzZURyb3AodGhpcy5jb250cmFjdFdyYXBwZXIpIHx8IHRoaXMuaXNOZXdNdWx0aXBoYXNlRHJvcCh0aGlzLmNvbnRyYWN0V3JhcHBlcikpIHtcbiAgICAgIGlmICghaGFzQWxsb3dMaXN0IHx8IGhhc0FsbG93TGlzdCAmJiAhYWxsb3dMaXN0RW50cnkpIHtcbiAgICAgICAgaWYgKGNsYWltQ29uZGl0aW9uLm1heENsYWltYWJsZVBlcldhbGxldCA9PT0gXCIwXCIpIHtcbiAgICAgICAgICByZWFzb25zLnB1c2goQ2xhaW1FbGlnaWJpbGl0eS5BZGRyZXNzTm90QWxsb3dlZCk7XG4gICAgICAgICAgcmV0dXJuIHJlYXNvbnM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgY2xhaW0gdGltZXN0YW1wIGJldHdlZW4gY2xhaW1zXG4gICAgbGV0IFtsYXN0Q2xhaW1lZFRpbWVzdGFtcCwgdGltZXN0YW1wRm9yTmV4dENsYWltXSA9IFtCaWdOdW1iZXIuZnJvbSgwKSwgQmlnTnVtYmVyLmZyb20oMCldO1xuICAgIGlmICh0aGlzLmlzTGVnYWN5TXVsdGlQaGFzZURyb3AodGhpcy5jb250cmFjdFdyYXBwZXIpKSB7XG4gICAgICBhY3RpdmVDb25kaXRpb25JbmRleCA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5nZXRBY3RpdmVDbGFpbUNvbmRpdGlvbklkKHRva2VuSWQpO1xuICAgICAgW2xhc3RDbGFpbWVkVGltZXN0YW1wLCB0aW1lc3RhbXBGb3JOZXh0Q2xhaW1dID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmdldENsYWltVGltZXN0YW1wKHRva2VuSWQsIGFjdGl2ZUNvbmRpdGlvbkluZGV4LCBhZGRyZXNzVG9DaGVjayk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzTGVnYWN5U2luZ2xlUGhhc2VEcm9wKHRoaXMuY29udHJhY3RXcmFwcGVyKSkge1xuICAgICAgW2xhc3RDbGFpbWVkVGltZXN0YW1wLCB0aW1lc3RhbXBGb3JOZXh0Q2xhaW1dID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmdldENsYWltVGltZXN0YW1wKHRva2VuSWQsIGFkZHJlc3NUb0NoZWNrKTtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gQmlnTnVtYmVyLmZyb20oRGF0ZS5ub3coKSkuZGl2KDEwMDApO1xuICAgIGlmIChsYXN0Q2xhaW1lZFRpbWVzdGFtcC5ndCgwKSAmJiBub3cubHQodGltZXN0YW1wRm9yTmV4dENsYWltKSkge1xuICAgICAgLy8gY29udHJhY3Qgd2lsbCByZXR1cm4gTWF4VWludDI1NiBpZiB1c2VyIGhhcyBhbHJlYWR5IGNsYWltZWQgYW5kIGNhbm5vdCBjbGFpbSBhZ2FpblxuICAgICAgaWYgKHRpbWVzdGFtcEZvck5leHRDbGFpbS5lcShjb25zdGFudHMuTWF4VWludDI1NikpIHtcbiAgICAgICAgcmVhc29ucy5wdXNoKENsYWltRWxpZ2liaWxpdHkuQWxyZWFkeUNsYWltZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVhc29ucy5wdXNoKENsYWltRWxpZ2liaWxpdHkuV2FpdEJlZm9yZU5leHRDbGFpbVRyYW5zYWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBub3Qgd2l0aGluIGEgYnJvd3NlciBjb25ldGV4dCwgY2hlY2sgZm9yIHdhbGxldCBiYWxhbmNlLlxuICAgIC8vIEluIGJyb3dzZXIgY29udGV4dCwgbGV0IHRoZSB3YWxsZXQgZG8gdGhhdCBqb2JcbiAgICBpZiAoY2xhaW1Db25kaXRpb24ucHJpY2UuZ3QoMCkgJiYgaXNOb2RlKCkpIHtcbiAgICAgIGNvbnN0IHRvdGFsUHJpY2UgPSBjbGFpbUNvbmRpdGlvbi5wcmljZS5tdWwocXVhbnRpdHkpO1xuICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRQcm92aWRlcigpO1xuICAgICAgaWYgKGlzTmF0aXZlVG9rZW4oY2xhaW1Db25kaXRpb24uY3VycmVuY3lBZGRyZXNzKSkge1xuICAgICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgcHJvdmlkZXIuZ2V0QmFsYW5jZShhZGRyZXNzVG9DaGVjayk7XG4gICAgICAgIGlmIChiYWxhbmNlLmx0KHRvdGFsUHJpY2UpKSB7XG4gICAgICAgICAgcmVhc29ucy5wdXNoKENsYWltRWxpZ2liaWxpdHkuTm90RW5vdWdoVG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXJjMjAgPSBuZXcgQ29udHJhY3RXcmFwcGVyKHByb3ZpZGVyLCBjbGFpbUNvbmRpdGlvbi5jdXJyZW5jeUFkZHJlc3MsIEVSQzIwQWJpLCB7fSk7XG4gICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBlcmMyMC5yZWFkQ29udHJhY3QuYmFsYW5jZU9mKGFkZHJlc3NUb0NoZWNrKTtcbiAgICAgICAgaWYgKGJhbGFuY2UubHQodG90YWxQcmljZSkpIHtcbiAgICAgICAgICByZWFzb25zLnB1c2goQ2xhaW1FbGlnaWJpbGl0eS5Ob3RFbm91Z2hUb2tlbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWFzb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsb3cgbGlzdCBpbmZvcm1hdGlvbiBhbmQgbWVya2xlIHByb29mcyBmb3IgdGhlIGdpdmVuIGFkZHJlc3MuXG4gICAqIEBwYXJhbSB0b2tlbklkIC0gdGhlIHRva2VuIElEIHRvIGNoZWNrXG4gICAqIEBwYXJhbSBjbGFpbWVyQWRkcmVzcyAtIHRoZSBjbGFpbWVyIGFkZHJlc3NcbiAgICogQHBhcmFtIGNsYWltQ29uZGl0aW9uSWQgLSBvcHRpb25hbCB0aGUgY2xhaW0gY29uZGl0aW9uIGlkIHRvIGdldCB0aGUgcHJvb2ZzIGZvclxuICAgKi9cbiAgYXN5bmMgZ2V0Q2xhaW1lclByb29mcyh0b2tlbklkLCBjbGFpbWVyQWRkcmVzcywgY2xhaW1Db25kaXRpb25JZCkge1xuICAgIGNvbnN0IGNsYWltQ29uZGl0aW9uID0gYXdhaXQgdGhpcy5nZXQodG9rZW5JZCwgY2xhaW1Db25kaXRpb25JZCk7XG4gICAgY29uc3QgbWVya2xlUm9vdCA9IGNsYWltQ29uZGl0aW9uLm1lcmtsZVJvb3Q7XG4gICAgY29uc3QgbWVya2xlUm9vdEFycmF5ID0gZXRoZXJzLnV0aWxzLnN0cmlwWmVyb3MobWVya2xlUm9vdCk7XG4gICAgaWYgKG1lcmtsZVJvb3RBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMubWV0YWRhdGEuZ2V0KCk7XG4gICAgICByZXR1cm4gYXdhaXQgZmV0Y2hTbmFwc2hvdEVudHJ5Rm9yQWRkcmVzcyhjbGFpbWVyQWRkcmVzcywgbWVya2xlUm9vdC50b1N0cmluZygpLCBtZXRhZGF0YS5tZXJrbGUsIHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFByb3ZpZGVyKCksIHRoaXMuc3RvcmFnZSwgdGhpcy5nZXRTbmFwc2hvdEZvcm1hdFZlcnNpb24oKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICogV1JJVEUgRlVOQ1RJT05TXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKipcbiAgICogU2V0IGNsYWltIGNvbmRpdGlvbnMgb24gYSBzaW5nbGUgTkZUXG4gICAqXG4gICAqIEByZW1hcmtzIFNldHMgdGhlIHB1YmxpYyBtaW50IGNvbmRpdGlvbnMgdGhhdCBuZWVkIHRvIGJlIGZ1bGZpbGxlZCBieSB1c2VycyB0byBjbGFpbSBhIHBhcnRpY3VsYXIgTkZUIGluIHRoaXMgY29udHJhY3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgcHJlc2FsZVN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAqIGNvbnN0IHB1YmxpY1NhbGVTdGFydFRpbWUgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgNjAgKiA2MCAqIDI0ICogMTAwMCk7XG4gICAqXG4gICAqIC8vIE9wdGlvbmFsbHkgc3BlY2lmeSBhZGRyZXNzZXMgdGhhdCBjYW4gY2xhaW1cbiAgICogY29uc3Qgc25hcHNob3RzID0gWycweC4uLicsICcweC4uLiddXG4gICAqXG4gICAqIC8vIE9yIGFsdGVybmF0aXZlbHksIHlvdSBjYW4gcGFzcyBzbmFwc2hvdHMgd2l0aCB0aGUgbWF4IG51bWJlciBvZiBORlRzIGVhY2ggYWRkcmVzcyBjYW4gY2xhaW1cbiAgICogLy8gY29uc3Qgc25hcHNob3RzID0gW3sgYWRkcmVzczogJzB4Li4uJywgbWF4Q2xhaW1hYmxlOiAxIH0sIHsgYWRkcmVzczogJzB4Li4uJywgbWF4Q2xhaW1hYmxlOiAyIH1dXG4gICAqXG4gICAqIGNvbnN0IGNsYWltQ29uZGl0aW9ucyA9IFtcbiAgICogICB7XG4gICAqICAgICBzdGFydFRpbWU6IHByZXNhbGVTdGFydFRpbWUsIC8vIHN0YXJ0IHRoZSBwcmVzYWxlIG5vd1xuICAgKiAgICAgbWF4UXVhbnRpdHk6IDIsIC8vIGxpbWl0IGhvdyBtYW55IG1pbnRzIGZvciB0aGlzIHByZXNhbGVcbiAgICogICAgIHByaWNlOiAwLjAxLCAvLyBwcmVzYWxlIHByaWNlXG4gICAqICAgICBzbmFwc2hvdDogc25hcHNob3RzLCAvLyBsaW1pdCBtaW50aW5nIHRvIG9ubHkgY2VydGFpbiBhZGRyZXNzZXNcbiAgICogICB9LFxuICAgKiAgIHtcbiAgICogICAgIHN0YXJ0VGltZTogcHVibGljU2FsZVN0YXJ0VGltZSwgLy8gMjRoIGFmdGVyIHByZXNhbGUsIHN0YXJ0IHB1YmxpYyBzYWxlXG4gICAqICAgICBwcmljZTogMC4wOCwgLy8gcHVibGljIHNhbGUgcHJpY2VcbiAgICogICB9XG4gICAqIF0pO1xuICAgKlxuICAgKiBjb25zdCB0b2tlbklkID0gMDsgLy8gdGhlIGlkIG9mIHRoZSBORlQgdG8gc2V0IGNsYWltIGNvbmRpdGlvbnMgb25cbiAgICogYXdhaXQgZHJvcENvbnRyYWN0LmNsYWltQ29uZGl0aW9ucy5zZXQodG9rZW5JZCwgY2xhaW1Db25kaXRpb25zKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB0b2tlbklkIC0gVGhlIGlkIG9mIHRoZSBORlQgdG8gc2V0IHRoZSBjbGFpbSBjb25kaXRpb25zIG9uXG4gICAqIEBwYXJhbSBjbGFpbUNvbmRpdGlvbklucHV0cyAtIFRoZSBjbGFpbSBjb25kaXRpb25zXG4gICAqIEBwYXJhbSByZXNldENsYWltRWxpZ2liaWxpdHlGb3JBbGwgLSBXaGV0aGVyIHRvIHJlc2V0IHRoZSBzdGF0ZSBvZiB3aG8gYWxyZWFkeSBjbGFpbWVkIE5GVHMgcHJldmlvdXNseVxuICAgKi9cbiAgYXN5bmMgc2V0KHRva2VuSWQsIGNsYWltQ29uZGl0aW9uSW5wdXRzKSB7XG4gICAgbGV0IHJlc2V0Q2xhaW1FbGlnaWJpbGl0eUZvckFsbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMuc2V0QmF0Y2goW3tcbiAgICAgIHRva2VuSWQsXG4gICAgICBjbGFpbUNvbmRpdGlvbnM6IGNsYWltQ29uZGl0aW9uSW5wdXRzXG4gICAgfV0sIHJlc2V0Q2xhaW1FbGlnaWJpbGl0eUZvckFsbCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGNsYWltIGNvbmRpdGlvbnMgb24gbXVsdGlwbGUgTkZUcyBhdCBvbmNlXG4gICAqXG4gICAqIEByZW1hcmtzIFNldHMgdGhlIGNsYWltIGNvbmRpdGlvbnMgdGhhdCBuZWVkIHRvIGJlIGZ1bGZpbGxlZCBieSB1c2VycyB0byBjbGFpbSB0aGUgZ2l2ZW4gTkZUcyBpbiB0aGlzIGNvbnRyYWN0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IGNsYWltQ29uZGl0aW9uc0ZvclRva2VucyA9IFtcbiAgICogICB7XG4gICAqICAgICB0b2tlbklkOiAwLFxuICAgKiAgICAgY2xhaW1Db25kaXRpb25zOiBbe1xuICAgKiAgICAgICBzdGFydFRpbWU6IG5ldyBEYXRlKCksIC8vIHN0YXJ0IHRoZSBjbGFpbSBwaGFzZSBub3dcbiAgICogICAgICAgbWF4UXVhbnRpdHk6IDIsIC8vIGxpbWl0IGhvdyBtYW55IG1pbnRzIGZvciB0aGlzIHRva2VuSWRcbiAgICogICAgICAgcHJpY2U6IDAuMDEsIC8vIHByaWNlIGZvciB0aGlzIHRva2VuSWRcbiAgICogICAgICAgc25hcHNob3Q6IFsnMHguLi4nLCAnMHguLi4nXSwgLy8gbGltaXQgbWludGluZyB0byBvbmx5IGNlcnRhaW4gYWRkcmVzc2VzXG4gICAqICAgICB9XVxuICAgKiAgIH0sXG4gICAqICAge1xuICAgKiAgICAgdG9rZW5JZDogMSxcbiAgICogICAgIGNsYWltQ29uZGl0aW9uczogW3tcbiAgICogICAgICAgc3RhcnRUaW1lOiBuZXcgRGF0ZSgpLFxuICAgKiAgICAgICBwcmljZTogMC4wOCwgLy8gZGlmZmVyZW50IHByaWNlIGZvciB0aGlzIHRva2VuSWRcbiAgICogICAgIH1dXG4gICAqICAgfSxcbiAgICogXTtcbiAgICpcbiAgICogYXdhaXQgZHJvcENvbnRyYWN0LmNsYWltQ29uZGl0aW9ucy5zZXRCYXRjaChjbGFpbUNvbmRpdGlvbnNGb3JUb2tlbnMpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGNsYWltQ29uZGl0aW9uc0ZvclRva2VuIC0gVGhlIGNsYWltIGNvbmRpdGlvbnMgZm9yIGVhY2ggTkZUXG4gICAqIEBwYXJhbSByZXNldENsYWltRWxpZ2liaWxpdHlGb3JBbGwgLSBXaGV0aGVyIHRvIHJlc2V0IHRoZSBzdGF0ZSBvZiB3aG8gYWxyZWFkeSBjbGFpbWVkIE5GVHMgcHJldmlvdXNseVxuICAgKi9cbiAgYXN5bmMgc2V0QmF0Y2goY2xhaW1Db25kaXRpb25zRm9yVG9rZW4pIHtcbiAgICBsZXQgcmVzZXRDbGFpbUVsaWdpYmlsaXR5Rm9yQWxsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICBjb25zdCBtZXJrbGVJbmZvID0ge307XG4gICAgY29uc3QgcHJvY2Vzc2VkQ2xhaW1Db25kaXRpb25zID0gYXdhaXQgUHJvbWlzZS5hbGwoY2xhaW1Db25kaXRpb25zRm9yVG9rZW4ubWFwKGFzeW5jIF9yZWYgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgdG9rZW5JZCxcbiAgICAgICAgY2xhaW1Db25kaXRpb25zXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIC8vIHNhbml0aXplIGZvciBzaW5nbGUgcGhhc2UgZGVsZXRpb25zXG4gICAgICBsZXQgY2xhaW1Db25kaXRpb25zUHJvY2Vzc2VkID0gY2xhaW1Db25kaXRpb25zO1xuICAgICAgaWYgKHRoaXMuaXNMZWdhY3lTaW5nbGVQaGFzZURyb3AodGhpcy5jb250cmFjdFdyYXBwZXIpKSB7XG4gICAgICAgIHJlc2V0Q2xhaW1FbGlnaWJpbGl0eUZvckFsbCA9IHRydWU7XG4gICAgICAgIGlmIChjbGFpbUNvbmRpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY2xhaW1Db25kaXRpb25zUHJvY2Vzc2VkID0gW3tcbiAgICAgICAgICAgIHN0YXJ0VGltZTogbmV3IERhdGUoMCksXG4gICAgICAgICAgICBjdXJyZW5jeUFkZHJlc3M6IGV0aGVycy5jb25zdGFudHMuQWRkcmVzc1plcm8sXG4gICAgICAgICAgICBwcmljZTogMCxcbiAgICAgICAgICAgIG1heENsYWltYWJsZVN1cHBseTogMCxcbiAgICAgICAgICAgIG1heENsYWltYWJsZVBlcldhbGxldDogMCxcbiAgICAgICAgICAgIHdhaXRJblNlY29uZHM6IDAsXG4gICAgICAgICAgICBtZXJrbGVSb290SGFzaDogdXRpbHMuaGV4WmVyb1BhZChbMF0sIDMyKSxcbiAgICAgICAgICAgIHNuYXBzaG90OiBbXVxuICAgICAgICAgIH1dO1xuICAgICAgICB9IGVsc2UgaWYgKGNsYWltQ29uZGl0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2luZ2xlIHBoYXNlIGRyb3AgY29udHJhY3QgY2Fubm90IGhhdmUgbXVsdGlwbGUgY2xhaW0gY29uZGl0aW9ucywgb25seSBvbmUgaXMgYWxsb3dlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaWYgdXNpbmcgbmV3IHNuYXBzaG90IGZvcm1hdCwgbWFrZSBzdXJlIHRoYXQgbWF4Q2xhaW1hYmxlUGVyV2FsbGV0IGlzIHNldCBpZiBhbGxvd2xpc3QgaXMgc2V0IGFzIHdlbGxcbiAgICAgIGlmICh0aGlzLmlzTmV3U2luZ2xlUGhhc2VEcm9wKHRoaXMuY29udHJhY3RXcmFwcGVyKSB8fCB0aGlzLmlzTmV3TXVsdGlwaGFzZURyb3AodGhpcy5jb250cmFjdFdyYXBwZXIpKSB7XG4gICAgICAgIGNsYWltQ29uZGl0aW9uc1Byb2Nlc3NlZC5mb3JFYWNoKGNjID0+IHtcbiAgICAgICAgICBpZiAoY2Muc25hcHNob3QgJiYgY2Muc25hcHNob3QubGVuZ3RoID4gMCAmJiAoY2MubWF4Q2xhaW1hYmxlUGVyV2FsbGV0ID09PSB1bmRlZmluZWQgfHwgY2MubWF4Q2xhaW1hYmxlUGVyV2FsbGV0ID09PSBcInVubGltaXRlZFwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWF4Q2xhaW1hYmxlUGVyV2FsbGV0IG11c3QgYmUgc2V0IHRvIGEgc3BlY2lmaWMgdmFsdWUgd2hlbiBhbiBhbGxvd2xpc3QgaXMgc2V0LlxcblwiICsgXCJTZXQgaXQgdG8gMCB0byBvbmx5IGFsbG93IGFkZHJlc3NlcyBpbiB0aGUgYWxsb3dsaXN0IHRvIGNsYWltIHRoZSBhbW91bnQgc3BlY2lmaWVkIGluIHRoZSBhbGxvd2xpc3QuXCIgKyBcIlxcblxcbmV4OlxcblwiICsgXCJjb250cmFjdC5jbGFpbUNvbmRpdGlvbnMuc2V0KHRva2VuSWQsIFt7IHNuYXBzaG90OiBbeyBhZGRyZXNzOiAnMHguLi4nLCBtYXhDbGFpbWFibGU6IDEgfV0sIG1heENsYWltYWJsZVBlcldhbGxldDogMCB9XSlcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYy5zbmFwc2hvdCAmJiBjYy5zbmFwc2hvdC5sZW5ndGggPiAwICYmIGNjLm1heENsYWltYWJsZVBlcldhbGxldD8udG9TdHJpbmcoKSA9PT0gXCIwXCIgJiYgY2Muc25hcHNob3QubWFwKHMgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcihzLm1heENsYWltYWJsZT8udG9TdHJpbmcoKSB8fCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5yZWR1Y2UoKGFjYywgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFjYyArIGN1cnJlbnQ7XG4gICAgICAgICAgfSwgMCkgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1heENsYWltYWJsZVBlcldhbGxldCBpcyBzZXQgdG8gMCwgYW5kIGFsbCBhZGRyZXNzZXMgaW4gdGhlIGFsbG93bGlzdCBoYXZlIG1heCBjbGFpbWFibGUgMC4gVGhpcyBtZWFucyB0aGF0IG5vIG9uZSBjYW4gY2xhaW0uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBwcm9jZXNzIGlucHV0c1xuICAgICAgY29uc3Qge1xuICAgICAgICBzbmFwc2hvdEluZm9zLFxuICAgICAgICBzb3J0ZWRDb25kaXRpb25zXG4gICAgICB9ID0gYXdhaXQgcHJvY2Vzc0NsYWltQ29uZGl0aW9uSW5wdXRzKGNsYWltQ29uZGl0aW9uc1Byb2Nlc3NlZCwgMCwgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJvdmlkZXIoKSwgdGhpcy5zdG9yYWdlLCB0aGlzLmdldFNuYXBzaG90Rm9ybWF0VmVyc2lvbigpKTtcbiAgICAgIHNuYXBzaG90SW5mb3MuZm9yRWFjaChzID0+IHtcbiAgICAgICAgbWVya2xlSW5mb1tzLm1lcmtsZVJvb3RdID0gcy5zbmFwc2hvdFVyaTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW5JZCxcbiAgICAgICAgc29ydGVkQ29uZGl0aW9uc1xuICAgICAgfTtcbiAgICB9KSk7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCB0aGlzLm1ldGFkYXRhLmdldCgpO1xuICAgIGNvbnN0IGVuY29kZWQgPSBbXTtcblxuICAgIC8vIGtlZXAgdGhlIG9sZCBtZXJrbGUgcm9vdHMgZnJvbSBvdGhlciB0b2tlbklkc1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG1ldGFkYXRhLm1lcmtsZSB8fCB7fSkpIHtcbiAgICAgIG1lcmtsZUluZm9ba2V5XSA9IG1ldGFkYXRhLm1lcmtsZVtrZXldO1xuICAgIH1cblxuICAgIC8vIHVwbG9hZCBuZXcgbWVya2xlIHJvb3RzIHRvIHNuYXBzaG90IFVSSXMgaWYgdXBkYXRlZFxuICAgIGlmICghZGVlcEVxdWFsKG1ldGFkYXRhLm1lcmtsZSwgbWVya2xlSW5mbykpIHtcbiAgICAgIGNvbnN0IG1lcmdlZE1ldGFkYXRhID0gdGhpcy5tZXRhZGF0YS5wYXJzZUlucHV0TWV0YWRhdGEoe1xuICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgbWVya2xlOiBtZXJrbGVJbmZvXG4gICAgICB9KTtcbiAgICAgIC8vIHVzaW5nIGludGVybmFsIG1ldGhvZCB0byBqdXN0IHVwbG9hZCwgYXZvaWRzIG9uZSBjb250cmFjdCBjYWxsXG4gICAgICBjb25zdCBjb250cmFjdFVSSSA9IGF3YWl0IHRoaXMubWV0YWRhdGEuX3BhcnNlQW5kVXBsb2FkTWV0YWRhdGEobWVyZ2VkTWV0YWRhdGEpO1xuICAgICAgaWYgKGhhc0Z1bmN0aW9uKFwic2V0Q29udHJhY3RVUklcIiwgdGhpcy5jb250cmFjdFdyYXBwZXIpKSB7XG4gICAgICAgIGVuY29kZWQucHVzaCh0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShcInNldENvbnRyYWN0VVJJXCIsIFtjb250cmFjdFVSSV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNldHRpbmcgYSBtZXJrbGUgcm9vdCByZXF1aXJlcyBpbXBsZW1lbnRpbmcgQ29udHJhY3RNZXRhZGF0YSBpbiB5b3VyIGNvbnRyYWN0IHRvIHN1cHBvcnQgc3RvcmluZyBhIG1lcmtsZSByb290LlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc2VkQ2xhaW1Db25kaXRpb25zLmZvckVhY2goX3JlZjIgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgdG9rZW5JZCxcbiAgICAgICAgc29ydGVkQ29uZGl0aW9uc1xuICAgICAgfSA9IF9yZWYyO1xuICAgICAgaWYgKHRoaXMuaXNMZWdhY3lTaW5nbGVQaGFzZURyb3AodGhpcy5jb250cmFjdFdyYXBwZXIpKSB7XG4gICAgICAgIGVuY29kZWQucHVzaCh0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShcInNldENsYWltQ29uZGl0aW9uc1wiLCBbdG9rZW5JZCwgYWJzdHJhY3RDb250cmFjdE1vZGVsVG9MZWdhY3koc29ydGVkQ29uZGl0aW9uc1swXSksIHJlc2V0Q2xhaW1FbGlnaWJpbGl0eUZvckFsbF0pKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0xlZ2FjeU11bHRpUGhhc2VEcm9wKHRoaXMuY29udHJhY3RXcmFwcGVyKSkge1xuICAgICAgICBlbmNvZGVkLnB1c2godGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoXCJzZXRDbGFpbUNvbmRpdGlvbnNcIiwgW3Rva2VuSWQsIHNvcnRlZENvbmRpdGlvbnMubWFwKGFic3RyYWN0Q29udHJhY3RNb2RlbFRvTGVnYWN5KSwgcmVzZXRDbGFpbUVsaWdpYmlsaXR5Rm9yQWxsXSkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzTmV3U2luZ2xlUGhhc2VEcm9wKHRoaXMuY29udHJhY3RXcmFwcGVyKSkge1xuICAgICAgICBlbmNvZGVkLnB1c2godGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoXCJzZXRDbGFpbUNvbmRpdGlvbnNcIiwgW3Rva2VuSWQsIGFic3RyYWN0Q29udHJhY3RNb2RlbFRvTmV3KHNvcnRlZENvbmRpdGlvbnNbMF0pLCByZXNldENsYWltRWxpZ2liaWxpdHlGb3JBbGxdKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNOZXdNdWx0aXBoYXNlRHJvcCh0aGlzLmNvbnRyYWN0V3JhcHBlcikpIHtcbiAgICAgICAgZW5jb2RlZC5wdXNoKHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKFwic2V0Q2xhaW1Db25kaXRpb25zXCIsIFt0b2tlbklkLCBzb3J0ZWRDb25kaXRpb25zLm1hcChhYnN0cmFjdENvbnRyYWN0TW9kZWxUb05ldyksIHJlc2V0Q2xhaW1FbGlnaWJpbGl0eUZvckFsbF0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRyYWN0IGRvZXMgbm90IHN1cHBvcnQgY2xhaW0gY29uZGl0aW9uc1wiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjZWlwdDogYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIubXVsdGlDYWxsKGVuY29kZWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYSBzaW5nbGUgY2xhaW0gY29uZGl0aW9uIHdpdGggbmV3IGRhdGEuXG4gICAqIEBwYXJhbSB0b2tlbklkIC0gdGhlIHRva2VuIGlkIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0gaW5kZXggLSB0aGUgaW5kZXggb2YgdGhlIGNsYWltIGNvbmRpdGlvbiB0byB1cGRhdGUsIGFzIGdpdmVuIGJ5IHRoZSBpbmRleCBmcm9tIHRoZSByZXN1bHQgb2YgYGdldEFsbCgpYFxuICAgKiBAcGFyYW0gY2xhaW1Db25kaXRpb25JbnB1dCAtIHRoZSBuZXcgZGF0YSB0byB1cGRhdGUsIHByZXZpb3VzIGRhdGEgd2lsbCBiZSByZXRhaW5lZFxuICAgKi9cbiAgYXN5bmMgdXBkYXRlKHRva2VuSWQsIGluZGV4LCBjbGFpbUNvbmRpdGlvbklucHV0KSB7XG4gICAgY29uc3QgZXhpc3RpbmdDb25kaXRpb25zID0gYXdhaXQgdGhpcy5nZXRBbGwodG9rZW5JZCk7XG4gICAgY29uc3QgbmV3Q29uZGl0aW9uSW5wdXRzID0gYXdhaXQgdXBkYXRlRXhpc3RpbmdDbGFpbUNvbmRpdGlvbnMoaW5kZXgsIGNsYWltQ29uZGl0aW9uSW5wdXQsIGV4aXN0aW5nQ29uZGl0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2V0KHRva2VuSWQsIG5ld0NvbmRpdGlvbklucHV0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBwcm9vZnMgYW5kIHRoZSBvdmVycmlkZXMgcmVxdWlyZWQgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgLSBgb3ZlcnJpZGVzYCBhbmQgYHByb29mc2AgYXMgYW4gb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgcHJlcGFyZUNsYWltKHRva2VuSWQsIHF1YW50aXR5LCBjaGVja0VSQzIwQWxsb3dhbmNlLCBhZGRyZXNzKSB7XG4gICAgY29uc3QgYWRkcmVzc1RvQ2xhaW0gPSBhZGRyZXNzID8gYWRkcmVzcyA6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFNpZ25lckFkZHJlc3MoKTtcbiAgICByZXR1cm4gcHJlcGFyZUNsYWltKGFkZHJlc3NUb0NsYWltLCBxdWFudGl0eSwgYXdhaXQgdGhpcy5nZXRBY3RpdmUodG9rZW5JZCksIGFzeW5jICgpID0+IChhd2FpdCB0aGlzLm1ldGFkYXRhLmdldCgpKS5tZXJrbGUsIDAsIHRoaXMuY29udHJhY3RXcmFwcGVyLCB0aGlzLnN0b3JhZ2UsIGNoZWNrRVJDMjBBbGxvd2FuY2UsIHRoaXMuZ2V0U25hcHNob3RGb3JtYXRWZXJzaW9uKCkpO1xuICB9XG4gIGFzeW5jIGdldENsYWltQXJndW1lbnRzKHRva2VuSWQsIGRlc3RpbmF0aW9uQWRkcmVzcywgcXVhbnRpdHksIGNsYWltVmVyaWZpY2F0aW9uKSB7XG4gICAgaWYgKHRoaXMuaXNMZWdhY3lNdWx0aVBoYXNlRHJvcCh0aGlzLmNvbnRyYWN0V3JhcHBlcikpIHtcbiAgICAgIHJldHVybiBbZGVzdGluYXRpb25BZGRyZXNzLCB0b2tlbklkLCBxdWFudGl0eSwgY2xhaW1WZXJpZmljYXRpb24uY3VycmVuY3lBZGRyZXNzLCBjbGFpbVZlcmlmaWNhdGlvbi5wcmljZSwgY2xhaW1WZXJpZmljYXRpb24ucHJvb2ZzLCBjbGFpbVZlcmlmaWNhdGlvbi5tYXhDbGFpbWFibGVdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0xlZ2FjeVNpbmdsZVBoYXNlRHJvcCh0aGlzLmNvbnRyYWN0V3JhcHBlcikpIHtcbiAgICAgIHJldHVybiBbZGVzdGluYXRpb25BZGRyZXNzLCB0b2tlbklkLCBxdWFudGl0eSwgY2xhaW1WZXJpZmljYXRpb24uY3VycmVuY3lBZGRyZXNzLCBjbGFpbVZlcmlmaWNhdGlvbi5wcmljZSwge1xuICAgICAgICBwcm9vZjogY2xhaW1WZXJpZmljYXRpb24ucHJvb2ZzLFxuICAgICAgICBtYXhRdWFudGl0eUluQWxsb3dsaXN0OiBjbGFpbVZlcmlmaWNhdGlvbi5tYXhDbGFpbWFibGVcbiAgICAgIH0sIGV0aGVycy51dGlscy50b1V0ZjhCeXRlcyhcIlwiKV07XG4gICAgfVxuICAgIHJldHVybiBbZGVzdGluYXRpb25BZGRyZXNzLCB0b2tlbklkLCBxdWFudGl0eSwgY2xhaW1WZXJpZmljYXRpb24uY3VycmVuY3lBZGRyZXNzLCBjbGFpbVZlcmlmaWNhdGlvbi5wcmljZSwge1xuICAgICAgcHJvb2Y6IGNsYWltVmVyaWZpY2F0aW9uLnByb29mcyxcbiAgICAgIHF1YW50aXR5TGltaXRQZXJXYWxsZXQ6IGNsYWltVmVyaWZpY2F0aW9uLm1heENsYWltYWJsZSxcbiAgICAgIHByaWNlUGVyVG9rZW46IGNsYWltVmVyaWZpY2F0aW9uLnByaWNlSW5Qcm9vZixcbiAgICAgIGN1cnJlbmN5OiBjbGFpbVZlcmlmaWNhdGlvbi5jdXJyZW5jeUFkZHJlc3NJblByb29mXG4gICAgfSwgZXRoZXJzLnV0aWxzLnRvVXRmOEJ5dGVzKFwiXCIpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBjbGFpbSB0cmFuc2FjdGlvbiB3aXRob3V0IGV4ZWN1dGluZyBpdC5cbiAgICogVGhpcyBpcyB1c2VmdWwgZm9yIGVzdGltYXRpbmcgdGhlIGdhcyBjb3N0IG9mIGEgY2xhaW0gdHJhbnNhY3Rpb24sIG92ZXJyaWRpbmcgdHJhbnNhY3Rpb24gb3B0aW9ucyBhbmQgaGF2aW5nIGZpbmUgZ3JhaW5lZCBjb250cm9sIG92ZXIgdGhlIHRyYW5zYWN0aW9uIGV4ZWN1dGlvbi5cbiAgICogQHBhcmFtIGRlc3RpbmF0aW9uQWRkcmVzcyAtIEFkZHJlc3MgeW91IHdhbnQgdG8gc2VuZCB0aGUgdG9rZW4gdG9cbiAgICogQHBhcmFtIHRva2VuSWQgLSBJZCBvZiB0aGUgdG9rZW4geW91IHdhbnQgdG8gY2xhaW1cbiAgICogQHBhcmFtIHF1YW50aXR5IC0gUXVhbnRpdHkgb2YgdGhlIHRva2VucyB5b3Ugd2FudCB0byBjbGFpbVxuICAgKi9cbiAgYXN5bmMgZ2V0Q2xhaW1UcmFuc2FjdGlvbihkZXN0aW5hdGlvbkFkZHJlc3MsIHRva2VuSWQsIHF1YW50aXR5LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnM/LnByaWNlUGVyVG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByaWNlIHBlciB0b2tlbiBzaG91bGQgYmUgc2V0IHZpYSBjbGFpbSBjb25kaXRpb25zIGJ5IGNhbGxpbmcgYGNvbnRyYWN0LmVyYzExNTUuY2xhaW1Db25kaXRpb25zLnNldCgpYFwiKTtcbiAgICB9XG4gICAgY29uc3QgY2xhaW1WZXJpZmljYXRpb24gPSBhd2FpdCB0aGlzLnByZXBhcmVDbGFpbSh0b2tlbklkLCBxdWFudGl0eSwgb3B0aW9ucz8uY2hlY2tFUkMyMEFsbG93YW5jZSB8fCB0cnVlKTtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25UYXNrLm1ha2Uoe1xuICAgICAgY29udHJhY3RXcmFwcGVyOiB0aGlzLmNvbnRyYWN0V3JhcHBlcixcbiAgICAgIGZ1bmN0aW9uTmFtZTogXCJjbGFpbVwiLFxuICAgICAgYXJnczogYXdhaXQgdGhpcy5nZXRDbGFpbUFyZ3VtZW50cyh0b2tlbklkLCBkZXN0aW5hdGlvbkFkZHJlc3MsIHF1YW50aXR5LCBjbGFpbVZlcmlmaWNhdGlvbiksXG4gICAgICBvdmVycmlkZXM6IGNsYWltVmVyaWZpY2F0aW9uLm92ZXJyaWRlc1xuICAgIH0pO1xuICB9XG4gIGlzTmV3U2luZ2xlUGhhc2VEcm9wKGNvbnRyYWN0V3JhcHBlcikge1xuICAgIHJldHVybiBkZXRlY3RDb250cmFjdEZlYXR1cmUoY29udHJhY3RXcmFwcGVyLCBcIkVSQzExNTVDbGFpbUNvbmRpdGlvbnNWMlwiKTtcbiAgfVxuICBpc05ld011bHRpcGhhc2VEcm9wKGNvbnRyYWN0V3JhcHBlcikge1xuICAgIHJldHVybiBkZXRlY3RDb250cmFjdEZlYXR1cmUoY29udHJhY3RXcmFwcGVyLCBcIkVSQzExNTVDbGFpbVBoYXNlc1YyXCIpO1xuICB9XG4gIGlzTGVnYWN5U2luZ2xlUGhhc2VEcm9wKGNvbnRyYWN0V3JhcHBlcikge1xuICAgIHJldHVybiBkZXRlY3RDb250cmFjdEZlYXR1cmUoY29udHJhY3RXcmFwcGVyLCBcIkVSQzExNTVDbGFpbUNvbmRpdGlvbnNWMVwiKTtcbiAgfVxuICBpc0xlZ2FjeU11bHRpUGhhc2VEcm9wKGNvbnRyYWN0V3JhcHBlcikge1xuICAgIHJldHVybiBkZXRlY3RDb250cmFjdEZlYXR1cmUoY29udHJhY3RXcmFwcGVyLCBcIkVSQzExNTVDbGFpbVBoYXNlc1YxXCIpO1xuICB9XG4gIGdldFNuYXBzaG90Rm9ybWF0VmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc0xlZ2FjeU11bHRpUGhhc2VEcm9wKHRoaXMuY29udHJhY3RXcmFwcGVyKSB8fCB0aGlzLmlzTGVnYWN5U2luZ2xlUGhhc2VEcm9wKHRoaXMuY29udHJhY3RXcmFwcGVyKSA/IFNuYXBzaG90Rm9ybWF0VmVyc2lvbi5WMSA6IFNuYXBzaG90Rm9ybWF0VmVyc2lvbi5WMjtcbiAgfVxufVxuXG4vKipcbiAqIE1hbmFnZXMgaGlzdG9yeSBmb3IgRWRpdGlvbiBEcm9wIGNvbnRyYWN0c1xuICogQHB1YmxpY1xuICovXG5jbGFzcyBEcm9wRXJjMTE1NUhpc3Rvcnkge1xuICBjb25zdHJ1Y3RvcihldmVudHMpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJldmVudHNcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGNsYWltZXIgYWRkcmVzc2VzXG4gICAqXG4gICAqIEByZW1hcmtzIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSBhZGRyZXNzZXMgdGhhdCBoYXZlIGNsYWltZWQgYSB0b2tlblxuICAgKiBAcGFyYW0gdG9rZW5JZCAtIHRoZSB0b2tlbklkIG9mIHRoZSBORlQgdG8gZ2V0IHRoZSBhZGRyZXNzZXMgb2YqXG4gICAqIEByZXR1cm5zIC0gQSB1bmlxdWUgbGlzdCBvZiBhZGRyZXNzZXMgdGhhdCBjbGFpbWVkIHRoZSB0b2tlblxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IHRva2VuSWQgPSBcIjBcIjtcbiAgICogY29uc3QgYWxsQ2xhaW1lckFkZHJlc3NlcyA9IGF3YWl0IGNvbnRyYWN0Lmhpc3RvcnkuZ2V0QWxsQ2xhaW1lckFkZHJlc3Nlcyh0b2tlbklkKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBnZXRBbGxDbGFpbWVyQWRkcmVzc2VzKHRva2VuSWQpIHtcbiAgICBjb25zdCBhID0gKGF3YWl0IHRoaXMuZXZlbnRzLmdldEV2ZW50cyhcIlRva2Vuc0NsYWltZWRcIikpLmZpbHRlcihlID0+IGUuZGF0YSAmJiBCaWdOdW1iZXIuaXNCaWdOdW1iZXIoZS5kYXRhLnRva2VuSWQpID8gZS5kYXRhLnRva2VuSWQuZXEodG9rZW5JZCkgOiBmYWxzZSk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChhLmZpbHRlcihiID0+IHR5cGVvZiBiLmRhdGE/LmNsYWltZXIgPT09IFwic3RyaW5nXCIpLm1hcChiID0+IGIuZGF0YS5jbGFpbWVyKSkpO1xuICB9XG59XG5cbmNsYXNzIEVyYzIwQnVybmFibGUge1xuICBjb25zdHJ1Y3RvcihlcmMyMCwgY29udHJhY3RXcmFwcGVyKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZmVhdHVyZU5hbWVcIiwgRkVBVFVSRV9UT0tFTl9CVVJOQUJMRS5uYW1lKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlcmMyMFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRyYWN0V3JhcHBlclwiLCB2b2lkIDApO1xuICAgIHRoaXMuZXJjMjAgPSBlcmMyMDtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlciA9IGNvbnRyYWN0V3JhcHBlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdXJuIFRva2Vuc1xuICAgKlxuICAgKiBAcmVtYXJrcyBCdXJuIHRva2VucyBoZWxkIGJ5IHRoZSBjb25uZWN0ZWQgd2FsbGV0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gVGhlIGFtb3VudCBvZiB0aGlzIHRva2VuIHlvdSB3YW50IHRvIGJ1cm5cbiAgICogY29uc3QgYW1vdW50ID0gMS4yO1xuICAgKlxuICAgKiBhd2FpdCBjb250cmFjdC50b2tlbi5idXJuLnRva2VucyhhbW91bnQpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHRva2VucyhhbW91bnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjZWlwdDogYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuc2VuZFRyYW5zYWN0aW9uKFwiYnVyblwiLCBbYXdhaXQgdGhpcy5lcmMyMC5ub3JtYWxpemVBbW91bnQoYW1vdW50KV0pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdXJuIFRva2Vuc1xuICAgKlxuICAgKiBAcmVtYXJrcyBCdXJuIHRva2VucyBoZWxkIGJ5IHRoZSBzcGVjaWZpZWQgd2FsbGV0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gQWRkcmVzcyBvZiB0aGUgd2FsbGV0IHNlbmRpbmcgdGhlIHRva2Vuc1xuICAgKiBjb25zdCBob2xkZXJBZGRyZXNzID0gXCJ7e3dhbGxldF9hZGRyZXNzfX1cIjtcbiAgICpcbiAgICogLy8gVGhlIGFtb3VudCBvZiB0aGlzIHRva2VuIHlvdSB3YW50IHRvIGJ1cm5cbiAgICogY29uc3QgYW1vdW50ID0gMS4yO1xuICAgKlxuICAgKiBhd2FpdCBjb250cmFjdC50b2tlbi5idXJuLmZyb20oaG9sZGVyQWRkcmVzcywgYW1vdW50KTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBmcm9tKGhvbGRlciwgYW1vdW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNlbmRUcmFuc2FjdGlvbihcImJ1cm5Gcm9tXCIsIFtob2xkZXIsIGF3YWl0IHRoaXMuZXJjMjAubm9ybWFsaXplQW1vdW50KGFtb3VudCldKVxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBDb25maWd1cmUgYW5kIGNsYWltIEVSQzIwIHRva2Vuc1xuICogQHJlbWFya3MgTWFuYWdlIGNsYWltIHBoYXNlcyBhbmQgY2xhaW0gRVJDMjAgdG9rZW5zIHRoYXQgaGF2ZSBiZWVuIGxhemlseSBtaW50ZWQuXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgY29udHJhY3QgPSBhd2FpdCBzZGsuZ2V0Q29udHJhY3QoXCJ7e2NvbnRyYWN0X2FkZHJlc3N9fVwiKTtcbiAqIGF3YWl0IGNvbnRyYWN0LnRva2VuLmRyb3AuY2xhaW0udG8oXCIweC4uLlwiLCBxdWFudGl0eSk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgRXJjMjBDbGFpbWFibGVXaXRoQ29uZGl0aW9ucyB7XG4gIC8qKlxuICAgKiBDb25maWd1cmUgY2xhaW0gY29uZGl0aW9uc1xuICAgKiBAcmVtYXJrcyBEZWZpbmUgd2hvIGNhbiBjbGFpbSBORlRzIGluIHRoZSBjb2xsZWN0aW9uLCB3aGVuIGFuZCBob3cgbWFueS5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBwcmVzYWxlU3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICogY29uc3QgcHVibGljU2FsZVN0YXJ0VGltZSA9IG5ldyBEYXRlKERhdGUubm93KCkgKyA2MCAqIDYwICogMjQgKiAxMDAwKTtcbiAgICogY29uc3QgY2xhaW1Db25kaXRpb25zID0gW1xuICAgKiAgIHtcbiAgICogICAgIHN0YXJ0VGltZTogcHJlc2FsZVN0YXJ0VGltZSwgLy8gc3RhcnQgdGhlIHByZXNhbGUgbm93XG4gICAqICAgICBtYXhRdWFudGl0eTogMiwgLy8gbGltaXQgaG93IG1hbnkgbWludHMgZm9yIHRoaXMgcHJlc2FsZVxuICAgKiAgICAgcHJpY2U6IDAuMDEsIC8vIHByZXNhbGUgcHJpY2VcbiAgICogICAgIHNuYXBzaG90OiBbJzB4Li4uJywgJzB4Li4uJ10sIC8vIGxpbWl0IG1pbnRpbmcgdG8gb25seSBjZXJ0YWluIGFkZHJlc3Nlc1xuICAgKiAgIH0sXG4gICAqICAge1xuICAgKiAgICAgc3RhcnRUaW1lOiBwdWJsaWNTYWxlU3RhcnRUaW1lLCAvLyAyNGggYWZ0ZXIgcHJlc2FsZSwgc3RhcnQgcHVibGljIHNhbGVcbiAgICogICAgIHByaWNlOiAwLjA4LCAvLyBwdWJsaWMgc2FsZSBwcmljZVxuICAgKiAgIH1cbiAgICogXSk7XG4gICAqIGF3YWl0IGNvbnRyYWN0LnRva2VuLmRyb3AuY2xhaW0uY29uZGl0aW9ucy5zZXQoY2xhaW1Db25kaXRpb25zKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKGVyYzIwLCBjb250cmFjdFdyYXBwZXIsIHN0b3JhZ2UpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmZWF0dXJlTmFtZVwiLCBGRUFUVVJFX1RPS0VOX0NMQUlNX0NPTkRJVElPTlNfVjIubmFtZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uZGl0aW9uc1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRyYWN0V3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVyYzIwXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcmFnZVwiLCB2b2lkIDApO1xuICAgIHRoaXMuZXJjMjAgPSBlcmMyMDtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlciA9IGNvbnRyYWN0V3JhcHBlcjtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgIGNvbnN0IG1ldGFkYXRhID0gbmV3IENvbnRyYWN0TWV0YWRhdGEodGhpcy5jb250cmFjdFdyYXBwZXIsIEN1c3RvbUNvbnRyYWN0U2NoZW1hLCB0aGlzLnN0b3JhZ2UpO1xuICAgIHRoaXMuY29uZGl0aW9ucyA9IG5ldyBEcm9wQ2xhaW1Db25kaXRpb25zKHRoaXMuY29udHJhY3RXcmFwcGVyLCBtZXRhZGF0YSwgdGhpcy5zdG9yYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGFpbSBhIGNlcnRhaW4gYW1vdW50IG9mIHRva2VucyB0byBhIHNwZWNpZmljIFdhbGxldFxuICAgKlxuICAgKiBAcmVtYXJrcyBMZXQgdGhlIHNwZWNpZmllZCB3YWxsZXQgY2xhaW0gVG9rZW5zLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IGFkZHJlc3MgPSBcInt7d2FsbGV0X2FkZHJlc3N9fVwiOyAvLyBhZGRyZXNzIG9mIHRoZSB3YWxsZXQgeW91IHdhbnQgdG8gY2xhaW0gdGhlIE5GVHNcbiAgICogY29uc3QgcXVhbnRpdHkgPSA0Mi42OTsgLy8gaG93IG1hbnkgdG9rZW5zIHlvdSB3YW50IHRvIGNsYWltXG4gICAqXG4gICAqIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QudG9rZW4uZHJvcC5jbGFpbS50byhhZGRyZXNzLCBxdWFudGl0eSk7XG4gICAqIGNvbnN0IHJlY2VpcHQgPSB0eC5yZWNlaXB0OyAvLyB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdFxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGRlc3RpbmF0aW9uQWRkcmVzcyAtIEFkZHJlc3MgeW91IHdhbnQgdG8gc2VuZCB0aGUgdG9rZW4gdG9cbiAgICogQHBhcmFtIGFtb3VudCAtIFF1YW50aXR5IG9mIHRoZSB0b2tlbnMgeW91IHdhbnQgdG8gY2xhaW1cbiAgICogQHBhcmFtIGNoZWNrRVJDMjBBbGxvd2FuY2UgLSBPcHRpb25hbCwgY2hlY2sgaWYgdGhlIHdhbGxldCBoYXMgZW5vdWdoIEVSQzIwIGFsbG93YW5jZSB0byBjbGFpbSB0aGUgdG9rZW5zLCBhbmQgaWYgbm90LCBhcHByb3ZlIHRoZSB0cmFuc2ZlclxuICAgKiBAcGFyYW0gY2xhaW1EYXRhXG4gICAqIEByZXR1cm5zIC0gVGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRcbiAgICovXG4gIGFzeW5jIHRvKGRlc3RpbmF0aW9uQWRkcmVzcywgYW1vdW50LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcXVhbnRpdHkgPSBhd2FpdCB0aGlzLmVyYzIwLm5vcm1hbGl6ZUFtb3VudChhbW91bnQpO1xuICAgIGNvbnN0IHRhc2sgPSBhd2FpdCB0aGlzLmNvbmRpdGlvbnMuZ2V0Q2xhaW1UcmFuc2FjdGlvbihkZXN0aW5hdGlvbkFkZHJlc3MsIHF1YW50aXR5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGFzay5leGVjdXRlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb25maWd1cmUgYW5kIGNsYWltIEVSQzIwIHRva2Vuc1xuICogQHJlbWFya3MgTWFuYWdlIGNsYWltIHBoYXNlcyBhbmQgY2xhaW0gRVJDMjAgdG9rZW5zIHRoYXQgaGF2ZSBiZWVuIGxhemlseSBtaW50ZWQuXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgY29udHJhY3QgPSBhd2FpdCBzZGsuZ2V0Q29udHJhY3QoXCJ7e2NvbnRyYWN0X2FkZHJlc3N9fVwiKTtcbiAqIGF3YWl0IGNvbnRyYWN0LnRva2VuLmRyb3AuY2xhaW0udG8oXCIweC4uLlwiLCBxdWFudGl0eSk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgRXJjMjBEcm9wcGFibGUge1xuICAvKipcbiAgICogQ29uZmlndXJlIGNsYWltIGNvbmRpdGlvbnNcbiAgICogQHJlbWFya3MgRGVmaW5lIHdobyBjYW4gY2xhaW0gTkZUcyBpbiB0aGUgY29sbGVjdGlvbiwgd2hlbiBhbmQgaG93IG1hbnkuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgcHJlc2FsZVN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAqIGNvbnN0IHB1YmxpY1NhbGVTdGFydFRpbWUgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgNjAgKiA2MCAqIDI0ICogMTAwMCk7XG4gICAqIGNvbnN0IGNsYWltQ29uZGl0aW9ucyA9IFtcbiAgICogICB7XG4gICAqICAgICBzdGFydFRpbWU6IHByZXNhbGVTdGFydFRpbWUsIC8vIHN0YXJ0IHRoZSBwcmVzYWxlIG5vd1xuICAgKiAgICAgbWF4UXVhbnRpdHk6IDIsIC8vIGxpbWl0IGhvdyBtYW55IG1pbnRzIGZvciB0aGlzIHByZXNhbGVcbiAgICogICAgIHByaWNlOiAwLjAxLCAvLyBwcmVzYWxlIHByaWNlXG4gICAqICAgICBzbmFwc2hvdDogWycweC4uLicsICcweC4uLiddLCAvLyBsaW1pdCBtaW50aW5nIHRvIG9ubHkgY2VydGFpbiBhZGRyZXNzZXNcbiAgICogICB9LFxuICAgKiAgIHtcbiAgICogICAgIHN0YXJ0VGltZTogcHVibGljU2FsZVN0YXJ0VGltZSwgLy8gMjRoIGFmdGVyIHByZXNhbGUsIHN0YXJ0IHB1YmxpYyBzYWxlXG4gICAqICAgICBwcmljZTogMC4wOCwgLy8gcHVibGljIHNhbGUgcHJpY2VcbiAgICogICB9XG4gICAqIF0pO1xuICAgKiBhd2FpdCBjb250cmFjdC5uZnQuZHJvcC5jbGFpbS5jb25kaXRpb25zLnNldChjbGFpbUNvbmRpdGlvbnMpO1xuICAgKiBgYGBcbiAgICovXG5cbiAgY29uc3RydWN0b3IoZXJjMjAsIGNvbnRyYWN0V3JhcHBlciwgc3RvcmFnZSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNsYWltXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZXJjMjBcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yYWdlXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5lcmMyMCA9IGVyYzIwO1xuICAgIHRoaXMuY29udHJhY3RXcmFwcGVyID0gY29udHJhY3RXcmFwcGVyO1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgdGhpcy5jbGFpbSA9IG5ldyBFcmMyMENsYWltYWJsZVdpdGhDb25kaXRpb25zKHRoaXMuZXJjMjAsIHRoaXMuY29udHJhY3RXcmFwcGVyLCB0aGlzLnN0b3JhZ2UpO1xuICB9XG59XG5cbi8qKlxuICogTWludCBNYW55IEVSQzIwIFRva2VucyBhdCBvbmNlXG4gKiBAcmVtYXJrcyBUb2tlbiBiYXRjaCBtaW50aW5nIGZ1bmN0aW9uYWxpdHkgdGhhdCBoYW5kbGVzIHVuaXQgcGFyc2luZyBmb3IgeW91LlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgc2RrLmdldENvbnRyYWN0KFwie3tjb250cmFjdF9hZGRyZXNzfX1cIik7XG4gKiBhd2FpdCBjb250cmFjdC50b2tlbi5taW50LmJhdGNoLnRvKHdhbGxldEFkZHJlc3MsIFtuZnRNZXRhZGF0YTEsIG5mdE1ldGFkYXRhMiwgLi4uXSk7XG4gKiBgYGBcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgRXJjMjBCYXRjaE1pbnRhYmxlIHtcbiAgY29uc3RydWN0b3IoZXJjMjAsIGNvbnRyYWN0V3JhcHBlcikge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZlYXR1cmVOYW1lXCIsIEZFQVRVUkVfVE9LRU5fQkFUQ0hfTUlOVEFCTEUubmFtZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZXJjMjBcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmVyYzIwID0gZXJjMjA7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIgPSBjb250cmFjdFdyYXBwZXI7XG4gIH1cblxuICAvKipcbiAgICogTWludCBUb2tlbnMgVG8gTWFueSBXYWxsZXRzXG4gICAqXG4gICAqIEByZW1hcmtzIE1pbnQgdG9rZW5zIHRvIG1hbnkgd2FsbGV0cyBpbiBvbmUgdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gRGF0YSBvZiB0aGUgdG9rZW5zIHlvdSB3YW50IHRvIG1pbnRcbiAgICogY29uc3QgZGF0YSA9IFtcbiAgICogICB7XG4gICAqICAgICB0b0FkZHJlc3M6IFwie3t3YWxsZXRfYWRkcmVzc319XCIsIC8vIEFkZHJlc3MgdG8gbWludCB0b2tlbnMgdG9cbiAgICogICAgIGFtb3VudDogMC4yLCAvLyBIb3cgbWFueSB0b2tlbnMgdG8gbWludCB0byBzcGVjaWZpZWQgYWRkcmVzc1xuICAgKiAgIH0sXG4gICAqICB7XG4gICAqICAgIHRvQWRkcmVzczogXCIweC4uLlwiLFxuICAgKiAgICBhbW91bnQ6IDEuNCxcbiAgICogIH1cbiAgICogXVxuICAgKlxuICAgKiBhd2FpdCBjb250cmFjdC50b2tlbi5taW50LmJhdGNoKGRhdGEpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHRvKGFyZ3MpIHtcbiAgICBjb25zdCBlbmNvZGVkID0gW107XG4gICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgZW5jb2RlZC5wdXNoKHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKFwibWludFRvXCIsIFthcmcudG9BZGRyZXNzLCBhd2FpdCB0aGlzLmVyYzIwLm5vcm1hbGl6ZUFtb3VudChhcmcuYW1vdW50KV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLm11bHRpQ2FsbChlbmNvZGVkKVxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBNaW50IEVSQzIwIFRva2Vuc1xuICogQHJlbWFya3MgVG9rZW4gbWludGluZyBmdW5jdGlvbmFsaXR5IHRoYXQgaGFuZGxlcyB1bml0IHBhcnNpbmcgZm9yIHlvdS5cbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBjb250cmFjdCA9IGF3YWl0IHNkay5nZXRDb250cmFjdChcInt7Y29udHJhY3RfYWRkcmVzc319XCIpO1xuICogYXdhaXQgY29udHJhY3QubmZ0Lm1pbnQudG8od2FsbGV0QWRkcmVzcywgbmZ0TWV0YWRhdGEpO1xuICogYGBgXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEVyYzIwTWludGFibGUge1xuICAvKipcbiAgICogQmF0Y2ggbWludCBUb2tlbnMgdG8gbWFueSBhZGRyZXNzZXNcbiAgICovXG5cbiAgY29uc3RydWN0b3IoZXJjMjAsIGNvbnRyYWN0V3JhcHBlcikge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZlYXR1cmVOYW1lXCIsIEZFQVRVUkVfVE9LRU5fTUlOVEFCTEUubmFtZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZXJjMjBcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYXRjaFwiLCB2b2lkIDApO1xuICAgIHRoaXMuZXJjMjAgPSBlcmMyMDtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlciA9IGNvbnRyYWN0V3JhcHBlcjtcbiAgICB0aGlzLmJhdGNoID0gdGhpcy5kZXRlY3RFcmMyMEJhdGNoTWludGFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNaW50IFRva2Vuc1xuICAgKlxuICAgKiBAcmVtYXJrcyBNaW50IHRva2VucyB0byBhIHNwZWNpZmllZCBhZGRyZXNzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IHRvQWRkcmVzcyA9IFwie3t3YWxsZXRfYWRkcmVzc319XCI7IC8vIEFkZHJlc3Mgb2YgdGhlIHdhbGxldCB5b3Ugd2FudCB0byBtaW50IHRoZSB0b2tlbnMgdG9cbiAgICogY29uc3QgYW1vdW50ID0gXCIxLjVcIjsgLy8gVGhlIGFtb3VudCBvZiB0aGlzIHRva2VuIHlvdSB3YW50IHRvIG1pbnRcbiAgICogYXdhaXQgY29udHJhY3QudG9rZW4ubWludC50byh0b0FkZHJlc3MsIGFtb3VudCk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgdG8odG8sIGFtb3VudCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWNlaXB0OiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJtaW50VG9cIiwgW3RvLCBhd2FpdCB0aGlzLmVyYzIwLm5vcm1hbGl6ZUFtb3VudChhbW91bnQpXSlcbiAgICB9O1xuICB9XG4gIGRldGVjdEVyYzIwQmF0Y2hNaW50YWJsZSgpIHtcbiAgICBpZiAoZGV0ZWN0Q29udHJhY3RGZWF0dXJlKHRoaXMuY29udHJhY3RXcmFwcGVyLCBcIkVSQzIwQmF0Y2hNaW50YWJsZVwiKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcmMyMEJhdGNoTWludGFibGUodGhpcy5lcmMyMCwgdGhpcy5jb250cmFjdFdyYXBwZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogRW5hYmxlcyBnZW5lcmF0aW5nIEVSQzIwIFRva2VucyB3aXRoIHJ1bGVzIGFuZCBhbiBhc3NvY2lhdGVkIHNpZ25hdHVyZSwgd2hpY2ggY2FuIHRoZW4gYmUgbWludGVkIGJ5IGFueW9uZSBzZWN1cmVseVxuICogQHB1YmxpY1xuICovXG4vLyBUT0RPIGNvbnNvbGlkYXRlIGludG8gYSBzaW5nbGUgY2xhc3NcbmNsYXNzIEVyYzIwU2lnbmF0dXJlTWludGFibGUge1xuICBjb25zdHJ1Y3Rvcihjb250cmFjdFdyYXBwZXIsIHJvbGVzKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZmVhdHVyZU5hbWVcIiwgRkVBVFVSRV9UT0tFTl9TSUdOQVRVUkVfTUlOVEFCTEUubmFtZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicm9sZXNcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlciA9IGNvbnRyYWN0V3JhcHBlcjtcbiAgICB0aGlzLnJvbGVzID0gcm9sZXM7XG4gIH1cblxuICAvKipcbiAgICogTWludCB0b2tlbnMgZnJvbSBhIHNpZ25hdHVyZVxuICAgKlxuICAgKiBAcmVtYXJrcyBNaW50IGEgY2VydGFpbiBhbW91bnQgb2YgdG9rZW5zIGZyb20gYSBwcmV2aW91c2x5IGdlbmVyYXRlZCBzaWduYXR1cmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gc2VlIGhvdyB0byBjcmFmdCBhIHBheWxvYWQgdG8gc2lnbiBpbiB0aGUgYGdlbmVyYXRlKClgIGRvY3VtZW50YXRpb25cbiAgICogY29uc3Qgc2lnbmVkUGF5bG9hZCA9IGNvbnRyYWN0LmVyYzIwLnNpZ25hdHVyZS5nZW5lcmF0ZShwYXlsb2FkKTtcbiAgICpcbiAgICogLy8gVXNlIHRoZSBzaWduZWQgcGF5bG9hZCB0byBtaW50IHRoZSB0b2tlbnNcbiAgICogY29uc3QgdHggPSBjb250cmFjdC5lcmMyMC5zaWduYXR1cmUubWludChzaWduZWRQYXlsb2FkKTtcbiAgICogYGBgXG4gICAqIEBwYXJhbSBzaWduZWRQYXlsb2FkIC0gdGhlIHByZXZpb3VzbHkgZ2VuZXJhdGVkIHBheWxvYWQgYW5kIHNpZ25hdHVyZSB3aXRoIHtAbGluayBFcmMyMFNpZ25hdHVyZU1pbnRhYmxlLmdlbmVyYXRlfVxuICAgKiBAdHdmZWF0dXJlIEVSQzIwU2lnbmF0dXJlTWludGFibGVcbiAgICovXG4gIGFzeW5jIG1pbnQoc2lnbmVkUGF5bG9hZCkge1xuICAgIGNvbnN0IG1pbnRSZXF1ZXN0ID0gc2lnbmVkUGF5bG9hZC5wYXlsb2FkO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ25lZFBheWxvYWQuc2lnbmF0dXJlO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLm1hcFBheWxvYWRUb0NvbnRyYWN0U3RydWN0KG1pbnRSZXF1ZXN0KTtcbiAgICBjb25zdCBvdmVycmlkZXMgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRDYWxsT3ZlcnJpZGVzKCk7XG4gICAgYXdhaXQgc2V0RXJjMjBBbGxvd2FuY2UodGhpcy5jb250cmFjdFdyYXBwZXIsIEJpZ051bWJlci5mcm9tKG1lc3NhZ2UucHJpY2UpLCBtaW50UmVxdWVzdC5jdXJyZW5jeUFkZHJlc3MsIG92ZXJyaWRlcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNlbmRUcmFuc2FjdGlvbihcIm1pbnRXaXRoU2lnbmF0dXJlXCIsIFttZXNzYWdlLCBzaWduYXR1cmVdLCBvdmVycmlkZXMpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNaW50IGFueSBudW1iZXIgb2YgZ2VuZXJhdGVkIHRva2VucyBzaWduYXR1cmVzIGF0IG9uY2VcbiAgICogQHJlbWFya3MgTWludCBtdWx0aXBsZSB0b2tlbiBzaWduYXR1cmVzIGluIG9uZSB0cmFuc2FjdGlvbi4gTm90ZSB0aGF0IHRoaXMgaXMgb25seSBwb3NzaWJsZSBmb3IgZnJlZSBtaW50cyAoY2Fubm90IGJhdGNoIG1pbnRzIHdpdGggYSBwcmljZSBhdHRhY2hlZCB0byBpdCBmb3Igc2VjdXJpdHkgcmVhc29ucylcbiAgICogQHBhcmFtIHNpZ25lZFBheWxvYWRzIC0gdGhlIGFycmF5IG9mIHNpZ25lZCBwYXlsb2FkcyB0byBtaW50XG4gICAqIEB0d2ZlYXR1cmUgRVJDMjBTaWduYXR1cmVNaW50YWJsZVxuICAgKi9cbiAgYXN5bmMgbWludEJhdGNoKHNpZ25lZFBheWxvYWRzKSB7XG4gICAgY29uc3QgY29udHJhY3RQYXlsb2FkcyA9IGF3YWl0IFByb21pc2UuYWxsKHNpZ25lZFBheWxvYWRzLm1hcChhc3luYyBzID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLm1hcFBheWxvYWRUb0NvbnRyYWN0U3RydWN0KHMucGF5bG9hZCk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBzLnNpZ25hdHVyZTtcbiAgICAgIGNvbnN0IHByaWNlID0gcy5wYXlsb2FkLnByaWNlO1xuICAgICAgaWYgKEJpZ051bWJlci5mcm9tKHByaWNlKS5ndCgwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gb25seSBiYXRjaCBmcmVlIG1pbnRzLiBGb3IgbWludHMgd2l0aCBhIHByaWNlLCB1c2UgcmVndWxhciBtaW50KClcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBzaWduYXR1cmVcbiAgICAgIH07XG4gICAgfSkpO1xuICAgIGNvbnN0IGVuY29kZWQgPSBjb250cmFjdFBheWxvYWRzLm1hcChwID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShcIm1pbnRXaXRoU2lnbmF0dXJlXCIsIFtwLm1lc3NhZ2UsIHAuc2lnbmF0dXJlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLm11bHRpQ2FsbChlbmNvZGVkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoYXQgYSBwYXlsb2FkIGlzIGNvcnJlY3RseSBzaWduZWRcbiAgICogQHBhcmFtIHNpZ25lZFBheWxvYWQgLSB0aGUgcGF5bG9hZCB0byB2ZXJpZnlcbiAgICogQHR3ZmVhdHVyZSBFUkMyMFNpZ25hdHVyZU1pbnRhYmxlXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3Qgc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICogY29uc3QgZW5kVGltZSA9IG5ldyBEYXRlKERhdGUubm93KCkgKyA2MCAqIDYwICogMjQgKiAxMDAwKTtcbiAgICogY29uc3QgcGF5bG9hZCA9IHtcbiAgICogICBxdWFudGl0eTogNC4yLCAvLyBUaGUgcXVhbnRpdHkgb2YgdG9rZW5zIHRvIGJlIG1pbnRlZFxuICAgKiAgIHRvOiB7e3dhbGxldF9hZGRyZXNzfX0sIC8vIFdobyB3aWxsIHJlY2VpdmUgdGhlIHRva2Vuc1xuICAgKiAgIHByaWNlOiAwLjUsIC8vIHRoZSBwcmljZSB0byBwYXkgZm9yIG1pbnRpbmcgdGhvc2UgdG9rZW5zXG4gICAqICAgY3VycmVuY3lBZGRyZXNzOiBOQVRJVkVfVE9LRU5fQUREUkVTUywgLy8gdGhlIGN1cnJlbmN5IHRvIHBheSB3aXRoXG4gICAqICAgbWludFN0YXJ0VGltZTogc3RhcnRUaW1lLCAvLyBjYW4gbWludCBhbnl0aW1lIGZyb20gbm93XG4gICAqICAgbWludEVuZFRpbWU6IGVuZFRpbWUsIC8vIHRvIDI0aCBmcm9tIG5vdyxcbiAgICogICBwcmltYXJ5U2FsZVJlY2lwaWVudDogXCIweC4uLlwiLCAvLyBjdXN0b20gc2FsZSByZWNpcGllbnQgZm9yIHRoaXMgdG9rZW4gbWludFxuICAgKiB9O1xuICAgKlxuICAgKiBjb25zdCBzaWduZWRQYXlsb2FkID0gYXdhaXQgY29udHJhY3QuZXJjMjAuc2lnbmF0dXJlLmdlbmVyYXRlKHBheWxvYWQpO1xuICAgKiAvLyBOb3cgeW91IGNhbiB2ZXJpZnkgaWYgdGhlIHNpZ25lZCBwYXlsb2FkIGlzIHZhbGlkXG4gICAqIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBjb250cmFjdC5lcmMyMC5zaWduYXR1cmUudmVyaWZ5KHNpZ25lZFBheWxvYWQpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHZlcmlmeShzaWduZWRQYXlsb2FkKSB7XG4gICAgY29uc3QgbWludFJlcXVlc3QgPSBzaWduZWRQYXlsb2FkLnBheWxvYWQ7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbmVkUGF5bG9hZC5zaWduYXR1cmU7XG4gICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHRoaXMubWFwUGF5bG9hZFRvQ29udHJhY3RTdHJ1Y3QobWludFJlcXVlc3QpO1xuICAgIGNvbnN0IHZlcmlmaWNhdGlvbiA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC52ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlKTtcbiAgICByZXR1cm4gdmVyaWZpY2F0aW9uWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgc2lnbmF0dXJlIHRoYXQgY2FuIGJlIHVzZWQgdG8gbWludCBhIGNlcnRhaW4gYW1vdW50IG9mIHRva2Vuc1xuICAgKlxuICAgKiBAcmVtYXJrcyBUYWtlcyBpbiBhIHF1YW50aXR5IG9mIHRva2Vucywgc29tZSBjb25kaXRpb25zIGZvciBob3cgaXQgY2FuIGJlIG1pbnRlZCBhbmQgc2lnbnMgaXQgd2l0aCB5b3VyIHByaXZhdGUga2V5LiBUaGUgZ2VuZXJhdGVkIHNpZ25hdHVyZSBjYW4gdGhlbiBiZSB1c2VkIHRvIG1pbnQgdGhvc2UgdG9rZW5zIHVzaW5nIHRoZSBleGFjdCBwYXlsb2FkIGFuZCBzaWduYXR1cmUgZ2VuZXJhdGVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAqIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgNjAgKiA2MCAqIDI0ICogMTAwMCk7XG4gICAqIGNvbnN0IHBheWxvYWQgPSB7XG4gICAqICAgcXVhbnRpdHk6IDQuMiwgLy8gVGhlIHF1YW50aXR5IG9mIHRva2VucyB0byBiZSBtaW50ZWRcbiAgICogICB0bzoge3t3YWxsZXRfYWRkcmVzc319LCAvLyBXaG8gd2lsbCByZWNlaXZlIHRoZSB0b2tlbnNcbiAgICogICBwcmljZTogMC41LCAvLyB0aGUgcHJpY2UgdG8gcGF5IGZvciBtaW50aW5nIHRob3NlIHRva2Vuc1xuICAgKiAgIGN1cnJlbmN5QWRkcmVzczogTkFUSVZFX1RPS0VOX0FERFJFU1MsIC8vIHRoZSBjdXJyZW5jeSB0byBwYXkgd2l0aFxuICAgKiAgIG1pbnRTdGFydFRpbWU6IHN0YXJ0VGltZSwgLy8gY2FuIG1pbnQgYW55dGltZSBmcm9tIG5vd1xuICAgKiAgIG1pbnRFbmRUaW1lOiBlbmRUaW1lLCAvLyB0byAyNGggZnJvbSBub3csXG4gICAqICAgcHJpbWFyeVNhbGVSZWNpcGllbnQ6IFwiMHguLi5cIiwgLy8gY3VzdG9tIHNhbGUgcmVjaXBpZW50IGZvciB0aGlzIHRva2VuIG1pbnRcbiAgICogfTtcbiAgICpcbiAgICogY29uc3Qgc2lnbmVkUGF5bG9hZCA9IGF3YWl0IGNvbnRyYWN0LmVyYzIwLnNpZ25hdHVyZS5nZW5lcmF0ZShwYXlsb2FkKTtcbiAgICogLy8gbm93IGFueW9uZSBjYW4gdXNlIHRoZXNlIHRvIG1pbnQgdGhlIE5GVCB1c2luZyBgY29udHJhY3QuZXJjMjAuc2lnbmF0dXJlLm1pbnQoc2lnbmVkUGF5bG9hZClgXG4gICAqIGBgYFxuICAgKiBAcGFyYW0gbWludFJlcXVlc3QgLSB0aGUgcGF5bG9hZCB0byBzaWduXG4gICAqIEByZXR1cm5zIHRoZSBzaWduZWQgcGF5bG9hZCBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgc2lnbmF0dXJlXG4gICAqIEB0d2ZlYXR1cmUgRVJDMjBTaWduYXR1cmVNaW50YWJsZVxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGUobWludFJlcXVlc3QpIHtcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2VuZXJhdGVCYXRjaChbbWludFJlcXVlc3RdKSlbMF07XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBiYXRjaCBvZiBzaWduYXR1cmVzIHRoYXQgY2FuIGJlIHVzZWQgdG8gbWludCBtYW55IHRva2VuIHNpZ25hdHVyZXMuXG4gICAqXG4gICAqIEByZW1hcmtzIFNlZSB7QGxpbmsgRXJjMjBTaWduYXR1cmVNaW50YWJsZS5nZW5lcmF0ZX1cbiAgICpcbiAgICogQHBhcmFtIHBheWxvYWRzVG9TaWduIC0gdGhlIHBheWxvYWRzIHRvIHNpZ25cbiAgICogQHJldHVybnMgYW4gYXJyYXkgb2YgcGF5bG9hZHMgYW5kIHNpZ25hdHVyZXNcbiAgICogQHR3ZmVhdHVyZSBFUkMyMFNpZ25hdHVyZU1pbnRhYmxlXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZUJhdGNoKHBheWxvYWRzVG9TaWduKSB7XG4gICAgYXdhaXQgdGhpcy5yb2xlcz8udmVyaWZ5KFtcIm1pbnRlclwiXSwgYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0U2lnbmVyQWRkcmVzcygpKTtcbiAgICBjb25zdCBwYXJzZWRSZXF1ZXN0cyA9IHBheWxvYWRzVG9TaWduLm1hcChtID0+IFNpZ25hdHVyZTIwUGF5bG9hZElucHV0LnBhcnNlKG0pKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0Q2hhaW5JRCgpO1xuICAgIGNvbnN0IHNpZ25lciA9IHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFNpZ25lcigpO1xuICAgIGludmFyaWFudChzaWduZXIsIFwiTm8gc2lnbmVyIGF2YWlsYWJsZVwiKTtcblxuICAgIC8vIEVSQzIwUGVybWl0IChFSVAtNzEyKSBzcGVjIGRpZmZlcnMgZnJvbSBzaWduYXR1cmUgbWludCA3MjEsIDExNTUuXG4gICAgY29uc3QgbmFtZSA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5uYW1lKCk7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHBhcnNlZFJlcXVlc3RzLm1hcChhc3luYyBtID0+IHtcbiAgICAgIGNvbnN0IGZpbmFsUGF5bG9hZCA9IFNpZ25hdHVyZTIwUGF5bG9hZE91dHB1dC5wYXJzZShtKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNpZ25UeXBlZERhdGEoc2lnbmVyLCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZlcnNpb246IFwiMVwiLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICB2ZXJpZnlpbmdDb250cmFjdDogdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmFkZHJlc3NcbiAgICAgIH0sIHtcbiAgICAgICAgTWludFJlcXVlc3Q6IE1pbnRSZXF1ZXN0MjBcbiAgICAgIH0sIGF3YWl0IHRoaXMubWFwUGF5bG9hZFRvQ29udHJhY3RTdHJ1Y3QoZmluYWxQYXlsb2FkKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXlsb2FkOiBmaW5hbFBheWxvYWQsXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLnRvU3RyaW5nKClcbiAgICAgIH07XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBQUklWQVRFIEZVTkNUSU9OU1xuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKipcbiAgICogTWFwcyBhIHBheWxvYWQgdG8gdGhlIGZvcm1hdCBleHBlY3RlZCBieSB0aGUgY29udHJhY3RcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIEBwYXJhbSBtaW50UmVxdWVzdCAtIFRoZSBwYXlsb2FkIHRvIG1hcC5cbiAgICogQHJldHVybnMgLSBUaGUgbWFwcGVkIHBheWxvYWQuXG4gICAqL1xuICBhc3luYyBtYXBQYXlsb2FkVG9Db250cmFjdFN0cnVjdChtaW50UmVxdWVzdCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRQcmljZSA9IGF3YWl0IG5vcm1hbGl6ZVByaWNlVmFsdWUodGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJvdmlkZXIoKSwgbWludFJlcXVlc3QucHJpY2UsIG1pbnRSZXF1ZXN0LmN1cnJlbmN5QWRkcmVzcyk7XG4gICAgY29uc3QgYW1vdW50V2l0aERlY2ltYWxzID0gZXRoZXJzLnV0aWxzLnBhcnNlVW5pdHMobWludFJlcXVlc3QucXVhbnRpdHksIGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5kZWNpbWFscygpKTtcbiAgICByZXR1cm4ge1xuICAgICAgdG86IG1pbnRSZXF1ZXN0LnRvLFxuICAgICAgcHJpbWFyeVNhbGVSZWNpcGllbnQ6IG1pbnRSZXF1ZXN0LnByaW1hcnlTYWxlUmVjaXBpZW50LFxuICAgICAgcXVhbnRpdHk6IGFtb3VudFdpdGhEZWNpbWFscyxcbiAgICAgIHByaWNlOiBub3JtYWxpemVkUHJpY2UsXG4gICAgICBjdXJyZW5jeTogbWludFJlcXVlc3QuY3VycmVuY3lBZGRyZXNzLFxuICAgICAgdmFsaWRpdHlFbmRUaW1lc3RhbXA6IG1pbnRSZXF1ZXN0Lm1pbnRFbmRUaW1lLFxuICAgICAgdmFsaWRpdHlTdGFydFRpbWVzdGFtcDogbWludFJlcXVlc3QubWludFN0YXJ0VGltZSxcbiAgICAgIHVpZDogbWludFJlcXVlc3QudWlkXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFN0YW5kYXJkIEVSQzIwIFRva2VuIGZ1bmN0aW9uc1xuICogQHJlbWFya3MgQmFzaWMgZnVuY3Rpb25hbGl0eSBmb3IgYSBFUkMyMCBjb250cmFjdCB0aGF0IGhhbmRsZXMgYWxsIHVuaXQgdHJhbnNmb3JtYXRpb24gZm9yIHlvdS5cbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBjb250cmFjdCA9IGF3YWl0IHNkay5nZXRDb250cmFjdChcInt7Y29udHJhY3RfYWRkcmVzc319XCIpO1xuICogYXdhaXQgY29udHJhY3QuZXJjMjAudHJhbnNmZXIod2FsbGV0QWRkcmVzcywgYW1vdW50KTtcbiAqIGBgYFxuICogQHB1YmxpY1xuICovXG5jbGFzcyBFcmMyMCB7XG4gIC8qKlxuICAgKiBNaW50IHRva2Vuc1xuICAgKi9cblxuICBnZXQgY2hhaW5JZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhaW5JZDtcbiAgfVxuICBjb25zdHJ1Y3Rvcihjb250cmFjdFdyYXBwZXIsIHN0b3JhZ2UsIGNoYWluSWQpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmZWF0dXJlTmFtZVwiLCBGRUFUVVJFX1RPS0VOLm5hbWUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1pbnRhYmxlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYnVybmFibGVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkcm9wcGFibGVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaWduYXR1cmVNaW50YWJsZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRyYWN0V3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3JhZ2VcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY2hhaW5JZFwiLCB2b2lkIDApO1xuICAgIHRoaXMuY29udHJhY3RXcmFwcGVyID0gY29udHJhY3RXcmFwcGVyO1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgdGhpcy5taW50YWJsZSA9IHRoaXMuZGV0ZWN0RXJjMjBNaW50YWJsZSgpO1xuICAgIHRoaXMuYnVybmFibGUgPSB0aGlzLmRldGVjdEVyYzIwQnVybmFibGUoKTtcbiAgICB0aGlzLmRyb3BwYWJsZSA9IHRoaXMuZGV0ZWN0RXJjMjBEcm9wcGFibGUoKTtcbiAgICB0aGlzLnNpZ25hdHVyZU1pbnRhYmxlID0gdGhpcy5kZXRlY3RFcmMyMFNpZ25hdHVyZU1pbnRhYmxlKCk7XG4gICAgdGhpcy5fY2hhaW5JZCA9IGNoYWluSWQ7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBvbk5ldHdvcmtVcGRhdGVkKG5ldHdvcmspIHtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlci51cGRhdGVTaWduZXJPclByb3ZpZGVyKG5ldHdvcmspO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0QWRkcmVzcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmFkZHJlc3M7XG4gIH1cblxuICAvLy8vLy8gU3RhbmRhcmQgRVJDMjAgRXh0ZW5zaW9uIC8vLy8vL1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRva2VuIE1ldGFkYXRhIChuYW1lLCBzeW1ib2wsIGV0Yy4uLilcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCB0b2tlbiA9IGF3YWl0IGNvbnRyYWN0LmVyYzIwLmdldCgpO1xuICAgKiBgYGBcbiAgICogQHJldHVybnMgVGhlIHRva2VuIG1ldGFkYXRhXG4gICAqIEB0d2ZlYXR1cmUgRVJDMjBcbiAgICovXG4gIGFzeW5jIGdldCgpIHtcbiAgICByZXR1cm4gYXdhaXQgZmV0Y2hDdXJyZW5jeU1ldGFkYXRhKHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFByb3ZpZGVyKCksIHRoaXMuZ2V0QWRkcmVzcygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgVG9rZW4gQmFsYW5jZSBmb3IgdGhlIGN1cnJlbnRseSBjb25uZWN0ZWQgd2FsbGV0XG4gICAqXG4gICAqIEByZW1hcmtzIEdldCBhIHdhbGxldHMgdG9rZW4gYmFsYW5jZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBiYWxhbmNlID0gYXdhaXQgY29udHJhY3QuZXJjMjAuYmFsYW5jZSgpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybnMgVGhlIGJhbGFuY2Ugb2YgYSBzcGVjaWZpYyB3YWxsZXQuXG4gICAqIEB0d2ZlYXR1cmUgRVJDMjBcbiAgICovXG4gIGFzeW5jIGJhbGFuY2UoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYmFsYW5jZU9mKGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFNpZ25lckFkZHJlc3MoKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IFRva2VuIEJhbGFuY2VcbiAgICpcbiAgICogQHJlbWFya3MgR2V0IGEgd2FsbGV0cyB0b2tlbiBiYWxhbmNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIEFkZHJlc3Mgb2YgdGhlIHdhbGxldCB0byBjaGVjayB0b2tlbiBiYWxhbmNlXG4gICAqIGNvbnN0IHdhbGxldEFkZHJlc3MgPSBcInt7d2FsbGV0X2FkZHJlc3N9fVwiO1xuICAgKiBjb25zdCBiYWxhbmNlID0gYXdhaXQgY29udHJhY3QuZXJjMjAuYmFsYW5jZU9mKHdhbGxldEFkZHJlc3MpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybnMgVGhlIGJhbGFuY2Ugb2YgYSBzcGVjaWZpYyB3YWxsZXQuXG4gICAqIEB0d2ZlYXR1cmUgRVJDMjBcbiAgICovXG4gIGFzeW5jIGJhbGFuY2VPZihhZGRyZXNzKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmJhbGFuY2VPZihhZGRyZXNzKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRvdGFsIHN1cHBseSBmb3IgdGhpcyBUb2tlblxuICAgKiBAcmVtYXJrcyBHZXQgaG93IG11Y2ggc3VwcGx5IGhhcyBiZWVuIG1pbnRlZFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjb250cmFjdC5lcmMyMC50b3RhbFN1cHBseSgpO1xuICAgKiBgYGBcbiAgICogQHR3ZmVhdHVyZSBFUkMyMFxuICAgKi9cbiAgYXN5bmMgdG90YWxTdXBwbHkoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0VmFsdWUoYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LnRvdGFsU3VwcGx5KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBUb2tlbiBBbGxvd2FuY2VcbiAgICpcbiAgICogQHJlbWFya3MgR2V0IHRoZSBhbGxvd2FuY2Ugb2YgYSAnc3BlbmRlcicgd2FsbGV0IG92ZXIgdGhlIGNvbm5lY3RlZCB3YWxsZXQncyBmdW5kcyAtIHRoZSBhbGxvd2FuY2Ugb2YgYSBkaWZmZXJlbnQgYWRkcmVzcyBmb3IgYSB0b2tlbiBpcyB0aGUgYW1vdW50IG9mIHRva2VucyB0aGF0IHRoZSBgc3BlbmRlcmAgd2FsbGV0IGlzIGFsbG93ZWQgdG8gc3BlbmQgb24gYmVoYWxmIG9mIHRoZSBjb25uZWN0ZWQgd2FsbGV0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIEFkZHJlc3Mgb2YgdGhlIHdhbGxldCB0byBjaGVjayB0b2tlbiBhbGxvd2FuY2VcbiAgICogY29uc3Qgc3BlbmRlckFkZHJlc3MgPSBcIjB4Li4uXCI7XG4gICAqIGNvbnN0IGFsbG93YW5jZSA9IGF3YWl0IGNvbnRyYWN0LmVyYzIwLmFsbG93YW5jZShzcGVuZGVyQWRkcmVzcyk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgYWxsb3dhbmNlIG9mIG9uZSB3YWxsZXQgb3ZlciBhbm90aGVycyBmdW5kcy5cbiAgICogQHR3ZmVhdHVyZSBFUkMyMFxuICAgKi9cbiAgYXN5bmMgYWxsb3dhbmNlKHNwZW5kZXIpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hbGxvd2FuY2VPZihhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRTaWduZXJBZGRyZXNzKCksIHNwZW5kZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBUb2tlbiBBbGxvd2FuY2VcbiAgICpcbiAgICogQHJlbWFya3MgR2V0IHRoZSBhbGxvd2FuY2Ugb2Ygb25lIHdhbGxldCBvdmVyIGFub3RoZXIgd2FsbGV0J3MgZnVuZHMgLSB0aGUgYWxsb3dhbmNlIG9mIGEgZGlmZmVyZW50IGFkZHJlc3MgZm9yIGEgdG9rZW4gaXMgdGhlIGFtb3VudCBvZiB0b2tlbnMgdGhhdCB0aGUgd2FsbGV0IGlzIGFsbG93ZWQgdG8gc3BlbmQgb24gYmVoYWxmIG9mIHRoZSBzcGVjaWZpZWQgd2FsbGV0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIEFkZHJlc3Mgb2YgdGhlIHdhbGxldCB3aG8gb3ducyB0aGUgZnVuZHNcbiAgICogY29uc3Qgb3duZXIgPSBcInt7d2FsbGV0X2FkZHJlc3N9fVwiO1xuICAgKiAvLyBBZGRyZXNzIG9mIHRoZSB3YWxsZXQgdG8gY2hlY2sgdG9rZW4gYWxsb3dhbmNlXG4gICAqIGNvbnN0IHNwZW5kZXIgPSBcIjB4Li4uXCI7XG4gICAqIGNvbnN0IGFsbG93YW5jZSA9IGF3YWl0IGNvbnRyYWN0LmVyYzIwLmFsbG93YW5jZU9mKG93bmVyLCBzcGVuZGVyKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBhbGxvd2FuY2Ugb2Ygb25lIHdhbGxldCBvdmVyIGFub3RoZXJzIGZ1bmRzLlxuICAgKiBAdHdmZWF0dXJlIEVSQzIwXG4gICAqL1xuICBhc3luYyBhbGxvd2FuY2VPZihvd25lciwgc3BlbmRlcikge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFZhbHVlKGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5hbGxvd2FuY2Uob3duZXIsIHNwZW5kZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2ZlciBUb2tlbnNcbiAgICpcbiAgICogQHJlbWFya3MgVHJhbnNmZXIgdG9rZW5zIGZyb20gdGhlIGNvbm5lY3RlZCB3YWxsZXQgdG8gYW5vdGhlciB3YWxsZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gQWRkcmVzcyBvZiB0aGUgd2FsbGV0IHlvdSB3YW50IHRvIHNlbmQgdGhlIHRva2VucyB0b1xuICAgKiBjb25zdCB0b0FkZHJlc3MgPSBcIjB4Li4uXCI7XG4gICAqIC8vIFRoZSBhbW91bnQgb2YgdG9rZW5zIHlvdSB3YW50IHRvIHNlbmRcbiAgICogY29uc3QgYW1vdW50ID0gMC4xO1xuICAgKiBhd2FpdCBjb250cmFjdC5lcmMyMC50cmFuc2Zlcih0b0FkZHJlc3MsIGFtb3VudCk7XG4gICAqIGBgYFxuICAgKiBAdHdmZWF0dXJlIEVSQzIwXG4gICAqL1xuICBhc3luYyB0cmFuc2Zlcih0bywgYW1vdW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNlbmRUcmFuc2FjdGlvbihcInRyYW5zZmVyXCIsIFt0bywgYXdhaXQgdGhpcy5ub3JtYWxpemVBbW91bnQoYW1vdW50KV0pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2ZlciBUb2tlbnMgRnJvbSBBZGRyZXNzXG4gICAqXG4gICAqIEByZW1hcmtzIFRyYW5zZmVyIHRva2VucyBmcm9tIG9uZSB3YWxsZXQgdG8gYW5vdGhlclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIEFkZHJlc3Mgb2YgdGhlIHdhbGxldCBzZW5kaW5nIHRoZSB0b2tlbnNcbiAgICogY29uc3QgZnJvbUFkZHJlc3MgPSBcInt7d2FsbGV0X2FkZHJlc3N9fVwiO1xuICAgKiAvLyBBZGRyZXNzIG9mIHRoZSB3YWxsZXQgeW91IHdhbnQgdG8gc2VuZCB0aGUgdG9rZW5zIHRvXG4gICAqIGNvbnN0IHRvQWRkcmVzcyA9IFwiMHguLi5cIjtcbiAgICogLy8gVGhlIG51bWJlciBvZiB0b2tlbnMgeW91IHdhbnQgdG8gc2VuZFxuICAgKiBjb25zdCBhbW91bnQgPSAxLjJcbiAgICogLy8gTm90ZSB0aGF0IHRoZSBjb25uZWN0ZWQgd2FsbGV0IG11c3QgaGF2ZSBhcHByb3ZhbCB0byB0cmFuc2ZlciB0aGUgdG9rZW5zIG9mIHRoZSBmcm9tQWRkcmVzc1xuICAgKiBhd2FpdCBjb250cmFjdC5lcmMyMC50cmFuc2ZlckZyb20oZnJvbUFkZHJlc3MsIHRvQWRkcmVzcywgYW1vdW50KTtcbiAgICogYGBgXG4gICAqIEB0d2ZlYXR1cmUgRVJDMjBcbiAgICovXG4gIGFzeW5jIHRyYW5zZmVyRnJvbShmcm9tLCB0bywgYW1vdW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNlbmRUcmFuc2FjdGlvbihcInRyYW5zZmVyRnJvbVwiLCBbZnJvbSwgdG8sIGF3YWl0IHRoaXMubm9ybWFsaXplQW1vdW50KGFtb3VudCldKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIHRoZSBzcGVjaWZpZWQgYHNwZW5kZXJgIHdhbGxldCB0byB0cmFuc2ZlciB0aGUgZ2l2ZW4gYGFtb3VudGAgb2YgdG9rZW5zIHRvIGFub3RoZXIgd2FsbGV0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gQWRkcmVzcyBvZiB0aGUgd2FsbGV0IHRvIGFsbG93IHRyYW5zZmVycyBmcm9tXG4gICAqIGNvbnN0IHNwZW5kZXJBZGRyZXNzID0gXCIweC4uLlwiO1xuICAgKiAvLyBUaGUgbnVtYmVyIG9mIHRva2VucyB0byBnaXZlIGFzIGFsbG93YW5jZVxuICAgKiBjb25zdCBhbW91bnQgPSAxMDBcbiAgICogYXdhaXQgY29udHJhY3QuZXJjMjAuc2V0QWxsb3dhbmNlKHNwZW5kZXJBZGRyZXNzLCBhbW91bnQpO1xuICAgKiBgYGBcbiAgICogQHR3ZmVhdHVyZSBFUkMyMFxuICAgKi9cbiAgYXN5bmMgc2V0QWxsb3dhbmNlKHNwZW5kZXIsIGFtb3VudCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWNlaXB0OiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJhcHByb3ZlXCIsIFtzcGVuZGVyLCBhd2FpdCB0aGlzLm5vcm1hbGl6ZUFtb3VudChhbW91bnQpXSlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZmVyIFRva2VucyBUbyBNYW55IFdhbGxldHNcbiAgICpcbiAgICogQHJlbWFya3MgTWludCB0b2tlbnMgZnJvbSB0aGUgY29ubmVjdGVkIHdhbGxldCB0byBtYW55IHdhbGxldHNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBEYXRhIG9mIHRoZSB0b2tlbnMgeW91IHdhbnQgdG8gbWludFxuICAgKiBjb25zdCBkYXRhID0gW1xuICAgKiAgIHtcbiAgICogICAgIHRvQWRkcmVzczogXCJ7e3dhbGxldF9hZGRyZXNzfX1cIiwgLy8gQWRkcmVzcyB0byBtaW50IHRva2VucyB0b1xuICAgKiAgICAgYW1vdW50OiAxMDAsIC8vIEhvdyBtYW55IHRva2VucyB0byBtaW50IHRvIHNwZWNpZmllZCBhZGRyZXNzXG4gICAqICAgfSxcbiAgICogIHtcbiAgICogICAgdG9BZGRyZXNzOiBcIjB4Li4uXCIsXG4gICAqICAgIGFtb3VudDogMTAwLFxuICAgKiAgfVxuICAgKiBdXG4gICAqXG4gICAqIGF3YWl0IGNvbnRyYWN0LmVyYzIwLnRyYW5zZmVyQmF0Y2goZGF0YSk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgdHJhbnNmZXJCYXRjaChhcmdzKSB7XG4gICAgY29uc3QgZW5jb2RlZCA9IGF3YWl0IFByb21pc2UuYWxsKGFyZ3MubWFwKGFzeW5jIGFyZyA9PiB7XG4gICAgICBjb25zdCBhbW91bnRXaXRoRGVjaW1hbHMgPSBhd2FpdCB0aGlzLm5vcm1hbGl6ZUFtb3VudChhcmcuYW1vdW50KTtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShcInRyYW5zZmVyXCIsIFthcmcudG9BZGRyZXNzLCBhbW91bnRXaXRoRGVjaW1hbHNdKTtcbiAgICB9KSk7XG4gICAgYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIubXVsdGlDYWxsKGVuY29kZWQpO1xuICB9XG5cbiAgLy8vLy8vIEVSQzIwIE1pbnRhYmxlIEV4dGVuc2lvbiAvLy8vLy9cblxuICAvKipcbiAgICogTWludCBUb2tlbnNcbiAgICpcbiAgICogQHJlbWFya3MgTWludCB0b2tlbnMgdG8gdGhlIGNvbm5lY3RlZCB3YWxsZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgYW1vdW50ID0gXCIxLjVcIjsgLy8gVGhlIGFtb3VudCBvZiB0aGlzIHRva2VuIHlvdSB3YW50IHRvIG1pbnRcbiAgICogYXdhaXQgY29udHJhY3QuZXJjMjAubWludCh0b0FkZHJlc3MsIGFtb3VudCk7XG4gICAqIGBgYFxuICAgKiBAdHdmZWF0dXJlIEVSQzIwTWludGFibGVcbiAgICovXG4gIGFzeW5jIG1pbnQoYW1vdW50KSB7XG4gICAgcmV0dXJuIHRoaXMubWludFRvKGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFNpZ25lckFkZHJlc3MoKSwgYW1vdW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNaW50IFRva2Vuc1xuICAgKlxuICAgKiBAcmVtYXJrcyBNaW50IHRva2VucyB0byBhIHNwZWNpZmllZCBhZGRyZXNzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IHRvQWRkcmVzcyA9IFwie3t3YWxsZXRfYWRkcmVzc319XCI7IC8vIEFkZHJlc3Mgb2YgdGhlIHdhbGxldCB5b3Ugd2FudCB0byBtaW50IHRoZSB0b2tlbnMgdG9cbiAgICogY29uc3QgYW1vdW50ID0gXCIxLjVcIjsgLy8gVGhlIGFtb3VudCBvZiB0aGlzIHRva2VuIHlvdSB3YW50IHRvIG1pbnRcbiAgICogYXdhaXQgY29udHJhY3QuZXJjMjAubWludFRvKHRvQWRkcmVzcywgYW1vdW50KTtcbiAgICogYGBgXG4gICAqIEB0d2ZlYXR1cmUgRVJDMjBNaW50YWJsZVxuICAgKi9cbiAgYXN5bmMgbWludFRvKHJlY2VpdmVyLCBhbW91bnQpIHtcbiAgICByZXR1cm4gYXNzZXJ0RW5hYmxlZCh0aGlzLm1pbnRhYmxlLCBGRUFUVVJFX1RPS0VOX01JTlRBQkxFKS50byhyZWNlaXZlciwgYW1vdW50KTtcbiAgfVxuXG4gIC8vLy8vLyBFUkMyMCBCYXRjaE1pbnRhYmxlIEV4dGVuc2lvbiAvLy8vLy9cblxuICAvKipcbiAgICogTWludCBUb2tlbnMgVG8gTWFueSBXYWxsZXRzXG4gICAqXG4gICAqIEByZW1hcmtzIE1pbnQgdG9rZW5zIHRvIG1hbnkgd2FsbGV0cyBpbiBvbmUgdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gRGF0YSBvZiB0aGUgdG9rZW5zIHlvdSB3YW50IHRvIG1pbnRcbiAgICogY29uc3QgZGF0YSA9IFtcbiAgICogICB7XG4gICAqICAgICB0b0FkZHJlc3M6IFwie3t3YWxsZXRfYWRkcmVzc319XCIsIC8vIEFkZHJlc3MgdG8gbWludCB0b2tlbnMgdG9cbiAgICogICAgIGFtb3VudDogMC4yLCAvLyBIb3cgbWFueSB0b2tlbnMgdG8gbWludCB0byBzcGVjaWZpZWQgYWRkcmVzc1xuICAgKiAgIH0sXG4gICAqICB7XG4gICAqICAgIHRvQWRkcmVzczogXCIweC4uLlwiLFxuICAgKiAgICBhbW91bnQ6IDEuNCxcbiAgICogIH1cbiAgICogXVxuICAgKlxuICAgKiBhd2FpdCBjb250cmFjdC5taW50QmF0Y2hUbyhkYXRhKTtcbiAgICogYGBgXG4gICAqIEB0d2ZlYXR1cmUgRVJDMjBCYXRjaE1pbnRhYmxlXG4gICAqL1xuICBhc3luYyBtaW50QmF0Y2hUbyhhcmdzKSB7XG4gICAgcmV0dXJuIGFzc2VydEVuYWJsZWQodGhpcy5taW50YWJsZT8uYmF0Y2gsIEZFQVRVUkVfVE9LRU5fQkFUQ0hfTUlOVEFCTEUpLnRvKGFyZ3MpO1xuICB9XG5cbiAgLy8vLy8vIEVSQzIwIEJ1cm5hYmxlIEV4dGVuc2lvbiAvLy8vLy9cblxuICAvKipcbiAgICogQnVybiBUb2tlbnNcbiAgICpcbiAgICogQHJlbWFya3MgQnVybiB0b2tlbnMgaGVsZCBieSB0aGUgY29ubmVjdGVkIHdhbGxldFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIFRoZSBhbW91bnQgb2YgdGhpcyB0b2tlbiB5b3Ugd2FudCB0byBidXJuXG4gICAqIGNvbnN0IGFtb3VudCA9IDEuMjtcbiAgICpcbiAgICogYXdhaXQgY29udHJhY3QuZXJjMjAuYnVybihhbW91bnQpO1xuICAgKiBgYGBcbiAgICogQHR3ZmVhdHVyZSBFUkMyMEJ1cm5hYmxlXG4gICAqL1xuICBhc3luYyBidXJuKGFtb3VudCkge1xuICAgIHJldHVybiBhc3NlcnRFbmFibGVkKHRoaXMuYnVybmFibGUsIEZFQVRVUkVfVE9LRU5fQlVSTkFCTEUpLnRva2VucyhhbW91bnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1cm4gVG9rZW5zXG4gICAqXG4gICAqIEByZW1hcmtzIEJ1cm4gdG9rZW5zIGhlbGQgYnkgdGhlIHNwZWNpZmllZCB3YWxsZXRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBBZGRyZXNzIG9mIHRoZSB3YWxsZXQgc2VuZGluZyB0aGUgdG9rZW5zXG4gICAqIGNvbnN0IGhvbGRlckFkZHJlc3MgPSBcInt7d2FsbGV0X2FkZHJlc3N9fVwiO1xuICAgKlxuICAgKiAvLyBUaGUgYW1vdW50IG9mIHRoaXMgdG9rZW4geW91IHdhbnQgdG8gYnVyblxuICAgKiBjb25zdCBhbW91bnQgPSAxLjI7XG4gICAqXG4gICAqIGF3YWl0IGNvbnRyYWN0LmVyYzIwLmJ1cm5Gcm9tKGhvbGRlckFkZHJlc3MsIGFtb3VudCk7XG4gICAqIGBgYFxuICAgKiBAdHdmZWF0dXJlIEVSQzIwQnVybmFibGVcbiAgICovXG4gIGFzeW5jIGJ1cm5Gcm9tKGhvbGRlciwgYW1vdW50KSB7XG4gICAgcmV0dXJuIGFzc2VydEVuYWJsZWQodGhpcy5idXJuYWJsZSwgRkVBVFVSRV9UT0tFTl9CVVJOQUJMRSkuZnJvbShob2xkZXIsIGFtb3VudCk7XG4gIH1cblxuICAvLy8vLy8gRVJDMjAgQ2xhaW1hYmxlIEV4dGVuc2lvbiAvLy8vLy9cblxuICAvKipcbiAgICogQ2xhaW0gYSBjZXJ0YWluIGFtb3VudCBvZiB0b2tlbnMgdG8gdGhlIGNvbm5lY3RlZCBXYWxsZXRcbiAgICpcbiAgICogQHJlbWFya3MgTGV0IHRoZSBzcGVjaWZpZWQgd2FsbGV0IGNsYWltIFRva2Vucy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBhZGRyZXNzID0gXCJ7e3dhbGxldF9hZGRyZXNzfX1cIjsgLy8gYWRkcmVzcyBvZiB0aGUgd2FsbGV0IHlvdSB3YW50IHRvIGNsYWltIHRoZSBORlRzXG4gICAqIGNvbnN0IHF1YW50aXR5ID0gNDIuNjk7IC8vIGhvdyBtYW55IHRva2VucyB5b3Ugd2FudCB0byBjbGFpbVxuICAgKlxuICAgKiBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmVyYzIwLmNsYWltKGFkZHJlc3MsIHF1YW50aXR5KTtcbiAgICogY29uc3QgcmVjZWlwdCA9IHR4LnJlY2VpcHQ7IC8vIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gZGVzdGluYXRpb25BZGRyZXNzIC0gQWRkcmVzcyB5b3Ugd2FudCB0byBzZW5kIHRoZSB0b2tlbiB0b1xuICAgKiBAcGFyYW0gYW1vdW50IC0gUXVhbnRpdHkgb2YgdGhlIHRva2VucyB5b3Ugd2FudCB0byBjbGFpbVxuICAgKiBAcGFyYW0gY2hlY2tFUkMyMEFsbG93YW5jZSAtIE9wdGlvbmFsLCBjaGVjayBpZiB0aGUgd2FsbGV0IGhhcyBlbm91Z2ggRVJDMjAgYWxsb3dhbmNlIHRvIGNsYWltIHRoZSB0b2tlbnMsIGFuZCBpZiBub3QsIGFwcHJvdmUgdGhlIHRyYW5zZmVyXG4gICAqIEBwYXJhbSBjbGFpbURhdGFcbiAgICogQHJldHVybnMgLSBUaGUgdHJhbnNhY3Rpb24gcmVjZWlwdFxuICAgKiBAdHdmZWF0dXJlIEVSQzIwQ2xhaW1hYmxlV2l0aENvbmRpdGlvbnNcbiAgICovXG4gIGFzeW5jIGNsYWltKGFtb3VudCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNsYWltVG8oYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0U2lnbmVyQWRkcmVzcygpLCBhbW91bnQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsYWltIGEgY2VydGFpbiBhbW91bnQgb2YgdG9rZW5zIHRvIGEgc3BlY2lmaWMgV2FsbGV0XG4gICAqXG4gICAqIEByZW1hcmtzIExldCB0aGUgc3BlY2lmaWVkIHdhbGxldCBjbGFpbSBUb2tlbnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgYWRkcmVzcyA9IFwie3t3YWxsZXRfYWRkcmVzc319XCI7IC8vIGFkZHJlc3Mgb2YgdGhlIHdhbGxldCB5b3Ugd2FudCB0byBjbGFpbSB0aGUgTkZUc1xuICAgKiBjb25zdCBxdWFudGl0eSA9IDQyLjY5OyAvLyBob3cgbWFueSB0b2tlbnMgeW91IHdhbnQgdG8gY2xhaW1cbiAgICpcbiAgICogY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5lcmMyMC5jbGFpbShhZGRyZXNzLCBxdWFudGl0eSk7XG4gICAqIGNvbnN0IHJlY2VpcHQgPSB0eC5yZWNlaXB0OyAvLyB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdFxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGRlc3RpbmF0aW9uQWRkcmVzcyAtIEFkZHJlc3MgeW91IHdhbnQgdG8gc2VuZCB0aGUgdG9rZW4gdG9cbiAgICogQHBhcmFtIGFtb3VudCAtIFF1YW50aXR5IG9mIHRoZSB0b2tlbnMgeW91IHdhbnQgdG8gY2xhaW1cbiAgICogQHBhcmFtIGNoZWNrRVJDMjBBbGxvd2FuY2UgLSBPcHRpb25hbCwgY2hlY2sgaWYgdGhlIHdhbGxldCBoYXMgZW5vdWdoIEVSQzIwIGFsbG93YW5jZSB0byBjbGFpbSB0aGUgdG9rZW5zLCBhbmQgaWYgbm90LCBhcHByb3ZlIHRoZSB0cmFuc2ZlclxuICAgKiBAcGFyYW0gY2xhaW1EYXRhXG4gICAqIEByZXR1cm5zIC0gVGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRcbiAgICogQHR3ZmVhdHVyZSBFUkMyMENsYWltYWJsZVdpdGhDb25kaXRpb25zXG4gICAqL1xuICBhc3luYyBjbGFpbVRvKGRlc3RpbmF0aW9uQWRkcmVzcywgYW1vdW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGFzc2VydEVuYWJsZWQodGhpcy5kcm9wcGFibGU/LmNsYWltLCBGRUFUVVJFX1RPS0VOX0NMQUlNX0NPTkRJVElPTlNfVjIpLnRvKGRlc3RpbmF0aW9uQWRkcmVzcywgYW1vdW50LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmUgY2xhaW0gY29uZGl0aW9uc1xuICAgKiBAcmVtYXJrcyBEZWZpbmUgd2hvIGNhbiBjbGFpbSBORlRzIGluIHRoZSBjb2xsZWN0aW9uLCB3aGVuIGFuZCBob3cgbWFueS5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBwcmVzYWxlU3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICogY29uc3QgcHVibGljU2FsZVN0YXJ0VGltZSA9IG5ldyBEYXRlKERhdGUubm93KCkgKyA2MCAqIDYwICogMjQgKiAxMDAwKTtcbiAgICogY29uc3QgY2xhaW1Db25kaXRpb25zID0gW1xuICAgKiAgIHtcbiAgICogICAgIHN0YXJ0VGltZTogcHJlc2FsZVN0YXJ0VGltZSwgLy8gc3RhcnQgdGhlIHByZXNhbGUgbm93XG4gICAqICAgICBtYXhRdWFudGl0eTogMiwgLy8gbGltaXQgaG93IG1hbnkgbWludHMgZm9yIHRoaXMgcHJlc2FsZVxuICAgKiAgICAgcHJpY2U6IDAuMDEsIC8vIHByZXNhbGUgcHJpY2VcbiAgICogICAgIHNuYXBzaG90OiBbJzB4Li4uJywgJzB4Li4uJ10sIC8vIGxpbWl0IG1pbnRpbmcgdG8gb25seSBjZXJ0YWluIGFkZHJlc3Nlc1xuICAgKiAgIH0sXG4gICAqICAge1xuICAgKiAgICAgc3RhcnRUaW1lOiBwdWJsaWNTYWxlU3RhcnRUaW1lLCAvLyAyNGggYWZ0ZXIgcHJlc2FsZSwgc3RhcnQgcHVibGljIHNhbGVcbiAgICogICAgIHByaWNlOiAwLjA4LCAvLyBwdWJsaWMgc2FsZSBwcmljZVxuICAgKiAgIH1cbiAgICogXSk7XG4gICAqIGF3YWl0IGNvbnRyYWN0LmVyYzIwLmNsYWltQ29uZGl0aW9ucy5zZXQoY2xhaW1Db25kaXRpb25zKTtcbiAgICogYGBgXG4gICAqIEB0d2ZlYXR1cmUgRVJDMjBDbGFpbWFibGVXaXRoQ29uZGl0aW9uc1xuICAgKi9cbiAgZ2V0IGNsYWltQ29uZGl0aW9ucygpIHtcbiAgICByZXR1cm4gYXNzZXJ0RW5hYmxlZCh0aGlzLmRyb3BwYWJsZT8uY2xhaW0sIEZFQVRVUkVfVE9LRU5fQ0xBSU1fQ09ORElUSU9OU19WMikuY29uZGl0aW9ucztcbiAgfVxuXG4gIC8vLy8vLyBFUkMyMCBTaWduYXR1cmVNaW50IEV4dGVuc2lvbiAvLy8vLy9cblxuICAvKipcbiAgICogU2lnbmF0dXJlIE1pbnRpbmdcbiAgICogQHJlbWFya3MgR2VuZXJhdGUgZHluYW1pYyB0b2tlbnMgd2l0aCB5b3VyIG93biBzaWduYXR1cmUsIGFuZCBsZXQgb3RoZXJzIG1pbnQgdGhlbSB1c2luZyB0aGF0IHNpZ25hdHVyZS5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBzZWUgaG93IHRvIGNyYWZ0IGEgcGF5bG9hZCB0byBzaWduIGluIHRoZSBgY29udHJhY3QuZXJjMjAuc2lnbmF0dXJlLmdlbmVyYXRlKClgIGRvY3VtZW50YXRpb25cbiAgICogY29uc3Qgc2lnbmVkUGF5bG9hZCA9IGNvbnRyYWN0LmVyYzIwLnNpZ25hdHVyZSgpLmdlbmVyYXRlKHBheWxvYWQpO1xuICAgKlxuICAgKiAvLyBub3cgdGhlIHBheWxvYWQgY2FuIGJlIHVzZWQgdG8gbWludCB0b2tlbnNcbiAgICogY29uc3QgdHggPSBjb250cmFjdC5lcmMyMC5zaWduYXR1cmUubWludChzaWduZWRQYXlsb2FkKTtcbiAgICogYGBgXG4gICAqIEB0d2ZlYXR1cmUgRVJDMjBTaWduYXR1cmVNaW50YWJsZVxuICAgKi9cbiAgZ2V0IHNpZ25hdHVyZSgpIHtcbiAgICByZXR1cm4gYXNzZXJ0RW5hYmxlZCh0aGlzLnNpZ25hdHVyZU1pbnRhYmxlLCBGRUFUVVJFX1RPS0VOX1NJR05BVFVSRV9NSU5UQUJMRSk7XG4gIH1cblxuICAvKiogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIFBSSVZBVEUgRlVOQ1RJT05TXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSB3ZWkgYW1vdW50IGZyb20gYSB0b2tlbiBhbW91bnRcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSBhbW91bnRcbiAgICovXG4gIGFzeW5jIG5vcm1hbGl6ZUFtb3VudChhbW91bnQpIHtcbiAgICBjb25zdCBkZWNpbWFscyA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5kZWNpbWFscygpO1xuICAgIHJldHVybiBldGhlcnMudXRpbHMucGFyc2VVbml0cyhBbW91bnRTY2hlbWEucGFyc2UoYW1vdW50KSwgZGVjaW1hbHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgZ2V0VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gYXdhaXQgZmV0Y2hDdXJyZW5jeVZhbHVlKHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFByb3ZpZGVyKCksIHRoaXMuZ2V0QWRkcmVzcygpLCBCaWdOdW1iZXIuZnJvbSh2YWx1ZSkpO1xuICB9XG4gIGRldGVjdEVyYzIwTWludGFibGUoKSB7XG4gICAgaWYgKGRldGVjdENvbnRyYWN0RmVhdHVyZSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgXCJFUkMyMFwiKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcmMyME1pbnRhYmxlKHRoaXMsIHRoaXMuY29udHJhY3RXcmFwcGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBkZXRlY3RFcmMyMEJ1cm5hYmxlKCkge1xuICAgIGlmIChkZXRlY3RDb250cmFjdEZlYXR1cmUodGhpcy5jb250cmFjdFdyYXBwZXIsIFwiRVJDMjBCdXJuYWJsZVwiKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcmMyMEJ1cm5hYmxlKHRoaXMsIHRoaXMuY29udHJhY3RXcmFwcGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBkZXRlY3RFcmMyMERyb3BwYWJsZSgpIHtcbiAgICBpZiAoZGV0ZWN0Q29udHJhY3RGZWF0dXJlKHRoaXMuY29udHJhY3RXcmFwcGVyLCBcIkVSQzIwQ2xhaW1Db25kaXRpb25zVjFcIikgfHwgZGV0ZWN0Q29udHJhY3RGZWF0dXJlKHRoaXMuY29udHJhY3RXcmFwcGVyLCBcIkVSQzIwQ2xhaW1Db25kaXRpb25zVjJcIikgfHwgZGV0ZWN0Q29udHJhY3RGZWF0dXJlKHRoaXMuY29udHJhY3RXcmFwcGVyLCBcIkVSQzIwQ2xhaW1QaGFzZXNWMVwiKSB8fCBkZXRlY3RDb250cmFjdEZlYXR1cmUodGhpcy5jb250cmFjdFdyYXBwZXIsIFwiRVJDMjBDbGFpbVBoYXNlc1YyXCIpKSB7XG4gICAgICByZXR1cm4gbmV3IEVyYzIwRHJvcHBhYmxlKHRoaXMsIHRoaXMuY29udHJhY3RXcmFwcGVyLCB0aGlzLnN0b3JhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGRldGVjdEVyYzIwU2lnbmF0dXJlTWludGFibGUoKSB7XG4gICAgaWYgKGRldGVjdENvbnRyYWN0RmVhdHVyZSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgXCJFUkMyMFNpZ25hdHVyZU1pbnRhYmxlXCIpKSB7XG4gICAgICByZXR1cm4gbmV3IEVyYzIwU2lnbmF0dXJlTWludGFibGUodGhpcy5jb250cmFjdFdyYXBwZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogTWFuYWdlcyBoaXN0b3J5IGZvciBUb2tlbiBjb250cmFjdHNcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgVG9rZW5FUkMyMEhpc3Rvcnkge1xuICBjb25zdHJ1Y3Rvcihjb250cmFjdFdyYXBwZXIsIGV2ZW50cykge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV2ZW50c1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRyYWN0V3JhcHBlclwiLCB2b2lkIDApO1xuICAgIHRoaXMuY29udHJhY3RXcmFwcGVyID0gY29udHJhY3RXcmFwcGVyO1xuICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgaG9sZGVyIGJhbGFuY2VzXG4gICAqXG4gICAqIEByZW1hcmtzIExldHMgeW91IGdldCBhbGwgdG9rZW4gaG9sZGVycyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBiYWxhbmNlc1xuICAgKiBAcmV0dXJucyAtIEEgSlNPTiBvYmplY3Qgb2YgYWxsIHRva2VuIGhvbGRlcnMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgYmFsYW5jZXNcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBhbGxIb2xkZXJCYWxhbmNlcyA9IGF3YWl0IGNvbnRyYWN0Lmhpc3RvcnkuZ2V0QWxsSG9sZGVyQmFsYW5jZXMoKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBnZXRBbGxIb2xkZXJCYWxhbmNlcygpIHtcbiAgICBjb25zdCBhID0gYXdhaXQgdGhpcy5ldmVudHMuZ2V0RXZlbnRzKFwiVHJhbnNmZXJcIik7XG4gICAgY29uc3QgdHhucyA9IGEubWFwKGIgPT4gYi5kYXRhKTtcbiAgICBjb25zdCBiYWxhbmNlcyA9IHt9O1xuICAgIHR4bnMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGNvbnN0IGZyb20gPSBpdGVtPy5mcm9tO1xuICAgICAgY29uc3QgdG8gPSBpdGVtPy50bztcbiAgICAgIGNvbnN0IGFtb3VudCA9IGl0ZW0/LnZhbHVlO1xuICAgICAgaWYgKCEoZnJvbSA9PT0gY29uc3RhbnRzLkFkZHJlc3NaZXJvKSkge1xuICAgICAgICBpZiAoIShmcm9tIGluIGJhbGFuY2VzKSkge1xuICAgICAgICAgIGJhbGFuY2VzW2Zyb21dID0gQmlnTnVtYmVyLmZyb20oMCk7XG4gICAgICAgIH1cbiAgICAgICAgYmFsYW5jZXNbZnJvbV0gPSBiYWxhbmNlc1tmcm9tXS5zdWIoYW1vdW50KTtcbiAgICAgIH1cbiAgICAgIGlmICghKHRvID09PSBjb25zdGFudHMuQWRkcmVzc1plcm8pKSB7XG4gICAgICAgIGlmICghKHRvIGluIGJhbGFuY2VzKSkge1xuICAgICAgICAgIGJhbGFuY2VzW3RvXSA9IEJpZ051bWJlci5mcm9tKDApO1xuICAgICAgICB9XG4gICAgICAgIGJhbGFuY2VzW3RvXSA9IGJhbGFuY2VzW3RvXS5hZGQoYW1vdW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoT2JqZWN0LmtleXMoYmFsYW5jZXMpLm1hcChhc3luYyBhZGRyID0+ICh7XG4gICAgICBob2xkZXI6IGFkZHIsXG4gICAgICBiYWxhbmNlOiBhd2FpdCBmZXRjaEN1cnJlbmN5VmFsdWUodGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJvdmlkZXIoKSwgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmFkZHJlc3MsIGJhbGFuY2VzW2FkZHJdKVxuICAgIH0pKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTdGFuZGFyZCBFUkMyMCBUb2tlbiBmdW5jdGlvbnNcbiAqIEByZW1hcmtzIEJhc2ljIGZ1bmN0aW9uYWxpdHkgZm9yIGEgRVJDMjAgY29udHJhY3QgdGhhdCBoYW5kbGVzIGFsbCB1bml0IHRyYW5zZm9ybWF0aW9uIGZvciB5b3UuXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgY29udHJhY3QgPSBhd2FpdCBzZGsuZ2V0Q29udHJhY3QoXCJ7e2NvbnRyYWN0X2FkZHJlc3N9fVwiKTtcbiAqIGF3YWl0IGNvbnRyYWN0LnRva2VuLnRyYW5zZmVyKHdhbGxldEFkZHJlc3MsIGFtb3VudCk7XG4gKiBgYGBcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgU3RhbmRhcmRFcmMyMCB7XG4gIGdldCBjaGFpbklkKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFpbklkO1xuICB9XG4gIGNvbnN0cnVjdG9yKGNvbnRyYWN0V3JhcHBlciwgc3RvcmFnZSwgY2hhaW5JZCkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRyYWN0V3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3JhZ2VcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlcmMyMFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jaGFpbklkXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIgPSBjb250cmFjdFdyYXBwZXI7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICB0aGlzLmVyYzIwID0gbmV3IEVyYzIwKHRoaXMuY29udHJhY3RXcmFwcGVyLCB0aGlzLnN0b3JhZ2UsIGNoYWluSWQpO1xuICAgIHRoaXMuX2NoYWluSWQgPSBjaGFpbklkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb25OZXR3b3JrVXBkYXRlZChuZXR3b3JrKSB7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIudXBkYXRlU2lnbmVyT3JQcm92aWRlcihuZXR3b3JrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldEFkZHJlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5hZGRyZXNzO1xuICB9XG5cbiAgLyoqICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBSRUFEIEZVTkNUSU9OU1xuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKipcbiAgICogR2V0IHRoZSB0b2tlbiBNZXRhZGF0YSAobmFtZSwgc3ltYm9sLCBldGMuLi4pXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBjb250cmFjdC5nZXQoKTtcbiAgICogYGBgXG4gICAqIEByZXR1cm5zIFRoZSB0b2tlbiBtZXRhZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLmVyYzIwLmdldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBUb2tlbiBCYWxhbmNlIGZvciB0aGUgY3VycmVudGx5IGNvbm5lY3RlZCB3YWxsZXRcbiAgICpcbiAgICogQHJlbWFya3MgR2V0IGEgd2FsbGV0cyB0b2tlbiBiYWxhbmNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjb250cmFjdC5iYWxhbmNlKCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgYmFsYW5jZSBvZiBhIHNwZWNpZmljIHdhbGxldC5cbiAgICovXG4gIGFzeW5jIGJhbGFuY2UoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZXJjMjAuYmFsYW5jZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBUb2tlbiBCYWxhbmNlXG4gICAqXG4gICAqIEByZW1hcmtzIEdldCBhIHdhbGxldHMgdG9rZW4gYmFsYW5jZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBBZGRyZXNzIG9mIHRoZSB3YWxsZXQgdG8gY2hlY2sgdG9rZW4gYmFsYW5jZVxuICAgKiBjb25zdCB3YWxsZXRBZGRyZXNzID0gXCJ7e3dhbGxldF9hZGRyZXNzfX1cIjtcbiAgICogY29uc3QgYmFsYW5jZSA9IGF3YWl0IGNvbnRyYWN0LmJhbGFuY2VPZih3YWxsZXRBZGRyZXNzKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBiYWxhbmNlIG9mIGEgc3BlY2lmaWMgd2FsbGV0LlxuICAgKi9cbiAgYXN5bmMgYmFsYW5jZU9mKGFkZHJlc3MpIHtcbiAgICByZXR1cm4gdGhpcy5lcmMyMC5iYWxhbmNlT2YoYWRkcmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRvdGFsIHN1cHBseSBmb3IgdGhpcyBUb2tlblxuICAgKiBAcmVtYXJrcyBHZXQgaG93IG11Y2ggc3VwcGx5IGhhcyBiZWVuIG1pbnRlZFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjb250cmFjdC50b3RhbFN1cHBseSgpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHRvdGFsU3VwcGx5KCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmVyYzIwLnRvdGFsU3VwcGx5KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IFRva2VuIEFsbG93YW5jZVxuICAgKlxuICAgKiBAcmVtYXJrcyBHZXQgdGhlIGFsbG93YW5jZSBvZiBhICdzcGVuZGVyJyB3YWxsZXQgb3ZlciB0aGUgY29ubmVjdGVkIHdhbGxldCdzIGZ1bmRzIC0gdGhlIGFsbG93YW5jZSBvZiBhIGRpZmZlcmVudCBhZGRyZXNzIGZvciBhIHRva2VuIGlzIHRoZSBhbW91bnQgb2YgdG9rZW5zIHRoYXQgdGhlIGBzcGVuZGVyYCB3YWxsZXQgaXMgYWxsb3dlZCB0byBzcGVuZCBvbiBiZWhhbGYgb2YgdGhlIGNvbm5lY3RlZCB3YWxsZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gQWRkcmVzcyBvZiB0aGUgd2FsbGV0IHRvIGNoZWNrIHRva2VuIGFsbG93YW5jZVxuICAgKiBjb25zdCBzcGVuZGVyQWRkcmVzcyA9IFwiMHguLi5cIjtcbiAgICogY29uc3QgYWxsb3dhbmNlID0gYXdhaXQgY29udHJhY3QuYWxsb3dhbmNlKHNwZW5kZXJBZGRyZXNzKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBhbGxvd2FuY2Ugb2Ygb25lIHdhbGxldCBvdmVyIGFub3RoZXJzIGZ1bmRzLlxuICAgKi9cbiAgYXN5bmMgYWxsb3dhbmNlKHNwZW5kZXIpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5lcmMyMC5hbGxvd2FuY2Uoc3BlbmRlcik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IFRva2VuIEFsbG93YW5jZVxuICAgKlxuICAgKiBAcmVtYXJrcyBHZXQgdGhlIGFsbG93YW5jZSBvZiBvbmUgd2FsbGV0IG92ZXIgYW5vdGhlciB3YWxsZXQncyBmdW5kcyAtIHRoZSBhbGxvd2FuY2Ugb2YgYSBkaWZmZXJlbnQgYWRkcmVzcyBmb3IgYSB0b2tlbiBpcyB0aGUgYW1vdW50IG9mIHRva2VucyB0aGF0IHRoZSB3YWxsZXQgaXMgYWxsb3dlZCB0byBzcGVuZCBvbiBiZWhhbGYgb2YgdGhlIHNwZWNpZmllZCB3YWxsZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gQWRkcmVzcyBvZiB0aGUgd2FsbGV0IHdobyBvd25zIHRoZSBmdW5kc1xuICAgKiBjb25zdCBvd25lciA9IFwie3t3YWxsZXRfYWRkcmVzc319XCI7XG4gICAqIC8vIEFkZHJlc3Mgb2YgdGhlIHdhbGxldCB0byBjaGVjayB0b2tlbiBhbGxvd2FuY2VcbiAgICogY29uc3Qgc3BlbmRlciA9IFwiMHguLi5cIjtcbiAgICogY29uc3QgYWxsb3dhbmNlID0gYXdhaXQgY29udHJhY3QuYWxsb3dhbmNlT2Yob3duZXIsIHNwZW5kZXIpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybnMgVGhlIGFsbG93YW5jZSBvZiBvbmUgd2FsbGV0IG92ZXIgYW5vdGhlcnMgZnVuZHMuXG4gICAqL1xuICBhc3luYyBhbGxvd2FuY2VPZihvd25lciwgc3BlbmRlcikge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmVyYzIwLmFsbG93YW5jZU9mKG93bmVyLCBzcGVuZGVyKTtcbiAgfVxuXG4gIC8qKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICogV1JJVEUgRlVOQ1RJT05TXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiBUcmFuc2ZlciBUb2tlbnNcbiAgICpcbiAgICogQHJlbWFya3MgVHJhbnNmZXIgdG9rZW5zIGZyb20gdGhlIGNvbm5lY3RlZCB3YWxsZXQgdG8gYW5vdGhlciB3YWxsZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gQWRkcmVzcyBvZiB0aGUgd2FsbGV0IHlvdSB3YW50IHRvIHNlbmQgdGhlIHRva2VucyB0b1xuICAgKiBjb25zdCB0b0FkZHJlc3MgPSBcIjB4Li4uXCI7XG4gICAqIC8vIFRoZSBhbW91bnQgb2YgdG9rZW5zIHlvdSB3YW50IHRvIHNlbmRcbiAgICogY29uc3QgYW1vdW50ID0gMC4xO1xuICAgKiBhd2FpdCBjb250cmFjdC50cmFuc2Zlcih0b0FkZHJlc3MsIGFtb3VudCk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgdHJhbnNmZXIodG8sIGFtb3VudCkge1xuICAgIHJldHVybiB0aGlzLmVyYzIwLnRyYW5zZmVyKHRvLCBhbW91bnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZmVyIFRva2VucyBGcm9tIEFkZHJlc3NcbiAgICpcbiAgICogQHJlbWFya3MgVHJhbnNmZXIgdG9rZW5zIGZyb20gb25lIHdhbGxldCB0byBhbm90aGVyXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gQWRkcmVzcyBvZiB0aGUgd2FsbGV0IHNlbmRpbmcgdGhlIHRva2Vuc1xuICAgKiBjb25zdCBmcm9tQWRkcmVzcyA9IFwie3t3YWxsZXRfYWRkcmVzc319XCI7XG4gICAqIC8vIEFkZHJlc3Mgb2YgdGhlIHdhbGxldCB5b3Ugd2FudCB0byBzZW5kIHRoZSB0b2tlbnMgdG9cbiAgICogY29uc3QgdG9BZGRyZXNzID0gXCIweC4uLlwiO1xuICAgKiAvLyBUaGUgbnVtYmVyIG9mIHRva2VucyB5b3Ugd2FudCB0byBzZW5kXG4gICAqIGNvbnN0IGFtb3VudCA9IDEuMlxuICAgKiAvLyBOb3RlIHRoYXQgdGhlIGNvbm5lY3RlZCB3YWxsZXQgbXVzdCBoYXZlIGFwcHJvdmFsIHRvIHRyYW5zZmVyIHRoZSB0b2tlbnMgb2YgdGhlIGZyb21BZGRyZXNzXG4gICAqIGF3YWl0IGNvbnRyYWN0LnRyYW5zZmVyRnJvbShmcm9tQWRkcmVzcywgdG9BZGRyZXNzLCBhbW91bnQpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHRyYW5zZmVyRnJvbShmcm9tLCB0bywgYW1vdW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZXJjMjAudHJhbnNmZXJGcm9tKGZyb20sIHRvLCBhbW91bnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgc3BlY2lmaWVkIGBzcGVuZGVyYCB3YWxsZXQgdG8gdHJhbnNmZXIgdGhlIGdpdmVuIGBhbW91bnRgIG9mIHRva2VucyB0byBhbm90aGVyIHdhbGxldFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIEFkZHJlc3Mgb2YgdGhlIHdhbGxldCB0byBhbGxvdyB0cmFuc2ZlcnMgZnJvbVxuICAgKiBjb25zdCBzcGVuZGVyQWRkcmVzcyA9IFwiMHguLi5cIjtcbiAgICogLy8gVGhlIG51bWJlciBvZiB0b2tlbnMgdG8gZ2l2ZSBhcyBhbGxvd2FuY2VcbiAgICogY29uc3QgYW1vdW50ID0gMTAwXG4gICAqIGF3YWl0IGNvbnRyYWN0LnNldEFsbG93YW5jZShzcGVuZGVyQWRkcmVzcywgYW1vdW50KTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBzZXRBbGxvd2FuY2Uoc3BlbmRlciwgYW1vdW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZXJjMjAuc2V0QWxsb3dhbmNlKHNwZW5kZXIsIGFtb3VudCk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmZXIgVG9rZW5zIFRvIE1hbnkgV2FsbGV0c1xuICAgKlxuICAgKiBAcmVtYXJrcyBNaW50IHRva2VucyBmcm9tIHRoZSBjb25uZWN0ZWQgd2FsbGV0IHRvIG1hbnkgd2FsbGV0c1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIERhdGEgb2YgdGhlIHRva2VucyB5b3Ugd2FudCB0byBtaW50XG4gICAqIGNvbnN0IGRhdGEgPSBbXG4gICAqICAge1xuICAgKiAgICAgdG9BZGRyZXNzOiBcInt7d2FsbGV0X2FkZHJlc3N9fVwiLCAvLyBBZGRyZXNzIHRvIG1pbnQgdG9rZW5zIHRvXG4gICAqICAgICBhbW91bnQ6IDEwMCwgLy8gSG93IG1hbnkgdG9rZW5zIHRvIG1pbnQgdG8gc3BlY2lmaWVkIGFkZHJlc3NcbiAgICogICB9LFxuICAgKiAge1xuICAgKiAgICB0b0FkZHJlc3M6IFwiMHguLi5cIixcbiAgICogICAgYW1vdW50OiAxMDAsXG4gICAqICB9XG4gICAqIF1cbiAgICpcbiAgICogYXdhaXQgY29udHJhY3QudHJhbnNmZXJCYXRjaChkYXRhKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyB0cmFuc2ZlckJhdGNoKGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5lcmMyMC50cmFuc2ZlckJhdGNoKGFyZ3MpO1xuICB9XG59XG5cbmNsYXNzIEVyYzcyMUJ1cm5hYmxlIHtcbiAgY29uc3RydWN0b3IoY29udHJhY3RXcmFwcGVyKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZmVhdHVyZU5hbWVcIiwgRkVBVFVSRV9ORlRfQlVSTkFCTEUubmFtZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIgPSBjb250cmFjdFdyYXBwZXI7XG4gIH1cblxuICAvKipcbiAgICogQnVybiBORlRzXG4gICAqXG4gICAqIEByZW1hcmtzIEJ1cm4gTkZUcyBoZWxkIGJ5IHRoZSBjb25uZWN0ZWQgd2FsbGV0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gVGhlIHRva2VuIElEIG9mIHRoZSBORlQgeW91IHdhbnQgdG8gYnVyblxuICAgKiBjb25zdCB0b2tlbklkID0gMDtcbiAgICpcbiAgICogYXdhaXQgY29udHJhY3QubmZ0LmJ1cm4udG9rZW4odG9rZW5JZCk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgdG9rZW4odG9rZW5JZCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWNlaXB0OiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJidXJuXCIsIFt0b2tlbklkXSlcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ29uZmlndXJlIGFuZCBjbGFpbSBFUkM3MjEgTkZUc1xuICogQHJlbWFya3MgTWFuYWdlIGNsYWltIHBoYXNlcyBhbmQgY2xhaW0gRVJDNzIxIE5GVHMgdGhhdCBoYXZlIGJlZW4gbGF6aWx5IG1pbnRlZC5cbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBjb250cmFjdCA9IGF3YWl0IHNkay5nZXRDb250cmFjdChcInt7Y29udHJhY3RfYWRkcmVzc319XCIpO1xuICogYXdhaXQgY29udHJhY3QuZXJjNzIxLmNsYWltKHRva2VuSWQsIHF1YW50aXR5KTtcbiAqIGBgYFxuICovXG5jbGFzcyBFcmM3MjFDbGFpbWFibGUge1xuICBjb25zdHJ1Y3RvcihlcmM3MjEsIGNvbnRyYWN0V3JhcHBlcikge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZlYXR1cmVOYW1lXCIsIEZFQVRVUkVfTkZUX0NMQUlNX0NVU1RPTS5uYW1lKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlcmM3MjFcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250cmFjdFdyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmVyYzcyMSA9IGVyYzcyMTtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlciA9IGNvbnRyYWN0V3JhcHBlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBjbGFpbSB0cmFuc2FjdGlvbiB3aXRob3V0IGV4ZWN1dGluZyBpdC5cbiAgICogVGhpcyBpcyB1c2VmdWwgZm9yIGVzdGltYXRpbmcgdGhlIGdhcyBjb3N0IG9mIGEgY2xhaW0gdHJhbnNhY3Rpb24sIG92ZXJyaWRpbmcgdHJhbnNhY3Rpb24gb3B0aW9ucyBhbmQgaGF2aW5nIGZpbmUgZ3JhaW5lZCBjb250cm9sIG92ZXIgdGhlIHRyYW5zYWN0aW9uIGV4ZWN1dGlvbi5cbiAgICogQHBhcmFtIGRlc3RpbmF0aW9uQWRkcmVzcyAtIEFkZHJlc3MgeW91IHdhbnQgdG8gc2VuZCB0aGUgdG9rZW4gdG9cbiAgICogQHBhcmFtIHRva2VuSWQgLSBJZCBvZiB0aGUgdG9rZW4geW91IHdhbnQgdG8gY2xhaW1cbiAgICogQHBhcmFtIHF1YW50aXR5IC0gUXVhbnRpdHkgb2YgdGhlIHRva2VucyB5b3Ugd2FudCB0byBjbGFpbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGNsYWltaW5nIHRoZSBORlRzXG4gICAqL1xuICBhc3luYyBnZXRDbGFpbVRyYW5zYWN0aW9uKGRlc3RpbmF0aW9uQWRkcmVzcywgcXVhbnRpdHksIG9wdGlvbnMpIHtcbiAgICBsZXQgb3ZlcnJpZGVzID0ge307XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wcmljZVBlclRva2VuKSB7XG4gICAgICBvdmVycmlkZXMgPSBhd2FpdCBjYWxjdWxhdGVDbGFpbUNvc3QodGhpcy5jb250cmFjdFdyYXBwZXIsIG9wdGlvbnMucHJpY2VQZXJUb2tlbiwgcXVhbnRpdHksIG9wdGlvbnMuY3VycmVuY3lBZGRyZXNzLCBvcHRpb25zLmNoZWNrRVJDMjBBbGxvd2FuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gVHJhbnNhY3Rpb25UYXNrLm1ha2Uoe1xuICAgICAgY29udHJhY3RXcmFwcGVyOiB0aGlzLmNvbnRyYWN0V3JhcHBlcixcbiAgICAgIGZ1bmN0aW9uTmFtZTogXCJjbGFpbVwiLFxuICAgICAgYXJnczogW2Rlc3RpbmF0aW9uQWRkcmVzcywgcXVhbnRpdHldLFxuICAgICAgb3ZlcnJpZGVzXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xhaW0gTkZUcyB0byBhIHNwZWNpZmljIFdhbGxldFxuICAgKlxuICAgKiBAcmVtYXJrcyBMZXQgdGhlIHNwZWNpZmllZCB3YWxsZXQgY2xhaW0gTkZUcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBhZGRyZXNzID0gXCJ7e3dhbGxldF9hZGRyZXNzfX1cIjsgLy8gYWRkcmVzcyBvZiB0aGUgd2FsbGV0IHlvdSB3YW50IHRvIGNsYWltIHRoZSBORlRzXG4gICAqIGNvbnN0IHRva2VuSWQgPSAwOyAvLyB0aGUgaWQgb2YgdGhlIE5GVCB5b3Ugd2FudCB0byBjbGFpbVxuICAgKiBjb25zdCBxdWFudGl0eSA9IDE7IC8vIGhvdyBtYW55IE5GVHMgeW91IHdhbnQgdG8gY2xhaW1cbiAgICpcbiAgICogY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5lcmM3MjEuY2xhaW1UbyhhZGRyZXNzLCB0b2tlbklkLCBxdWFudGl0eSk7XG4gICAqIGNvbnN0IHJlY2VpcHQgPSB0eFswXS5yZWNlaXB0OyAvLyB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdFxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGRlc3RpbmF0aW9uQWRkcmVzcyAtIEFkZHJlc3MgeW91IHdhbnQgdG8gc2VuZCB0aGUgdG9rZW4gdG9cbiAgICogQHBhcmFtIHF1YW50aXR5IC0gUXVhbnRpdHkgb2YgdGhlIHRva2VucyB5b3Ugd2FudCB0byBjbGFpbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGNsYWltaW5nIHRoZSBORlRzXG4gICAqXG4gICAqIEByZXR1cm5zIC0gUmVjZWlwdCBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBhc3luYyB0byhkZXN0aW5hdGlvbkFkZHJlc3MsIHF1YW50aXR5LCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGFzayA9IGF3YWl0IHRoaXMuZ2V0Q2xhaW1UcmFuc2FjdGlvbihkZXN0aW5hdGlvbkFkZHJlc3MsIHF1YW50aXR5LCBvcHRpb25zKTtcbiAgICBjb25zdCB7XG4gICAgICByZWNlaXB0XG4gICAgfSA9IGF3YWl0IHRhc2suZXhlY3V0ZSgpO1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5jb250cmFjdFdyYXBwZXIucGFyc2VMb2dzKFwiVG9rZW5zQ2xhaW1lZFwiLCByZWNlaXB0Py5sb2dzKTtcbiAgICBjb25zdCBzdGFydGluZ0luZGV4ID0gZXZlbnRbMF0uYXJncy5zdGFydFRva2VuSWQ7XG4gICAgY29uc3QgZW5kaW5nSW5kZXggPSBzdGFydGluZ0luZGV4LmFkZChxdWFudGl0eSk7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAobGV0IGlkID0gc3RhcnRpbmdJbmRleDsgaWQubHQoZW5kaW5nSW5kZXgpOyBpZCA9IGlkLmFkZCgxKSkge1xuICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIHJlY2VpcHQsXG4gICAgICAgIGRhdGE6ICgpID0+IHRoaXMuZXJjNzIxLmdldChpZClcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxufVxuXG4vKipcbiAqIENvbmZpZ3VyZSBhbmQgY2xhaW0gRVJDNzIxIE5GVHNcbiAqIEByZW1hcmtzIE1hbmFnZSBjbGFpbSBwaGFzZXMgYW5kIGNsYWltIEVSQzcyMSBORlRzIHRoYXQgaGF2ZSBiZWVuIGxhemlseSBtaW50ZWQuXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgY29udHJhY3QgPSBhd2FpdCBzZGsuZ2V0Q29udHJhY3QoXCJ7e2NvbnRyYWN0X2FkZHJlc3N9fVwiKTtcbiAqIGF3YWl0IGNvbnRyYWN0LmVyYzcyMS5jbGFpbShxdWFudGl0eSk7XG4gKiBhd2FpdCBjb250cmFjdC5lcmM3MjEuY2xhaW1Db25kaXRpb25zLmdldEFjdGl2ZSgpO1xuICogYGBgXG4gKi9cbmNsYXNzIEVyYzcyMUNsYWltYWJsZVdpdGhDb25kaXRpb25zIHtcbiAgLyoqXG4gICAqIENvbmZpZ3VyZSBjbGFpbSBjb25kaXRpb25zXG4gICAqIEByZW1hcmtzIERlZmluZSB3aG8gY2FuIGNsYWltIE5GVHMgaW4gdGhlIGNvbGxlY3Rpb24sIHdoZW4gYW5kIGhvdyBtYW55LlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IHByZXNhbGVTdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgKiBjb25zdCBwdWJsaWNTYWxlU3RhcnRUaW1lID0gbmV3IERhdGUoRGF0ZS5ub3coKSArIDYwICogNjAgKiAyNCAqIDEwMDApO1xuICAgKiBjb25zdCBjbGFpbUNvbmRpdGlvbnMgPSBbXG4gICAqICAge1xuICAgKiAgICAgc3RhcnRUaW1lOiBwcmVzYWxlU3RhcnRUaW1lLCAvLyBzdGFydCB0aGUgcHJlc2FsZSBub3dcbiAgICogICAgIG1heFF1YW50aXR5OiAyLCAvLyBsaW1pdCBob3cgbWFueSBtaW50cyBmb3IgdGhpcyBwcmVzYWxlXG4gICAqICAgICBwcmljZTogMC4wMSwgLy8gcHJlc2FsZSBwcmljZVxuICAgKiAgICAgc25hcHNob3Q6IFsnMHguLi4nLCAnMHguLi4nXSwgLy8gbGltaXQgbWludGluZyB0byBvbmx5IGNlcnRhaW4gYWRkcmVzc2VzXG4gICAqICAgfSxcbiAgICogICB7XG4gICAqICAgICBzdGFydFRpbWU6IHB1YmxpY1NhbGVTdGFydFRpbWUsIC8vIDI0aCBhZnRlciBwcmVzYWxlLCBzdGFydCBwdWJsaWMgc2FsZVxuICAgKiAgICAgcHJpY2U6IDAuMDgsIC8vIHB1YmxpYyBzYWxlIHByaWNlXG4gICAqICAgfVxuICAgKiBdKTtcbiAgICogYXdhaXQgY29udHJhY3QuZXJjNzIxLmNsYWltQ29uZGl0aW9ucy5zZXQoY2xhaW1Db25kaXRpb25zKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKGVyYzcyMSwgY29udHJhY3RXcmFwcGVyLCBzdG9yYWdlKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZmVhdHVyZU5hbWVcIiwgRkVBVFVSRV9ORlRfQ0xBSU1fQ09ORElUSU9OU19WMi5uYW1lKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25kaXRpb25zXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZXJjNzIxXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcmFnZVwiLCB2b2lkIDApO1xuICAgIHRoaXMuZXJjNzIxID0gZXJjNzIxO1xuICAgIHRoaXMuY29udHJhY3RXcmFwcGVyID0gY29udHJhY3RXcmFwcGVyO1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBuZXcgQ29udHJhY3RNZXRhZGF0YSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgQ3VzdG9tQ29udHJhY3RTY2hlbWEsIHRoaXMuc3RvcmFnZSk7XG4gICAgdGhpcy5jb25kaXRpb25zID0gbmV3IERyb3BDbGFpbUNvbmRpdGlvbnModGhpcy5jb250cmFjdFdyYXBwZXIsIG1ldGFkYXRhLCB0aGlzLnN0b3JhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsYWltIHVuaXF1ZSBORlRzIHRvIGEgc3BlY2lmaWMgV2FsbGV0XG4gICAqXG4gICAqIEByZW1hcmtzIExldCB0aGUgc3BlY2lmaWVkIHdhbGxldCBjbGFpbSBORlRzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IGFkZHJlc3MgPSBcInt7d2FsbGV0X2FkZHJlc3N9fVwiOyAvLyBhZGRyZXNzIG9mIHRoZSB3YWxsZXQgeW91IHdhbnQgdG8gY2xhaW0gdGhlIE5GVHNcbiAgICogY29uc3QgcXVhbnRpdHkgPSAxOyAvLyBob3cgbWFueSB1bmlxdWUgTkZUcyB5b3Ugd2FudCB0byBjbGFpbVxuICAgKlxuICAgKiBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmVyYzcyMS5jbGFpbVRvKGFkZHJlc3MsIHF1YW50aXR5KTtcbiAgICogY29uc3QgcmVjZWlwdCA9IHR4WzBdLnJlY2VpcHQ7IC8vIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0XG4gICAqIGNvbnN0IGNsYWltZWRUb2tlbklkID0gdHhbMF0uaWQ7IC8vIHRoZSBpZCBvZiB0aGUgZmlyc3QgTkZUIGNsYWltZWRcbiAgICogY29uc3QgY2xhaW1lZE5GVCA9IGF3YWl0IHR4WzBdLmRhdGEoKTsgLy8gKG9wdGlvbmFsKSBnZXQgdGhlIGZpcnN0IGNsYWltZWQgTkZUIG1ldGFkYXRhXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gZGVzdGluYXRpb25BZGRyZXNzIC0gQWRkcmVzcyB5b3Ugd2FudCB0byBzZW5kIHRoZSB0b2tlbiB0b1xuICAgKiBAcGFyYW0gcXVhbnRpdHkgLSBRdWFudGl0eSBvZiB0aGUgdG9rZW5zIHlvdSB3YW50IHRvIGNsYWltXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEByZXR1cm5zIC0gYW4gYXJyYXkgb2YgcmVzdWx0cyBjb250YWluaW5nIHRoZSBpZCBvZiB0aGUgdG9rZW4gY2xhaW1lZCwgdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHQgYW5kIGEgcHJvbWlzZSB0byBvcHRpb25hbGx5IGZldGNoIHRoZSBuZnQgbWV0YWRhdGFcbiAgICovXG4gIGFzeW5jIHRvKGRlc3RpbmF0aW9uQWRkcmVzcywgcXVhbnRpdHksIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0YXNrID0gYXdhaXQgdGhpcy5jb25kaXRpb25zLmdldENsYWltVHJhbnNhY3Rpb24oZGVzdGluYXRpb25BZGRyZXNzLCBxdWFudGl0eSwgb3B0aW9ucyk7XG4gICAgY29uc3Qge1xuICAgICAgcmVjZWlwdFxuICAgIH0gPSBhd2FpdCB0YXNrLmV4ZWN1dGUoKTtcbiAgICBjb25zdCBldmVudCA9IHRoaXMuY29udHJhY3RXcmFwcGVyLnBhcnNlTG9ncyhcIlRva2Vuc0NsYWltZWRcIiwgcmVjZWlwdD8ubG9ncyk7XG4gICAgY29uc3Qgc3RhcnRpbmdJbmRleCA9IGV2ZW50WzBdLmFyZ3Muc3RhcnRUb2tlbklkO1xuICAgIGNvbnN0IGVuZGluZ0luZGV4ID0gc3RhcnRpbmdJbmRleC5hZGQocXVhbnRpdHkpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpZCA9IHN0YXJ0aW5nSW5kZXg7IGlkLmx0KGVuZGluZ0luZGV4KTsgaWQgPSBpZC5hZGQoMSkpIHtcbiAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgIGlkLFxuICAgICAgICByZWNlaXB0LFxuICAgICAgICBkYXRhOiAoKSA9PiB0aGlzLmVyYzcyMS5nZXQoaWQpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbn1cblxuLyoqXG4gKiBMYXppbHkgbWludCBhbmQgY2xhaW0gRVJDNzIxIE5GVHNcbiAqIEByZW1hcmtzIE1hbmFnZSBjbGFpbSBwaGFzZXMgYW5kIGNsYWltIEVSQzcyMSBORlRzIHRoYXQgaGF2ZSBiZWVuIGxhemlseSBtaW50ZWQuXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgY29udHJhY3QgPSBhd2FpdCBzZGsuZ2V0Q29udHJhY3QoXCJ7e2NvbnRyYWN0X2FkZHJlc3N9fVwiKTtcbiAqIGF3YWl0IGNvbnRyYWN0LmRyb3AuY2xhaW0ocXVhbnRpdHkpO1xuICogYGBgXG4gKi9cbmNsYXNzIEVyYzcyMUxhenlNaW50YWJsZSB7XG4gIC8qKlxuICAgKiBEZWxheWVkIHJldmVhbFxuICAgKiBAcmVtYXJrcyBDcmVhdGUgYSBiYXRjaCBvZiBlbmNyeXB0ZWQgTkZUcyB0aGF0IGNhbiBiZSByZXZlYWxlZCBhdCBhIGxhdGVyIHRpbWUuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gdGhlIHJlYWwgTkZUcywgdGhlc2Ugd2lsbCBiZSBlbmNyeXB0ZWQgdW50aWwgeW91IHJldmVhbCB0aGVtXG4gICAqIGNvbnN0IHJlYWxORlRzID0gW3tcbiAgICogICBuYW1lOiBcIkNvbW1vbiBORlQgIzFcIixcbiAgICogICBkZXNjcmlwdGlvbjogXCJDb21tb24gTkZULCBvbmUgb2YgbWFueS5cIixcbiAgICogICBpbWFnZTogZnMucmVhZEZpbGVTeW5jKFwicGF0aC90by9pbWFnZS5wbmdcIiksXG4gICAqIH0sIHtcbiAgICogICBuYW1lOiBcIlN1cGVyIFJhcmUgTkZUICMyXCIsXG4gICAqICAgZGVzY3JpcHRpb246IFwiWW91IGdvdCBhIFN1cGVyIFJhcmUgTkZUIVwiLFxuICAgKiAgIGltYWdlOiBmcy5yZWFkRmlsZVN5bmMoXCJwYXRoL3RvL2ltYWdlLnBuZ1wiKSxcbiAgICogfV07XG4gICAqIC8vIEEgcGxhY2Vob2xkZXIgTkZUIHRoYXQgcGVvcGxlIHdpbGwgZ2V0IGltbWVkaWF0ZWx5IGluIHRoZWlyIHdhbGxldCwgYW5kIHdpbGwgYmUgY29udmVydGVkIHRvIHRoZSByZWFsIE5GVCBhdCByZXZlYWwgdGltZVxuICAgKiBjb25zdCBwbGFjZWhvbGRlck5GVCA9IHtcbiAgICogICBuYW1lOiBcIkhpZGRlbiBORlRcIixcbiAgICogICBkZXNjcmlwdGlvbjogXCJXaWxsIGJlIHJldmVhbGVkIG5leHQgd2VlayFcIlxuICAgKiB9O1xuICAgKiAvLyBDcmVhdGUgYW5kIGVuY3J5cHQgdGhlIE5GVHNcbiAgICogYXdhaXQgY29udHJhY3QubmZ0LmRyb3AucmV2ZWFsZXIuY3JlYXRlRGVsYXllZFJldmVhbEJhdGNoKFxuICAgKiAgIHBsYWNlaG9sZGVyTkZULFxuICAgKiAgIHJlYWxORlRzLFxuICAgKiAgIFwibXkgc2VjcmV0IHBhc3N3b3JkXCIsXG4gICAqICk7XG4gICAqIC8vIFdoZW5ldmVyIHlvdSdyZSByZWFkeSwgcmV2ZWFsIHlvdXIgTkZUcyBhdCBhbnkgdGltZVxuICAgKiBjb25zdCBiYXRjaElkID0gMDsgLy8gdGhlIGJhdGNoIHRvIHJldmVhbFxuICAgKiBhd2FpdCBjb250cmFjdC5lcmM3MjEucmV2ZWFsZXIucmV2ZWFsKGJhdGNoSWQsIFwibXkgc2VjcmV0IHBhc3N3b3JkXCIpO1xuICAgKiBgYGBcbiAgICovXG5cbiAgLyoqXG4gICAqIENsYWltIHRva2VucyBhbmQgY29uZmlndXJlIGNsYWltIGNvbmRpdGlvbnNcbiAgICogQHJlbWFya3MgTGV0IHVzZXJzIGNsYWltIE5GVHMuIERlZmluZSB3aG8gY2FuIGNsYWltIE5GVHMgaW4gdGhlIGNvbGxlY3Rpb24sIHdoZW4gYW5kIGhvdyBtYW55LlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IHF1YW50aXR5ID0gMTA7XG4gICAqIGF3YWl0IGNvbnRyYWN0LmVyYzcyMS5jbGFpbShxdWFudGl0eSk7XG4gICAqIGBgYFxuICAgKi9cblxuICBjb25zdHJ1Y3RvcihlcmM3MjEsIGNvbnRyYWN0V3JhcHBlciwgc3RvcmFnZSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZlYXR1cmVOYW1lXCIsIEZFQVRVUkVfTkZUX0xBWllfTUlOVEFCTEUubmFtZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmV2ZWFsZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGFpbVdpdGhDb25kaXRpb25zXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xhaW1cIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250cmFjdFdyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlcmM3MjFcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yYWdlXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5lcmM3MjEgPSBlcmM3MjE7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIgPSBjb250cmFjdFdyYXBwZXI7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICB0aGlzLnJldmVhbGVyID0gdGhpcy5kZXRlY3RFcmM3MjFSZXZlYWxhYmxlKCk7XG4gICAgdGhpcy5jbGFpbVdpdGhDb25kaXRpb25zID0gdGhpcy5kZXRlY3RFcmM3MjFDbGFpbWFibGVXaXRoQ29uZGl0aW9ucygpO1xuICAgIHRoaXMuY2xhaW0gPSB0aGlzLmRldGVjdEVyYzcyMUNsYWltYWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGJhdGNoIG9mIHVuaXF1ZSBORlRzIHRvIGJlIGNsYWltZWQgaW4gdGhlIGZ1dHVyZVxuICAgKlxuICAgKiBAcmVtYXJrcyBDcmVhdGUgYmF0Y2ggYWxsb3dzIHlvdSB0byBjcmVhdGUgYSBiYXRjaCBvZiBtYW55IHVuaXF1ZSBORlRzIGluIG9uZSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBDdXN0b20gbWV0YWRhdGEgb2YgdGhlIE5GVHMgdG8gY3JlYXRlXG4gICAqIGNvbnN0IG1ldGFkYXRhcyA9IFt7XG4gICAqICAgbmFtZTogXCJDb29sIE5GVFwiLFxuICAgKiAgIGRlc2NyaXB0aW9uOiBcIlRoaXMgaXMgYSBjb29sIE5GVFwiLFxuICAgKiAgIGltYWdlOiBmcy5yZWFkRmlsZVN5bmMoXCJwYXRoL3RvL2ltYWdlLnBuZ1wiKSwgLy8gVGhpcyBjYW4gYmUgYW4gaW1hZ2UgdXJsIG9yIGZpbGVcbiAgICogfSwge1xuICAgKiAgIG5hbWU6IFwiQ29vbCBORlRcIixcbiAgICogICBkZXNjcmlwdGlvbjogXCJUaGlzIGlzIGEgY29vbCBORlRcIixcbiAgICogICBpbWFnZTogZnMucmVhZEZpbGVTeW5jKFwicGF0aC90by9pbWFnZS5wbmdcIiksXG4gICAqIH1dO1xuICAgKlxuICAgKiBjb25zdCByZXN1bHRzID0gYXdhaXQgY29udHJhY3QuZXJjNzIxLmxhenlNaW50KG1ldGFkYXRhcyk7IC8vIHVwbG9hZHMgYW5kIGNyZWF0ZXMgdGhlIE5GVHMgb24gY2hhaW5cbiAgICogY29uc3QgZmlyc3RUb2tlbklkID0gcmVzdWx0c1swXS5pZDsgLy8gdG9rZW4gaWQgb2YgdGhlIGZpcnN0IGNyZWF0ZWQgTkZUXG4gICAqIGNvbnN0IGZpcnN0TkZUID0gYXdhaXQgcmVzdWx0c1swXS5kYXRhKCk7IC8vIChvcHRpb25hbCkgZmV0Y2ggZGV0YWlscyBvZiB0aGUgZmlyc3QgY3JlYXRlZCBORlRcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBtZXRhZGF0YXMgLSBUaGUgbWV0YWRhdGEgdG8gaW5jbHVkZSBpbiB0aGUgYmF0Y2guXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9uYWwgdXBsb2FkIHByb2dyZXNzIGNhbGxiYWNrXG4gICAqL1xuICBhc3luYyBsYXp5TWludChtZXRhZGF0YXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdGFydEZpbGVOdW1iZXIgPSBhd2FpdCB0aGlzLmVyYzcyMS5uZXh0VG9rZW5JZFRvTWludCgpO1xuICAgIGNvbnN0IGJhdGNoID0gYXdhaXQgdXBsb2FkT3JFeHRyYWN0VVJJcyhtZXRhZGF0YXMsIHRoaXMuc3RvcmFnZSwgc3RhcnRGaWxlTnVtYmVyLnRvTnVtYmVyKCksIG9wdGlvbnMpO1xuICAgIC8vIGVuc3VyZSBiYXNlVXJpIGlzIHRoZSBzYW1lIGZvciB0aGUgZW50aXJlIGJhdGNoXG4gICAgY29uc3QgYmFzZVVyaSA9IGdldEJhc2VVcmlGcm9tQmF0Y2goYmF0Y2gpO1xuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJsYXp5TWludFwiLCBbYmF0Y2gubGVuZ3RoLCBiYXNlVXJpLmVuZHNXaXRoKFwiL1wiKSA/IGJhc2VVcmkgOiBgJHtiYXNlVXJpfS9gLCBldGhlcnMudXRpbHMudG9VdGY4Qnl0ZXMoXCJcIildKTtcbiAgICBjb25zdCBldmVudCA9IHRoaXMuY29udHJhY3RXcmFwcGVyLnBhcnNlTG9ncyhcIlRva2Vuc0xhenlNaW50ZWRcIiwgcmVjZWlwdD8ubG9ncyk7XG4gICAgY29uc3Qgc3RhcnRpbmdJbmRleCA9IGV2ZW50WzBdLmFyZ3Muc3RhcnRUb2tlbklkO1xuICAgIGNvbnN0IGVuZGluZ0luZGV4ID0gZXZlbnRbMF0uYXJncy5lbmRUb2tlbklkO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpZCA9IHN0YXJ0aW5nSW5kZXg7IGlkLmx0ZShlbmRpbmdJbmRleCk7IGlkID0gaWQuYWRkKDEpKSB7XG4gICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgcmVjZWlwdCxcbiAgICAgICAgZGF0YTogKCkgPT4gdGhpcy5lcmM3MjEuZ2V0VG9rZW5NZXRhZGF0YShpZClcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICogUFJJVkFURSBGVU5DVElPTlNcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgZGV0ZWN0RXJjNzIxUmV2ZWFsYWJsZSgpIHtcbiAgICBpZiAoZGV0ZWN0Q29udHJhY3RGZWF0dXJlKHRoaXMuY29udHJhY3RXcmFwcGVyLCBcIkVSQzcyMVJldmVhbGFibGVcIikpIHtcbiAgICAgIHJldHVybiBuZXcgRGVsYXllZFJldmVhbCh0aGlzLmNvbnRyYWN0V3JhcHBlciwgdGhpcy5zdG9yYWdlLCBGRUFUVVJFX05GVF9SRVZFQUxBQkxFLm5hbWUsICgpID0+IHRoaXMuZXJjNzIxLm5leHRUb2tlbklkVG9NaW50KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGRldGVjdEVyYzcyMUNsYWltYWJsZVdpdGhDb25kaXRpb25zKCkge1xuICAgIGlmIChkZXRlY3RDb250cmFjdEZlYXR1cmUodGhpcy5jb250cmFjdFdyYXBwZXIsIFwiRVJDNzIxQ2xhaW1Db25kaXRpb25zVjFcIikgfHwgZGV0ZWN0Q29udHJhY3RGZWF0dXJlKHRoaXMuY29udHJhY3RXcmFwcGVyLCBcIkVSQzcyMUNsYWltQ29uZGl0aW9uc1YyXCIpIHx8IGRldGVjdENvbnRyYWN0RmVhdHVyZSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgXCJFUkM3MjFDbGFpbVBoYXNlc1YxXCIpIHx8IGRldGVjdENvbnRyYWN0RmVhdHVyZSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgXCJFUkM3MjFDbGFpbVBoYXNlc1YyXCIpKSB7XG4gICAgICByZXR1cm4gbmV3IEVyYzcyMUNsYWltYWJsZVdpdGhDb25kaXRpb25zKHRoaXMuZXJjNzIxLCB0aGlzLmNvbnRyYWN0V3JhcHBlciwgdGhpcy5zdG9yYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBkZXRlY3RFcmM3MjFDbGFpbWFibGUoKSB7XG4gICAgaWYgKGRldGVjdENvbnRyYWN0RmVhdHVyZSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgXCJFUkM3MjFDbGFpbUN1c3RvbVwiKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcmM3MjFDbGFpbWFibGUodGhpcy5lcmM3MjEsIHRoaXMuY29udHJhY3RXcmFwcGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIE1pbnQgTWFueSBFUkM3MjEgTkZUcyBhdCBvbmNlXG4gKiBAcmVtYXJrcyBORlQgYmF0Y2ggbWludGluZyBmdW5jdGlvbmFsaXR5IHRoYXQgaGFuZGxlcyBJUEZTIHN0b3JhZ2UgZm9yIHlvdS5cbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBjb250cmFjdCA9IGF3YWl0IHNkay5nZXRDb250cmFjdChcInt7Y29udHJhY3RfYWRkcmVzc319XCIpO1xuICogYXdhaXQgY29udHJhY3QubmZ0Lm1pbnQuYmF0Y2gudG8od2FsbGV0QWRkcmVzcywgW25mdE1ldGFkYXRhMSwgbmZ0TWV0YWRhdGEyLCAuLi5dKTtcbiAqIGBgYFxuICogQHB1YmxpY1xuICovXG5jbGFzcyBFcmM3MjFCYXRjaE1pbnRhYmxlIHtcbiAgY29uc3RydWN0b3IoZXJjNzIxLCBjb250cmFjdFdyYXBwZXIsIHN0b3JhZ2UpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmZWF0dXJlTmFtZVwiLCBGRUFUVVJFX05GVF9CQVRDSF9NSU5UQUJMRS5uYW1lKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250cmFjdFdyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yYWdlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZXJjNzIxXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5lcmM3MjEgPSBlcmM3MjE7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIgPSBjb250cmFjdFdyYXBwZXI7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNaW50IE1hbnkgdW5pcXVlIE5GVHNcbiAgICpcbiAgICogQHJlbWFya3MgTWludCBtYW55IHVuaXF1ZSBORlRzIGF0IG9uY2UgdG8gYSBzcGVjaWZpZWQgd2FsbGV0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIEFkZHJlc3Mgb2YgdGhlIHdhbGxldCB5b3Ugd2FudCB0byBtaW50IHRoZSBORlQgdG9cbiAgICogY29uc3Qgd2FsbGV0QWRkcmVzcyA9IFwie3t3YWxsZXRfYWRkcmVzc319XCI7XG4gICAqXG4gICAqIC8vIEN1c3RvbSBtZXRhZGF0YSBvZiB0aGUgTkZUcyB5b3Ugd2FudCB0byBtaW50LlxuICAgKiBjb25zdCBtZXRhZGF0YXMgPSBbe1xuICAgKiAgIG5hbWU6IFwiQ29vbCBORlQgIzFcIixcbiAgICogICBkZXNjcmlwdGlvbjogXCJUaGlzIGlzIGEgY29vbCBORlRcIixcbiAgICogICBpbWFnZTogZnMucmVhZEZpbGVTeW5jKFwicGF0aC90by9pbWFnZS5wbmdcIiksIC8vIFRoaXMgY2FuIGJlIGFuIGltYWdlIHVybCBvciBmaWxlXG4gICAqIH0sIHtcbiAgICogICBuYW1lOiBcIkNvb2wgTkZUICMyXCIsXG4gICAqICAgZGVzY3JpcHRpb246IFwiVGhpcyBpcyBhIGNvb2wgTkZUXCIsXG4gICAqICAgaW1hZ2U6IGZzLnJlYWRGaWxlU3luYyhcInBhdGgvdG8vb3RoZXIvaW1hZ2UucG5nXCIpLFxuICAgKiB9XTtcbiAgICpcbiAgICogY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5taW50LmJhdGNoLnRvKHdhbGxldEFkZHJlc3MsIG1ldGFkYXRhcyk7XG4gICAqIGNvbnN0IHJlY2VpcHQgPSB0eFswXS5yZWNlaXB0OyAvLyBzYW1lIHRyYW5zYWN0aW9uIHJlY2VpcHQgZm9yIGFsbCBtaW50ZWQgTkZUc1xuICAgKiBjb25zdCBmaXJzdFRva2VuSWQgPSB0eFswXS5pZDsgLy8gdG9rZW4gaWQgb2YgdGhlIGZpcnN0IG1pbnRlZCBORlRcbiAgICogY29uc3QgZmlyc3RORlQgPSBhd2FpdCB0eFswXS5kYXRhKCk7IC8vIChvcHRpb25hbCkgZmV0Y2ggZGV0YWlscyBvZiB0aGUgZmlyc3QgbWludGVkIE5GVFxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHRvKHRvLCBtZXRhZGF0YXMpIHtcbiAgICBjb25zdCB1cmlzID0gYXdhaXQgdXBsb2FkT3JFeHRyYWN0VVJJcyhtZXRhZGF0YXMsIHRoaXMuc3RvcmFnZSk7XG4gICAgY29uc3QgZW5jb2RlZCA9IHVyaXMubWFwKHVyaSA9PiB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShcIm1pbnRUb1wiLCBbdG8sIHVyaV0pKTtcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIubXVsdGlDYWxsKGVuY29kZWQpO1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuY29udHJhY3RXcmFwcGVyLnBhcnNlTG9ncyhcIlRva2Vuc01pbnRlZFwiLCByZWNlaXB0LmxvZ3MpO1xuICAgIGlmIChldmVudHMubGVuZ3RoID09PSAwIHx8IGV2ZW50cy5sZW5ndGggPCBtZXRhZGF0YXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb2tlbk1pbnRlZCBldmVudCBub3QgZm91bmQsIG1pbnRpbmcgZmFpbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzLm1hcChlID0+IHtcbiAgICAgIGNvbnN0IGlkID0gZS5hcmdzLnRva2VuSWRNaW50ZWQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZCxcbiAgICAgICAgcmVjZWlwdCxcbiAgICAgICAgZGF0YTogKCkgPT4gdGhpcy5lcmM3MjEuZ2V0KGlkKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIE1pbnQgRVJDNzIxIE5GVHNcbiAqIEByZW1hcmtzIE5GVCBtaW50aW5nIGZ1bmN0aW9uYWxpdHkgdGhhdCBoYW5kbGVzIElQRlMgc3RvcmFnZSBmb3IgeW91LlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgc2RrLmdldENvbnRyYWN0KFwie3tjb250cmFjdF9hZGRyZXNzfX1cIik7XG4gKiBhd2FpdCBjb250cmFjdC5uZnQubWludC50byh3YWxsZXRBZGRyZXNzLCBuZnRNZXRhZGF0YSk7XG4gKiBgYGBcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgRXJjNzIxTWludGFibGUge1xuICBjb25zdHJ1Y3RvcihlcmM3MjEsIGNvbnRyYWN0V3JhcHBlciwgc3RvcmFnZSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZlYXR1cmVOYW1lXCIsIEZFQVRVUkVfTkZUX01JTlRBQkxFLm5hbWUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRyYWN0V3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3JhZ2VcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlcmM3MjFcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYXRjaFwiLCB2b2lkIDApO1xuICAgIHRoaXMuZXJjNzIxID0gZXJjNzIxO1xuICAgIHRoaXMuY29udHJhY3RXcmFwcGVyID0gY29udHJhY3RXcmFwcGVyO1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgdGhpcy5iYXRjaCA9IHRoaXMuZGV0ZWN0RXJjNzIxQmF0Y2hNaW50YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1pbnQgYSB1bmlxdWUgTkZUXG4gICAqXG4gICAqIEByZW1hcmtzIE1pbnQgYSB1bmlxdWUgTkZUIHRvIGEgc3BlY2lmaWVkIHdhbGxldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBBZGRyZXNzIG9mIHRoZSB3YWxsZXQgeW91IHdhbnQgdG8gbWludCB0aGUgTkZUIHRvXG4gICAqIGNvbnN0IHdhbGxldEFkZHJlc3MgPSBcInt7d2FsbGV0X2FkZHJlc3N9fVwiO1xuICAgKlxuICAgKiAvLyBDdXN0b20gbWV0YWRhdGEgb2YgdGhlIE5GVCwgbm90ZSB0aGF0IHlvdSBjYW4gZnVsbHkgY3VzdG9taXplIHRoaXMgbWV0YWRhdGEgd2l0aCBvdGhlciBwcm9wZXJ0aWVzLlxuICAgKiBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICogICBuYW1lOiBcIkNvb2wgTkZUXCIsXG4gICAqICAgZGVzY3JpcHRpb246IFwiVGhpcyBpcyBhIGNvb2wgTkZUXCIsXG4gICAqICAgaW1hZ2U6IGZzLnJlYWRGaWxlU3luYyhcInBhdGgvdG8vaW1hZ2UucG5nXCIpLCAvLyBUaGlzIGNhbiBiZSBhbiBpbWFnZSB1cmwgb3IgZmlsZVxuICAgKiB9O1xuICAgKlxuICAgKiBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0Lm5mdC5taW50LnRvKHdhbGxldEFkZHJlc3MsIG1ldGFkYXRhKTtcbiAgICogY29uc3QgcmVjZWlwdCA9IHR4LnJlY2VpcHQ7IC8vIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0XG4gICAqIGNvbnN0IHRva2VuSWQgPSB0eC5pZDsgLy8gdGhlIGlkIG9mIHRoZSBORlQgbWludGVkXG4gICAqIGNvbnN0IG5mdCA9IGF3YWl0IHR4LmRhdGEoKTsgLy8gKG9wdGlvbmFsKSBmZXRjaCBkZXRhaWxzIG9mIG1pbnRlZCBORlRcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyB0byh0bywgbWV0YWRhdGEpIHtcbiAgICBjb25zdCB1cmkgPSBhd2FpdCB1cGxvYWRPckV4dHJhY3RVUkkobWV0YWRhdGEsIHRoaXMuc3RvcmFnZSk7XG4gICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNlbmRUcmFuc2FjdGlvbihcIm1pbnRUb1wiLCBbdG8sIHVyaV0pO1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5jb250cmFjdFdyYXBwZXIucGFyc2VMb2dzKFwiVHJhbnNmZXJcIiwgcmVjZWlwdD8ubG9ncyk7XG4gICAgaWYgKGV2ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNmZXJFdmVudCBldmVudCBub3QgZm91bmRcIik7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gZXZlbnRbMF0uYXJncy50b2tlbklkO1xuICAgIHJldHVybiB7XG4gICAgICBpZCxcbiAgICAgIHJlY2VpcHQsXG4gICAgICBkYXRhOiAoKSA9PiB0aGlzLmVyYzcyMS5nZXQoaWQpXG4gICAgfTtcbiAgfVxuICBkZXRlY3RFcmM3MjFCYXRjaE1pbnRhYmxlKCkge1xuICAgIGlmIChkZXRlY3RDb250cmFjdEZlYXR1cmUodGhpcy5jb250cmFjdFdyYXBwZXIsIFwiRVJDNzIxQmF0Y2hNaW50YWJsZVwiKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcmM3MjFCYXRjaE1pbnRhYmxlKHRoaXMuZXJjNzIxLCB0aGlzLmNvbnRyYWN0V3JhcHBlciwgdGhpcy5zdG9yYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIExpc3Qgb3duZWQgRVJDNzIxIE5GVHNcbiAqIEByZW1hcmtzIEVhc2lseSBsaXN0IGFsbCB0aGUgTkZUcyBmcm9tIGEgRVJDNzIxIGNvbnRyYWN0LCBvd25lZCBieSBhIGNlcnRhaW4gd2FsbGV0LlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgc2RrLmdldENvbnRyYWN0KFwie3tjb250cmFjdF9hZGRyZXNzfX1cIik7XG4gKiBjb25zdCB3YWxsZXRBZGRyZXNzID0gXCIweC4uLlwiO1xuICogY29uc3Qgb3duZWRORlRzID0gYXdhaXQgY29udHJhY3QubmZ0LnF1ZXJ5Lm93bmVkLmFsbCh3YWxsZXRBZGRyZXNzKTtcbiAqIGBgYFxuICogQHB1YmxpY1xuICovXG5jbGFzcyBFcmM3MjFFbnVtZXJhYmxlIHtcbiAgY29uc3RydWN0b3IoZXJjNzIxLCBjb250cmFjdFdyYXBwZXIpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmZWF0dXJlTmFtZVwiLCBGRUFUVVJFX05GVF9FTlVNRVJBQkxFLm5hbWUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRyYWN0V3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVyYzcyMVwiLCB2b2lkIDApO1xuICAgIHRoaXMuZXJjNzIxID0gZXJjNzIxO1xuICAgIHRoaXMuY29udHJhY3RXcmFwcGVyID0gY29udHJhY3RXcmFwcGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBPd25lZCBORlRzXG4gICAqXG4gICAqIEByZW1hcmtzIEdldCBhbGwgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBORlRzIG93bmVkIGJ5IGEgc3BlY2lmaWMgd2FsbGV0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIEFkZHJlc3Mgb2YgdGhlIHdhbGxldCB0byBnZXQgdGhlIE5GVHMgb2ZcbiAgICogY29uc3QgYWRkcmVzcyA9IFwie3t3YWxsZXRfYWRkcmVzc319XCI7XG4gICAqIGNvbnN0IG5mdHMgPSBhd2FpdCBjb250cmFjdC5uZnQucXVlcnkub3duZWQuYWxsKGFkZHJlc3MpO1xuICAgKiBgYGBcbiAgICogQHBhcmFtIHdhbGxldEFkZHJlc3MgLSB0aGUgd2FsbGV0IGFkZHJlc3MgdG8gcXVlcnksIGRlZmF1bHRzIHRvIHRoZSBjb25uZWN0ZWQgd2FsbGV0XG4gICAqIEByZXR1cm5zIFRoZSBORlQgbWV0YWRhdGEgZm9yIGFsbCBORlRzIGluIHRoZSBjb250cmFjdC5cbiAgICovXG4gIGFzeW5jIGFsbCh3YWxsZXRBZGRyZXNzKSB7XG4gICAgY29uc3QgdG9rZW5JZHMgPSBhd2FpdCB0aGlzLnRva2VuSWRzKHdhbGxldEFkZHJlc3MpO1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbCh0b2tlbklkcy5tYXAodG9rZW5JZCA9PiB0aGlzLmVyYzcyMS5nZXQodG9rZW5JZC50b1N0cmluZygpKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgdG9rZW4gaWRzIG9mIE5GVHMgb3duZWQgYnkgYSBzcGVjaWZpYyB3YWxsZXQuXG4gICAqIEBwYXJhbSB3YWxsZXRBZGRyZXNzIC0gdGhlIHdhbGxldCBhZGRyZXNzIHRvIHF1ZXJ5LCBkZWZhdWx0cyB0byB0aGUgY29ubmVjdGVkIHdhbGxldFxuICAgKi9cbiAgYXN5bmMgdG9rZW5JZHMod2FsbGV0QWRkcmVzcykge1xuICAgIGNvbnN0IGFkZHJlc3MgPSB3YWxsZXRBZGRyZXNzIHx8IChhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRTaWduZXJBZGRyZXNzKCkpO1xuICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuYmFsYW5jZU9mKGFkZHJlc3MpO1xuICAgIGNvbnN0IGluZGljZXMgPSBBcnJheS5mcm9tKEFycmF5KGJhbGFuY2UudG9OdW1iZXIoKSkua2V5cygpKTtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoaW5kaWNlcy5tYXAoaSA9PiB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QudG9rZW5PZk93bmVyQnlJbmRleChhZGRyZXNzLCBpKSkpO1xuICB9XG59XG5cbi8qKlxuICogTGlzdCBFUkM3MjEgTkZUc1xuICogQHJlbWFya3MgRWFzaWx5IGxpc3QgYWxsIHRoZSBORlRzIGluIGEgRVJDNzIxIGNvbnRyYWN0LlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgc2RrLmdldENvbnRyYWN0KFwie3tjb250cmFjdF9hZGRyZXNzfX1cIik7XG4gKiBjb25zdCBuZnRzID0gYXdhaXQgY29udHJhY3QubmZ0LnF1ZXJ5LmFsbCgpO1xuICogYGBgXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEVyYzcyMVN1cHBseSB7XG4gIGNvbnN0cnVjdG9yKGVyYzcyMSwgY29udHJhY3RXcmFwcGVyKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZmVhdHVyZU5hbWVcIiwgRkVBVFVSRV9ORlRfU1VQUExZLm5hbWUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRyYWN0V3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVyYzcyMVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm93bmVkXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5lcmM3MjEgPSBlcmM3MjE7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIgPSBjb250cmFjdFdyYXBwZXI7XG4gICAgdGhpcy5vd25lZCA9IHRoaXMuZGV0ZWN0RXJjNzIxT3duZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgQWxsIE1pbnRlZCBORlRzXG4gICAqXG4gICAqIEByZW1hcmtzIEdldCBhbGwgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGV2ZXJ5IE5GVCBpbiB0aGlzIGNvbnRyYWN0LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCByZXR1cm5zIHRoZSBmaXJzdCAxMDAgTkZUcywgdXNlIHF1ZXJ5UGFyYW1zIHRvIGZldGNoIG1vcmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgbmZ0cyA9IGF3YWl0IGNvbnRyYWN0Lm5mdC5xdWVyeS5hbGwoKTtcbiAgICogYGBgXG4gICAqIEBwYXJhbSBxdWVyeVBhcmFtcyAtIG9wdGlvbmFsIGZpbHRlcmluZyB0byBvbmx5IGZldGNoIGEgc3Vic2V0IG9mIHJlc3VsdHMuXG4gICAqIEByZXR1cm5zIFRoZSBORlQgbWV0YWRhdGEgZm9yIGFsbCBORlRzIHF1ZXJpZWQuXG4gICAqL1xuICBhc3luYyBhbGwocXVlcnlQYXJhbXMpIHtcbiAgICBjb25zdCBzdGFydCA9IEJpZ051bWJlci5mcm9tKHF1ZXJ5UGFyYW1zPy5zdGFydCB8fCAwKS50b051bWJlcigpO1xuICAgIGNvbnN0IGNvdW50ID0gQmlnTnVtYmVyLmZyb20ocXVlcnlQYXJhbXM/LmNvdW50IHx8IERFRkFVTFRfUVVFUllfQUxMX0NPVU5UKS50b051bWJlcigpO1xuICAgIGNvbnN0IG1heFN1cHBseSA9IGF3YWl0IHRoaXMuZXJjNzIxLm5leHRUb2tlbklkVG9NaW50KCk7XG4gICAgY29uc3QgbWF4SWQgPSBNYXRoLm1pbihtYXhTdXBwbHkudG9OdW1iZXIoKSwgc3RhcnQgKyBjb3VudCk7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKFsuLi5BcnJheShtYXhJZCAtIHN0YXJ0KS5rZXlzKCldLm1hcChpID0+IHRoaXMuZXJjNzIxLmdldCgoc3RhcnQgKyBpKS50b1N0cmluZygpKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgdGhlIG93bmVycyBvZiBlYWNoIHRva2VuIGlkIGluIHRoaXMgY29udHJhY3RcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGFsbE93bmVycygpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoWy4uLm5ldyBBcnJheSgoYXdhaXQgdGhpcy50b3RhbENvdW50KCkpLnRvTnVtYmVyKCkpLmtleXMoKV0ubWFwKGFzeW5jIGkgPT4gKHtcbiAgICAgIHRva2VuSWQ6IGksXG4gICAgICBvd25lcjogYXdhaXQgdGhpcy5lcmM3MjEub3duZXJPZihpKS5jYXRjaCgoKSA9PiBjb25zdGFudHMuQWRkcmVzc1plcm8pXG4gICAgfSkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlciBvZiBORlRzIG1pbnRlZFxuICAgKiBAcmVtYXJrcyBUaGlzIHJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBORlRzIG1pbnRlZCBpbiB0aGlzIGNvbnRyYWN0LCAqKm5vdCoqIHRoZSB0b3RhbCBzdXBwbHkgb2YgYSBnaXZlbiB0b2tlbi5cbiAgICpcbiAgICogQHJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBORlRzIG1pbnRlZCBpbiB0aGlzIGNvbnRyYWN0XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFzeW5jIHRvdGFsQ291bnQoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZXJjNzIxLm5leHRUb2tlbklkVG9NaW50KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXIgb2YgTkZUcyBvZiB0aGlzIGNvbnRyYWN0IGN1cnJlbnRseSBvd25lZCBieSBlbmQgdXNlcnNcbiAgICogQHJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBORlRzIG9mIHRoaXMgY29udHJhY3QgaW4gY2lyY3VsYXRpb24gKG1pbnRlZCAmIG5vdCBidXJuZWQpXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFzeW5jIHRvdGFsQ2lyY3VsYXRpbmdTdXBwbHkoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC50b3RhbFN1cHBseSgpO1xuICB9XG4gIGRldGVjdEVyYzcyMU93bmVkKCkge1xuICAgIGlmIChkZXRlY3RDb250cmFjdEZlYXR1cmUodGhpcy5jb250cmFjdFdyYXBwZXIsIFwiRVJDNzIxRW51bWVyYWJsZVwiKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcmM3MjFFbnVtZXJhYmxlKHRoaXMuZXJjNzIxLCB0aGlzLmNvbnRyYWN0V3JhcHBlcik7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgVGllcmVkRHJvcFBheWxvYWRTY2hlbWEgPSBCYXNlU2lnbmF0dXJlUGF5bG9hZElucHV0LmV4dGVuZCh7XG4gIHRpZXJQcmlvcml0eTogei5hcnJheSh6LnN0cmluZygpKSxcbiAgcm95YWx0eVJlY2lwaWVudDogei5zdHJpbmcoKS5kZWZhdWx0KGNvbnN0YW50cy5BZGRyZXNzWmVybyksXG4gIHJveWFsdHlCcHM6IEJhc2lzUG9pbnRzU2NoZW1hLmRlZmF1bHQoMCksXG4gIHF1YW50aXR5OiBCaWdOdW1iZXJTY2hlbWEuZGVmYXVsdCgxKVxufSk7XG5cbmNsYXNzIEVyYzcyMVRpZXJlZERyb3Age1xuICBjb25zdHJ1Y3RvcihlcmM3MjEsIGNvbnRyYWN0V3JhcHBlciwgc3RvcmFnZSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZlYXR1cmVOYW1lXCIsIEZFQVRVUkVfTkZUX1RJRVJFRF9EUk9QLm5hbWUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRyYWN0V3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVyYzcyMVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3JhZ2VcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmVyYzcyMSA9IGVyYzcyMTtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlciA9IGNvbnRyYWN0V3JhcHBlcjtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICB9XG4gIGFzeW5jIGdldE1ldGFkYXRhSW5UaWVyKHRpZXIpIHtcbiAgICBjb25zdCB0aWVycyA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5nZXRNZXRhZGF0YUZvckFsbFRpZXJzKCk7XG4gICAgY29uc3QgYmF0Y2hlcyA9IHRpZXJzLmZpbmQodCA9PiB0LnRpZXIgPT09IHRpZXIpO1xuICAgIGlmICghYmF0Y2hlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGllciBub3QgZm91bmQgaW4gY29udHJhY3QuXCIpO1xuICAgIH1cbiAgICBjb25zdCBuZnRzID0gYXdhaXQgUHJvbWlzZS5hbGwoYmF0Y2hlcy5yYW5nZXMubWFwKChyYW5nZSwgaSkgPT4ge1xuICAgICAgY29uc3QgbmZ0c0luUmFuZ2UgPSBbXTtcbiAgICAgIGNvbnN0IGJhc2VVcmkgPSBiYXRjaGVzLmJhc2VVUklzW2ldO1xuICAgICAgZm9yIChsZXQgaiA9IHJhbmdlLnN0YXJ0SWRJbmNsdXNpdmUudG9OdW1iZXIoKTsgaiA8IHJhbmdlLmVuZElkTm9uSW5jbHVzaXZlLnRvTnVtYmVyKCk7IGorKykge1xuICAgICAgICBjb25zdCB1cmkgPSBgJHtiYXNlVXJpfS8ke2p9YDtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLnN0b3JhZ2UuZG93bmxvYWRKU09OKHVyaSk7XG4gICAgICAgIG5mdHNJblJhbmdlLnB1c2gobWV0YWRhdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5mdHNJblJhbmdlO1xuICAgIH0pLmZsYXQoKSk7XG4gICAgcmV0dXJuIG5mdHM7XG4gIH1cbiAgYXN5bmMgZ2V0VG9rZW5zSW5UaWVyKHRpZXIpIHtcbiAgICBjb25zdCBlbmRJbmRleCA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5nZXRUb2tlbnNJblRpZXJMZW4oKTtcbiAgICBpZiAoZW5kSW5kZXguZXEoMCkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2VzID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmdldFRva2Vuc0luVGllcih0aWVyLCAwLCBlbmRJbmRleCk7XG4gICAgY29uc3QgbmZ0cyA9IGF3YWl0IFByb21pc2UuYWxsKHJhbmdlcy5tYXAocmFuZ2UgPT4ge1xuICAgICAgY29uc3QgbmZ0c0luUmFuZ2UgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSByYW5nZS5zdGFydElkSW5jbHVzaXZlLnRvTnVtYmVyKCk7IGkgPCByYW5nZS5lbmRJZE5vbkluY2x1c2l2ZS50b051bWJlcigpOyBpKyspIHtcbiAgICAgICAgbmZ0c0luUmFuZ2UucHVzaCh0aGlzLmVyYzcyMS5nZXQoaSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5mdHNJblJhbmdlO1xuICAgIH0pLmZsYXQoKSk7XG4gICAgcmV0dXJuIG5mdHM7XG4gIH1cbiAgYXN5bmMgY3JlYXRlQmF0Y2hXaXRoVGllcihtZXRhZGF0YXMsIHRpZXIsIG9wdGlvbnMpIHtcbiAgICAvLyBUT0RPOiBDaGFuZ2UgdGhpcyB0byBvbiBleHRlbnNpb25cbiAgICBjb25zdCBzdGFydEZpbGVOdW1iZXIgPSBhd2FpdCB0aGlzLmVyYzcyMS5uZXh0VG9rZW5JZFRvTWludCgpO1xuICAgIGNvbnN0IGJhdGNoID0gYXdhaXQgdXBsb2FkT3JFeHRyYWN0VVJJcyhtZXRhZGF0YXMsIHRoaXMuc3RvcmFnZSwgc3RhcnRGaWxlTnVtYmVyLnRvTnVtYmVyKCksIG9wdGlvbnMpO1xuICAgIGNvbnN0IGJhc2VVcmkgPSBnZXRCYXNlVXJpRnJvbUJhdGNoKGJhdGNoKTtcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuc2VuZFRyYW5zYWN0aW9uKFwibGF6eU1pbnRcIiwgW2JhdGNoLmxlbmd0aCwgYmFzZVVyaS5lbmRzV2l0aChcIi9cIikgPyBiYXNlVXJpIDogYCR7YmFzZVVyaX0vYCwgdGllciwgZXRoZXJzLnV0aWxzLnRvVXRmOEJ5dGVzKFwiXCIpXSk7XG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLmNvbnRyYWN0V3JhcHBlci5wYXJzZUxvZ3MoXCJUb2tlbnNMYXp5TWludGVkXCIsIHJlY2VpcHQ/LmxvZ3MpO1xuICAgIGNvbnN0IHN0YXJ0aW5nSW5kZXggPSBldmVudFswXS5hcmdzWzFdO1xuICAgIGNvbnN0IGVuZGluZ0luZGV4ID0gZXZlbnRbMF0uYXJnc1syXTtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgZm9yIChsZXQgaWQgPSBzdGFydGluZ0luZGV4OyBpZC5sdGUoZW5kaW5nSW5kZXgpOyBpZCA9IGlkLmFkZCgxKSkge1xuICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIHJlY2VpcHQsXG4gICAgICAgIGRhdGE6ICgpID0+IHRoaXMuZXJjNzIxLmdldFRva2VuTWV0YWRhdGEoaWQpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgYXN5bmMgY3JlYXRlRGVsYXllZFJldmVhbEJhdGNoV2l0aFRpZXIocGxhY2Vob2xkZXIsIG1ldGFkYXRhcywgcGFzc3dvcmQsIHRpZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXBhc3N3b3JkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXNzd29yZCBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgcGxhY2Vob2xkZXJVcmlzID0gYXdhaXQgdGhpcy5zdG9yYWdlLnVwbG9hZEJhdGNoKFtDb21tb25ORlRJbnB1dC5wYXJzZShwbGFjZWhvbGRlcildLCB7XG4gICAgICByZXdyaXRlRmlsZU5hbWVzOiB7XG4gICAgICAgIGZpbGVTdGFydE51bWJlcjogMFxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyVXJpID0gZ2V0QmFzZVVyaUZyb21CYXRjaChwbGFjZWhvbGRlclVyaXMpO1xuICAgIGNvbnN0IHN0YXJ0RmlsZU51bWJlciA9IGF3YWl0IHRoaXMuZXJjNzIxLm5leHRUb2tlbklkVG9NaW50KCk7XG4gICAgY29uc3QgdXJpcyA9IGF3YWl0IHRoaXMuc3RvcmFnZS51cGxvYWRCYXRjaChtZXRhZGF0YXMubWFwKG0gPT4gQ29tbW9uTkZUSW5wdXQucGFyc2UobSkpLCB7XG4gICAgICBvblByb2dyZXNzOiBvcHRpb25zPy5vblByb2dyZXNzLFxuICAgICAgcmV3cml0ZUZpbGVOYW1lczoge1xuICAgICAgICBmaWxlU3RhcnROdW1iZXI6IHN0YXJ0RmlsZU51bWJlci50b051bWJlcigpXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgYmFzZVVyaSA9IGdldEJhc2VVcmlGcm9tQmF0Y2godXJpcyk7XG4gICAgY29uc3QgYmFzZVVyaUlkID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmdldEJhc2VVUklDb3VudCgpO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRDaGFpbklEKCk7XG4gICAgY29uc3QgaGFzaGVkUGFzc3dvcmQgPSBldGhlcnMudXRpbHMuc29saWRpdHlLZWNjYWsyNTYoW1wic3RyaW5nXCIsIFwidWludDI1NlwiLCBcInVpbnQyNTZcIiwgXCJhZGRyZXNzXCJdLCBbcGFzc3dvcmQsIGNoYWluSWQsIGJhc2VVcmlJZCwgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmFkZHJlc3NdKTtcbiAgICBjb25zdCBlbmNyeXB0ZWRCYXNlVXJpID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmVuY3J5cHREZWNyeXB0KGV0aGVycy51dGlscy50b1V0ZjhCeXRlcyhiYXNlVXJpKSwgaGFzaGVkUGFzc3dvcmQpO1xuICAgIGxldCBkYXRhO1xuICAgIGNvbnN0IHByb3ZlbmFuY2VIYXNoID0gZXRoZXJzLnV0aWxzLnNvbGlkaXR5S2VjY2FrMjU2KFtcImJ5dGVzXCIsIFwiYnl0ZXNcIiwgXCJ1aW50MjU2XCJdLCBbZXRoZXJzLnV0aWxzLnRvVXRmOEJ5dGVzKGJhc2VVcmkpLCBoYXNoZWRQYXNzd29yZCwgY2hhaW5JZF0pO1xuICAgIGRhdGEgPSBldGhlcnMudXRpbHMuZGVmYXVsdEFiaUNvZGVyLmVuY29kZShbXCJieXRlc1wiLCBcImJ5dGVzMzJcIl0sIFtlbmNyeXB0ZWRCYXNlVXJpLCBwcm92ZW5hbmNlSGFzaF0pO1xuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJsYXp5TWludFwiLCBbdXJpcy5sZW5ndGgsIHBsYWNlaG9sZGVyVXJpLmVuZHNXaXRoKFwiL1wiKSA/IHBsYWNlaG9sZGVyVXJpIDogYCR7cGxhY2Vob2xkZXJVcml9L2AsIHRpZXIsIGRhdGFdKTtcbiAgICBjb25zdCBldmVudCA9IHRoaXMuY29udHJhY3RXcmFwcGVyLnBhcnNlTG9ncyhcIlRva2Vuc0xhenlNaW50ZWRcIiwgcmVjZWlwdD8ubG9ncyk7XG4gICAgY29uc3Qgc3RhcnRpbmdJbmRleCA9IGV2ZW50WzBdLmFyZ3NbMV07XG4gICAgY29uc3QgZW5kaW5nSW5kZXggPSBldmVudFswXS5hcmdzWzJdO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpZCA9IHN0YXJ0aW5nSW5kZXg7IGlkLmx0ZShlbmRpbmdJbmRleCk7IGlkID0gaWQuYWRkKDEpKSB7XG4gICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgcmVjZWlwdCxcbiAgICAgICAgZGF0YTogKCkgPT4gdGhpcy5lcmM3MjEuZ2V0VG9rZW5NZXRhZGF0YShpZClcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBhc3luYyByZXZlYWwoYmF0Y2hJZCwgcGFzc3dvcmQpIHtcbiAgICBpZiAoIXBhc3N3b3JkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXNzd29yZCBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLmdldENoYWluSUQoKTtcbiAgICBjb25zdCBrZXkgPSBldGhlcnMudXRpbHMuc29saWRpdHlLZWNjYWsyNTYoW1wic3RyaW5nXCIsIFwidWludDI1NlwiLCBcInVpbnQyNTZcIiwgXCJhZGRyZXNzXCJdLCBbcGFzc3dvcmQsIGNoYWluSWQsIGJhdGNoSWQsIHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5hZGRyZXNzXSk7XG4gICAgLy8gcGVyZm9ybWluZyB0aGUgcmV2ZWFsIGxvY2FsbHkgdG8gbWFrZSBzdXJlIGl0J2Qgc3VjY2VlZCBiZWZvcmUgc2VuZGluZyB0aGUgdHJhbnNhY3Rpb25cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGVjcnlwdGVkVXJpID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuY2FsbFN0YXRpYygpLnJldmVhbChiYXRjaElkLCBrZXkpO1xuICAgICAgLy8gYmFzaWMgc2FuaXR5IGNoZWNrIGZvciBtYWtpbmcgc3VyZSBkZWNyeXB0ZWRVcmkgaXMgdmFsaWRcbiAgICAgIC8vIHRoaXMgaXMgb3B0aW9uYWwgYmVjYXVzZSBpbnZhbGlkIGRlY3J5cHRpb24ga2V5IHdvdWxkIHJlc3VsdCBpbiBub24tdXRmOCBieXRlcyBhbmRcbiAgICAgIC8vIGV0aGVycyB3b3VsZCB0aHJvdyB3aGVuIHRyeWluZyB0byBkZWNvZGUgaXRcbiAgICAgIGlmICghZGVjcnlwdGVkVXJpLmluY2x1ZGVzKFwiOi8vXCIpIHx8ICFkZWNyeXB0ZWRVcmkuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGFzc3dvcmRcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXNzd29yZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNlbmRUcmFuc2FjdGlvbihcInJldmVhbFwiLCBbYmF0Y2hJZCwga2V5XSlcbiAgICB9O1xuICB9XG4gIGFzeW5jIGdlbmVyYXRlKHBheWxvYWRUb1NpZ24pIHtcbiAgICBjb25zdCBbcGF5bG9hZF0gPSBhd2FpdCB0aGlzLmdlbmVyYXRlQmF0Y2goW3BheWxvYWRUb1NpZ25dKTtcbiAgICByZXR1cm4gcGF5bG9hZDtcbiAgfVxuICBhc3luYyBnZW5lcmF0ZUJhdGNoKHBheWxvYWRzVG9TaWduKSB7XG4gICAgY29uc3QgcGFyc2VkUGF5bG9hZHMgPSBwYXlsb2Fkc1RvU2lnbi5tYXAocGF5bG9hZCA9PiBUaWVyZWREcm9wUGF5bG9hZFNjaGVtYS5wYXJzZShwYXlsb2FkKSk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLmdldENoYWluSUQoKTtcbiAgICBjb25zdCBzaWduZXIgPSB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRTaWduZXIoKTtcbiAgICBpbnZhcmlhbnQoc2lnbmVyLCBcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHBhcnNlZFBheWxvYWRzLm1hcChhc3luYyBwYXlsb2FkID0+IHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNpZ25UeXBlZERhdGEoc2lnbmVyLCB7XG4gICAgICAgIG5hbWU6IFwiU2lnbmF0dXJlQWN0aW9uXCIsXG4gICAgICAgIHZlcnNpb246IFwiMVwiLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICB2ZXJpZnlpbmdDb250cmFjdDogdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmFkZHJlc3NcbiAgICAgIH0sIHtcbiAgICAgICAgR2VuZXJpY1JlcXVlc3Q6IEdlbmVyaWNSZXF1ZXN0XG4gICAgICB9LCBhd2FpdCB0aGlzLm1hcFBheWxvYWRUb0NvbnRyYWN0U3RydWN0KHBheWxvYWQpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBheWxvYWQsXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLnRvU3RyaW5nKClcbiAgICAgIH07XG4gICAgfSkpO1xuICB9XG4gIGFzeW5jIHZlcmlmeShzaWduZWRQYXlsb2FkKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHRoaXMubWFwUGF5bG9hZFRvQ29udHJhY3RTdHJ1Y3Qoc2lnbmVkUGF5bG9hZC5wYXlsb2FkKTtcbiAgICBjb25zdCB2ZXJpZmljYXRpb24gPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QudmVyaWZ5KG1lc3NhZ2UsIHNpZ25lZFBheWxvYWQuc2lnbmF0dXJlKTtcbiAgICByZXR1cm4gdmVyaWZpY2F0aW9uWzBdO1xuICB9XG4gIGFzeW5jIGNsYWltV2l0aFNpZ25hdHVyZShzaWduZWRQYXlsb2FkKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHRoaXMubWFwUGF5bG9hZFRvQ29udHJhY3RTdHJ1Y3Qoc2lnbmVkUGF5bG9hZC5wYXlsb2FkKTtcbiAgICBjb25zdCBwcmljZVBlclRva2VuID0gYXdhaXQgbm9ybWFsaXplUHJpY2VWYWx1ZSh0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRQcm92aWRlcigpLCBzaWduZWRQYXlsb2FkLnBheWxvYWQucHJpY2UsIHNpZ25lZFBheWxvYWQucGF5bG9hZC5jdXJyZW5jeUFkZHJlc3MpO1xuICAgIGNvbnN0IHByaWNlID0gcHJpY2VQZXJUb2tlbi5tdWwoc2lnbmVkUGF5bG9hZC5wYXlsb2FkLnF1YW50aXR5KTtcbiAgICBjb25zdCBvdmVycmlkZXMgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRDYWxsT3ZlcnJpZGVzKCk7XG4gICAgYXdhaXQgc2V0RXJjMjBBbGxvd2FuY2UodGhpcy5jb250cmFjdFdyYXBwZXIsIHByaWNlLCBzaWduZWRQYXlsb2FkLnBheWxvYWQuY3VycmVuY3lBZGRyZXNzLCBvdmVycmlkZXMpO1xuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJjbGFpbVdpdGhTaWduYXR1cmVcIiwgW21lc3NhZ2UsIHNpZ25lZFBheWxvYWQuc2lnbmF0dXJlXSwgb3ZlcnJpZGVzKTtcbiAgICBjb25zdCBldmVudCA9IHRoaXMuY29udHJhY3RXcmFwcGVyLnBhcnNlTG9ncyhcIlRva2Vuc0NsYWltZWRcIiwgcmVjZWlwdD8ubG9ncyk7XG4gICAgY29uc3Qgc3RhcnRpbmdJbmRleCA9IGV2ZW50WzBdLmFyZ3Muc3RhcnRUb2tlbklkO1xuICAgIGNvbnN0IGVuZGluZ0luZGV4ID0gc3RhcnRpbmdJbmRleC5hZGQoZXZlbnRbMF0uYXJncy5xdWFudGl0eUNsYWltZWQpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpZCA9IHN0YXJ0aW5nSW5kZXg7IGlkLmx0KGVuZGluZ0luZGV4KTsgaWQgPSBpZC5hZGQoMSkpIHtcbiAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgIGlkLFxuICAgICAgICByZWNlaXB0LFxuICAgICAgICBkYXRhOiAoKSA9PiB0aGlzLmVyYzcyMS5nZXQoaWQpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgYXN5bmMgbWFwUGF5bG9hZFRvQ29udHJhY3RTdHJ1Y3QocGF5bG9hZCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRQcmljZVBlclRva2VuID0gYXdhaXQgbm9ybWFsaXplUHJpY2VWYWx1ZSh0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRQcm92aWRlcigpLCBwYXlsb2FkLnByaWNlLCBwYXlsb2FkLmN1cnJlbmN5QWRkcmVzcyk7XG4gICAgY29uc3QgZGF0YSA9IGV0aGVycy51dGlscy5kZWZhdWx0QWJpQ29kZXIuZW5jb2RlKFtcInN0cmluZ1tdXCIsIFwiYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgXCJ1aW50MjU2XCIsIFwiYWRkcmVzc1wiLCBcInVpbnQyNTZcIiwgXCJ1aW50MjU2XCIsIFwiYWRkcmVzc1wiXSwgW3BheWxvYWQudGllclByaW9yaXR5LCBwYXlsb2FkLnRvLCBwYXlsb2FkLnJveWFsdHlSZWNpcGllbnQsIHBheWxvYWQucm95YWx0eUJwcywgcGF5bG9hZC5wcmltYXJ5U2FsZVJlY2lwaWVudCwgcGF5bG9hZC5xdWFudGl0eSwgbm9ybWFsaXplZFByaWNlUGVyVG9rZW4sIHBheWxvYWQuY3VycmVuY3lBZGRyZXNzXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVpZDogcGF5bG9hZC51aWQsXG4gICAgICB2YWxpZGl0eVN0YXJ0VGltZXN0YW1wOiBwYXlsb2FkLm1pbnRTdGFydFRpbWUsXG4gICAgICB2YWxpZGl0eUVuZFRpbWVzdGFtcDogcGF5bG9hZC5taW50RW5kVGltZSxcbiAgICAgIGRhdGFcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogRW5hYmxlcyBnZW5lcmF0aW5nIGR5bmFtaWMgRVJDNzIxIE5GVHMgd2l0aCBydWxlcyBhbmQgYW4gYXNzb2NpYXRlZCBzaWduYXR1cmUsIHdoaWNoIGNhbiB0aGVuIGJlIG1pbnRlZCBieSBhbnlvbmUgc2VjdXJlbHlcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgRXJjNzIxV2l0aFF1YW50aXR5U2lnbmF0dXJlTWludGFibGUge1xuICBjb25zdHJ1Y3Rvcihjb250cmFjdFdyYXBwZXIsIHN0b3JhZ2UpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmZWF0dXJlTmFtZVwiLCBGRUFUVVJFX05GVF9TSUdOQVRVUkVfTUlOVEFCTEVfVjIubmFtZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcmFnZVwiLCB2b2lkIDApO1xuICAgIHRoaXMuY29udHJhY3RXcmFwcGVyID0gY29udHJhY3RXcmFwcGVyO1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gIH1cblxuICAvKipcbiAgICogTWludCBhIGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBORlRcbiAgICpcbiAgICogQHJlbWFya3MgTWludCBhIGR5bmFtaWMgTkZUIHdpdGggYSBwcmV2aW91c2x5IGdlbmVyYXRlZCBzaWduYXR1cmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gc2VlIGhvdyB0byBjcmFmdCBhIHBheWxvYWQgdG8gc2lnbiBpbiB0aGUgYGdlbmVyYXRlKClgIGRvY3VtZW50YXRpb25cbiAgICogY29uc3Qgc2lnbmVkUGF5bG9hZCA9IGNvbnRyYWN0LmVyYzcyMS5zaWduYXR1cmUuZ2VuZXJhdGUocGF5bG9hZCk7XG4gICAqXG4gICAqIC8vIG5vdyBhbnlvbmUgY2FuIG1pbnQgdGhlIE5GVFxuICAgKiBjb25zdCB0eCA9IGNvbnRyYWN0LmVyYzcyMS5zaWduYXR1cmUubWludChzaWduZWRQYXlsb2FkKTtcbiAgICogY29uc3QgcmVjZWlwdCA9IHR4LnJlY2VpcHQ7IC8vIHRoZSBtaW50IHRyYW5zYWN0aW9uIHJlY2VpcHRcbiAgICogY29uc3QgbWludGVkSWQgPSB0eC5pZDsgLy8gdGhlIGlkIG9mIHRoZSBORlQgbWludGVkXG4gICAqIGBgYFxuICAgKiBAcGFyYW0gc2lnbmVkUGF5bG9hZCAtIHRoZSBwcmV2aW91c2x5IGdlbmVyYXRlZCBwYXlsb2FkIGFuZCBzaWduYXR1cmUgd2l0aCB7QGxpbmsgRXJjNzIxV2l0aFF1YW50aXR5U2lnbmF0dXJlTWludGFibGUuZ2VuZXJhdGV9XG4gICAqIEB0d2ZlYXR1cmUgRVJDNzIxU2lnbmF0dXJlTWludFxuICAgKi9cbiAgYXN5bmMgbWludChzaWduZWRQYXlsb2FkKSB7XG4gICAgY29uc3QgbWludFJlcXVlc3QgPSBzaWduZWRQYXlsb2FkLnBheWxvYWQ7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbmVkUGF5bG9hZC5zaWduYXR1cmU7XG4gICAgY29uc3QgaXNMZWdhY3lORlRDb250cmFjdCA9IGF3YWl0IHRoaXMuaXNMZWdhY3lORlRDb250cmFjdCgpO1xuICAgIGxldCBtZXNzYWdlO1xuICAgIGxldCBwcmljZTtcbiAgICBpZiAoaXNMZWdhY3lORlRDb250cmFjdCkge1xuICAgICAgbWVzc2FnZSA9IGF3YWl0IHRoaXMubWFwTGVnYWN5UGF5bG9hZFRvQ29udHJhY3RTdHJ1Y3QobWludFJlcXVlc3QpO1xuICAgICAgcHJpY2UgPSBtZXNzYWdlLnByaWNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlID0gYXdhaXQgdGhpcy5tYXBQYXlsb2FkVG9Db250cmFjdFN0cnVjdChtaW50UmVxdWVzdCk7XG4gICAgICBwcmljZSA9IG1lc3NhZ2UucHJpY2VQZXJUb2tlbi5tdWwobWVzc2FnZS5xdWFudGl0eSk7XG4gICAgfVxuICAgIGNvbnN0IG92ZXJyaWRlcyA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLmdldENhbGxPdmVycmlkZXMoKTtcbiAgICBhd2FpdCBzZXRFcmMyMEFsbG93YW5jZSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgcHJpY2UsIG1pbnRSZXF1ZXN0LmN1cnJlbmN5QWRkcmVzcywgb3ZlcnJpZGVzKTtcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuc2VuZFRyYW5zYWN0aW9uKFwibWludFdpdGhTaWduYXR1cmVcIiwgW21lc3NhZ2UsIHNpZ25hdHVyZV0sIG92ZXJyaWRlcyk7XG4gICAgY29uc3QgdCA9IHRoaXMuY29udHJhY3RXcmFwcGVyLnBhcnNlTG9ncyhcIlRva2Vuc01pbnRlZFdpdGhTaWduYXR1cmVcIiwgcmVjZWlwdC5sb2dzKTtcbiAgICBpZiAodC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE1pbnRXaXRoU2lnbmF0dXJlIGV2ZW50IGZvdW5kXCIpO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IHRbMF0uYXJncy50b2tlbklkTWludGVkO1xuICAgIHJldHVybiB7XG4gICAgICBpZCxcbiAgICAgIHJlY2VpcHRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE1pbnQgYW55IG51bWJlciBvZiBkeW5hbWljYWxseSBnZW5lcmF0ZWQgTkZUIGF0IG9uY2VcbiAgICogQHJlbWFya3MgTWludCBtdWx0aXBsZSBkeW5hbWljIE5GVHMgaW4gb25lIHRyYW5zYWN0aW9uLiBOb3RlIHRoYXQgdGhpcyBpcyBvbmx5IHBvc3NpYmxlIGZvciBmcmVlIG1pbnRzIChjYW5ub3QgYmF0Y2ggbWludHMgd2l0aCBhIHByaWNlIGF0dGFjaGVkIHRvIGl0IGZvciBzZWN1cml0eSByZWFzb25zKVxuICAgKiBAcGFyYW0gc2lnbmVkUGF5bG9hZHMgLSB0aGUgYXJyYXkgb2Ygc2lnbmVkIHBheWxvYWRzIHRvIG1pbnRcbiAgICogQHR3ZmVhdHVyZSBFUkM3MjFTaWduYXR1cmVNaW50XG4gICAqL1xuICBhc3luYyBtaW50QmF0Y2goc2lnbmVkUGF5bG9hZHMpIHtcbiAgICBjb25zdCBpc0xlZ2FjeU5GVENvbnRyYWN0ID0gYXdhaXQgdGhpcy5pc0xlZ2FjeU5GVENvbnRyYWN0KCk7XG4gICAgY29uc3QgY29udHJhY3RQYXlsb2FkcyA9IGF3YWl0IFByb21pc2UuYWxsKHNpZ25lZFBheWxvYWRzLm1hcChhc3luYyBzID0+IHtcbiAgICAgIGxldCBtZXNzYWdlO1xuICAgICAgaWYgKGlzTGVnYWN5TkZUQ29udHJhY3QpIHtcbiAgICAgICAgbWVzc2FnZSA9IGF3YWl0IHRoaXMubWFwTGVnYWN5UGF5bG9hZFRvQ29udHJhY3RTdHJ1Y3Qocy5wYXlsb2FkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2UgPSBhd2FpdCB0aGlzLm1hcFBheWxvYWRUb0NvbnRyYWN0U3RydWN0KHMucGF5bG9hZCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBzLnNpZ25hdHVyZTtcbiAgICAgIGNvbnN0IHByaWNlID0gcy5wYXlsb2FkLnByaWNlO1xuICAgICAgaWYgKEJpZ051bWJlci5mcm9tKHByaWNlKS5ndCgwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gb25seSBiYXRjaCBmcmVlIG1pbnRzLiBGb3IgbWludHMgd2l0aCBhIHByaWNlLCB1c2UgcmVndWxhciBtaW50KClcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBzaWduYXR1cmVcbiAgICAgIH07XG4gICAgfSkpO1xuICAgIGNvbnN0IGVuY29kZWQgPSBjb250cmFjdFBheWxvYWRzLm1hcChwID0+IHtcbiAgICAgIGlmIChpc0xlZ2FjeU5GVENvbnRyYWN0KSB7XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0O1xuICAgICAgICByZXR1cm4gY29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShcIm1pbnRXaXRoU2lnbmF0dXJlXCIsIFtwLm1lc3NhZ2UsIHAuc2lnbmF0dXJlXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb250cmFjdCA9IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdDtcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoXCJtaW50V2l0aFNpZ25hdHVyZVwiLCBbcC5tZXNzYWdlLCBwLnNpZ25hdHVyZV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5tdWx0aUNhbGwoZW5jb2RlZCk7XG4gICAgY29uc3QgZXZlbnRzID0gdGhpcy5jb250cmFjdFdyYXBwZXIucGFyc2VMb2dzKFwiVG9rZW5zTWludGVkV2l0aFNpZ25hdHVyZVwiLCByZWNlaXB0LmxvZ3MpO1xuICAgIGlmIChldmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBNaW50V2l0aFNpZ25hdHVyZSBldmVudCBmb3VuZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50cy5tYXAobG9nID0+ICh7XG4gICAgICBpZDogbG9nLmFyZ3MudG9rZW5JZE1pbnRlZCxcbiAgICAgIHJlY2VpcHRcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoYXQgYSBwYXlsb2FkIGlzIGNvcnJlY3RseSBzaWduZWRcbiAgICogQHBhcmFtIHNpZ25lZFBheWxvYWQgLSB0aGUgcGF5bG9hZCB0byB2ZXJpZnlcbiAgICogQHR3ZmVhdHVyZSBFUkM3MjFTaWduYXR1cmVNaW50XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgbmZ0TWV0YWRhdGEgPSB7XG4gICAqICAgbmFtZTogXCJDb29sIE5GVCAjMVwiLFxuICAgKiAgIGRlc2NyaXB0aW9uOiBcIlRoaXMgaXMgYSBjb29sIE5GVFwiLFxuICAgKiAgIGltYWdlOiBmcy5yZWFkRmlsZVN5bmMoXCJwYXRoL3RvL2ltYWdlLnBuZ1wiKSwgLy8gVGhpcyBjYW4gYmUgYW4gaW1hZ2UgdXJsIG9yIGZpbGVcbiAgICogfTtcbiAgICpcbiAgICogY29uc3Qgc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICogY29uc3QgZW5kVGltZSA9IG5ldyBEYXRlKERhdGUubm93KCkgKyA2MCAqIDYwICogMjQgKiAxMDAwKTtcbiAgICogY29uc3QgcGF5bG9hZCA9IHtcbiAgICogICBtZXRhZGF0YTogbmZ0TWV0YWRhdGEsIC8vIFRoZSBORlQgdG8gbWludFxuICAgKiAgIHRvOiB7e3dhbGxldF9hZGRyZXNzfX0sIC8vIFdobyB3aWxsIHJlY2VpdmUgdGhlIE5GVFxuICAgKiAgIHF1YW50aXR5OiAyLCAvLyB0aGUgcXVhbnRpdHkgb2YgTkZUcyB0byBtaW50XG4gICAqICAgcHJpY2U6IDAuNSwgLy8gdGhlIHByaWNlIHBlciBORlRcbiAgICogICBjdXJyZW5jeUFkZHJlc3M6IE5BVElWRV9UT0tFTl9BRERSRVNTLCAvLyB0aGUgY3VycmVuY3kgdG8gcGF5IHdpdGhcbiAgICogICBtaW50U3RhcnRUaW1lOiBzdGFydFRpbWUsIC8vIGNhbiBtaW50IGFueXRpbWUgZnJvbSBub3dcbiAgICogICBtaW50RW5kVGltZTogZW5kVGltZSwgLy8gdG8gMjRoIGZyb20gbm93XG4gICAqICAgcm95YWx0eVJlY2lwaWVudDogXCIweC4uLlwiLCAvLyBjdXN0b20gcm95YWx0eSByZWNpcGllbnQgZm9yIHRoaXMgTkZUXG4gICAqICAgcm95YWx0eUJwczogMTAwLCAvLyBjdXN0b20gcm95YWx0eSBmZWVzIGZvciB0aGlzIE5GVCAoaW4gYnBzKVxuICAgKiAgIHByaW1hcnlTYWxlUmVjaXBpZW50OiBcIjB4Li4uXCIsIC8vIGN1c3RvbSBzYWxlIHJlY2lwaWVudCBmb3IgdGhpcyBORlRcbiAgICogfTtcbiAgICpcbiAgICogY29uc3Qgc2lnbmVkUGF5bG9hZCA9IGF3YWl0IGNvbnRyYWN0LmVyYzcyMS5zaWduYXR1cmUuZ2VuZXJhdGUocGF5bG9hZCk7XG4gICAqIC8vIE5vdyB5b3UgY2FuIHZlcmlmeSBpZiB0aGUgc2lnbmVkIHBheWxvYWQgaXMgdmFsaWRcbiAgICogY29uc3QgaXNWYWxpZCA9IGF3YWl0IGNvbnRyYWN0LmVyYzcyMS5zaWduYXR1cmUudmVyaWZ5KHNpZ25lZFBheWxvYWQpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHZlcmlmeShzaWduZWRQYXlsb2FkKSB7XG4gICAgY29uc3QgaXNMZWdhY3lORlRDb250cmFjdCA9IGF3YWl0IHRoaXMuaXNMZWdhY3lORlRDb250cmFjdCgpO1xuICAgIGNvbnN0IG1pbnRSZXF1ZXN0ID0gc2lnbmVkUGF5bG9hZC5wYXlsb2FkO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ25lZFBheWxvYWQuc2lnbmF0dXJlO1xuICAgIGxldCBtZXNzYWdlO1xuICAgIGxldCB2ZXJpZmljYXRpb247XG4gICAgaWYgKGlzTGVnYWN5TkZUQ29udHJhY3QpIHtcbiAgICAgIGNvbnN0IGNvbnRyYWN0ID0gdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0O1xuICAgICAgbWVzc2FnZSA9IGF3YWl0IHRoaXMubWFwTGVnYWN5UGF5bG9hZFRvQ29udHJhY3RTdHJ1Y3QobWludFJlcXVlc3QpO1xuICAgICAgdmVyaWZpY2F0aW9uID0gYXdhaXQgY29udHJhY3QudmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbnRyYWN0ID0gdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0O1xuICAgICAgbWVzc2FnZSA9IGF3YWl0IHRoaXMubWFwUGF5bG9hZFRvQ29udHJhY3RTdHJ1Y3QobWludFJlcXVlc3QpO1xuICAgICAgdmVyaWZpY2F0aW9uID0gYXdhaXQgY29udHJhY3QudmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSk7XG4gICAgfVxuICAgIHJldHVybiB2ZXJpZmljYXRpb25bMF07XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBzaWduYXR1cmUgdGhhdCBjYW4gYmUgdXNlZCB0byBtaW50IGEgZHluYW1pYyBORlRcbiAgICpcbiAgICogQHJlbWFya3MgVGFrZXMgaW4gYW4gTkZUIGFuZCBzb21lIGluZm9ybWF0aW9uIGFib3V0IGhvdyBpdCBjYW4gYmUgbWludGVkLCB1cGxvYWRzIHRoZSBtZXRhZGF0YSBhbmQgc2lnbnMgaXQgd2l0aCB5b3VyIHByaXZhdGUga2V5LiBUaGUgZ2VuZXJhdGVkIHNpZ25hdHVyZSBjYW4gdGhlbiBiZSB1c2VkIHRvIG1pbnQgYW4gTkZUIHVzaW5nIHRoZSBleGFjdCBwYXlsb2FkIGFuZCBzaWduYXR1cmUgZ2VuZXJhdGVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IG5mdE1ldGFkYXRhID0ge1xuICAgKiAgIG5hbWU6IFwiQ29vbCBORlQgIzFcIixcbiAgICogICBkZXNjcmlwdGlvbjogXCJUaGlzIGlzIGEgY29vbCBORlRcIixcbiAgICogICBpbWFnZTogZnMucmVhZEZpbGVTeW5jKFwicGF0aC90by9pbWFnZS5wbmdcIiksIC8vIFRoaXMgY2FuIGJlIGFuIGltYWdlIHVybCBvciBmaWxlXG4gICAqIH07XG4gICAqXG4gICAqIGNvbnN0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAqIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgNjAgKiA2MCAqIDI0ICogMTAwMCk7XG4gICAqIGNvbnN0IHBheWxvYWQgPSB7XG4gICAqICAgbWV0YWRhdGE6IG5mdE1ldGFkYXRhLCAvLyBUaGUgTkZUIHRvIG1pbnRcbiAgICogICB0bzoge3t3YWxsZXRfYWRkcmVzc319LCAvLyBXaG8gd2lsbCByZWNlaXZlIHRoZSBORlRcbiAgICogICBxdWFudGl0eTogMiwgLy8gdGhlIHF1YW50aXR5IG9mIE5GVHMgdG8gbWludFxuICAgKiAgIHByaWNlOiAwLjUsIC8vIHRoZSBwcmljZSBwZXIgTkZUXG4gICAqICAgY3VycmVuY3lBZGRyZXNzOiBOQVRJVkVfVE9LRU5fQUREUkVTUywgLy8gdGhlIGN1cnJlbmN5IHRvIHBheSB3aXRoXG4gICAqICAgbWludFN0YXJ0VGltZTogc3RhcnRUaW1lLCAvLyBjYW4gbWludCBhbnl0aW1lIGZyb20gbm93XG4gICAqICAgbWludEVuZFRpbWU6IGVuZFRpbWUsIC8vIHRvIDI0aCBmcm9tIG5vd1xuICAgKiAgIHJveWFsdHlSZWNpcGllbnQ6IFwiMHguLi5cIiwgLy8gY3VzdG9tIHJveWFsdHkgcmVjaXBpZW50IGZvciB0aGlzIE5GVFxuICAgKiAgIHJveWFsdHlCcHM6IDEwMCwgLy8gY3VzdG9tIHJveWFsdHkgZmVlcyBmb3IgdGhpcyBORlQgKGluIGJwcylcbiAgICogICBwcmltYXJ5U2FsZVJlY2lwaWVudDogXCIweC4uLlwiLCAvLyBjdXN0b20gc2FsZSByZWNpcGllbnQgZm9yIHRoaXMgTkZUXG4gICAqIH07XG4gICAqXG4gICAqIGNvbnN0IHNpZ25lZFBheWxvYWQgPSBhd2FpdCBjb250cmFjdC5lcmM3MjEuc2lnbmF0dXJlLmdlbmVyYXRlKHBheWxvYWQpO1xuICAgKiAvLyBub3cgYW55b25lIGNhbiB1c2UgdGhlc2UgdG8gbWludCB0aGUgTkZUIHVzaW5nIGBjb250cmFjdC5lcmM3MjEuc2lnbmF0dXJlLm1pbnQoc2lnbmVkUGF5bG9hZClgXG4gICAqIGBgYFxuICAgKiBAcGFyYW0gbWludFJlcXVlc3QgLSB0aGUgcGF5bG9hZCB0byBzaWduXG4gICAqIEByZXR1cm5zIHRoZSBzaWduZWQgcGF5bG9hZCBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgc2lnbmF0dXJlXG4gICAqIEB0d2ZlYXR1cmUgRVJDNzIxU2lnbmF0dXJlTWludFxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGUobWludFJlcXVlc3QpIHtcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2VuZXJhdGVCYXRjaChbbWludFJlcXVlc3RdKSlbMF07XG4gIH1cblxuICAvKipcbiAgICogR2VucmF0ZSBhIGJhdGNoIG9mIHNpZ25hdHVyZXMgdGhhdCBjYW4gYmUgdXNlZCB0byBtaW50IG1hbnkgZHluYW1pYyBORlRzLlxuICAgKlxuICAgKiBAcmVtYXJrcyBTZWUge0BsaW5rIEVyYzcyMVdpdGhRdWFudGl0eVNpZ25hdHVyZU1pbnRhYmxlLmdlbmVyYXRlfVxuICAgKlxuICAgKiBAcGFyYW0gcGF5bG9hZHNUb1NpZ24gLSB0aGUgcGF5bG9hZHMgdG8gc2lnblxuICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBwYXlsb2FkcyBhbmQgc2lnbmF0dXJlc1xuICAgKiBAdHdmZWF0dXJlIEVSQzcyMVNpZ25hdHVyZU1pbnRcbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlQmF0Y2gocGF5bG9hZHNUb1NpZ24pIHtcbiAgICBjb25zdCBpc0xlZ2FjeU5GVENvbnRyYWN0ID0gYXdhaXQgdGhpcy5pc0xlZ2FjeU5GVENvbnRyYWN0KCk7XG4gICAgY29uc3QgcGFyc2VkUmVxdWVzdHMgPSBwYXlsb2Fkc1RvU2lnbi5tYXAobSA9PiBTaWduYXR1cmU3MjFXaXRoUXVhbnRpdHlJbnB1dC5wYXJzZShtKSk7XG4gICAgY29uc3QgbWV0YWRhdGFzID0gcGFyc2VkUmVxdWVzdHMubWFwKHIgPT4gci5tZXRhZGF0YSk7XG4gICAgY29uc3QgdXJpcyA9IGF3YWl0IHVwbG9hZE9yRXh0cmFjdFVSSXMobWV0YWRhdGFzLCB0aGlzLnN0b3JhZ2UpO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRDaGFpbklEKCk7XG4gICAgY29uc3Qgc2lnbmVyID0gdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0U2lnbmVyKCk7XG4gICAgaW52YXJpYW50KHNpZ25lciwgXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChwYXJzZWRSZXF1ZXN0cy5tYXAoYXN5bmMgKG0sIGkpID0+IHtcbiAgICAgIGNvbnN0IHVyaSA9IHVyaXNbaV07XG4gICAgICBjb25zdCBmaW5hbFBheWxvYWQgPSBTaWduYXR1cmU3MjFXaXRoUXVhbnRpdHlPdXRwdXQucGFyc2Uoe1xuICAgICAgICAuLi5tLFxuICAgICAgICB1cmlcbiAgICAgIH0pO1xuICAgICAgbGV0IHNpZ25hdHVyZTtcbiAgICAgIGlmIChpc0xlZ2FjeU5GVENvbnRyYWN0KSB7XG4gICAgICAgIHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNpZ25UeXBlZERhdGEoc2lnbmVyLCB7XG4gICAgICAgICAgbmFtZTogXCJUb2tlbkVSQzcyMVwiLFxuICAgICAgICAgIHZlcnNpb246IFwiMVwiLFxuICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgdmVyaWZ5aW5nQ29udHJhY3Q6IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5hZGRyZXNzXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBNaW50UmVxdWVzdDogTWludFJlcXVlc3Q3MjFcbiAgICAgICAgfSwgYXdhaXQgdGhpcy5tYXBMZWdhY3lQYXlsb2FkVG9Db250cmFjdFN0cnVjdChmaW5hbFBheWxvYWQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNpZ25UeXBlZERhdGEoc2lnbmVyLCB7XG4gICAgICAgICAgbmFtZTogXCJTaWduYXR1cmVNaW50RVJDNzIxXCIsXG4gICAgICAgICAgdmVyc2lvbjogXCIxXCIsXG4gICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICB2ZXJpZnlpbmdDb250cmFjdDogYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmFkZHJlc3NcbiAgICAgICAgfSwge1xuICAgICAgICAgIE1pbnRSZXF1ZXN0OiBNaW50UmVxdWVzdDcyMXdpdGhRdWFudGl0eVxuICAgICAgICB9LFxuICAgICAgICAvLyBUWVBFSEFTSFxuICAgICAgICBhd2FpdCB0aGlzLm1hcFBheWxvYWRUb0NvbnRyYWN0U3RydWN0KGZpbmFsUGF5bG9hZCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF5bG9hZDogZmluYWxQYXlsb2FkLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZS50b1N0cmluZygpXG4gICAgICB9O1xuICAgIH0pKTtcbiAgfVxuXG4gIC8qKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICogUFJJVkFURSBGVU5DVElPTlNcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIE1hcHMgYSBwYXlsb2FkIHRvIHRoZSBmb3JtYXQgZXhwZWN0ZWQgYnkgdGhlIGNvbnRyYWN0XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBAcGFyYW0gbWludFJlcXVlc3QgLSBUaGUgcGF5bG9hZCB0byBtYXAuXG4gICAqIEByZXR1cm5zIC0gVGhlIG1hcHBlZCBwYXlsb2FkLlxuICAgKi9cbiAgYXN5bmMgbWFwUGF5bG9hZFRvQ29udHJhY3RTdHJ1Y3QobWludFJlcXVlc3QpIHtcbiAgICBjb25zdCBub3JtYWxpemVkUHJpY2VQZXJUb2tlbiA9IGF3YWl0IG5vcm1hbGl6ZVByaWNlVmFsdWUodGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJvdmlkZXIoKSwgbWludFJlcXVlc3QucHJpY2UsIG1pbnRSZXF1ZXN0LmN1cnJlbmN5QWRkcmVzcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvOiBtaW50UmVxdWVzdC50byxcbiAgICAgIHJveWFsdHlSZWNpcGllbnQ6IG1pbnRSZXF1ZXN0LnJveWFsdHlSZWNpcGllbnQsXG4gICAgICByb3lhbHR5QnBzOiBtaW50UmVxdWVzdC5yb3lhbHR5QnBzLFxuICAgICAgcHJpbWFyeVNhbGVSZWNpcGllbnQ6IG1pbnRSZXF1ZXN0LnByaW1hcnlTYWxlUmVjaXBpZW50LFxuICAgICAgdXJpOiBtaW50UmVxdWVzdC51cmksXG4gICAgICBxdWFudGl0eTogbWludFJlcXVlc3QucXVhbnRpdHksXG4gICAgICBwcmljZVBlclRva2VuOiBub3JtYWxpemVkUHJpY2VQZXJUb2tlbixcbiAgICAgIGN1cnJlbmN5OiBtaW50UmVxdWVzdC5jdXJyZW5jeUFkZHJlc3MsXG4gICAgICB2YWxpZGl0eVN0YXJ0VGltZXN0YW1wOiBtaW50UmVxdWVzdC5taW50U3RhcnRUaW1lLFxuICAgICAgdmFsaWRpdHlFbmRUaW1lc3RhbXA6IG1pbnRSZXF1ZXN0Lm1pbnRFbmRUaW1lLFxuICAgICAgdWlkOiBtaW50UmVxdWVzdC51aWRcbiAgICB9O1xuICB9XG4gIGFzeW5jIG1hcExlZ2FjeVBheWxvYWRUb0NvbnRyYWN0U3RydWN0KG1pbnRSZXF1ZXN0KSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFByaWNlUGVyVG9rZW4gPSBhd2FpdCBub3JtYWxpemVQcmljZVZhbHVlKHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFByb3ZpZGVyKCksIG1pbnRSZXF1ZXN0LnByaWNlLCBtaW50UmVxdWVzdC5jdXJyZW5jeUFkZHJlc3MpO1xuICAgIHJldHVybiB7XG4gICAgICB0bzogbWludFJlcXVlc3QudG8sXG4gICAgICBwcmljZTogbm9ybWFsaXplZFByaWNlUGVyVG9rZW4sXG4gICAgICB1cmk6IG1pbnRSZXF1ZXN0LnVyaSxcbiAgICAgIGN1cnJlbmN5OiBtaW50UmVxdWVzdC5jdXJyZW5jeUFkZHJlc3MsXG4gICAgICB2YWxpZGl0eUVuZFRpbWVzdGFtcDogbWludFJlcXVlc3QubWludEVuZFRpbWUsXG4gICAgICB2YWxpZGl0eVN0YXJ0VGltZXN0YW1wOiBtaW50UmVxdWVzdC5taW50U3RhcnRUaW1lLFxuICAgICAgdWlkOiBtaW50UmVxdWVzdC51aWQsXG4gICAgICByb3lhbHR5UmVjaXBpZW50OiBtaW50UmVxdWVzdC5yb3lhbHR5UmVjaXBpZW50LFxuICAgICAgcm95YWx0eUJwczogbWludFJlcXVlc3Qucm95YWx0eUJwcyxcbiAgICAgIHByaW1hcnlTYWxlUmVjaXBpZW50OiBtaW50UmVxdWVzdC5wcmltYXJ5U2FsZVJlY2lwaWVudFxuICAgIH07XG4gIH1cbiAgYXN5bmMgaXNMZWdhY3lORlRDb250cmFjdCgpIHtcbiAgICBpZiAoaGFzRnVuY3Rpb24oXCJjb250cmFjdFR5cGVcIiwgdGhpcy5jb250cmFjdFdyYXBwZXIpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjb250cmFjdFR5cGUgPSBldGhlcnMudXRpbHMudG9VdGY4U3RyaW5nKGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5jb250cmFjdFR5cGUoKSk7XG4gICAgICAgIHJldHVybiBjb250cmFjdFR5cGUuaW5jbHVkZXMoXCJUb2tlbkVSQzcyMVwiKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU3RhbmRhcmQgRVJDNzIxIE5GVCBmdW5jdGlvbnNcbiAqIEByZW1hcmtzIEJhc2ljIGZ1bmN0aW9uYWxpdHkgZm9yIGEgRVJDNzIxIGNvbnRyYWN0IHRoYXQgaGFuZGxlcyBJUEZTIHN0b3JhZ2UgZm9yIHlvdS5cbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBjb250cmFjdCA9IGF3YWl0IHNkay5nZXRDb250cmFjdChcInt7Y29udHJhY3RfYWRkcmVzc319XCIpO1xuICogYXdhaXQgY29udHJhY3QuZXJjNzIxLnRyYW5zZmVyKHdhbGxldEFkZHJlc3MsIHRva2VuSWQpO1xuICogYGBgXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEVyYzcyMSB7XG4gIGdldCBjaGFpbklkKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFpbklkO1xuICB9XG4gIGNvbnN0cnVjdG9yKGNvbnRyYWN0V3JhcHBlciwgc3RvcmFnZSwgY2hhaW5JZCkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZlYXR1cmVOYW1lXCIsIEZFQVRVUkVfTkZULm5hbWUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInF1ZXJ5XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibWludGFibGVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJidXJuYWJsZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhenlNaW50YWJsZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRpZXJlZERyb3BhYmxlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2lnbmF0dXJlTWludGFibGVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250cmFjdFdyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yYWdlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NoYWluSWRcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlciA9IGNvbnRyYWN0V3JhcHBlcjtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgIHRoaXMucXVlcnkgPSB0aGlzLmRldGVjdEVyYzcyMUVudW1lcmFibGUoKTtcbiAgICB0aGlzLm1pbnRhYmxlID0gdGhpcy5kZXRlY3RFcmM3MjFNaW50YWJsZSgpO1xuICAgIHRoaXMuYnVybmFibGUgPSB0aGlzLmRldGVjdEVyYzcyMUJ1cm5hYmxlKCk7XG4gICAgdGhpcy5sYXp5TWludGFibGUgPSB0aGlzLmRldGVjdEVyYzcyMUxhenlNaW50YWJsZSgpO1xuICAgIHRoaXMudGllcmVkRHJvcGFibGUgPSB0aGlzLmRldGVjdEVyYzcyMVRpZXJlZERyb3AoKTtcbiAgICB0aGlzLnNpZ25hdHVyZU1pbnRhYmxlID0gdGhpcy5kZXRlY3RFcmM3MjFTaWduYXR1cmVNaW50YWJsZSgpO1xuICAgIHRoaXMuX2NoYWluSWQgPSBjaGFpbklkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb25OZXR3b3JrVXBkYXRlZChuZXR3b3JrKSB7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIudXBkYXRlU2lnbmVyT3JQcm92aWRlcihuZXR3b3JrKTtcbiAgfVxuICBnZXRBZGRyZXNzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuYWRkcmVzcztcbiAgfVxuXG4gIC8vLy8vLyBTdGFuZGFyZCBFUkM3MjEgRXh0ZW5zaW9uIC8vLy8vL1xuXG4gIC8qKlxuICAgKiBHZXQgYSBzaW5nbGUgTkZUIE1ldGFkYXRhXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgdG9rZW5JZCA9IDA7XG4gICAqIGNvbnN0IG5mdCA9IGF3YWl0IGNvbnRyYWN0LmVyYzcyMS5nZXQodG9rZW5JZCk7XG4gICAqIGBgYFxuICAgKiBAcGFyYW0gdG9rZW5JZCAtIHRoZSB0b2tlbklkIG9mIHRoZSBORlQgdG8gcmV0cmlldmVcbiAgICogQHJldHVybnMgVGhlIE5GVCBtZXRhZGF0YVxuICAgKiBAdHdmZWF0dXJlIEVSQzcyMVxuICAgKi9cbiAgYXN5bmMgZ2V0KHRva2VuSWQpIHtcbiAgICBjb25zdCBbb3duZXIsIG1ldGFkYXRhXSA9IGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLm93bmVyT2YodG9rZW5JZCkuY2F0Y2goKCkgPT4gY29uc3RhbnRzLkFkZHJlc3NaZXJvKSwgdGhpcy5nZXRUb2tlbk1ldGFkYXRhKHRva2VuSWQpLmNhdGNoKCgpID0+ICh7XG4gICAgICBpZDogdG9rZW5JZC50b1N0cmluZygpLFxuICAgICAgdXJpOiBcIlwiLFxuICAgICAgLi4uRkFMTEJBQ0tfTUVUQURBVEFcbiAgICB9KSldKTtcbiAgICByZXR1cm4ge1xuICAgICAgb3duZXIsXG4gICAgICBtZXRhZGF0YSxcbiAgICAgIHR5cGU6IFwiRVJDNzIxXCIsXG4gICAgICBzdXBwbHk6IDFcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBvd25lciBvZiBhIGdpdmVuIE5GVCB3aXRoaW4gdGhpcyBDb250cmFjdFxuICAgKlxuICAgKiBAcGFyYW0gdG9rZW5JZCAtIHRoZSB0b2tlbklkIG9mIHRoZSBORlRcbiAgICogQHJldHVybnMgdGhlIGFkZHJlc3Mgb2YgdGhlIG93bmVyXG4gICAqIEB0d2ZlYXR1cmUgRVJDNzIxXG4gICAqL1xuICBhc3luYyBvd25lck9mKHRva2VuSWQpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0Lm93bmVyT2YodG9rZW5JZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IE5GVCBCYWxhbmNlXG4gICAqXG4gICAqIEByZW1hcmtzIEdldCBhIHdhbGxldHMgTkZUIGJhbGFuY2UgKG51bWJlciBvZiBORlRzIGluIHRoaXMgY29udHJhY3Qgb3duZWQgYnkgdGhlIHdhbGxldCkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3Qgd2FsbGV0QWRkcmVzcyA9IFwie3t3YWxsZXRfYWRkcmVzc319XCI7XG4gICAqIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjb250cmFjdC5lcmM3MjEuYmFsYW5jZU9mKHdhbGxldEFkZHJlc3MpO1xuICAgKiBjb25zb2xlLmxvZyhiYWxhbmNlKTtcbiAgICogYGBgXG4gICAqIEB0d2ZlYXR1cmUgRVJDNzIxXG4gICAqL1xuICBhc3luYyBiYWxhbmNlT2YoYWRkcmVzcykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuYmFsYW5jZU9mKGFkZHJlc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBORlQgQmFsYW5jZSBmb3IgdGhlIGN1cnJlbnRseSBjb25uZWN0ZWQgd2FsbGV0XG4gICAqL1xuICBhc3luYyBiYWxhbmNlKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmJhbGFuY2VPZihhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRTaWduZXJBZGRyZXNzKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB3aGV0aGVyIHRoaXMgd2FsbGV0IGhhcyBhcHByb3ZlZCB0cmFuc2ZlcnMgZnJvbSB0aGUgZ2l2ZW4gb3BlcmF0b3JcbiAgICogQHBhcmFtIGFkZHJlc3MgLSB0aGUgd2FsbGV0IGFkZHJlc3NcbiAgICogQHBhcmFtIG9wZXJhdG9yIC0gdGhlIG9wZXJhdG9yIGFkZHJlc3NcbiAgICovXG4gIGFzeW5jIGlzQXBwcm92ZWQoYWRkcmVzcywgb3BlcmF0b3IpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmlzQXBwcm92ZWRGb3JBbGwoYWRkcmVzcywgb3BlcmF0b3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZmVyIGEgc2luZ2xlIE5GVFxuICAgKlxuICAgKiBAcmVtYXJrcyBUcmFuc2ZlciBhbiBORlQgZnJvbSB0aGUgY29ubmVjdGVkIHdhbGxldCB0byBhbm90aGVyIHdhbGxldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCB3YWxsZXRBZGRyZXNzID0gXCJ7e3dhbGxldF9hZGRyZXNzfX1cIjtcbiAgICogY29uc3QgdG9rZW5JZCA9IDA7XG4gICAqIGF3YWl0IGNvbnRyYWN0LmVyYzcyMS50cmFuc2Zlcih3YWxsZXRBZGRyZXNzLCB0b2tlbklkKTtcbiAgICogYGBgXG4gICAqIEB0d2ZlYXR1cmUgRVJDNzIxXG4gICAqL1xuICBhc3luYyB0cmFuc2Zlcih0bywgdG9rZW5JZCkge1xuICAgIGNvbnN0IGZyb20gPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRTaWduZXJBZGRyZXNzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNlbmRUcmFuc2FjdGlvbihcInNhZmVUcmFuc2ZlckZyb20oYWRkcmVzcyxhZGRyZXNzLHVpbnQyNTYpXCIsIFtmcm9tLCB0bywgdG9rZW5JZF0pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHByb3ZlIG9yIHJlbW92ZSBvcGVyYXRvciBhcyBhbiBvcGVyYXRvciBmb3IgdGhlIGNhbGxlci4gT3BlcmF0b3JzIGNhbiBjYWxsIHRyYW5zZmVyRnJvbSBvciBzYWZlVHJhbnNmZXJGcm9tIGZvciBhbnkgdG9rZW4gb3duZWQgYnkgdGhlIGNhbGxlci5cbiAgICogQHBhcmFtIG9wZXJhdG9yIC0gdGhlIG9wZXJhdG9yJ3MgYWRkcmVzc1xuICAgKiBAcGFyYW0gYXBwcm92ZWQgLSB3aGV0aGVyIHRvIGFwcHJvdmUgb3IgcmVtb3ZlXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgc2V0QXBwcm92YWxGb3JBbGwob3BlcmF0b3IsIGFwcHJvdmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNlbmRUcmFuc2FjdGlvbihcInNldEFwcHJvdmFsRm9yQWxsXCIsIFtvcGVyYXRvciwgYXBwcm92ZWRdKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQXBwcm92ZSBhbiBvcGVyYXRvciBmb3IgdGhlIE5GVCBvd25lci4gT3BlcmF0b3JzIGNhbiBjYWxsIHRyYW5zZmVyRnJvbSBvciBzYWZlVHJhbnNmZXJGcm9tIGZvciB0aGUgc3BlY2lmaWVkIHRva2VuLlxuICAgKiBAcGFyYW0gb3BlcmF0b3IgLSB0aGUgb3BlcmF0b3IncyBhZGRyZXNzXG4gICAqIEBwYXJhbSB0b2tlbklkIC0gdGhlIHRva2VuSWQgdG8gZ2l2ZSBhcHByb3ZhbCBmb3JcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBzZXRBcHByb3ZhbEZvclRva2VuKG9wZXJhdG9yLCB0b2tlbklkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNlbmRUcmFuc2FjdGlvbihcImFwcHJvdmVcIiwgW29wZXJhdG9yLCB0b2tlbklkXSlcbiAgICB9O1xuICB9XG5cbiAgLy8vLy8vIEVSQzcyMSBTdXBwbHkgRXh0ZW5zaW9uIC8vLy8vL1xuXG4gIC8qKlxuICAgKiBHZXQgQWxsIE1pbnRlZCBORlRzXG4gICAqXG4gICAqIEByZW1hcmtzIEdldCBhbGwgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGV2ZXJ5IE5GVCBpbiB0aGlzIGNvbnRyYWN0LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCByZXR1cm5zIHRoZSBmaXJzdCAxMDAgTkZUcywgdXNlIHF1ZXJ5UGFyYW1zIHRvIGZldGNoIG1vcmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgbmZ0cyA9IGF3YWl0IGNvbnRyYWN0LmVyYzcyMS5nZXRBbGwoKTtcbiAgICogY29uc29sZS5sb2cobmZ0cyk7XG4gICAqIGBgYFxuICAgKiBAcGFyYW0gcXVlcnlQYXJhbXMgLSBvcHRpb25hbCBmaWx0ZXJpbmcgdG8gb25seSBmZXRjaCBhIHN1YnNldCBvZiByZXN1bHRzLlxuICAgKiBAcmV0dXJucyBUaGUgTkZUIG1ldGFkYXRhIGZvciBhbGwgTkZUcyBxdWVyaWVkLlxuICAgKiBAdHdmZWF0dXJlIEVSQzcyMVN1cHBseVxuICAgKi9cbiAgYXN5bmMgZ2V0QWxsKHF1ZXJ5UGFyYW1zKSB7XG4gICAgcmV0dXJuIGFzc2VydEVuYWJsZWQodGhpcy5xdWVyeSwgRkVBVFVSRV9ORlRfU1VQUExZKS5hbGwocXVlcnlQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBBbGwgb3duZXJzIG9mIG1pbnRlZCBORlRzIG9uIHRoaXMgY29udHJhY3RcbiAgICogQHJldHVybnMgYW4gYXJyYXkgb2YgdG9rZW4gaWRzIGFuZCBvd25lcnNcbiAgICogQHR3ZmVhdHVyZSBFUkM3MjFTdXBwbHlcbiAgICovXG4gIGFzeW5jIGdldEFsbE93bmVycygpIHtcbiAgICByZXR1cm4gYXNzZXJ0RW5hYmxlZCh0aGlzLnF1ZXJ5LCBGRUFUVVJFX05GVF9TVVBQTFkpLmFsbE93bmVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyIG9mIE5GVHMgbWludGVkXG4gICAqIEByZW1hcmtzIFRoaXMgcmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIE5GVHMgbWludGVkIGluIHRoaXMgY29udHJhY3QsICoqbm90KiogdGhlIHRvdGFsIHN1cHBseSBvZiBhIGdpdmVuIHRva2VuLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIE5GVHMgbWludGVkIGluIHRoaXMgY29udHJhY3RcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYXN5bmMgdG90YWxDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW5JZFRvTWludCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdG90YWwgY291bnQgTkZUcyBtaW50ZWQgaW4gdGhpcyBjb250cmFjdFxuICAgKi9cbiAgYXN5bmMgdG90YWxDaXJjdWxhdGluZ1N1cHBseSgpIHtcbiAgICByZXR1cm4gYXNzZXJ0RW5hYmxlZCh0aGlzLnF1ZXJ5LCBGRUFUVVJFX05GVF9TVVBQTFkpLnRvdGFsQ2lyY3VsYXRpbmdTdXBwbHkoKTtcbiAgfVxuXG4gIC8vLy8vLyBFUkM3MjEgRW51bWVyYWJsZSBFeHRlbnNpb24gLy8vLy8vXG5cbiAgLyoqXG4gICAqIEdldCBPd25lZCBORlRzXG4gICAqXG4gICAqIEByZW1hcmtzIEdldCBhbGwgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBORlRzIG93bmVkIGJ5IGEgc3BlY2lmaWMgd2FsbGV0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIEFkZHJlc3Mgb2YgdGhlIHdhbGxldCB0byBnZXQgdGhlIE5GVHMgb2ZcbiAgICogY29uc3QgYWRkcmVzcyA9IFwie3t3YWxsZXRfYWRkcmVzc319XCI7XG4gICAqIGNvbnN0IG5mdHMgPSBhd2FpdCBjb250cmFjdC5lcmM3MjEuZ2V0T3duZWQoYWRkcmVzcyk7XG4gICAqIGNvbnNvbGUubG9nKG5mdHMpO1xuICAgKiBgYGBcbiAgICogQHBhcmFtIHdhbGxldEFkZHJlc3MgLSB0aGUgd2FsbGV0IGFkZHJlc3MgdG8gcXVlcnksIGRlZmF1bHRzIHRvIHRoZSBjb25uZWN0ZWQgd2FsbGV0XG4gICAqIEByZXR1cm5zIFRoZSBORlQgbWV0YWRhdGEgZm9yIGFsbCBORlRzIGluIHRoZSBjb250cmFjdC5cbiAgICogQHR3ZmVhdHVyZSBFUkM3MjFFbnVtZXJhYmxlXG4gICAqL1xuICBhc3luYyBnZXRPd25lZCh3YWxsZXRBZGRyZXNzKSB7XG4gICAgaWYgKHRoaXMucXVlcnk/Lm93bmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWVyeS5vd25lZC5hbGwod2FsbGV0QWRkcmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSB3YWxsZXRBZGRyZXNzIHx8IChhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRTaWduZXJBZGRyZXNzKCkpO1xuICAgICAgY29uc3QgYWxsT3duZXJzID0gYXdhaXQgdGhpcy5nZXRBbGxPd25lcnMoKTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCgoYWxsT3duZXJzIHx8IFtdKS5maWx0ZXIoaSA9PiBhZGRyZXNzPy50b0xvd2VyQ2FzZSgpID09PSBpLm93bmVyPy50b0xvd2VyQ2FzZSgpKS5tYXAoYXN5bmMgaSA9PiBhd2FpdCB0aGlzLmdldChpLnRva2VuSWQpKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgdG9rZW4gaWRzIG9mIE5GVHMgb3duZWQgYnkgYSBzcGVjaWZpYyB3YWxsZXQuXG4gICAqIEBwYXJhbSB3YWxsZXRBZGRyZXNzIC0gdGhlIHdhbGxldCBhZGRyZXNzIHRvIHF1ZXJ5LCBkZWZhdWx0cyB0byB0aGUgY29ubmVjdGVkIHdhbGxldFxuICAgKi9cbiAgYXN5bmMgZ2V0T3duZWRUb2tlbklkcyh3YWxsZXRBZGRyZXNzKSB7XG4gICAgaWYgKHRoaXMucXVlcnk/Lm93bmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWVyeS5vd25lZC50b2tlbklkcyh3YWxsZXRBZGRyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYWRkcmVzcyA9IHdhbGxldEFkZHJlc3MgfHwgKGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFNpZ25lckFkZHJlc3MoKSk7XG4gICAgICBjb25zdCBhbGxPd25lcnMgPSBhd2FpdCB0aGlzLmdldEFsbE93bmVycygpO1xuICAgICAgcmV0dXJuIChhbGxPd25lcnMgfHwgW10pLmZpbHRlcihpID0+IGFkZHJlc3M/LnRvTG93ZXJDYXNlKCkgPT09IGkub3duZXI/LnRvTG93ZXJDYXNlKCkpLm1hcChpID0+IEJpZ051bWJlci5mcm9tKGkudG9rZW5JZCkpO1xuICAgIH1cbiAgfVxuXG4gIC8vLy8vLyBFUkM3MjEgTWludGFibGUgRXh0ZW5zaW9uIC8vLy8vL1xuXG4gIC8qKlxuICAgKiBNaW50IGEgdW5pcXVlIE5GVFxuICAgKlxuICAgKiBAcmVtYXJrcyBNaW50IGEgdW5pcXVlIE5GVCB0byB0aGUgY29ubmVjdGVkIHdhbGxldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBDdXN0b20gbWV0YWRhdGEgb2YgdGhlIE5GVCwgbm90ZSB0aGF0IHlvdSBjYW4gZnVsbHkgY3VzdG9taXplIHRoaXMgbWV0YWRhdGEgd2l0aCBvdGhlciBwcm9wZXJ0aWVzLlxuICAgKiBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICogICBuYW1lOiBcIkNvb2wgTkZUXCIsXG4gICAqICAgZGVzY3JpcHRpb246IFwiVGhpcyBpcyBhIGNvb2wgTkZUXCIsXG4gICAqICAgaW1hZ2U6IGZzLnJlYWRGaWxlU3luYyhcInBhdGgvdG8vaW1hZ2UucG5nXCIpLCAvLyBUaGlzIGNhbiBiZSBhbiBpbWFnZSB1cmwgb3IgZmlsZVxuICAgKiB9O1xuICAgKlxuICAgKiBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmVyYzcyMS5taW50KG1ldGFkYXRhKTtcbiAgICogY29uc3QgcmVjZWlwdCA9IHR4LnJlY2VpcHQ7IC8vIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0XG4gICAqIGNvbnN0IHRva2VuSWQgPSB0eC5pZDsgLy8gdGhlIGlkIG9mIHRoZSBORlQgbWludGVkXG4gICAqIGNvbnN0IG5mdCA9IGF3YWl0IHR4LmRhdGEoKTsgLy8gKG9wdGlvbmFsKSBmZXRjaCBkZXRhaWxzIG9mIG1pbnRlZCBORlRcbiAgICogYGBgXG4gICAqIEB0d2ZlYXR1cmUgRVJDNzIxTWludGFibGVcbiAgICovXG4gIGFzeW5jIG1pbnQobWV0YWRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5taW50VG8oYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0U2lnbmVyQWRkcmVzcygpLCBtZXRhZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogTWludCBhIHVuaXF1ZSBORlRcbiAgICpcbiAgICogQHJlbWFya3MgTWludCBhIHVuaXF1ZSBORlQgdG8gYSBzcGVjaWZpZWQgd2FsbGV0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIEFkZHJlc3Mgb2YgdGhlIHdhbGxldCB5b3Ugd2FudCB0byBtaW50IHRoZSBORlQgdG9cbiAgICogY29uc3Qgd2FsbGV0QWRkcmVzcyA9IFwie3t3YWxsZXRfYWRkcmVzc319XCI7XG4gICAqXG4gICAqIC8vIEN1c3RvbSBtZXRhZGF0YSBvZiB0aGUgTkZULCBub3RlIHRoYXQgeW91IGNhbiBmdWxseSBjdXN0b21pemUgdGhpcyBtZXRhZGF0YSB3aXRoIG90aGVyIHByb3BlcnRpZXMuXG4gICAqIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgKiAgIG5hbWU6IFwiQ29vbCBORlRcIixcbiAgICogICBkZXNjcmlwdGlvbjogXCJUaGlzIGlzIGEgY29vbCBORlRcIixcbiAgICogICBpbWFnZTogZnMucmVhZEZpbGVTeW5jKFwicGF0aC90by9pbWFnZS5wbmdcIiksIC8vIFRoaXMgY2FuIGJlIGFuIGltYWdlIHVybCBvciBmaWxlXG4gICAqIH07XG4gICAqXG4gICAqIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuZXJjNzIxLm1pbnRUbyh3YWxsZXRBZGRyZXNzLCBtZXRhZGF0YSk7XG4gICAqIGNvbnN0IHJlY2VpcHQgPSB0eC5yZWNlaXB0OyAvLyB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdFxuICAgKiBjb25zdCB0b2tlbklkID0gdHguaWQ7IC8vIHRoZSBpZCBvZiB0aGUgTkZUIG1pbnRlZFxuICAgKiBjb25zdCBuZnQgPSBhd2FpdCB0eC5kYXRhKCk7IC8vIChvcHRpb25hbCkgZmV0Y2ggZGV0YWlscyBvZiBtaW50ZWQgTkZUXG4gICAqIGBgYFxuICAgKiBAdHdmZWF0dXJlIEVSQzcyMU1pbnRhYmxlXG4gICAqL1xuICBhc3luYyBtaW50VG8ocmVjZWl2ZXIsIG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIGFzc2VydEVuYWJsZWQodGhpcy5taW50YWJsZSwgRkVBVFVSRV9ORlRfTUlOVEFCTEUpLnRvKHJlY2VpdmVyLCBtZXRhZGF0YSk7XG4gIH1cblxuICAvLy8vLy8gRVJDNzIxIEJhdGNoIE1pbnRhYmxlIEV4dGVuc2lvbiAvLy8vLy9cblxuICAvKipcbiAgICogTWludCBNYW55IHVuaXF1ZSBORlRzXG4gICAqXG4gICAqIEByZW1hcmtzIE1pbnQgbWFueSB1bmlxdWUgTkZUcyBhdCBvbmNlIHRvIHRoZSBjb25uZWN0ZWQgd2FsbGV0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHQqXG4gICAqIC8vIEN1c3RvbSBtZXRhZGF0YSBvZiB0aGUgTkZUcyB5b3Ugd2FudCB0byBtaW50LlxuICAgKiBjb25zdCBtZXRhZGF0YXMgPSBbe1xuICAgKiAgIG5hbWU6IFwiQ29vbCBORlQgIzFcIixcbiAgICogICBkZXNjcmlwdGlvbjogXCJUaGlzIGlzIGEgY29vbCBORlRcIixcbiAgICogICBpbWFnZTogZnMucmVhZEZpbGVTeW5jKFwicGF0aC90by9pbWFnZS5wbmdcIiksIC8vIFRoaXMgY2FuIGJlIGFuIGltYWdlIHVybCBvciBmaWxlXG4gICAqIH0sIHtcbiAgICogICBuYW1lOiBcIkNvb2wgTkZUICMyXCIsXG4gICAqICAgZGVzY3JpcHRpb246IFwiVGhpcyBpcyBhIGNvb2wgTkZUXCIsXG4gICAqICAgaW1hZ2U6IGZzLnJlYWRGaWxlU3luYyhcInBhdGgvdG8vb3RoZXIvaW1hZ2UucG5nXCIpLFxuICAgKiB9XTtcbiAgICpcbiAgICogY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5lcmM3MjEubWludEJhdGNoKG1ldGFkYXRhcyk7XG4gICAqIGNvbnN0IHJlY2VpcHQgPSB0eFswXS5yZWNlaXB0OyAvLyBzYW1lIHRyYW5zYWN0aW9uIHJlY2VpcHQgZm9yIGFsbCBtaW50ZWQgTkZUc1xuICAgKiBjb25zdCBmaXJzdFRva2VuSWQgPSB0eFswXS5pZDsgLy8gdG9rZW4gaWQgb2YgdGhlIGZpcnN0IG1pbnRlZCBORlRcbiAgICogY29uc3QgZmlyc3RORlQgPSBhd2FpdCB0eFswXS5kYXRhKCk7IC8vIChvcHRpb25hbCkgZmV0Y2ggZGV0YWlscyBvZiB0aGUgZmlyc3QgbWludGVkIE5GVFxuICAgKiBgYGBcbiAgICogQHR3ZmVhdHVyZSBFUkM3MjFCYXRjaE1pbnRhYmxlXG4gICAqL1xuICBhc3luYyBtaW50QmF0Y2gobWV0YWRhdGFzKSB7XG4gICAgcmV0dXJuIHRoaXMubWludEJhdGNoVG8oYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0U2lnbmVyQWRkcmVzcygpLCBtZXRhZGF0YXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1pbnQgTWFueSB1bmlxdWUgTkZUc1xuICAgKlxuICAgKiBAcmVtYXJrcyBNaW50IG1hbnkgdW5pcXVlIE5GVHMgYXQgb25jZSB0byBhIHNwZWNpZmllZCB3YWxsZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gQWRkcmVzcyBvZiB0aGUgd2FsbGV0IHlvdSB3YW50IHRvIG1pbnQgdGhlIE5GVCB0b1xuICAgKiBjb25zdCB3YWxsZXRBZGRyZXNzID0gXCJ7e3dhbGxldF9hZGRyZXNzfX1cIjtcbiAgICpcbiAgICogLy8gQ3VzdG9tIG1ldGFkYXRhIG9mIHRoZSBORlRzIHlvdSB3YW50IHRvIG1pbnQuXG4gICAqIGNvbnN0IG1ldGFkYXRhcyA9IFt7XG4gICAqICAgbmFtZTogXCJDb29sIE5GVCAjMVwiLFxuICAgKiAgIGRlc2NyaXB0aW9uOiBcIlRoaXMgaXMgYSBjb29sIE5GVFwiLFxuICAgKiAgIGltYWdlOiBmcy5yZWFkRmlsZVN5bmMoXCJwYXRoL3RvL2ltYWdlLnBuZ1wiKSwgLy8gVGhpcyBjYW4gYmUgYW4gaW1hZ2UgdXJsIG9yIGZpbGVcbiAgICogfSwge1xuICAgKiAgIG5hbWU6IFwiQ29vbCBORlQgIzJcIixcbiAgICogICBkZXNjcmlwdGlvbjogXCJUaGlzIGlzIGEgY29vbCBORlRcIixcbiAgICogICBpbWFnZTogZnMucmVhZEZpbGVTeW5jKFwicGF0aC90by9vdGhlci9pbWFnZS5wbmdcIiksXG4gICAqIH1dO1xuICAgKlxuICAgKiBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmVyYzcyMS5taW50QmF0Y2hUbyh3YWxsZXRBZGRyZXNzLCBtZXRhZGF0YXMpO1xuICAgKiBjb25zdCByZWNlaXB0ID0gdHhbMF0ucmVjZWlwdDsgLy8gc2FtZSB0cmFuc2FjdGlvbiByZWNlaXB0IGZvciBhbGwgbWludGVkIE5GVHNcbiAgICogY29uc3QgZmlyc3RUb2tlbklkID0gdHhbMF0uaWQ7IC8vIHRva2VuIGlkIG9mIHRoZSBmaXJzdCBtaW50ZWQgTkZUXG4gICAqIGNvbnN0IGZpcnN0TkZUID0gYXdhaXQgdHhbMF0uZGF0YSgpOyAvLyAob3B0aW9uYWwpIGZldGNoIGRldGFpbHMgb2YgdGhlIGZpcnN0IG1pbnRlZCBORlRcbiAgICogYGBgXG4gICAqIEB0d2ZlYXR1cmUgRVJDNzIxQmF0Y2hNaW50YWJsZVxuICAgKi9cbiAgYXN5bmMgbWludEJhdGNoVG8ocmVjZWl2ZXIsIG1ldGFkYXRhcykge1xuICAgIHJldHVybiBhc3NlcnRFbmFibGVkKHRoaXMubWludGFibGU/LmJhdGNoLCBGRUFUVVJFX05GVF9CQVRDSF9NSU5UQUJMRSkudG8ocmVjZWl2ZXIsIG1ldGFkYXRhcyk7XG4gIH1cblxuICAvLy8vLy8gRVJDNzIxIEJ1cm5hYmxlIEV4dGVuc2lvbiAvLy8vLy9cblxuICAvKipcbiAgICogQnVybiBhIHNpbmdsZSBORlRcbiAgICogQHBhcmFtIHRva2VuSWQgLSB0aGUgdG9rZW4gSWQgdG8gYnVyblxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbnRyYWN0LmVyYzcyMS5idXJuKHRva2VuSWQpO1xuICAgKiBgYGBcbiAgICogQHR3ZmVhdHVyZSBFUkM3MjFCdXJuYWJsZVxuICAgKi9cbiAgYXN5bmMgYnVybih0b2tlbklkKSB7XG4gICAgcmV0dXJuIGFzc2VydEVuYWJsZWQodGhpcy5idXJuYWJsZSwgRkVBVFVSRV9ORlRfQlVSTkFCTEUpLnRva2VuKHRva2VuSWQpO1xuICB9XG5cbiAgLy8vLy8vIEVSQzcyMSBMYXp5TWludCBFeHRlbnNpb24gLy8vLy8vXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGJhdGNoIG9mIHVuaXF1ZSBORlRzIHRvIGJlIGNsYWltZWQgaW4gdGhlIGZ1dHVyZVxuICAgKlxuICAgKiBAcmVtYXJrcyBDcmVhdGUgYmF0Y2ggYWxsb3dzIHlvdSB0byBjcmVhdGUgYSBiYXRjaCBvZiBtYW55IHVuaXF1ZSBORlRzIGluIG9uZSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBDdXN0b20gbWV0YWRhdGEgb2YgdGhlIE5GVHMgdG8gY3JlYXRlXG4gICAqIGNvbnN0IG1ldGFkYXRhcyA9IFt7XG4gICAqICAgbmFtZTogXCJDb29sIE5GVFwiLFxuICAgKiAgIGRlc2NyaXB0aW9uOiBcIlRoaXMgaXMgYSBjb29sIE5GVFwiLFxuICAgKiAgIGltYWdlOiBmcy5yZWFkRmlsZVN5bmMoXCJwYXRoL3RvL2ltYWdlLnBuZ1wiKSwgLy8gVGhpcyBjYW4gYmUgYW4gaW1hZ2UgdXJsIG9yIGZpbGVcbiAgICogfSwge1xuICAgKiAgIG5hbWU6IFwiQ29vbCBORlRcIixcbiAgICogICBkZXNjcmlwdGlvbjogXCJUaGlzIGlzIGEgY29vbCBORlRcIixcbiAgICogICBpbWFnZTogZnMucmVhZEZpbGVTeW5jKFwicGF0aC90by9pbWFnZS5wbmdcIiksXG4gICAqIH1dO1xuICAgKlxuICAgKiBjb25zdCByZXN1bHRzID0gYXdhaXQgY29udHJhY3QuZXJjNzIxLmxhenlNaW50KG1ldGFkYXRhcyk7IC8vIHVwbG9hZHMgYW5kIGNyZWF0ZXMgdGhlIE5GVHMgb24gY2hhaW5cbiAgICogY29uc3QgZmlyc3RUb2tlbklkID0gcmVzdWx0c1swXS5pZDsgLy8gdG9rZW4gaWQgb2YgdGhlIGZpcnN0IGNyZWF0ZWQgTkZUXG4gICAqIGNvbnN0IGZpcnN0TkZUID0gYXdhaXQgcmVzdWx0c1swXS5kYXRhKCk7IC8vIChvcHRpb25hbCkgZmV0Y2ggZGV0YWlscyBvZiB0aGUgZmlyc3QgY3JlYXRlZCBORlRcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBtZXRhZGF0YXMgLSBUaGUgbWV0YWRhdGEgdG8gaW5jbHVkZSBpbiB0aGUgYmF0Y2guXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9uYWwgdXBsb2FkIHByb2dyZXNzIGNhbGxiYWNrXG4gICAqIEB0d2ZlYXR1cmUgRVJDNzIxTGF6eU1pbnRhYmxlXG4gICAqL1xuICBhc3luYyBsYXp5TWludChtZXRhZGF0YXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXNzZXJ0RW5hYmxlZCh0aGlzLmxhenlNaW50YWJsZSwgRkVBVFVSRV9ORlRfTEFaWV9NSU5UQUJMRSkubGF6eU1pbnQobWV0YWRhdGFzLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vLy8vLyBFUkM3MjEgQ2xhaW1hYmxlIEV4dGVuc2lvbiAvLy8vLy9cblxuICAvKipcbiAgICogQ2xhaW0gdW5pcXVlIE5GVHMgdG8gdGhlIGNvbm5lY3RlZCB3YWxsZXRcbiAgICpcbiAgICogQHJlbWFya3MgTGV0IHRoZSBzcGVjaWZpZWQgd2FsbGV0IGNsYWltIE5GVHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgcXVhbnRpdHkgPSAxOyAvLyBob3cgbWFueSB1bmlxdWUgTkZUcyB5b3Ugd2FudCB0byBjbGFpbVxuICAgKlxuICAgKiBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmVyYzcyMS5jbGFpbShxdWFudGl0eSk7XG4gICAqIGNvbnN0IHJlY2VpcHQgPSB0eC5yZWNlaXB0OyAvLyB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdFxuICAgKiBjb25zdCBjbGFpbWVkVG9rZW5JZCA9IHR4LmlkOyAvLyB0aGUgaWQgb2YgdGhlIE5GVCBjbGFpbWVkXG4gICAqIGNvbnN0IGNsYWltZWRORlQgPSBhd2FpdCB0eC5kYXRhKCk7IC8vIChvcHRpb25hbCkgZ2V0IHRoZSBjbGFpbWVkIE5GVCBtZXRhZGF0YVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHF1YW50aXR5IC0gUXVhbnRpdHkgb2YgdGhlIHRva2VucyB5b3Ugd2FudCB0byBjbGFpbVxuICAgKlxuICAgKiBAcmV0dXJucyAtIGFuIGFycmF5IG9mIHJlc3VsdHMgY29udGFpbmluZyB0aGUgaWQgb2YgdGhlIHRva2VuIGNsYWltZWQsIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0IGFuZCBhIHByb21pc2UgdG8gb3B0aW9uYWxseSBmZXRjaCB0aGUgbmZ0IG1ldGFkYXRhXG4gICAqIEB0d2ZlYXR1cmUgRVJDNzIxQ2xhaW1hYmxlXG4gICAqL1xuICBhc3luYyBjbGFpbShxdWFudGl0eSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNsYWltVG8oYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0U2lnbmVyQWRkcmVzcygpLCBxdWFudGl0eSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xhaW0gdW5pcXVlIE5GVHMgdG8gYSBzcGVjaWZpYyBXYWxsZXRcbiAgICpcbiAgICogQHJlbWFya3MgTGV0IHRoZSBzcGVjaWZpZWQgd2FsbGV0IGNsYWltIE5GVHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgYWRkcmVzcyA9IFwie3t3YWxsZXRfYWRkcmVzc319XCI7IC8vIGFkZHJlc3Mgb2YgdGhlIHdhbGxldCB5b3Ugd2FudCB0byBjbGFpbSB0aGUgTkZUc1xuICAgKiBjb25zdCBxdWFudGl0eSA9IDE7IC8vIGhvdyBtYW55IHVuaXF1ZSBORlRzIHlvdSB3YW50IHRvIGNsYWltXG4gICAqXG4gICAqIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuZXJjNzIxLmNsYWltVG8oYWRkcmVzcywgcXVhbnRpdHkpO1xuICAgKiBjb25zdCByZWNlaXB0ID0gdHgucmVjZWlwdDsgLy8gdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRcbiAgICogY29uc3QgY2xhaW1lZFRva2VuSWQgPSB0eC5pZDsgLy8gdGhlIGlkIG9mIHRoZSBORlQgY2xhaW1lZFxuICAgKiBjb25zdCBjbGFpbWVkTkZUID0gYXdhaXQgdHguZGF0YSgpOyAvLyAob3B0aW9uYWwpIGdldCB0aGUgY2xhaW1lZCBORlQgbWV0YWRhdGFcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBkZXN0aW5hdGlvbkFkZHJlc3MgLSBBZGRyZXNzIHlvdSB3YW50IHRvIHNlbmQgdGhlIHRva2VuIHRvXG4gICAqIEBwYXJhbSBxdWFudGl0eSAtIFF1YW50aXR5IG9mIHRoZSB0b2tlbnMgeW91IHdhbnQgdG8gY2xhaW1cbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQHR3ZmVhdHVyZSBFUkM3MjFDbGFpbWFibGVcbiAgICogQHJldHVybnMgLSBhbiBhcnJheSBvZiByZXN1bHRzIGNvbnRhaW5pbmcgdGhlIGlkIG9mIHRoZSB0b2tlbiBjbGFpbWVkLCB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdCBhbmQgYSBwcm9taXNlIHRvIG9wdGlvbmFsbHkgZmV0Y2ggdGhlIG5mdCBtZXRhZGF0YVxuICAgKi9cbiAgYXN5bmMgY2xhaW1UbyhkZXN0aW5hdGlvbkFkZHJlc3MsIHF1YW50aXR5LCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2xhaW1XaXRoQ29uZGl0aW9ucyA9IHRoaXMubGF6eU1pbnRhYmxlPy5jbGFpbVdpdGhDb25kaXRpb25zO1xuICAgIGNvbnN0IGNsYWltID0gdGhpcy5sYXp5TWludGFibGU/LmNsYWltO1xuICAgIGlmIChjbGFpbVdpdGhDb25kaXRpb25zKSB7XG4gICAgICByZXR1cm4gY2xhaW1XaXRoQ29uZGl0aW9ucy50byhkZXN0aW5hdGlvbkFkZHJlc3MsIHF1YW50aXR5LCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKGNsYWltKSB7XG4gICAgICByZXR1cm4gY2xhaW0udG8oZGVzdGluYXRpb25BZGRyZXNzLCBxdWFudGl0eSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFeHRlbnNpb25Ob3RJbXBsZW1lbnRlZEVycm9yKEZFQVRVUkVfTkZUX0NMQUlNX0NVU1RPTSk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgY2xhaW0gdHJhbnNhY3Rpb24gd2l0aG91dCBleGVjdXRpbmcgaXQuXG4gICAqIFRoaXMgaXMgdXNlZnVsIGZvciBlc3RpbWF0aW5nIHRoZSBnYXMgY29zdCBvZiBhIGNsYWltIHRyYW5zYWN0aW9uLCBvdmVycmlkaW5nIHRyYW5zYWN0aW9uIG9wdGlvbnMgYW5kIGhhdmluZyBmaW5lIGdyYWluZWQgY29udHJvbCBvdmVyIHRoZSB0cmFuc2FjdGlvbiBleGVjdXRpb24uXG4gICAqIEBwYXJhbSBkZXN0aW5hdGlvbkFkZHJlc3NcbiAgICogQHBhcmFtIHF1YW50aXR5XG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBhc3luYyBnZXRDbGFpbVRyYW5zYWN0aW9uKGRlc3RpbmF0aW9uQWRkcmVzcywgcXVhbnRpdHksIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjbGFpbVdpdGhDb25kaXRpb25zID0gdGhpcy5sYXp5TWludGFibGU/LmNsYWltV2l0aENvbmRpdGlvbnM7XG4gICAgY29uc3QgY2xhaW0gPSB0aGlzLmxhenlNaW50YWJsZT8uY2xhaW07XG4gICAgaWYgKGNsYWltV2l0aENvbmRpdGlvbnMpIHtcbiAgICAgIHJldHVybiBjbGFpbVdpdGhDb25kaXRpb25zLmNvbmRpdGlvbnMuZ2V0Q2xhaW1UcmFuc2FjdGlvbihkZXN0aW5hdGlvbkFkZHJlc3MsIHF1YW50aXR5LCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKGNsYWltKSB7XG4gICAgICByZXR1cm4gY2xhaW0uZ2V0Q2xhaW1UcmFuc2FjdGlvbihkZXN0aW5hdGlvbkFkZHJlc3MsIHF1YW50aXR5LCBvcHRpb25zKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEV4dGVuc2lvbk5vdEltcGxlbWVudGVkRXJyb3IoRkVBVFVSRV9ORlRfQ0xBSU1fQ1VTVE9NKTtcbiAgfVxuICBhc3luYyB0b3RhbENsYWltZWRTdXBwbHkoKSB7XG4gICAgY29uc3QgY29udHJhY3QgPSB0aGlzLmNvbnRyYWN0V3JhcHBlcjtcbiAgICBpZiAoaGFzRnVuY3Rpb24oXCJuZXh0VG9rZW5JZFRvQ2xhaW1cIiwgY29udHJhY3QpKSB7XG4gICAgICByZXR1cm4gY29udHJhY3QucmVhZENvbnRyYWN0Lm5leHRUb2tlbklkVG9DbGFpbSgpO1xuICAgIH1cbiAgICBpZiAoaGFzRnVuY3Rpb24oXCJ0b3RhbE1pbnRlZFwiLCBjb250cmFjdCkpIHtcbiAgICAgIHJldHVybiBjb250cmFjdC5yZWFkQ29udHJhY3QudG90YWxNaW50ZWQoKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZnVuY3Rpb24gZm91bmQgb24gY29udHJhY3QgdG8gZ2V0IHRvdGFsIGNsYWltZWQgc3VwcGx5XCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdW5jbGFpbWVkIHN1cHBseVxuICAgKlxuICAgKiBAcmVtYXJrcyBHZXQgdGhlIG51bWJlciBvZiB1bmNsYWltZWQgTkZUcyBpbiB0aGlzIERyb3AuXG4gICAqXG4gICAqICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCB1bmNsYWltZWRORlRDb3VudCA9IGF3YWl0IGNvbnRyYWN0LnRvdGFsVW5jbGFpbWVkU3VwcGx5KCk7XG4gICAqIGNvbnNvbGUubG9nKGBORlRzIGxlZnQgdG8gY2xhaW06ICR7dW5jbGFpbWVkTkZUQ291bnR9YCk7XG4gICAqIGBgYFxuICAgKiBAcmV0dXJucyB0aGUgdW5jbGFpbWVkIHN1cHBseVxuICAgKi9cbiAgYXN5bmMgdG90YWxVbmNsYWltZWRTdXBwbHkoKSB7XG4gICAgcmV0dXJuIChhd2FpdCB0aGlzLm5leHRUb2tlbklkVG9NaW50KCkpLnN1Yihhd2FpdCB0aGlzLnRvdGFsQ2xhaW1lZFN1cHBseSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmUgY2xhaW0gY29uZGl0aW9uc1xuICAgKiBAcmVtYXJrcyBEZWZpbmUgd2hvIGNhbiBjbGFpbSBORlRzIGluIHRoZSBjb2xsZWN0aW9uLCB3aGVuIGFuZCBob3cgbWFueS5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBwcmVzYWxlU3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICogY29uc3QgcHVibGljU2FsZVN0YXJ0VGltZSA9IG5ldyBEYXRlKERhdGUubm93KCkgKyA2MCAqIDYwICogMjQgKiAxMDAwKTtcbiAgICogY29uc3QgY2xhaW1Db25kaXRpb25zID0gW1xuICAgKiAgIHtcbiAgICogICAgIHN0YXJ0VGltZTogcHJlc2FsZVN0YXJ0VGltZSwgLy8gc3RhcnQgdGhlIHByZXNhbGUgbm93XG4gICAqICAgICBtYXhRdWFudGl0eTogMiwgLy8gbGltaXQgaG93IG1hbnkgbWludHMgZm9yIHRoaXMgcHJlc2FsZVxuICAgKiAgICAgcHJpY2U6IDAuMDEsIC8vIHByZXNhbGUgcHJpY2VcbiAgICogICAgIHNuYXBzaG90OiBbJzB4Li4uJywgJzB4Li4uJ10sIC8vIGxpbWl0IG1pbnRpbmcgdG8gb25seSBjZXJ0YWluIGFkZHJlc3Nlc1xuICAgKiAgIH0sXG4gICAqICAge1xuICAgKiAgICAgc3RhcnRUaW1lOiBwdWJsaWNTYWxlU3RhcnRUaW1lLCAvLyAyNGggYWZ0ZXIgcHJlc2FsZSwgc3RhcnQgcHVibGljIHNhbGVcbiAgICogICAgIHByaWNlOiAwLjA4LCAvLyBwdWJsaWMgc2FsZSBwcmljZVxuICAgKiAgIH1cbiAgICogXSk7XG4gICAqIGF3YWl0IGNvbnRyYWN0LmVyYzcyMS5jbGFpbUNvbmRpdGlvbnMuc2V0KGNsYWltQ29uZGl0aW9ucyk7XG4gICAqIGBgYFxuICAgKiBAdHdmZWF0dXJlIEVSQzcyMUNsYWltYWJsZVdpdGhDb25kaXRpb25zXG4gICAqL1xuICBnZXQgY2xhaW1Db25kaXRpb25zKCkge1xuICAgIHJldHVybiBhc3NlcnRFbmFibGVkKHRoaXMubGF6eU1pbnRhYmxlPy5jbGFpbVdpdGhDb25kaXRpb25zLCBGRUFUVVJFX05GVF9DTEFJTV9DT05ESVRJT05TX1YyKS5jb25kaXRpb25zO1xuICB9XG5cbiAgLy8vLy8vIEVSQzcyMSBUaWVyZWQgRHJvcCBFeHRlbnNpb24gLy8vLy8vXG5cbiAgLyoqXG4gICAqIFRpZXJlZCBEcm9wXG4gICAqIEByZW1hcmtzIERyb3AgbGF6eSBtaW50ZWQgTkZUcyB1c2luZyBhIHRpZXJlZCBkcm9wIG1lY2hhbmlzbS5cbiAgICovXG4gIGdldCB0aWVyZWREcm9wKCkge1xuICAgIHJldHVybiBhc3NlcnRFbmFibGVkKHRoaXMudGllcmVkRHJvcGFibGUsIEZFQVRVUkVfTkZUX1RJRVJFRF9EUk9QKTtcbiAgfVxuXG4gIC8vLy8vLyBFUkM3MjEgU2lnbmF0dXJlTWludCBFeHRlbnNpb24gLy8vLy8vXG5cbiAgLyoqXG4gICAqIFNpZ25hdHVyZSBNaW50aW5nXG4gICAqIEByZW1hcmtzIEdlbmVyYXRlIGR5bmFtaWMgTkZUcyB3aXRoIHlvdXIgb3duIHNpZ25hdHVyZSwgYW5kIGxldCBvdGhlcnMgbWludCB0aGVtIHVzaW5nIHRoYXQgc2lnbmF0dXJlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIHNlZSBob3cgdG8gY3JhZnQgYSBwYXlsb2FkIHRvIHNpZ24gaW4gdGhlIGBjb250cmFjdC5lcmM3MjEuc2lnbmF0dXJlLmdlbmVyYXRlKClgIGRvY3VtZW50YXRpb25cbiAgICogY29uc3Qgc2lnbmVkUGF5bG9hZCA9IGNvbnRyYWN0LmVyYzcyMS5zaWduYXR1cmUoKS5nZW5lcmF0ZShwYXlsb2FkKTtcbiAgICpcbiAgICogLy8gbm93IGFueW9uZSBjYW4gbWludCB0aGUgTkZUXG4gICAqIGNvbnN0IHR4ID0gY29udHJhY3QuZXJjNzIxLnNpZ25hdHVyZS5taW50KHNpZ25lZFBheWxvYWQpO1xuICAgKiBjb25zdCByZWNlaXB0ID0gdHgucmVjZWlwdDsgLy8gdGhlIG1pbnQgdHJhbnNhY3Rpb24gcmVjZWlwdFxuICAgKiBjb25zdCBtaW50ZWRJZCA9IHR4LmlkOyAvLyB0aGUgaWQgb2YgdGhlIE5GVCBtaW50ZWRcbiAgICogYGBgXG4gICAqIEB0d2ZlYXR1cmUgRVJDNzIxU2lnbmF0dXJlTWludFxuICAgKi9cbiAgZ2V0IHNpZ25hdHVyZSgpIHtcbiAgICByZXR1cm4gYXNzZXJ0RW5hYmxlZCh0aGlzLnNpZ25hdHVyZU1pbnRhYmxlLCBGRUFUVVJFX05GVF9TSUdOQVRVUkVfTUlOVEFCTEVfVjIpO1xuICB9XG5cbiAgLy8vLy8vIEVSQzcyMSBEZWxheWVkUmV2ZWFsIEV4dGVuc2lvbiAvLy8vLy9cblxuICAvKipcbiAgICogRGVsYXllZCByZXZlYWxcbiAgICogQHJlbWFya3MgQ3JlYXRlIGEgYmF0Y2ggb2YgZW5jcnlwdGVkIE5GVHMgdGhhdCBjYW4gYmUgcmV2ZWFsZWQgYXQgYSBsYXRlciB0aW1lLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIHRoZSByZWFsIE5GVHMsIHRoZXNlIHdpbGwgYmUgZW5jcnlwdGVkIHVudGlsIHlvdSByZXZlYWwgdGhlbVxuICAgKiBjb25zdCByZWFsTkZUcyA9IFt7XG4gICAqICAgbmFtZTogXCJDb21tb24gTkZUICMxXCIsXG4gICAqICAgZGVzY3JpcHRpb246IFwiQ29tbW9uIE5GVCwgb25lIG9mIG1hbnkuXCIsXG4gICAqICAgaW1hZ2U6IGZzLnJlYWRGaWxlU3luYyhcInBhdGgvdG8vaW1hZ2UucG5nXCIpLFxuICAgKiB9LCB7XG4gICAqICAgbmFtZTogXCJTdXBlciBSYXJlIE5GVCAjMlwiLFxuICAgKiAgIGRlc2NyaXB0aW9uOiBcIllvdSBnb3QgYSBTdXBlciBSYXJlIE5GVCFcIixcbiAgICogICBpbWFnZTogZnMucmVhZEZpbGVTeW5jKFwicGF0aC90by9pbWFnZS5wbmdcIiksXG4gICAqIH1dO1xuICAgKiAvLyBBIHBsYWNlaG9sZGVyIE5GVCB0aGF0IHBlb3BsZSB3aWxsIGdldCBpbW1lZGlhdGVseSBpbiB0aGVpciB3YWxsZXQsIGFuZCB3aWxsIGJlIGNvbnZlcnRlZCB0byB0aGUgcmVhbCBORlQgYXQgcmV2ZWFsIHRpbWVcbiAgICogY29uc3QgcGxhY2Vob2xkZXJORlQgPSB7XG4gICAqICAgbmFtZTogXCJIaWRkZW4gTkZUXCIsXG4gICAqICAgZGVzY3JpcHRpb246IFwiV2lsbCBiZSByZXZlYWxlZCBuZXh0IHdlZWshXCJcbiAgICogfTtcbiAgICogLy8gQ3JlYXRlIGFuZCBlbmNyeXB0IHRoZSBORlRzXG4gICAqIGF3YWl0IGNvbnRyYWN0LmVyYzcyMS5yZXZlYWxlci5jcmVhdGVEZWxheWVkUmV2ZWFsQmF0Y2goXG4gICAqICAgcGxhY2Vob2xkZXJORlQsXG4gICAqICAgcmVhbE5GVHMsXG4gICAqICAgXCJteSBzZWNyZXQgcGFzc3dvcmRcIixcbiAgICogKTtcbiAgICogLy8gV2hlbmV2ZXIgeW91J3JlIHJlYWR5LCByZXZlYWwgeW91ciBORlRzIGF0IGFueSB0aW1lXG4gICAqIGNvbnN0IGJhdGNoSWQgPSAwOyAvLyB0aGUgYmF0Y2ggdG8gcmV2ZWFsXG4gICAqIGF3YWl0IGNvbnRyYWN0LmVyYzcyMS5yZXZlYWxlci5yZXZlYWwoYmF0Y2hJZCwgXCJteSBzZWNyZXQgcGFzc3dvcmRcIik7XG4gICAqIGBgYFxuICAgKiBAdHdmZWF0dXJlIEVSQzcyMVJldmVhbGFibGVcbiAgICovXG4gIGdldCByZXZlYWxlcigpIHtcbiAgICByZXR1cm4gYXNzZXJ0RW5hYmxlZCh0aGlzLmxhenlNaW50YWJsZT8ucmV2ZWFsZXIsIEZFQVRVUkVfTkZUX1JFVkVBTEFCTEUpO1xuICB9XG5cbiAgLyoqICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBQUklWQVRFIEZVTkNUSU9OU1xuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBnZXRUb2tlbk1ldGFkYXRhKHRva2VuSWQpIHtcbiAgICBjb25zdCB0b2tlblVyaSA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC50b2tlblVSSSh0b2tlbklkKTtcbiAgICBpZiAoIXRva2VuVXJpKSB7XG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gZmV0Y2hUb2tlbk1ldGFkYXRhKHRva2VuSWQsIHRva2VuVXJpLCB0aGlzLnN0b3JhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbmV4dCBhdmFpbGFibGUgdG9rZW4gSUQgdG8gbWludFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIG5leHRUb2tlbklkVG9NaW50KCkge1xuICAgIGlmIChoYXNGdW5jdGlvbihcIm5leHRUb2tlbklkVG9NaW50XCIsIHRoaXMuY29udHJhY3RXcmFwcGVyKSkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5uZXh0VG9rZW5JZFRvTWludCgpO1xuICAgIH0gZWxzZSBpZiAoaGFzRnVuY3Rpb24oXCJ0b3RhbFN1cHBseVwiLCB0aGlzLmNvbnRyYWN0V3JhcHBlcikpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QudG90YWxTdXBwbHkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udHJhY3QgcmVxdWlyZXMgZWl0aGVyIGBuZXh0VG9rZW5JZFRvTWludGAgb3IgYHRvdGFsU3VwcGx5YCBmdW5jdGlvbiBhdmFpbGFibGUgdG8gZGV0ZXJtaW5lIHRoZSBuZXh0IHRva2VuIElEIHRvIG1pbnRcIik7XG4gICAgfVxuICB9XG4gIGRldGVjdEVyYzcyMUVudW1lcmFibGUoKSB7XG4gICAgaWYgKGRldGVjdENvbnRyYWN0RmVhdHVyZSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgXCJFUkM3MjFTdXBwbHlcIikgfHwgaGFzRnVuY3Rpb24oXCJuZXh0VG9rZW5JZFRvTWludFwiLCB0aGlzLmNvbnRyYWN0V3JhcHBlcikpIHtcbiAgICAgIHJldHVybiBuZXcgRXJjNzIxU3VwcGx5KHRoaXMsIHRoaXMuY29udHJhY3RXcmFwcGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBkZXRlY3RFcmM3MjFNaW50YWJsZSgpIHtcbiAgICBpZiAoZGV0ZWN0Q29udHJhY3RGZWF0dXJlKHRoaXMuY29udHJhY3RXcmFwcGVyLCBcIkVSQzcyMU1pbnRhYmxlXCIpKSB7XG4gICAgICByZXR1cm4gbmV3IEVyYzcyMU1pbnRhYmxlKHRoaXMsIHRoaXMuY29udHJhY3RXcmFwcGVyLCB0aGlzLnN0b3JhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGRldGVjdEVyYzcyMUJ1cm5hYmxlKCkge1xuICAgIGlmIChkZXRlY3RDb250cmFjdEZlYXR1cmUodGhpcy5jb250cmFjdFdyYXBwZXIsIFwiRVJDNzIxQnVybmFibGVcIikpIHtcbiAgICAgIHJldHVybiBuZXcgRXJjNzIxQnVybmFibGUodGhpcy5jb250cmFjdFdyYXBwZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGRldGVjdEVyYzcyMUxhenlNaW50YWJsZSgpIHtcbiAgICBpZiAoZGV0ZWN0Q29udHJhY3RGZWF0dXJlKHRoaXMuY29udHJhY3RXcmFwcGVyLCBcIkVSQzcyMUxhenlNaW50YWJsZVwiKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcmM3MjFMYXp5TWludGFibGUodGhpcywgdGhpcy5jb250cmFjdFdyYXBwZXIsIHRoaXMuc3RvcmFnZSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgZGV0ZWN0RXJjNzIxVGllcmVkRHJvcCgpIHtcbiAgICBpZiAoZGV0ZWN0Q29udHJhY3RGZWF0dXJlKHRoaXMuY29udHJhY3RXcmFwcGVyLCBcIkVSQzcyMVRpZXJlZERyb3BcIikpIHtcbiAgICAgIHJldHVybiBuZXcgRXJjNzIxVGllcmVkRHJvcCh0aGlzLCB0aGlzLmNvbnRyYWN0V3JhcHBlciwgdGhpcy5zdG9yYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBkZXRlY3RFcmM3MjFTaWduYXR1cmVNaW50YWJsZSgpIHtcbiAgICBpZiAoZGV0ZWN0Q29udHJhY3RGZWF0dXJlKHRoaXMuY29udHJhY3RXcmFwcGVyLCBcIkVSQzcyMVNpZ25hdHVyZU1pbnRWMVwiKSB8fCBkZXRlY3RDb250cmFjdEZlYXR1cmUodGhpcy5jb250cmFjdFdyYXBwZXIsIFwiRVJDNzIxU2lnbmF0dXJlTWludFYyXCIpKSB7XG4gICAgICByZXR1cm4gbmV3IEVyYzcyMVdpdGhRdWFudGl0eVNpZ25hdHVyZU1pbnRhYmxlKHRoaXMuY29udHJhY3RXcmFwcGVyLCB0aGlzLnN0b3JhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU3RhbmRhcmQgRVJDNzIxIE5GVCBmdW5jdGlvbnNcbiAqIEByZW1hcmtzIEJhc2ljIGZ1bmN0aW9uYWxpdHkgZm9yIGEgRVJDNzIxIGNvbnRyYWN0IHRoYXQgaGFuZGxlcyBJUEZTIHN0b3JhZ2UgZm9yIHlvdS5cbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBjb250cmFjdCA9IGF3YWl0IHNkay5nZXRDb250cmFjdChcInt7Y29udHJhY3RfYWRkcmVzc319XCIpO1xuICogYXdhaXQgY29udHJhY3QubmZ0LnRyYW5zZmVyKHdhbGxldEFkZHJlc3MsIHRva2VuSWQpO1xuICogYGBgXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFN0YW5kYXJkRXJjNzIxIHtcbiAgZ2V0IGNoYWluSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYWluSWQ7XG4gIH1cbiAgY29uc3RydWN0b3IoY29udHJhY3RXcmFwcGVyLCBzdG9yYWdlLCBjaGFpbklkKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcmFnZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVyYzcyMVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jaGFpbklkXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIgPSBjb250cmFjdFdyYXBwZXI7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICB0aGlzLmVyYzcyMSA9IG5ldyBFcmM3MjEodGhpcy5jb250cmFjdFdyYXBwZXIsIHRoaXMuc3RvcmFnZSwgY2hhaW5JZCk7XG4gICAgdGhpcy5fY2hhaW5JZCA9IGNoYWluSWQ7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBvbk5ldHdvcmtVcGRhdGVkKG5ldHdvcmspIHtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlci51cGRhdGVTaWduZXJPclByb3ZpZGVyKG5ldHdvcmspO1xuICB9XG4gIGdldEFkZHJlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5hZGRyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBBbGwgTWludGVkIE5GVHNcbiAgICpcbiAgICogQHJlbWFya3MgR2V0IGFsbCB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggZXZlcnkgTkZUIGluIHRoaXMgY29udHJhY3QuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHJldHVybnMgdGhlIGZpcnN0IDEwMCBORlRzLCB1c2UgcXVlcnlQYXJhbXMgdG8gZmV0Y2ggbW9yZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBuZnRzID0gYXdhaXQgY29udHJhY3QuZ2V0QWxsKCk7XG4gICAqIGNvbnNvbGUubG9nKG5mdHMpO1xuICAgKiBgYGBcbiAgICogQHBhcmFtIHF1ZXJ5UGFyYW1zIC0gb3B0aW9uYWwgZmlsdGVyaW5nIHRvIG9ubHkgZmV0Y2ggYSBzdWJzZXQgb2YgcmVzdWx0cy5cbiAgICogQHJldHVybnMgVGhlIE5GVCBtZXRhZGF0YSBmb3IgYWxsIE5GVHMgcXVlcmllZC5cbiAgICovXG4gIGFzeW5jIGdldEFsbChxdWVyeVBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLmVyYzcyMS5nZXRBbGwocXVlcnlQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBPd25lZCBORlRzXG4gICAqXG4gICAqIEByZW1hcmtzIEdldCBhbGwgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBORlRzIG93bmVkIGJ5IGEgc3BlY2lmaWMgd2FsbGV0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIEFkZHJlc3Mgb2YgdGhlIHdhbGxldCB0byBnZXQgdGhlIE5GVHMgb2ZcbiAgICogY29uc3QgYWRkcmVzcyA9IFwie3t3YWxsZXRfYWRkcmVzc319XCI7XG4gICAqIGNvbnN0IG5mdHMgPSBhd2FpdCBjb250cmFjdC5nZXRPd25lZChhZGRyZXNzKTtcbiAgICogY29uc29sZS5sb2cobmZ0cyk7XG4gICAqIGBgYFxuICAgKiBAcGFyYW0gd2FsbGV0QWRkcmVzcyAtIHRoZSB3YWxsZXQgYWRkcmVzcyB0byBxdWVyeSwgZGVmYXVsdHMgdG8gdGhlIGNvbm5lY3RlZCB3YWxsZXRcbiAgICogQHJldHVybnMgVGhlIE5GVCBtZXRhZGF0YSBmb3IgYWxsIE5GVHMgaW4gdGhlIGNvbnRyYWN0LlxuICAgKi9cbiAgYXN5bmMgZ2V0T3duZWQod2FsbGV0QWRkcmVzcykge1xuICAgIHJldHVybiB0aGlzLmVyYzcyMS5nZXRPd25lZCh3YWxsZXRBZGRyZXNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgT3duZWQgVG9rZW4gSWRzXG4gICAqIEByZW1hcmtzIEdldCBhbGwgdGhlIHRva2VuIGlkcyBvZiBORlRzIG93bmVkIGJ5IGEgc3BlY2lmaWMgd2FsbGV0IChubyBtZXRhZGF0YSlcbiAgICovXG4gIGFzeW5jIGdldE93bmVkVG9rZW5JZHMod2FsbGV0QWRkcmVzcykge1xuICAgIHJldHVybiB0aGlzLmVyYzcyMS5nZXRPd25lZFRva2VuSWRzKHdhbGxldEFkZHJlc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdG90YWwgY291bnQgTkZUcyBtaW50ZWQgaW4gdGhpcyBjb250cmFjdFxuICAgKi9cbiAgYXN5bmMgdG90YWxTdXBwbHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXJjNzIxLnRvdGFsQ2lyY3VsYXRpbmdTdXBwbHkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBzaW5nbGUgTkZUIE1ldGFkYXRhXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgdG9rZW5JZCA9IDA7XG4gICAqIGNvbnN0IG5mdCA9IGF3YWl0IGNvbnRyYWN0LmdldCh0b2tlbklkKTtcbiAgICogYGBgXG4gICAqIEBwYXJhbSB0b2tlbklkIC0gdGhlIHRva2VuSWQgb2YgdGhlIE5GVCB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJucyBUaGUgTkZUIG1ldGFkYXRhXG4gICAqL1xuICBhc3luYyBnZXQodG9rZW5JZCkge1xuICAgIHJldHVybiB0aGlzLmVyYzcyMS5nZXQodG9rZW5JZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IG93bmVyIG9mIGEgZ2l2ZW4gTkZUIHdpdGhpbiB0aGlzIENvbnRyYWN0XG4gICAqXG4gICAqIEBwYXJhbSB0b2tlbklkIC0gdGhlIHRva2VuSWQgb2YgdGhlIE5GVFxuICAgKiBAcmV0dXJucyB0aGUgYWRkcmVzcyBvZiB0aGUgb3duZXJcbiAgICovXG4gIGFzeW5jIG93bmVyT2YodG9rZW5JZCkge1xuICAgIHJldHVybiB0aGlzLmVyYzcyMS5vd25lck9mKHRva2VuSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBORlQgQmFsYW5jZVxuICAgKlxuICAgKiBAcmVtYXJrcyBHZXQgYSB3YWxsZXRzIE5GVCBiYWxhbmNlIChudW1iZXIgb2YgTkZUcyBpbiB0aGlzIGNvbnRyYWN0IG93bmVkIGJ5IHRoZSB3YWxsZXQpLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IHdhbGxldEFkZHJlc3MgPSBcInt7d2FsbGV0X2FkZHJlc3N9fVwiO1xuICAgKiBjb25zdCBiYWxhbmNlID0gYXdhaXQgY29udHJhY3QuYmFsYW5jZU9mKHdhbGxldEFkZHJlc3MpO1xuICAgKiBjb25zb2xlLmxvZyhiYWxhbmNlKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBiYWxhbmNlT2YoYWRkcmVzcykge1xuICAgIHJldHVybiB0aGlzLmVyYzcyMS5iYWxhbmNlT2YoYWRkcmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IE5GVCBCYWxhbmNlIGZvciB0aGUgY3VycmVudGx5IGNvbm5lY3RlZCB3YWxsZXRcbiAgICovXG4gIGFzeW5jIGJhbGFuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXJjNzIxLmJhbGFuY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciB0aGlzIHdhbGxldCBoYXMgYXBwcm92ZWQgdHJhbnNmZXJzIGZyb20gdGhlIGdpdmVuIG9wZXJhdG9yXG4gICAqIEBwYXJhbSBhZGRyZXNzIC0gdGhlIHdhbGxldCBhZGRyZXNzXG4gICAqIEBwYXJhbSBvcGVyYXRvciAtIHRoZSBvcGVyYXRvciBhZGRyZXNzXG4gICAqL1xuICBhc3luYyBpc0FwcHJvdmVkKGFkZHJlc3MsIG9wZXJhdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuZXJjNzIxLmlzQXBwcm92ZWQoYWRkcmVzcywgb3BlcmF0b3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZmVyIGEgc2luZ2xlIE5GVFxuICAgKlxuICAgKiBAcmVtYXJrcyBUcmFuc2ZlciBhbiBORlQgZnJvbSB0aGUgY29ubmVjdGVkIHdhbGxldCB0byBhbm90aGVyIHdhbGxldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCB3YWxsZXRBZGRyZXNzID0gXCJ7e3dhbGxldF9hZGRyZXNzfX1cIjtcbiAgICogY29uc3QgdG9rZW5JZCA9IDA7XG4gICAqIGF3YWl0IGNvbnRyYWN0LnRyYW5zZmVyKHdhbGxldEFkZHJlc3MsIHRva2VuSWQpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHRyYW5zZmVyKHRvLCB0b2tlbklkKSB7XG4gICAgcmV0dXJuIHRoaXMuZXJjNzIxLnRyYW5zZmVyKHRvLCB0b2tlbklkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHByb3ZlIG9yIHJlbW92ZSBvcGVyYXRvciBhcyBhbiBvcGVyYXRvciBmb3IgdGhlIGNhbGxlci4gT3BlcmF0b3JzIGNhbiBjYWxsIHRyYW5zZmVyRnJvbSBvciBzYWZlVHJhbnNmZXJGcm9tIGZvciBhbnkgdG9rZW4gb3duZWQgYnkgdGhlIGNhbGxlci5cbiAgICogQHBhcmFtIG9wZXJhdG9yIC0gdGhlIG9wZXJhdG9yJ3MgYWRkcmVzc1xuICAgKiBAcGFyYW0gYXBwcm92ZWQgLSB3aGV0aGVyIHRvIGFwcHJvdmUgb3IgcmVtb3ZlXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgc2V0QXBwcm92YWxGb3JBbGwob3BlcmF0b3IsIGFwcHJvdmVkKSB7XG4gICAgcmV0dXJuIHRoaXMuZXJjNzIxLnNldEFwcHJvdmFsRm9yQWxsKG9wZXJhdG9yLCBhcHByb3ZlZCk7XG4gIH1cblxuICAvKipcbiAgICogQXBwcm92ZSBhbiBvcGVyYXRvciBmb3IgdGhlIE5GVCBvd25lci4gT3BlcmF0b3JzIGNhbiBjYWxsIHRyYW5zZmVyRnJvbSBvciBzYWZlVHJhbnNmZXJGcm9tIGZvciB0aGUgc3BlY2lmaWVkIHRva2VuLlxuICAgKiBAcGFyYW0gb3BlcmF0b3IgLSB0aGUgb3BlcmF0b3IncyBhZGRyZXNzXG4gICAqIEBwYXJhbSB0b2tlbklkIC0gdGhlIHRva2VuSWQgdG8gZ2l2ZSBhcHByb3ZhbCBmb3JcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBzZXRBcHByb3ZhbEZvclRva2VuKG9wZXJhdG9yLCB0b2tlbklkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNlbmRUcmFuc2FjdGlvbihcImFwcHJvdmVcIiwgW29wZXJhdG9yLCB0b2tlbklkXSlcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEFpcmRyb3BBZGRyZXNzSW5wdXQgPSB6Lm9iamVjdCh7XG4gIGFkZHJlc3M6IEFkZHJlc3NTY2hlbWEsXG4gIHF1YW50aXR5OiBBbW91bnRTY2hlbWEuZGVmYXVsdCgxKVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEFpcmRyb3BJbnB1dFNjaGVtYSA9IHoudW5pb24oW3ouYXJyYXkoei5zdHJpbmcoKSkudHJhbnNmb3JtKHN0cmluZ3MgPT4gc3RyaW5ncy5tYXAoYWRkcmVzcyA9PiBBaXJkcm9wQWRkcmVzc0lucHV0LnBhcnNlKHtcbiAgYWRkcmVzc1xufSkpKSwgei5hcnJheShBaXJkcm9wQWRkcmVzc0lucHV0KV0pO1xuXG5jbGFzcyBFcmMxMTU1QnVybmFibGUge1xuICBjb25zdHJ1Y3Rvcihjb250cmFjdFdyYXBwZXIpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmZWF0dXJlTmFtZVwiLCBGRUFUVVJFX0VESVRJT05fQlVSTkFCTEUubmFtZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIgPSBjb250cmFjdFdyYXBwZXI7XG4gIH1cblxuICAvKipcbiAgICogQnVybiBhIHNwZWNpZmllZCBhbW91bnQgb2YgYSBORlRzXG4gICAqXG4gICAqIEByZW1hcmtzIEJ1cm4gdGhlIHNwZWNpZmllZCBORlRzIGZyb20gdGhlIGNvbm5lY3RlZCB3YWxsZXRcbiAgICpcbiAgICogQHBhcmFtIHRva2VuSWQgLSB0aGUgdG9rZW4gSWQgdG8gYnVyblxuICAgKiBAcGFyYW0gYW1vdW50IC0gYW1vdW50IHRvIGJ1cm5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBUaGUgdG9rZW4gSUQgdG8gYnVybiBORlRzIG9mXG4gICAqIGNvbnN0IHRva2VuSWQgPSAwO1xuICAgKiAvLyBUaGUgYW1vdW50IG9mIHRoZSBORlQgeW91IHdhbnQgdG8gYnVyblxuICAgKiBjb25zdCBhbW91bnQgPSAyO1xuICAgKlxuICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBjb250cmFjdC5lZGl0aW9uLmJ1cm4udG9rZW5zKHRva2VuSWQsIGFtb3VudCk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgdG9rZW5zKHRva2VuSWQsIGFtb3VudCkge1xuICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRTaWduZXJBZGRyZXNzKCk7XG4gICAgcmV0dXJuIHRoaXMuZnJvbShhY2NvdW50LCB0b2tlbklkLCBhbW91bnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1cm4gYSBzcGVjaWZpZWQgYW1vdW50IG9mIGEgTkZUc1xuICAgKlxuICAgKiBAcmVtYXJrcyBCdXJuIHRoZSBzcGVjaWZpZWQgTkZUcyBmcm9tIGEgc3BlY2lmaWVkIHdhbGxldFxuICAgKlxuICAgKiBAcGFyYW0gYWNjb3VudCAtIHRoZSBhZGRyZXNzIHRvIGJ1cm4gTkZUcyBmcm9tXG4gICAqIEBwYXJhbSB0b2tlbklkIC0gdGhlIHRva2VuSWQgdG8gYnVyblxuICAgKiBAcGFyYW0gYW1vdW50IC0gYW1vdW50IHRvIGJ1cm5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBUaGUgYWRkcmVzcyBvZiB0aGUgd2FsbGV0IHRvIGJ1cm4gTkZUUyBmcm9tXG4gICAqIGNvbnN0IGFjY291bnQgPSBcIjB4Li4uXCI7XG4gICAqIC8vIFRoZSB0b2tlbiBJRCB0byBidXJuIE5GVHMgb2ZcbiAgICogY29uc3QgdG9rZW5JZCA9IDA7XG4gICAqIC8vIFRoZSBhbW91bnQgb2YgdGhpcyBORlQgeW91IHdhbnQgdG8gYnVyblxuICAgKiBjb25zdCBhbW91bnQgPSAyO1xuICAgKlxuICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBjb250cmFjdC5lZGl0aW9uLmJ1cm4uZnJvbShhY2NvdW50LCB0b2tlbklkLCBhbW91bnQpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGZyb20oYWNjb3VudCwgdG9rZW5JZCwgYW1vdW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNlbmRUcmFuc2FjdGlvbihcImJ1cm5cIiwgW2FjY291bnQsIHRva2VuSWQsIGFtb3VudF0pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdXJuIGEgYmF0Y2ggb2YgTkZUc1xuICAgKlxuICAgKiBAcmVtYXJrcyBCdXJuIHRoZSBiYXRjaCBORlRzIGZyb20gdGhlIGNvbm5lY3RlZCB3YWxsZXRcbiAgICpcbiAgICogQHBhcmFtIHRva2VuSWRzIC0gdGhlIHRva2VuSWRzIHRvIGJ1cm5cbiAgICogQHBhcmFtIGFtb3VudHMgLSBhbW91bnQgb2YgZWFjaCB0b2tlbiB0byBidXJuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gVGhlIHRva2VuIElEcyB0byBidXJuIE5GVHMgb2ZcbiAgICogY29uc3QgdG9rZW5JZHMgPSBbMCwgMV07XG4gICAqIC8vIFRoZSBhbW91bnRzIG9mIGVhY2ggTkZUIHlvdSB3YW50IHRvIGJ1cm5cbiAgICogY29uc3QgYW1vdW50cyA9IFsyLCAyXTtcbiAgICpcbiAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgY29udHJhY3QuZWRpdGlvbi5idXJuLmJhdGNoKHRva2VuSWRzLCBhbW91bnRzKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBiYXRjaCh0b2tlbklkcywgYW1vdW50cykge1xuICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRTaWduZXJBZGRyZXNzKCk7XG4gICAgcmV0dXJuIHRoaXMuYmF0Y2hGcm9tKGFjY291bnQsIHRva2VuSWRzLCBhbW91bnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdXJuIGEgYmF0Y2ggb2YgTkZUc1xuICAgKlxuICAgKiBAcmVtYXJrcyBCdXJuIHRoZSBiYXRjaCBORlRzIGZyb20gdGhlIHNwZWNpZmllZCB3YWxsZXRcbiAgICpcbiAgICogQHBhcmFtIGFjY291bnQgLSB0aGUgYWRkcmVzcyB0byBidXJuIE5GVHMgZnJvbVxuICAgKiBAcGFyYW0gdG9rZW5JZHMgLSB0aGUgdG9rZW5JZHMgdG8gYnVyblxuICAgKiBAcGFyYW0gYW1vdW50cyAtIGFtb3VudCBvZiBlYWNoIHRva2VuIHRvIGJ1cm5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBUaGUgYWRkcmVzcyBvZiB0aGUgd2FsbGV0IHRvIGJ1cm4gTkZUUyBmcm9tXG4gICAqIGNvbnN0IGFjY291bnQgPSBcIjB4Li4uXCI7XG4gICAqIC8vIFRoZSB0b2tlbiBJRHMgdG8gYnVybiBORlRzIG9mXG4gICAqIGNvbnN0IHRva2VuSWRzID0gWzAsIDFdO1xuICAgKiAvLyBUaGUgYW1vdW50cyBvZiBlYWNoIE5GVCB5b3Ugd2FudCB0byBidXJuXG4gICAqIGNvbnN0IGFtb3VudHMgPSBbMiwgMl07XG4gICAqXG4gICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbnRyYWN0LmVkaXRpb24uYnVybi5iYXRjaEZyb20oYWNjb3VudCwgdG9rZW5JZHMsIGFtb3VudHMpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGJhdGNoRnJvbShhY2NvdW50LCB0b2tlbklkcywgYW1vdW50cykge1xuICAgIHJldHVybiB7XG4gICAgICByZWNlaXB0OiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJidXJuQmF0Y2hcIiwgW2FjY291bnQsIHRva2VuSWRzLCBhbW91bnRzXSlcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogTGlzdCBFUkMxMTU1IE5GVHNcbiAqIEByZW1hcmtzIEVhc2lseSBsaXN0IGFsbCB0aGUgTkZUcyBpbiBhIEVSQzExNTUgY29udHJhY3QuXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgY29udHJhY3QgPSBhd2FpdCBzZGsuZ2V0Q29udHJhY3QoXCJ7e2NvbnRyYWN0X2FkZHJlc3N9fVwiKTtcbiAqIGNvbnN0IG5mdHMgPSBhd2FpdCBjb250cmFjdC5lZGl0aW9uLnF1ZXJ5LmFsbCgpO1xuICogYGBgXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEVyYzExNTVFbnVtZXJhYmxlIHtcbiAgY29uc3RydWN0b3IoZXJjMTE1NSwgY29udHJhY3RXcmFwcGVyKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZmVhdHVyZU5hbWVcIiwgRkVBVFVSRV9FRElUSU9OX0VOVU1FUkFCTEUubmFtZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZXJjMTE1NVwiLCB2b2lkIDApO1xuICAgIHRoaXMuZXJjMTE1NSA9IGVyYzExNTU7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIgPSBjb250cmFjdFdyYXBwZXI7XG4gIH1cblxuICAvKipcbiAgICogR2V0IEFsbCBORlRzXG4gICAqXG4gICAqIEByZW1hcmtzIEdldCBhbGwgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGV2ZXJ5IE5GVCBpbiB0aGlzIGNvbnRyYWN0LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCByZXR1cm5zIHRoZSBmaXJzdCAxMDAgTkZUcywgdXNlIHF1ZXJ5UGFyYW1zIHRvIGZldGNoIG1vcmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgbmZ0cyA9IGF3YWl0IGNvbnRyYWN0LmVkaXRpb24ucXVlcnkuYWxsKCk7XG4gICAqIGBgYFxuICAgKiBAcGFyYW0gcXVlcnlQYXJhbXMgLSBvcHRpb25hbCBmaWx0ZXJpbmcgdG8gb25seSBmZXRjaCBhIHN1YnNldCBvZiByZXN1bHRzLlxuICAgKiBAcmV0dXJucyBUaGUgTkZUIG1ldGFkYXRhIGZvciBhbGwgTkZUcyBxdWVyaWVkLlxuICAgKi9cbiAgYXN5bmMgYWxsKHF1ZXJ5UGFyYW1zKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBCaWdOdW1iZXIuZnJvbShxdWVyeVBhcmFtcz8uc3RhcnQgfHwgMCkudG9OdW1iZXIoKTtcbiAgICBjb25zdCBjb3VudCA9IEJpZ051bWJlci5mcm9tKHF1ZXJ5UGFyYW1zPy5jb3VudCB8fCBERUZBVUxUX1FVRVJZX0FMTF9DT1VOVCkudG9OdW1iZXIoKTtcbiAgICBjb25zdCBtYXhJZCA9IE1hdGgubWluKChhd2FpdCB0aGlzLnRvdGFsQ291bnQoKSkudG9OdW1iZXIoKSwgc3RhcnQgKyBjb3VudCk7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKFsuLi5BcnJheShtYXhJZCAtIHN0YXJ0KS5rZXlzKCldLm1hcChpID0+IHRoaXMuZXJjMTE1NS5nZXQoKHN0YXJ0ICsgaSkudG9TdHJpbmcoKSkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlciBvZiBORlRzIG1pbnRlZFxuICAgKiBAcmVtYXJrcyBUaGlzIHJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBORlRzIG1pbnRlZCBpbiB0aGlzIGNvbnRyYWN0LCAqKm5vdCoqIHRoZSB0b3RhbCBzdXBwbHkgb2YgYSBnaXZlbiB0b2tlbi5cbiAgICpcbiAgICogQHJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBORlRzIG1pbnRlZCBpbiB0aGlzIGNvbnRyYWN0XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFzeW5jIHRvdGFsQ291bnQoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5uZXh0VG9rZW5JZFRvTWludCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3VwcGx5IG9mIHRva2VuIGZvciBhIGdpdmVuIHRva2VuSWQuXG4gICAqIEByZW1hcmtzIFRoaXMgaXMgKipub3QqKiB0aGUgc3VtIG9mIHN1cHBseSBvZiBhbGwgTkZUcyBpbiB0aGUgY29udHJhY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2YgTkZUcyBtaW50ZWQgaW4gdGhpcyBjb250cmFjdFxuICAgKiBAcHVibGljXG4gICAqL1xuICBhc3luYyB0b3RhbENpcmN1bGF0aW5nU3VwcGx5KHRva2VuSWQpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LnRvdGFsU3VwcGx5KHRva2VuSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBPd25lZCBORlRzXG4gICAqXG4gICAqIEByZW1hcmtzIEdldCBhbGwgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBORlRzIG93bmVkIGJ5IGEgc3BlY2lmaWMgd2FsbGV0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIEFkZHJlc3Mgb2YgdGhlIHdhbGxldCB0byBnZXQgdGhlIE5GVHMgb2ZcbiAgICogY29uc3QgYWRkcmVzcyA9IFwie3t3YWxsZXRfYWRkcmVzc319XCI7XG4gICAqIGNvbnN0IG5mdHMgPSBhd2FpdCBjb250cmFjdC5lZGl0aW9uLnF1ZXJ5Lm93bmVkKGFkZHJlc3MpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybnMgVGhlIE5GVCBtZXRhZGF0YSBmb3IgYWxsIE5GVHMgaW4gdGhlIGNvbnRyYWN0LlxuICAgKi9cbiAgYXN5bmMgb3duZWQod2FsbGV0QWRkcmVzcykge1xuICAgIGNvbnN0IGFkZHJlc3MgPSB3YWxsZXRBZGRyZXNzIHx8IChhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRTaWduZXJBZGRyZXNzKCkpO1xuICAgIGNvbnN0IG1heElkID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0Lm5leHRUb2tlbklkVG9NaW50KCk7XG4gICAgY29uc3QgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuYmFsYW5jZU9mQmF0Y2goQXJyYXkobWF4SWQudG9OdW1iZXIoKSkuZmlsbChhZGRyZXNzKSwgQXJyYXkuZnJvbShBcnJheShtYXhJZC50b051bWJlcigpKS5rZXlzKCkpKTtcbiAgICBjb25zdCBvd25lZEJhbGFuY2VzID0gYmFsYW5jZXMubWFwKChiLCBpKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbklkOiBpLFxuICAgICAgICBiYWxhbmNlOiBiXG4gICAgICB9O1xuICAgIH0pLmZpbHRlcihiID0+IGIuYmFsYW5jZS5ndCgwKSk7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKG93bmVkQmFsYW5jZXMubWFwKGFzeW5jIGIgPT4ge1xuICAgICAgY29uc3QgZWRpdGlvbk1ldGFkYXRhID0gYXdhaXQgdGhpcy5lcmMxMTU1LmdldChiLnRva2VuSWQudG9TdHJpbmcoKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5lZGl0aW9uTWV0YWRhdGEsXG4gICAgICAgIG93bmVyOiBhZGRyZXNzLFxuICAgICAgICBxdWFudGl0eU93bmVkOiBiLmJhbGFuY2UudG9OdW1iZXIoKVxuICAgICAgfTtcbiAgICB9KSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0UHJlYnVpbHRJbmZvKGFkZHJlc3MsIHByb3ZpZGVyKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGFkZHJlc3MsIElUaGlyZHdlYkNvbnRyYWN0QUJJLCBwcm92aWRlcik7XG4gICAgY29uc3QgW3R5cGUsIHZlcnNpb25dID0gYXdhaXQgUHJvbWlzZS5hbGwoW2V0aGVycy51dGlscy50b1V0ZjhTdHJpbmcoYXdhaXQgY29udHJhY3QuY29udHJhY3RUeXBlKCkpIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgLnJlcGxhY2UoL1xceDAwL2csIFwiXCIpLCBhd2FpdCBjb250cmFjdC5jb250cmFjdFZlcnNpb24oKV0pO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlLFxuICAgICAgdmVyc2lvblxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogQ29uZmlndXJlIGFuZCBjbGFpbSBFUkMxMTU1IE5GVHNcbiAqIEByZW1hcmtzIE1hbmFnZSBjbGFpbSBwaGFzZXMgYW5kIGNsYWltIEVSQzExNTUgTkZUcyB0aGF0IGhhdmUgYmVlbiBsYXppbHkgbWludGVkLlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgc2RrLmdldENvbnRyYWN0KFwie3tjb250cmFjdF9hZGRyZXNzfX1cIik7XG4gKiBhd2FpdCBjb250cmFjdC5lZGl0aW9uLmRyb3AuY2xhaW0udG8oXCIweC4uLlwiLCB0b2tlbklkLCBxdWFudGl0eSk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgRVJDMTE1NUNsYWltYWJsZSB7XG4gIGNvbnN0cnVjdG9yKGNvbnRyYWN0V3JhcHBlcikge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZlYXR1cmVOYW1lXCIsIEZFQVRVUkVfRURJVElPTl9DTEFJTV9DVVNUT00ubmFtZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIgPSBjb250cmFjdFdyYXBwZXI7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgY2xhaW0gdHJhbnNhY3Rpb24gd2l0aG91dCBleGVjdXRpbmcgaXQuXG4gICAqIFRoaXMgaXMgdXNlZnVsIGZvciBlc3RpbWF0aW5nIHRoZSBnYXMgY29zdCBvZiBhIGNsYWltIHRyYW5zYWN0aW9uLCBvdmVycmlkaW5nIHRyYW5zYWN0aW9uIG9wdGlvbnMgYW5kIGhhdmluZyBmaW5lIGdyYWluZWQgY29udHJvbCBvdmVyIHRoZSB0cmFuc2FjdGlvbiBleGVjdXRpb24uXG4gICAqIEBwYXJhbSBkZXN0aW5hdGlvbkFkZHJlc3MgLSBBZGRyZXNzIHlvdSB3YW50IHRvIHNlbmQgdGhlIHRva2VuIHRvXG4gICAqIEBwYXJhbSB0b2tlbklkIC0gSWQgb2YgdGhlIHRva2VuIHlvdSB3YW50IHRvIGNsYWltXG4gICAqIEBwYXJhbSBxdWFudGl0eSAtIFF1YW50aXR5IG9mIHRoZSB0b2tlbnMgeW91IHdhbnQgdG8gY2xhaW1cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBjbGFpbWluZyB0aGUgTkZUc1xuICAgKi9cbiAgYXN5bmMgZ2V0Q2xhaW1UcmFuc2FjdGlvbihkZXN0aW5hdGlvbkFkZHJlc3MsIHRva2VuSWQsIHF1YW50aXR5LCBvcHRpb25zKSB7XG4gICAgbGV0IG92ZXJyaWRlcyA9IHt9O1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucHJpY2VQZXJUb2tlbikge1xuICAgICAgb3ZlcnJpZGVzID0gYXdhaXQgY2FsY3VsYXRlQ2xhaW1Db3N0KHRoaXMuY29udHJhY3RXcmFwcGVyLCBvcHRpb25zLnByaWNlUGVyVG9rZW4sIHF1YW50aXR5LCBvcHRpb25zLmN1cnJlbmN5QWRkcmVzcywgb3B0aW9ucy5jaGVja0VSQzIwQWxsb3dhbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uVGFzay5tYWtlKHtcbiAgICAgIGNvbnRyYWN0V3JhcHBlcjogdGhpcy5jb250cmFjdFdyYXBwZXIsXG4gICAgICBmdW5jdGlvbk5hbWU6IFwiY2xhaW1cIixcbiAgICAgIGFyZ3M6IFtkZXN0aW5hdGlvbkFkZHJlc3MsIHRva2VuSWQsIHF1YW50aXR5XSxcbiAgICAgIG92ZXJyaWRlc1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENsYWltIE5GVHMgdG8gYSBzcGVjaWZpYyBXYWxsZXRcbiAgICpcbiAgICogQHJlbWFya3MgTGV0IHRoZSBzcGVjaWZpZWQgd2FsbGV0IGNsYWltIE5GVHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgYWRkcmVzcyA9IFwie3t3YWxsZXRfYWRkcmVzc319XCI7IC8vIGFkZHJlc3Mgb2YgdGhlIHdhbGxldCB5b3Ugd2FudCB0byBjbGFpbSB0aGUgTkZUc1xuICAgKiBjb25zdCB0b2tlbklkID0gMDsgLy8gdGhlIGlkIG9mIHRoZSBORlQgeW91IHdhbnQgdG8gY2xhaW1cbiAgICogY29uc3QgcXVhbnRpdHkgPSAxOyAvLyBob3cgbWFueSBORlRzIHlvdSB3YW50IHRvIGNsYWltXG4gICAqXG4gICAqIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuZXJjMTE1NS5jbGFpbVRvKGFkZHJlc3MsIHRva2VuSWQsIHF1YW50aXR5KTtcbiAgICogY29uc3QgcmVjZWlwdCA9IHR4LnJlY2VpcHQ7IC8vIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gZGVzdGluYXRpb25BZGRyZXNzIC0gQWRkcmVzcyB5b3Ugd2FudCB0byBzZW5kIHRoZSB0b2tlbiB0b1xuICAgKiBAcGFyYW0gdG9rZW5JZCAtIElkIG9mIHRoZSB0b2tlbiB5b3Ugd2FudCB0byBjbGFpbVxuICAgKiBAcGFyYW0gcXVhbnRpdHkgLSBRdWFudGl0eSBvZiB0aGUgdG9rZW5zIHlvdSB3YW50IHRvIGNsYWltXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgY2xhaW1pbmcgdGhlIE5GVHNcbiAgICpcbiAgICogQHJldHVybnMgLSBSZWNlaXB0IGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIGFzeW5jIHRvKGRlc3RpbmF0aW9uQWRkcmVzcywgdG9rZW5JZCwgcXVhbnRpdHksIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuZ2V0Q2xhaW1UcmFuc2FjdGlvbihkZXN0aW5hdGlvbkFkZHJlc3MsIHRva2VuSWQsIHF1YW50aXR5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdHguZXhlY3V0ZSgpO1xuICB9XG59XG5cbi8qKlxuICogQ29uZmlndXJlIGFuZCBjbGFpbSBFUkMxMTU1IE5GVHNcbiAqIEByZW1hcmtzIE1hbmFnZSBjbGFpbSBwaGFzZXMgYW5kIGNsYWltIEVSQzExNTUgTkZUcyB0aGF0IGhhdmUgYmVlbiBsYXppbHkgbWludGVkLlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgc2RrLmdldENvbnRyYWN0KFwie3tjb250cmFjdF9hZGRyZXNzfX1cIik7XG4gKiBhd2FpdCBjb250cmFjdC5lcmMxMTU1LmNsYWltKHRva2VuSWQsIHF1YW50aXR5KTtcbiAqIGF3YWl0IGNvbnRyYWN0LmVyYzExNTUuY2xhaW1Db25kaXRpb25zLmdldEFjdGl2ZSh0b2tlbklkKTtcbiAqIGBgYFxuICovXG5jbGFzcyBFcmMxMTU1Q2xhaW1hYmxlV2l0aENvbmRpdGlvbnMge1xuICBjb25zdHJ1Y3Rvcihjb250cmFjdFdyYXBwZXIsIHN0b3JhZ2UpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmZWF0dXJlTmFtZVwiLCBGRUFUVVJFX0VESVRJT05fQ0xBSU1fQ09ORElUSU9OU19WMi5uYW1lKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25kaXRpb25zXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcmFnZVwiLCB2b2lkIDApO1xuICAgIHRoaXMuY29udHJhY3RXcmFwcGVyID0gY29udHJhY3RXcmFwcGVyO1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBuZXcgQ29udHJhY3RNZXRhZGF0YSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgQ3VzdG9tQ29udHJhY3RTY2hlbWEsIHRoaXMuc3RvcmFnZSk7XG4gICAgdGhpcy5jb25kaXRpb25zID0gbmV3IERyb3BFcmMxMTU1Q2xhaW1Db25kaXRpb25zKGNvbnRyYWN0V3JhcHBlciwgbWV0YWRhdGEsIHRoaXMuc3RvcmFnZSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xhaW0gTkZUcyB0byBhIHNwZWNpZmljIFdhbGxldFxuICAgKlxuICAgKiBAcmVtYXJrcyBMZXQgdGhlIHNwZWNpZmllZCB3YWxsZXQgY2xhaW0gTkZUcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBhZGRyZXNzID0gXCJ7e3dhbGxldF9hZGRyZXNzfX1cIjsgLy8gYWRkcmVzcyBvZiB0aGUgd2FsbGV0IHlvdSB3YW50IHRvIGNsYWltIHRoZSBORlRzXG4gICAqIGNvbnN0IHRva2VuSWQgPSAwOyAvLyB0aGUgaWQgb2YgdGhlIE5GVCB5b3Ugd2FudCB0byBjbGFpbVxuICAgKiBjb25zdCBxdWFudGl0eSA9IDE7IC8vIGhvdyBtYW55IE5GVHMgeW91IHdhbnQgdG8gY2xhaW1cbiAgICpcbiAgICogY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5lcmMxMTU1LmNsYWltVG8oYWRkcmVzcywgdG9rZW5JZCwgcXVhbnRpdHkpO1xuICAgKiBjb25zdCByZWNlaXB0ID0gdHgucmVjZWlwdDsgLy8gdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBkZXN0aW5hdGlvbkFkZHJlc3MgLSBBZGRyZXNzIHlvdSB3YW50IHRvIHNlbmQgdGhlIHRva2VuIHRvXG4gICAqIEBwYXJhbSB0b2tlbklkIC0gSWQgb2YgdGhlIHRva2VuIHlvdSB3YW50IHRvIGNsYWltXG4gICAqIEBwYXJhbSBxdWFudGl0eSAtIFF1YW50aXR5IG9mIHRoZSB0b2tlbnMgeW91IHdhbnQgdG8gY2xhaW1cbiAgICpcbiAgICogQHJldHVybnMgLSBSZWNlaXB0IGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIGFzeW5jIHRvKGRlc3RpbmF0aW9uQWRkcmVzcywgdG9rZW5JZCwgcXVhbnRpdHksIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuY29uZGl0aW9ucy5nZXRDbGFpbVRyYW5zYWN0aW9uKGRlc3RpbmF0aW9uQWRkcmVzcywgdG9rZW5JZCwgcXVhbnRpdHksIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0eC5leGVjdXRlKCk7XG4gIH1cbn1cblxuY2xhc3MgRXJjMTE1NUxhenlNaW50YWJsZSB7XG4gIC8qKlxuICAgKiBEZWxheWVkIHJldmVhbFxuICAgKiBAcmVtYXJrcyBDcmVhdGUgYSBiYXRjaCBvZiBlbmNyeXB0ZWQgTkZUcyB0aGF0IGNhbiBiZSByZXZlYWxlZCBhdCBhIGxhdGVyIHRpbWUuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gdGhlIHJlYWwgTkZUcywgdGhlc2Ugd2lsbCBiZSBlbmNyeXB0ZWQgdW50aWwgeW91IHJldmVhbCB0aGVtXG4gICAqIGNvbnN0IHJlYWxORlRzID0gW3tcbiAgICogICBuYW1lOiBcIkNvbW1vbiBORlQgIzFcIixcbiAgICogICBkZXNjcmlwdGlvbjogXCJDb21tb24gTkZULCBvbmUgb2YgbWFueS5cIixcbiAgICogICBpbWFnZTogZnMucmVhZEZpbGVTeW5jKFwicGF0aC90by9pbWFnZS5wbmdcIiksXG4gICAqIH0sIHtcbiAgICogICBuYW1lOiBcIlN1cGVyIFJhcmUgTkZUICMyXCIsXG4gICAqICAgZGVzY3JpcHRpb246IFwiWW91IGdvdCBhIFN1cGVyIFJhcmUgTkZUIVwiLFxuICAgKiAgIGltYWdlOiBmcy5yZWFkRmlsZVN5bmMoXCJwYXRoL3RvL2ltYWdlLnBuZ1wiKSxcbiAgICogfV07XG4gICAqIC8vIEEgcGxhY2Vob2xkZXIgTkZUIHRoYXQgcGVvcGxlIHdpbGwgZ2V0IGltbWVkaWF0ZWx5IGluIHRoZWlyIHdhbGxldCwgYW5kIHdpbGwgYmUgY29udmVydGVkIHRvIHRoZSByZWFsIE5GVCBhdCByZXZlYWwgdGltZVxuICAgKiBjb25zdCBwbGFjZWhvbGRlck5GVCA9IHtcbiAgICogICBuYW1lOiBcIkhpZGRlbiBORlRcIixcbiAgICogICBkZXNjcmlwdGlvbjogXCJXaWxsIGJlIHJldmVhbGVkIG5leHQgd2VlayFcIlxuICAgKiB9O1xuICAgKiAvLyBDcmVhdGUgYW5kIGVuY3J5cHQgdGhlIE5GVHNcbiAgICogYXdhaXQgY29udHJhY3QuZWRpdGlvbi5kcm9wLnJldmVhbGVyLmNyZWF0ZURlbGF5ZWRSZXZlYWxCYXRjaChcbiAgICogICBwbGFjZWhvbGRlck5GVCxcbiAgICogICByZWFsTkZUcyxcbiAgICogICBcIm15IHNlY3JldCBwYXNzd29yZFwiLFxuICAgKiApO1xuICAgKiAvLyBXaGVuZXZlciB5b3UncmUgcmVhZHksIHJldmVhbCB5b3VyIE5GVHMgYXQgYW55IHRpbWVcbiAgICogY29uc3QgYmF0Y2hJZCA9IDA7IC8vIHRoZSBiYXRjaCB0byByZXZlYWxcbiAgICogYXdhaXQgY29udHJhY3QuZWRpdGlvbi5kcm9wLnJldmVhbGVyLnJldmVhbChiYXRjaElkLCBcIm15IHNlY3JldCBwYXNzd29yZFwiKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDbGFpbSB0b2tlbnMgYW5kIGNvbmZpZ3VyZSBjbGFpbSBjb25kaXRpb25zXG4gICAqIEByZW1hcmtzIExldCB1c2VycyBjbGFpbSBORlRzLiBEZWZpbmUgd2hvIGNhbiBjbGFpbSBORlRzIGluIHRoZSBjb2xsZWN0aW9uLCB3aGVuIGFuZCBob3cgbWFueS5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBxdWFudGl0eSA9IDEwO1xuICAgKiBjb25zdCB0b2tlbklkID0gMDtcbiAgICogYXdhaXQgY29udHJhY3QuZXJjMTE1NS5jbGFpbVRvKFwiMHguLi5cIiwgMCwgcXVhbnRpdHkpO1xuICAgKiBgYGBcbiAgICovXG5cbiAgY29uc3RydWN0b3IoZXJjMTE1NSwgY29udHJhY3RXcmFwcGVyLCBzdG9yYWdlKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZmVhdHVyZU5hbWVcIiwgRkVBVFVSRV9FRElUSU9OX0xBWllfTUlOVEFCTEVfVjIubmFtZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmV2ZWFsZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGFpbVdpdGhDb25kaXRpb25zXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xhaW1cIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250cmFjdFdyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlcmMxMTU1XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcmFnZVwiLCB2b2lkIDApO1xuICAgIHRoaXMuZXJjMTE1NSA9IGVyYzExNTU7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIgPSBjb250cmFjdFdyYXBwZXI7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICB0aGlzLmNsYWltID0gdGhpcy5kZXRlY3RFcmMxMTU1Q2xhaW1hYmxlKCk7XG4gICAgdGhpcy5jbGFpbVdpdGhDb25kaXRpb25zID0gdGhpcy5kZXRlY3RFcmMxMTU1Q2xhaW1hYmxlV2l0aENvbmRpdGlvbnMoKTtcbiAgICB0aGlzLnJldmVhbGVyID0gdGhpcy5kZXRlY3RFcmMxMTU1UmV2ZWFsYWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGJhdGNoIG9mIE5GVHMgdG8gYmUgY2xhaW1lZCBpbiB0aGUgZnV0dXJlXG4gICAqXG4gICAqIEByZW1hcmtzIENyZWF0ZSBiYXRjaCBhbGxvd3MgeW91IHRvIGNyZWF0ZSBhIGJhdGNoIG9mIG1hbnkgTkZUcyBpbiBvbmUgdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gQ3VzdG9tIG1ldGFkYXRhIG9mIHRoZSBORlRzIHRvIGNyZWF0ZVxuICAgKiBjb25zdCBtZXRhZGF0YXMgPSBbe1xuICAgKiAgIG5hbWU6IFwiQ29vbCBORlRcIixcbiAgICogICBkZXNjcmlwdGlvbjogXCJUaGlzIGlzIGEgY29vbCBORlRcIixcbiAgICogICBpbWFnZTogZnMucmVhZEZpbGVTeW5jKFwicGF0aC90by9pbWFnZS5wbmdcIiksIC8vIFRoaXMgY2FuIGJlIGFuIGltYWdlIHVybCBvciBmaWxlXG4gICAqIH0sIHtcbiAgICogICBuYW1lOiBcIkNvb2wgTkZUXCIsXG4gICAqICAgZGVzY3JpcHRpb246IFwiVGhpcyBpcyBhIGNvb2wgTkZUXCIsXG4gICAqICAgaW1hZ2U6IGZzLnJlYWRGaWxlU3luYyhcInBhdGgvdG8vaW1hZ2UucG5nXCIpLFxuICAgKiB9XTtcbiAgICpcbiAgICogY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNvbnRyYWN0LmVyYzExNTUubGF6eU1pbnQobWV0YWRhdGFzKTsgLy8gdXBsb2FkcyBhbmQgY3JlYXRlcyB0aGUgTkZUcyBvbiBjaGFpblxuICAgKiBjb25zdCBmaXJzdFRva2VuSWQgPSByZXN1bHRzWzBdLmlkOyAvLyB0b2tlbiBpZCBvZiB0aGUgZmlyc3QgY3JlYXRlZCBORlRcbiAgICogY29uc3QgZmlyc3RORlQgPSBhd2FpdCByZXN1bHRzWzBdLmRhdGEoKTsgLy8gKG9wdGlvbmFsKSBmZXRjaCBkZXRhaWxzIG9mIHRoZSBmaXJzdCBjcmVhdGVkIE5GVFxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIG1ldGFkYXRhcyAtIFRoZSBtZXRhZGF0YSB0byBpbmNsdWRlIGluIHRoZSBiYXRjaC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBvcHRpb25hbCB1cGxvYWQgcHJvZ3Jlc3MgY2FsbGJhY2tcbiAgICovXG4gIGFzeW5jIGxhenlNaW50KG1ldGFkYXRhcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHN0YXJ0RmlsZU51bWJlciA9IGF3YWl0IHRoaXMuZXJjMTE1NS5uZXh0VG9rZW5JZFRvTWludCgpO1xuICAgIGNvbnN0IGJhdGNoID0gYXdhaXQgdXBsb2FkT3JFeHRyYWN0VVJJcyhtZXRhZGF0YXMsIHRoaXMuc3RvcmFnZSwgc3RhcnRGaWxlTnVtYmVyLnRvTnVtYmVyKCksIG9wdGlvbnMpO1xuICAgIC8vIGVuc3VyZSBiYXNlVXJpIGlzIHRoZSBzYW1lIGZvciB0aGUgZW50aXJlIGJhdGNoXG4gICAgY29uc3QgYmFzZVVyaSA9IGJhdGNoWzBdLnN1YnN0cmluZygwLCBiYXRjaFswXS5sYXN0SW5kZXhPZihcIi9cIikpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHVyaSA9IGJhdGNoW2ldLnN1YnN0cmluZygwLCBiYXRjaFtpXS5sYXN0SW5kZXhPZihcIi9cIikpO1xuICAgICAgaWYgKGJhc2VVcmkgIT09IHVyaSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBvbmx5IGNyZWF0ZSBiYXRjaGVzIHdpdGggdGhlIHNhbWUgYmFzZSBVUkkgZm9yIGV2ZXJ5IGVudHJ5IGluIHRoZSBiYXRjaC4gRXhwZWN0ZWQgJyR7YmFzZVVyaX0nIGJ1dCBnb3QgJyR7dXJpfSdgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaXNMZWdhY3lFZGl0aW9uRHJvcENvbnRyYWN0ID0gYXdhaXQgdGhpcy5pc0xlZ2FjeUVkaXRpb25Ecm9wQ29udHJhY3QoKTtcbiAgICBsZXQgcmVjZWlwdDtcbiAgICBpZiAoaXNMZWdhY3lFZGl0aW9uRHJvcENvbnRyYWN0KSB7XG4gICAgICByZWNlaXB0ID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuc2VuZFRyYW5zYWN0aW9uKFwibGF6eU1pbnRcIiwgW2JhdGNoLmxlbmd0aCwgYCR7YmFzZVVyaS5lbmRzV2l0aChcIi9cIikgPyBiYXNlVXJpIDogYCR7YmFzZVVyaX0vYH1gXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5ldyBjb250cmFjdHMvZXh0ZW5zaW9ucyBoYXZlIHN1cHBvcnQgZm9yIGRlbGF5ZWQgcmV2ZWFsIHRoYXQgYWRkcyBhbiBleHRyYSBwYXJhbWV0ZXIgdG8gbGF6eU1pbnRcbiAgICAgIHJlY2VpcHQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJsYXp5TWludFwiLCBbYmF0Y2gubGVuZ3RoLCBgJHtiYXNlVXJpLmVuZHNXaXRoKFwiL1wiKSA/IGJhc2VVcmkgOiBgJHtiYXNlVXJpfS9gfWAsIGV0aGVycy51dGlscy50b1V0ZjhCeXRlcyhcIlwiKV0pO1xuICAgIH1cbiAgICBjb25zdCBldmVudCA9IHRoaXMuY29udHJhY3RXcmFwcGVyLnBhcnNlTG9ncyhcIlRva2Vuc0xhenlNaW50ZWRcIiwgcmVjZWlwdD8ubG9ncyk7XG4gICAgY29uc3Qgc3RhcnRpbmdJbmRleCA9IGV2ZW50WzBdLmFyZ3Muc3RhcnRUb2tlbklkO1xuICAgIGNvbnN0IGVuZGluZ0luZGV4ID0gZXZlbnRbMF0uYXJncy5lbmRUb2tlbklkO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpZCA9IHN0YXJ0aW5nSW5kZXg7IGlkLmx0ZShlbmRpbmdJbmRleCk7IGlkID0gaWQuYWRkKDEpKSB7XG4gICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgcmVjZWlwdCxcbiAgICAgICAgZGF0YTogKCkgPT4gdGhpcy5lcmMxMTU1LmdldFRva2VuTWV0YWRhdGEoaWQpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKiogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIFBSSVZBVEUgRlVOQ1RJT05TXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIGRldGVjdEVyYzExNTVDbGFpbWFibGUoKSB7XG4gICAgaWYgKGRldGVjdENvbnRyYWN0RmVhdHVyZSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgXCJFUkMxMTU1Q2xhaW1DdXN0b21cIikpIHtcbiAgICAgIHJldHVybiBuZXcgRVJDMTE1NUNsYWltYWJsZSh0aGlzLmNvbnRyYWN0V3JhcHBlcik7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgZGV0ZWN0RXJjMTE1NUNsYWltYWJsZVdpdGhDb25kaXRpb25zKCkge1xuICAgIGlmIChkZXRlY3RDb250cmFjdEZlYXR1cmUodGhpcy5jb250cmFjdFdyYXBwZXIsIFwiRVJDMTE1NUNsYWltQ29uZGl0aW9uc1YxXCIpIHx8IGRldGVjdENvbnRyYWN0RmVhdHVyZSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgXCJFUkMxMTU1Q2xhaW1Db25kaXRpb25zVjJcIikgfHwgZGV0ZWN0Q29udHJhY3RGZWF0dXJlKHRoaXMuY29udHJhY3RXcmFwcGVyLCBcIkVSQzExNTVDbGFpbVBoYXNlc1YxXCIpIHx8IGRldGVjdENvbnRyYWN0RmVhdHVyZSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgXCJFUkMxMTU1Q2xhaW1QaGFzZXNWMlwiKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcmMxMTU1Q2xhaW1hYmxlV2l0aENvbmRpdGlvbnModGhpcy5jb250cmFjdFdyYXBwZXIsIHRoaXMuc3RvcmFnZSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgZGV0ZWN0RXJjMTE1NVJldmVhbGFibGUoKSB7XG4gICAgaWYgKGRldGVjdENvbnRyYWN0RmVhdHVyZSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgXCJFUkMxMTU1UmV2ZWFsYWJsZVwiKSkge1xuICAgICAgcmV0dXJuIG5ldyBEZWxheWVkUmV2ZWFsKHRoaXMuY29udHJhY3RXcmFwcGVyLCB0aGlzLnN0b3JhZ2UsIEZFQVRVUkVfRURJVElPTl9SRVZFQUxBQkxFLm5hbWUsICgpID0+IHRoaXMuZXJjMTE1NS5uZXh0VG9rZW5JZFRvTWludCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBhc3luYyBpc0xlZ2FjeUVkaXRpb25Ecm9wQ29udHJhY3QoKSB7XG4gICAgY29uc3QgaW5mbyA9IGF3YWl0IGdldFByZWJ1aWx0SW5mbyh0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuYWRkcmVzcywgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJvdmlkZXIoKSk7XG4gICAgcmV0dXJuIGluZm8gJiYgaW5mby50eXBlID09PSBcIkRyb3BFUkMxMTU1XCIgJiYgaW5mby52ZXJzaW9uIDwgMztcbiAgfVxufVxuXG4vKipcbiAqIE1pbnQgTWFueSBFUkMxMTU1IE5GVHMgYXQgb25jZVxuICogQHJlbWFya3MgTkZUIGJhdGNoIG1pbnRpbmcgZnVuY3Rpb25hbGl0eSB0aGF0IGhhbmRsZXMgSVBGUyBzdG9yYWdlIGZvciB5b3UuXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgY29udHJhY3QgPSBhd2FpdCBzZGsuZ2V0Q29udHJhY3QoXCJ7e2NvbnRyYWN0X2FkZHJlc3N9fVwiKTtcbiAqIGF3YWl0IGNvbnRyYWN0LmVkaXRpb24ubWludC5iYXRjaC50byh3YWxsZXRBZGRyZXNzLCBbbmZ0TWV0YWRhdGFXaXRoU3VwcGx5MSwgbmZ0TWV0YWRhdGFXaXRoU3VwcGx5MiwgLi4uXSk7XG4gKiBgYGBcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgRXJjMTE1NUJhdGNoTWludGFibGUge1xuICBjb25zdHJ1Y3RvcihlcmMxMTU1LCBjb250cmFjdFdyYXBwZXIsIHN0b3JhZ2UpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmZWF0dXJlTmFtZVwiLCBGRUFUVVJFX0VESVRJT05fQkFUQ0hfTUlOVEFCTEUubmFtZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZXJjMTE1NVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3JhZ2VcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmVyYzExNTUgPSBlcmMxMTU1O1xuICAgIHRoaXMuY29udHJhY3RXcmFwcGVyID0gY29udHJhY3RXcmFwcGVyO1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gIH1cblxuICAvKipcbiAgICogTWludCBNYW55IE5GVHMgd2l0aCBsaW1pdGVkIHN1cHBsaWVzXG4gICAqXG4gICAqIEByZW1hcmtzIE1pbnQgbWFueSBkaWZmZXJlbnQgTkZUcyB3aXRoIGxpbWl0ZWQgc3VwcGxpZXMgdG8gYSBzcGVjaWZpZWQgd2FsbGV0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIEFkZHJlc3Mgb2YgdGhlIHdhbGxldCB5b3Ugd2FudCB0byBtaW50IHRoZSBORlQgdG9cbiAgICogY29uc3QgdG9BZGRyZXNzID0gXCJ7e3dhbGxldF9hZGRyZXNzfX1cIlxuICAgKlxuICAgKiAvLyBDdXN0b20gbWV0YWRhdGEgYW5kIHN1cHBsaWVzIG9mIHlvdXIgTkZUc1xuICAgKiBjb25zdCBtZXRhZGF0YVdpdGhTdXBwbHkgPSBbe1xuICAgKiAgIHN1cHBseTogNTAsIC8vIFRoZSBudW1iZXIgb2YgdGhpcyBORlQgeW91IHdhbnQgdG8gbWludFxuICAgKiAgIG1ldGFkYXRhOiB7XG4gICAqICAgICBuYW1lOiBcIkNvb2wgTkZUICMxXCIsXG4gICAqICAgICBkZXNjcmlwdGlvbjogXCJUaGlzIGlzIGEgY29vbCBORlRcIixcbiAgICogICAgIGltYWdlOiBmcy5yZWFkRmlsZVN5bmMoXCJwYXRoL3RvL2ltYWdlLnBuZ1wiKSwgLy8gVGhpcyBjYW4gYmUgYW4gaW1hZ2UgdXJsIG9yIGZpbGVcbiAgICogICB9LFxuICAgKiB9LCB7XG4gICAqICAgc3VwcGx5OiAxMDAsXG4gICAqICAgbWV0YWRhdGE6IHtcbiAgICogICAgIG5hbWU6IFwiQ29vbCBORlQgIzJcIixcbiAgICogICAgIGRlc2NyaXB0aW9uOiBcIlRoaXMgaXMgYSBjb29sIE5GVFwiLFxuICAgKiAgICAgaW1hZ2U6IGZzLnJlYWRGaWxlU3luYyhcInBhdGgvdG8vaW1hZ2UucG5nXCIpLCAvLyBUaGlzIGNhbiBiZSBhbiBpbWFnZSB1cmwgb3IgZmlsZVxuICAgKiAgIH0sXG4gICAqIH1dO1xuICAgKlxuICAgKiBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmVkaXRpb24ubWludC5iYXRjaC50byh0b0FkZHJlc3MsIG1ldGFkYXRhV2l0aFN1cHBseSk7XG4gICAqIGNvbnN0IHJlY2VpcHQgPSB0eFswXS5yZWNlaXB0OyAvLyBzYW1lIHRyYW5zYWN0aW9uIHJlY2VpcHQgZm9yIGFsbCBtaW50ZWQgTkZUc1xuICAgKiBjb25zdCBmaXJzdFRva2VuSWQgPSB0eFswXS5pZDsgLy8gdG9rZW4gaWQgb2YgdGhlIGZpcnN0IG1pbnRlZCBORlRcbiAgICogY29uc3QgZmlyc3RORlQgPSBhd2FpdCB0eFswXS5kYXRhKCk7IC8vIChvcHRpb25hbCkgZmV0Y2ggZGV0YWlscyBvZiB0aGUgZmlyc3QgbWludGVkIE5GVFxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHRvKHRvLCBtZXRhZGF0YVdpdGhTdXBwbHkpIHtcbiAgICBjb25zdCBtZXRhZGF0YXMgPSBtZXRhZGF0YVdpdGhTdXBwbHkubWFwKGEgPT4gYS5tZXRhZGF0YSk7XG4gICAgY29uc3Qgc3VwcGxpZXMgPSBtZXRhZGF0YVdpdGhTdXBwbHkubWFwKGEgPT4gYS5zdXBwbHkpO1xuICAgIGNvbnN0IHVyaXMgPSBhd2FpdCB1cGxvYWRPckV4dHJhY3RVUklzKG1ldGFkYXRhcywgdGhpcy5zdG9yYWdlKTtcbiAgICBjb25zdCBlbmNvZGVkID0gdXJpcy5tYXAoKHVyaSwgaW5kZXgpID0+IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKFwibWludFRvXCIsIFt0bywgZXRoZXJzLmNvbnN0YW50cy5NYXhVaW50MjU2LCB1cmksIHN1cHBsaWVzW2luZGV4XV0pKTtcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIubXVsdGlDYWxsKGVuY29kZWQpO1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuY29udHJhY3RXcmFwcGVyLnBhcnNlTG9ncyhcIlRva2Vuc01pbnRlZFwiLCByZWNlaXB0LmxvZ3MpO1xuICAgIGlmIChldmVudHMubGVuZ3RoID09PSAwIHx8IGV2ZW50cy5sZW5ndGggPCBtZXRhZGF0YXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb2tlbk1pbnRlZCBldmVudCBub3QgZm91bmQsIG1pbnRpbmcgZmFpbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzLm1hcChlID0+IHtcbiAgICAgIGNvbnN0IGlkID0gZS5hcmdzLnRva2VuSWRNaW50ZWQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZCxcbiAgICAgICAgcmVjZWlwdCxcbiAgICAgICAgZGF0YTogKCkgPT4gdGhpcy5lcmMxMTU1LmdldChpZClcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBNaW50IEVSQzExNTUgTkZUc1xuICogQHJlbWFya3MgTkZUIG1pbnRpbmcgZnVuY3Rpb25hbGl0eSB0aGF0IGhhbmRsZXMgSVBGUyBzdG9yYWdlIGZvciB5b3UuXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgY29udHJhY3QgPSBhd2FpdCBzZGsuZ2V0Q29udHJhY3QoXCJ7e2NvbnRyYWN0X2FkZHJlc3N9fVwiKTtcbiAqIGF3YWl0IGNvbnRyYWN0LmVkaXRpb24ubWludC50byh3YWxsZXRBZGRyZXNzLCBuZnRNZXRhZGF0YSk7XG4gKiBgYGBcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgRXJjMTE1NU1pbnRhYmxlIHtcbiAgLyoqXG4gICAqIEJhdGNoIG1pbnQgVG9rZW5zIHRvIG1hbnkgYWRkcmVzc2VzXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKGVyYzExNTUsIGNvbnRyYWN0V3JhcHBlciwgc3RvcmFnZSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZlYXR1cmVOYW1lXCIsIEZFQVRVUkVfRURJVElPTl9NSU5UQUJMRS5uYW1lKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250cmFjdFdyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlcmMxMTU1XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcmFnZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJhdGNoXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5lcmMxMTU1ID0gZXJjMTE1NTtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlciA9IGNvbnRyYWN0V3JhcHBlcjtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgIHRoaXMuYmF0Y2ggPSB0aGlzLmRldGVjdEVyYzExNTVCYXRjaE1pbnRhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogTWludCBhbiBORlQgd2l0aCBhIGxpbWl0ZWQgc3VwcGx5XG4gICAqXG4gICAqIEByZW1hcmtzIE1pbnQgYW4gTkZUIHdpdGggYSBsaW1pdGVkIHN1cHBseSB0byBhIHNwZWNpZmllZCB3YWxsZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gQWRkcmVzcyBvZiB0aGUgd2FsbGV0IHlvdSB3YW50IHRvIG1pbnQgdGhlIE5GVCB0b1xuICAgKiBjb25zdCB0b0FkZHJlc3MgPSBcInt7d2FsbGV0X2FkZHJlc3N9fVwiXG4gICAqXG4gICAqIC8vIEN1c3RvbSBtZXRhZGF0YSBvZiB0aGUgTkZULCBub3RlIHRoYXQgeW91IGNhbiBmdWxseSBjdXN0b21pemUgdGhpcyBtZXRhZGF0YSB3aXRoIG90aGVyIHByb3BlcnRpZXMuXG4gICAqIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgKiAgIG5hbWU6IFwiQ29vbCBORlRcIixcbiAgICogICBkZXNjcmlwdGlvbjogXCJUaGlzIGlzIGEgY29vbCBORlRcIixcbiAgICogICBpbWFnZTogZnMucmVhZEZpbGVTeW5jKFwicGF0aC90by9pbWFnZS5wbmdcIiksIC8vIFRoaXMgY2FuIGJlIGFuIGltYWdlIHVybCBvciBmaWxlXG4gICAqIH1cbiAgICpcbiAgICogY29uc3QgbWV0YWRhdGFXaXRoU3VwcGx5ID0ge1xuICAgKiAgIG1ldGFkYXRhLFxuICAgKiAgIHN1cHBseTogMTAwMCwgLy8gVGhlIG51bWJlciBvZiB0aGlzIE5GVCB5b3Ugd2FudCB0byBtaW50XG4gICAqIH1cbiAgICpcbiAgICogY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5lZGl0aW9uLm1pbnQudG8odG9BZGRyZXNzLCBtZXRhZGF0YVdpdGhTdXBwbHkpO1xuICAgKiBjb25zdCByZWNlaXB0ID0gdHgucmVjZWlwdDsgLy8gdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRcbiAgICogY29uc3QgdG9rZW5JZCA9IHR4LmlkOyAvLyB0aGUgaWQgb2YgdGhlIE5GVCBtaW50ZWRcbiAgICogY29uc3QgbmZ0ID0gYXdhaXQgdHguZGF0YSgpOyAvLyAob3B0aW9uYWwpIGZldGNoIGRldGFpbHMgb2YgbWludGVkIE5GVFxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHRvKHRvLCBtZXRhZGF0YVdpdGhTdXBwbHkpIHtcbiAgICBjb25zdCB1cmkgPSBhd2FpdCB1cGxvYWRPckV4dHJhY3RVUkkobWV0YWRhdGFXaXRoU3VwcGx5Lm1ldGFkYXRhLCB0aGlzLnN0b3JhZ2UpO1xuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJtaW50VG9cIiwgW3RvLCBldGhlcnMuY29uc3RhbnRzLk1heFVpbnQyNTYsIHVyaSwgbWV0YWRhdGFXaXRoU3VwcGx5LnN1cHBseV0pO1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5jb250cmFjdFdyYXBwZXIucGFyc2VMb2dzKFwiVHJhbnNmZXJTaW5nbGVcIiwgcmVjZWlwdD8ubG9ncyk7XG4gICAgaWYgKGV2ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNmZXJTaW5nbGVFdmVudCBldmVudCBub3QgZm91bmRcIik7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gZXZlbnRbMF0uYXJncy5pZDtcbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICByZWNlaXB0LFxuICAgICAgZGF0YTogKCkgPT4gdGhpcy5lcmMxMTU1LmdldChpZC50b1N0cmluZygpKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVhc2UgdGhlIHN1cHBseSBvZiBhbiBleGlzdGluZyBORlQgYW5kIG1pbnQgaXQgdG8gYSBnaXZlbiB3YWxsZXQgYWRkcmVzc1xuICAgKlxuICAgKiBAcGFyYW0gdG8gLSB0aGUgYWRkcmVzcyB0byBtaW50IHRvXG4gICAqIEBwYXJhbSB0b2tlbklkIC0gdGhlIHRva2VuIGlkIG9mIHRoZSBORlQgdG8gaW5jcmVhc2Ugc3VwcGx5IG9mXG4gICAqIEBwYXJhbSBhZGRpdGlvbmFsU3VwcGx5IC0gdGhlIGFkZGl0aW9uYWwgYW1vdW50IHRvIG1pbnRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBBZGRyZXNzIG9mIHRoZSB3YWxsZXQgeW91IHdhbnQgdG8gbWludCB0aGUgTkZUIHRvXG4gICAqIGNvbnN0IHRvQWRkcmVzcyA9IFwie3t3YWxsZXRfYWRkcmVzc319XCJcbiAgICogY29uc3QgdG9rZW5JZCA9IDA7XG4gICAqIGNvbnN0IGFkZGl0aW9uYWxTdXBwbHkgPSAxMDAwO1xuICAgKlxuICAgKiBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmVkaXRpb24ubWludC5hZGRpdGlvbmFsU3VwcGx5VG8odG9BZGRyZXNzLCB0b2tlbklkLCBhZGRpdGlvbmFsU3VwcGx5KTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBhZGRpdGlvbmFsU3VwcGx5VG8odG8sIHRva2VuSWQsIGFkZGl0aW9uYWxTdXBwbHkpIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuZXJjMTE1NS5nZXRUb2tlbk1ldGFkYXRhKHRva2VuSWQpO1xuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJtaW50VG9cIiwgW3RvLCB0b2tlbklkLCBtZXRhZGF0YS51cmksIGFkZGl0aW9uYWxTdXBwbHldKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IEJpZ051bWJlci5mcm9tKHRva2VuSWQpLFxuICAgICAgcmVjZWlwdCxcbiAgICAgIGRhdGE6ICgpID0+IHRoaXMuZXJjMTE1NS5nZXQodG9rZW5JZClcbiAgICB9O1xuICB9XG4gIGRldGVjdEVyYzExNTVCYXRjaE1pbnRhYmxlKCkge1xuICAgIGlmIChkZXRlY3RDb250cmFjdEZlYXR1cmUodGhpcy5jb250cmFjdFdyYXBwZXIsIFwiRVJDMTE1NUJhdGNoTWludGFibGVcIikpIHtcbiAgICAgIHJldHVybiBuZXcgRXJjMTE1NUJhdGNoTWludGFibGUodGhpcy5lcmMxMTU1LCB0aGlzLmNvbnRyYWN0V3JhcHBlciwgdGhpcy5zdG9yYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZXMgZ2VuZXJhdGluZyBkeW5hbWljIEVSQzExNTUgTkZUcyB3aXRoIHJ1bGVzIGFuZCBhbiBhc3NvY2lhdGVkIHNpZ25hdHVyZSwgd2hpY2ggY2FuIHRoZW4gYmUgbWludGVkIGJ5IGFueW9uZSBzZWN1cmVseVxuICogQHB1YmxpY1xuICovXG5jbGFzcyBFcmMxMTU1U2lnbmF0dXJlTWludGFibGUge1xuICBjb25zdHJ1Y3Rvcihjb250cmFjdFdyYXBwZXIsIHN0b3JhZ2UsIHJvbGVzKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZmVhdHVyZU5hbWVcIiwgRkVBVFVSRV9FRElUSU9OX1NJR05BVFVSRV9NSU5UQUJMRS5uYW1lKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250cmFjdFdyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yYWdlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicm9sZXNcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlciA9IGNvbnRyYWN0V3JhcHBlcjtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgIHRoaXMucm9sZXMgPSByb2xlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNaW50IGEgZHluYW1pY2FsbHkgZ2VuZXJhdGVkIE5GVFxuICAgKlxuICAgKiBAcmVtYXJrcyBNaW50IGEgZHluYW1pYyBORlQgd2l0aCBhIHByZXZpb3VzbHkgZ2VuZXJhdGVkIHNpZ25hdHVyZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBzZWUgaG93IHRvIGNyYWZ0IGEgcGF5bG9hZCB0byBzaWduIGluIHRoZSBgZ2VuZXJhdGUoKWAgZG9jdW1lbnRhdGlvblxuICAgKiBjb25zdCBzaWduZWRQYXlsb2FkID0gY29udHJhY3QuZXJjMTE1NS5zaWduYXR1cmUuZ2VuZXJhdGUocGF5bG9hZCk7XG4gICAqXG4gICAqIC8vIG5vdyBhbnlvbmUgY2FuIG1pbnQgdGhlIE5GVFxuICAgKiBjb25zdCB0eCA9IGNvbnRyYWN0LmVyYzExNTUuc2lnbmF0dXJlLm1pbnQoc2lnbmVkUGF5bG9hZCk7XG4gICAqIGBgYFxuICAgKiBAcGFyYW0gc2lnbmVkUGF5bG9hZCAtIHRoZSBwcmV2aW91c2x5IGdlbmVyYXRlZCBwYXlsb2FkIGFuZCBzaWduYXR1cmUgd2l0aCB7QGxpbmsgRXJjMTE1NVNpZ25hdHVyZU1pbnRhYmxlLmdlbmVyYXRlfVxuICAgKiBAdHdmZWF0dXJlIEVSQzExNTVTaWduYXR1cmVNaW50YWJsZVxuICAgKi9cbiAgYXN5bmMgbWludChzaWduZWRQYXlsb2FkKSB7XG4gICAgY29uc3QgbWludFJlcXVlc3QgPSBzaWduZWRQYXlsb2FkLnBheWxvYWQ7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbmVkUGF5bG9hZC5zaWduYXR1cmU7XG4gICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHRoaXMubWFwUGF5bG9hZFRvQ29udHJhY3RTdHJ1Y3QobWludFJlcXVlc3QpO1xuICAgIGNvbnN0IG92ZXJyaWRlcyA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLmdldENhbGxPdmVycmlkZXMoKTtcbiAgICBhd2FpdCBzZXRFcmMyMEFsbG93YW5jZSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgbWVzc2FnZS5wcmljZVBlclRva2VuLm11bChtZXNzYWdlLnF1YW50aXR5KSwgbWludFJlcXVlc3QuY3VycmVuY3lBZGRyZXNzLCBvdmVycmlkZXMpO1xuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJtaW50V2l0aFNpZ25hdHVyZVwiLCBbbWVzc2FnZSwgc2lnbmF0dXJlXSwgb3ZlcnJpZGVzKTtcbiAgICBjb25zdCB0ID0gdGhpcy5jb250cmFjdFdyYXBwZXIucGFyc2VMb2dzKFwiVG9rZW5zTWludGVkV2l0aFNpZ25hdHVyZVwiLCByZWNlaXB0LmxvZ3MpO1xuICAgIGlmICh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gTWludFdpdGhTaWduYXR1cmUgZXZlbnQgZm91bmRcIik7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gdFswXS5hcmdzLnRva2VuSWRNaW50ZWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkLFxuICAgICAgcmVjZWlwdFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogTWludCBhbnkgbnVtYmVyIG9mIGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBORlQgYXQgb25jZVxuICAgKiBAcmVtYXJrcyBNaW50IG11bHRpcGxlIGR5bmFtaWMgTkZUcyBpbiBvbmUgdHJhbnNhY3Rpb24uIE5vdGUgdGhhdCB0aGlzIGlzIG9ubHkgcG9zc2libGUgZm9yIGZyZWUgbWludHMgKGNhbm5vdCBiYXRjaCBtaW50cyB3aXRoIGEgcHJpY2UgYXR0YWNoZWQgdG8gaXQgZm9yIHNlY3VyaXR5IHJlYXNvbnMpXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gc2VlIGhvdyB0byBjcmFmdCBhIGJhdGNoIG9mIHBheWxvYWRzIHRvIHNpZ24gaW4gdGhlIGBnZW5lcmF0ZUJhdGNoKClgIGRvY3VtZW50YXRpb25cbiAgICogY29uc3Qgc2lnbmVkUGF5bG9hZHMgPSBjb250cmFjdC5lcmMxMTU1LnNpZ25hdHVyZS5nZW5lcmF0ZUJhdGNoKHBheWxvYWRzKTtcbiAgICpcbiAgICogLy8gbm93IGFueW9uZSBjYW4gbWludCB0aGUgTkZUXG4gICAqIGNvbnN0IHR4ID0gY29udHJhY3QuZXJjMTE1NS5zaWduYXR1cmUubWludEJhdGNoKHNpZ25lZFBheWxvYWRzKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBzaWduZWRQYXlsb2FkcyAtIHRoZSBhcnJheSBvZiBzaWduZWQgcGF5bG9hZHMgdG8gbWludFxuICAgKiBAdHdmZWF0dXJlIEVSQzExNTVTaWduYXR1cmVNaW50YWJsZVxuICAgKi9cbiAgYXN5bmMgbWludEJhdGNoKHNpZ25lZFBheWxvYWRzKSB7XG4gICAgY29uc3QgY29udHJhY3RQYXlsb2FkcyA9IGF3YWl0IFByb21pc2UuYWxsKHNpZ25lZFBheWxvYWRzLm1hcChhc3luYyBzID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLm1hcFBheWxvYWRUb0NvbnRyYWN0U3RydWN0KHMucGF5bG9hZCk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBzLnNpZ25hdHVyZTtcbiAgICAgIGNvbnN0IHByaWNlID0gcy5wYXlsb2FkLnByaWNlO1xuICAgICAgaWYgKEJpZ051bWJlci5mcm9tKHByaWNlKS5ndCgwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gb25seSBiYXRjaCBmcmVlIG1pbnRzLiBGb3IgbWludHMgd2l0aCBhIHByaWNlLCB1c2UgcmVndWxhciBtaW50KClcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBzaWduYXR1cmVcbiAgICAgIH07XG4gICAgfSkpO1xuICAgIGNvbnN0IGVuY29kZWQgPSBjb250cmFjdFBheWxvYWRzLm1hcChwID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShcIm1pbnRXaXRoU2lnbmF0dXJlXCIsIFtwLm1lc3NhZ2UsIHAuc2lnbmF0dXJlXSk7XG4gICAgfSk7XG4gICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLm11bHRpQ2FsbChlbmNvZGVkKTtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLmNvbnRyYWN0V3JhcHBlci5wYXJzZUxvZ3MoXCJUb2tlbnNNaW50ZWRXaXRoU2lnbmF0dXJlXCIsIHJlY2VpcHQubG9ncyk7XG4gICAgaWYgKGV2ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE1pbnRXaXRoU2lnbmF0dXJlIGV2ZW50IGZvdW5kXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzLm1hcChsb2cgPT4gKHtcbiAgICAgIGlkOiBsb2cuYXJncy50b2tlbklkTWludGVkLFxuICAgICAgcmVjZWlwdFxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhhdCBhIHBheWxvYWQgaXMgY29ycmVjdGx5IHNpZ25lZFxuICAgKiBAcGFyYW0gc2lnbmVkUGF5bG9hZCAtIHRoZSBwYXlsb2FkIHRvIHZlcmlmeVxuICAgKiBAdHdmZWF0dXJlIEVSQzExNTVTaWduYXR1cmVNaW50YWJsZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IG5mdE1ldGFkYXRhID0ge1xuICAgKiAgIG5hbWU6IFwiQ29vbCBORlQgIzFcIixcbiAgICogICBkZXNjcmlwdGlvbjogXCJUaGlzIGlzIGEgY29vbCBORlRcIixcbiAgICogICBpbWFnZTogZnMucmVhZEZpbGVTeW5jKFwicGF0aC90by9pbWFnZS5wbmdcIiksIC8vIFRoaXMgY2FuIGJlIGFuIGltYWdlIHVybCBvciBmaWxlXG4gICAqIH07XG4gICAqXG4gICAqIGNvbnN0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAqIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgNjAgKiA2MCAqIDI0ICogMTAwMCk7XG4gICAqIGNvbnN0IHBheWxvYWQgPSB7XG4gICAqICAgbWV0YWRhdGE6IG5mdE1ldGFkYXRhLCAvLyBUaGUgTkZUIHRvIG1pbnRcbiAgICogICB0bzoge3t3YWxsZXRfYWRkcmVzc319LCAvLyBXaG8gd2lsbCByZWNlaXZlIHRoZSBORlRcbiAgICogICBxdWFudGl0eTogMiwgLy8gdGhlIHF1YW50aXR5IG9mIE5GVHMgdG8gbWludFxuICAgKiAgIHByaWNlOiAwLjUsIC8vIHRoZSBwcmljZSBwZXIgTkZUXG4gICAqICAgY3VycmVuY3lBZGRyZXNzOiBOQVRJVkVfVE9LRU5fQUREUkVTUywgLy8gdGhlIGN1cnJlbmN5IHRvIHBheSB3aXRoXG4gICAqICAgbWludFN0YXJ0VGltZTogc3RhcnRUaW1lLCAvLyBjYW4gbWludCBhbnl0aW1lIGZyb20gbm93XG4gICAqICAgbWludEVuZFRpbWU6IGVuZFRpbWUsIC8vIHRvIDI0aCBmcm9tIG5vd1xuICAgKiAgIHJveWFsdHlSZWNpcGllbnQ6IFwiMHguLi5cIiwgLy8gY3VzdG9tIHJveWFsdHkgcmVjaXBpZW50IGZvciB0aGlzIE5GVFxuICAgKiAgIHJveWFsdHlCcHM6IDEwMCwgLy8gY3VzdG9tIHJveWFsdHkgZmVlcyBmb3IgdGhpcyBORlQgKGluIGJwcylcbiAgICogICBwcmltYXJ5U2FsZVJlY2lwaWVudDogXCIweC4uLlwiLCAvLyBjdXN0b20gc2FsZSByZWNpcGllbnQgZm9yIHRoaXMgTkZUXG4gICAqIH07XG4gICAqXG4gICAqIGNvbnN0IHNpZ25lZFBheWxvYWQgPSBjb250cmFjdC5lcmMxMTU1LnNpZ25hdHVyZS5nZW5lcmF0ZShwYXlsb2FkKTtcbiAgICogLy8gTm93IHlvdSBjYW4gdmVyaWZ5IHRoYXQgdGhlIHBheWxvYWQgaXMgdmFsaWRcbiAgICogY29uc3QgaXNWYWxpZCA9IGF3YWl0IGNvbnRyYWN0LmVyYzExNTUuc2lnbmF0dXJlLnZlcmlmeShzaWduZWRQYXlsb2FkKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyB2ZXJpZnkoc2lnbmVkUGF5bG9hZCkge1xuICAgIGNvbnN0IG1pbnRSZXF1ZXN0ID0gc2lnbmVkUGF5bG9hZC5wYXlsb2FkO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ25lZFBheWxvYWQuc2lnbmF0dXJlO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLm1hcFBheWxvYWRUb0NvbnRyYWN0U3RydWN0KG1pbnRSZXF1ZXN0KTtcbiAgICBjb25zdCB2ZXJpZmljYXRpb24gPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QudmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSk7XG4gICAgcmV0dXJuIHZlcmlmaWNhdGlvblswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHNpZ25hdHVyZSB0aGF0IGNhbiBiZSB1c2VkIHRvIG1pbnQgYW4gTkZUIGR5bmFtaWNhbGx5LlxuICAgKlxuICAgKiBAcmVtYXJrcyBUYWtlcyBpbiBhbiBORlQgYW5kIHNvbWUgaW5mb3JtYXRpb24gYWJvdXQgaG93IGl0IGNhbiBiZSBtaW50ZWQsIHVwbG9hZHMgdGhlIG1ldGFkYXRhIGFuZCBzaWducyBpdCB3aXRoIHlvdXIgcHJpdmF0ZSBrZXkuIFRoZSBnZW5lcmF0ZWQgc2lnbmF0dXJlIGNhbiB0aGVuIGJlIHVzZWQgdG8gbWludCBhbiBORlQgdXNpbmcgdGhlIGV4YWN0IHBheWxvYWQgYW5kIHNpZ25hdHVyZSBnZW5lcmF0ZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgbmZ0TWV0YWRhdGEgPSB7XG4gICAqICAgbmFtZTogXCJDb29sIE5GVCAjMVwiLFxuICAgKiAgIGRlc2NyaXB0aW9uOiBcIlRoaXMgaXMgYSBjb29sIE5GVFwiLFxuICAgKiAgIGltYWdlOiBmcy5yZWFkRmlsZVN5bmMoXCJwYXRoL3RvL2ltYWdlLnBuZ1wiKSwgLy8gVGhpcyBjYW4gYmUgYW4gaW1hZ2UgdXJsIG9yIGZpbGVcbiAgICogfTtcbiAgICpcbiAgICogY29uc3Qgc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICogY29uc3QgZW5kVGltZSA9IG5ldyBEYXRlKERhdGUubm93KCkgKyA2MCAqIDYwICogMjQgKiAxMDAwKTtcbiAgICogY29uc3QgcGF5bG9hZCA9IHtcbiAgICogICBtZXRhZGF0YTogbmZ0TWV0YWRhdGEsIC8vIFRoZSBORlQgdG8gbWludFxuICAgKiAgIHRvOiB7e3dhbGxldF9hZGRyZXNzfX0sIC8vIFdobyB3aWxsIHJlY2VpdmUgdGhlIE5GVFxuICAgKiAgIHF1YW50aXR5OiAyLCAvLyB0aGUgcXVhbnRpdHkgb2YgTkZUcyB0byBtaW50XG4gICAqICAgcHJpY2U6IDAuNSwgLy8gdGhlIHByaWNlIHBlciBORlRcbiAgICogICBjdXJyZW5jeUFkZHJlc3M6IE5BVElWRV9UT0tFTl9BRERSRVNTLCAvLyB0aGUgY3VycmVuY3kgdG8gcGF5IHdpdGhcbiAgICogICBtaW50U3RhcnRUaW1lOiBzdGFydFRpbWUsIC8vIGNhbiBtaW50IGFueXRpbWUgZnJvbSBub3dcbiAgICogICBtaW50RW5kVGltZTogZW5kVGltZSwgLy8gdG8gMjRoIGZyb20gbm93XG4gICAqICAgcm95YWx0eVJlY2lwaWVudDogXCIweC4uLlwiLCAvLyBjdXN0b20gcm95YWx0eSByZWNpcGllbnQgZm9yIHRoaXMgTkZUXG4gICAqICAgcm95YWx0eUJwczogMTAwLCAvLyBjdXN0b20gcm95YWx0eSBmZWVzIGZvciB0aGlzIE5GVCAoaW4gYnBzKVxuICAgKiAgIHByaW1hcnlTYWxlUmVjaXBpZW50OiBcIjB4Li4uXCIsIC8vIGN1c3RvbSBzYWxlIHJlY2lwaWVudCBmb3IgdGhpcyBORlRcbiAgICogfTtcbiAgICpcbiAgICogY29uc3Qgc2lnbmVkUGF5bG9hZCA9IGF3YWl0IGNvbnRyYWN0LmVyYzExNTUuc2lnbmF0dXJlLmdlbmVyYXRlKHBheWxvYWQpO1xuICAgKiAvLyBub3cgYW55b25lIGNhbiB1c2UgdGhlc2UgdG8gbWludCB0aGUgTkZUIHVzaW5nIGBjb250cmFjdC5lcmMxMTU1LnNpZ25hdHVyZS5taW50KHNpZ25lZFBheWxvYWQpYFxuICAgKiBgYGBcbiAgICogQHBhcmFtIHBheWxvYWRUb1NpZ24gLSB0aGUgcGF5bG9hZCB0byBzaWduXG4gICAqIEByZXR1cm5zIHRoZSBzaWduZWQgcGF5bG9hZCBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgc2lnbmF0dXJlXG4gICAqIEB0d2ZlYXR1cmUgRVJDMTE1NVNpZ25hdHVyZU1pbnRhYmxlXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZShwYXlsb2FkVG9TaWduKSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIC4uLnBheWxvYWRUb1NpZ24sXG4gICAgICB0b2tlbklkOiBldGhlcnMuY29uc3RhbnRzLk1heFVpbnQyNTZcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmdlbmVyYXRlRnJvbVRva2VuSWQocGF5bG9hZCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBzaWduYXR1cmUgdGhhdCBjYW4gYmUgdXNlZCB0byBtaW50IGFkZGl0aW9uYWx5IHN1cHBseSB0byBhbiBleGlzdGluZyBORlQuXG4gICAqXG4gICAqIEByZW1hcmtzIFRha2VzIGluIGEgcGF5bG9hZCB3aXRoIHRoZSB0b2tlbiBJRCBvZiBhbiBleGlzdGluZyBORlQsIGFuZCBzaWducyBpdCB3aXRoIHlvdXIgcHJpdmF0ZSBrZXkuIFRoZSBnZW5lcmF0ZWQgc2lnbmF0dXJlIGNhbiB0aGVuIGJlIHVzZWQgdG8gbWludCBhZGRpdGlvbmFsIHN1cHBseSB0byB0aGUgTkZUIHVzaW5nIHRoZSBleGFjdCBwYXlsb2FkIGFuZCBzaWduYXR1cmUgZ2VuZXJhdGVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IG5mdE1ldGFkYXRhID0ge1xuICAgKiAgIG5hbWU6IFwiQ29vbCBORlQgIzFcIixcbiAgICogICBkZXNjcmlwdGlvbjogXCJUaGlzIGlzIGEgY29vbCBORlRcIixcbiAgICogICBpbWFnZTogZnMucmVhZEZpbGVTeW5jKFwicGF0aC90by9pbWFnZS5wbmdcIiksIC8vIFRoaXMgY2FuIGJlIGFuIGltYWdlIHVybCBvciBmaWxlXG4gICAqIH07XG4gICAqXG4gICAqIGNvbnN0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAqIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgNjAgKiA2MCAqIDI0ICogMTAwMCk7XG4gICAqIGNvbnN0IHBheWxvYWQgPSB7XG4gICAqICAgdG9rZW5JZDogMCwgLy8gSW5zdGVhZCBvZiBtZXRhZGF0YSwgd2Ugc3BlY2lmaWN5IHRoZSB0b2tlbiBJRCBvZiB0aGUgTkZUIHRvIG1pbnQgc3VwcGx5IHRvXG4gICAqICAgdG86IHt7d2FsbGV0X2FkZHJlc3N9fSwgLy8gV2hvIHdpbGwgcmVjZWl2ZSB0aGUgTkZUIChvciBBZGRyZXNzWmVybyBmb3IgYW55b25lKVxuICAgKiAgIHF1YW50aXR5OiAyLCAvLyB0aGUgcXVhbnRpdHkgb2YgTkZUcyB0byBtaW50XG4gICAqICAgcHJpY2U6IDAuNSwgLy8gdGhlIHByaWNlIHBlciBORlRcbiAgICogICBjdXJyZW5jeUFkZHJlc3M6IE5BVElWRV9UT0tFTl9BRERSRVNTLCAvLyB0aGUgY3VycmVuY3kgdG8gcGF5IHdpdGhcbiAgICogICBtaW50U3RhcnRUaW1lOiBzdGFydFRpbWUsIC8vIGNhbiBtaW50IGFueXRpbWUgZnJvbSBub3dcbiAgICogICBtaW50RW5kVGltZTogZW5kVGltZSwgLy8gdG8gMjRoIGZyb20gbm93XG4gICAqICAgcm95YWx0eVJlY2lwaWVudDogXCIweC4uLlwiLCAvLyBjdXN0b20gcm95YWx0eSByZWNpcGllbnQgZm9yIHRoaXMgTkZUXG4gICAqICAgcm95YWx0eUJwczogMTAwLCAvLyBjdXN0b20gcm95YWx0eSBmZWVzIGZvciB0aGlzIE5GVCAoaW4gYnBzKVxuICAgKiAgIHByaW1hcnlTYWxlUmVjaXBpZW50OiBcIjB4Li4uXCIsIC8vIGN1c3RvbSBzYWxlIHJlY2lwaWVudCBmb3IgdGhpcyBORlRcbiAgICogfTtcbiAgICpcbiAgICogY29uc3Qgc2lnbmVkUGF5bG9hZCA9IGF3YWl0IGNvbnRyYWN0LmVyYzExNTUuc2lnbmF0dXJlLmdlbmVyYXRlRnJvbVRva2VuSWQocGF5bG9hZCk7XG4gICAqIC8vIG5vdyBhbnlvbmUgY2FuIHVzZSB0aGVzZSB0byBtaW50IHRoZSBORlQgdXNpbmcgYGNvbnRyYWN0LmVyYzExNTUuc2lnbmF0dXJlLm1pbnQoc2lnbmVkUGF5bG9hZClgXG4gICAqIGBgYFxuICAgKiBAcGFyYW0gcGF5bG9hZFRvU2lnbiAtIHRoZSBwYXlsb2FkIHRvIHNpZ25cbiAgICogQHJldHVybnMgdGhlIHNpZ25lZCBwYXlsb2FkIGFuZCB0aGUgY29ycmVzcG9uZGluZyBzaWduYXR1cmVcbiAgICogQHR3ZmVhdHVyZSBFUkMxMTU1U2lnbmF0dXJlTWludGFibGVcbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlRnJvbVRva2VuSWQocGF5bG9hZFRvU2lnbikge1xuICAgIGNvbnN0IHBheWxvYWRzID0gYXdhaXQgdGhpcy5nZW5lcmF0ZUJhdGNoRnJvbVRva2VuSWRzKFtwYXlsb2FkVG9TaWduXSk7XG4gICAgcmV0dXJuIHBheWxvYWRzWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgYmF0Y2ggb2Ygc2lnbmF0dXJlcyB0aGF0IGNhbiBiZSB1c2VkIHRvIG1pbnQgbWFueSBuZXcgTkZUcyBkeW5hbWljYWxseS5cbiAgICpcbiAgICogQHJlbWFya3MgU2VlIHtAbGluayBFcmMxMTU1U2lnbmF0dXJlTWludGFibGUuZ2VuZXJhdGV9XG4gICAqXG4gICAqIEBwYXJhbSBwYXlsb2Fkc1RvU2lnbiAtIHRoZSBwYXlsb2FkcyB0byBzaWduXG4gICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHBheWxvYWRzIGFuZCBzaWduYXR1cmVzXG4gICAqIEB0d2ZlYXR1cmUgRVJDMTE1NVNpZ25hdHVyZU1pbnRhYmxlXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZUJhdGNoKHBheWxvYWRzVG9TaWduKSB7XG4gICAgY29uc3QgcGF5bG9hZHMgPSBwYXlsb2Fkc1RvU2lnbi5tYXAocGF5bG9hZCA9PiAoe1xuICAgICAgLi4ucGF5bG9hZCxcbiAgICAgIHRva2VuSWQ6IGV0aGVycy5jb25zdGFudHMuTWF4VWludDI1NlxuICAgIH0pKTtcbiAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUJhdGNoRnJvbVRva2VuSWRzKHBheWxvYWRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5yYXRlIGEgYmF0Y2ggb2Ygc2lnbmF0dXJlcyB0aGF0IGNhbiBiZSB1c2VkIHRvIG1pbnQgbmV3IE5GVHMgb3IgYWRkaXRpb25hbHkgc3VwcGx5IHRvIGV4aXN0aW5nIE5GVHMgZHluYW1pY2FsbHkuXG4gICAqXG4gICAqIEByZW1hcmtzIFNlZSB7QGxpbmsgRXJjMTE1NVNpZ25hdHVyZU1pbnRhYmxlLmdlbmVyYXRlRnJvbVRva2VuSWR9XG4gICAqXG4gICAqIEBwYXJhbSBwYXlsb2Fkc1RvU2lnbiAtIHRoZSBwYXlsb2FkcyB0byBzaWduIHdpdGggdG9rZW5JZHMgc3BlY2lmaWVkXG4gICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHBheWxvYWRzIGFuZCBzaWduYXR1cmVzXG4gICAqIEB0d2ZlYXR1cmUgRVJDMTE1NVNpZ25hdHVyZU1pbnRhYmxlXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZUJhdGNoRnJvbVRva2VuSWRzKHBheWxvYWRzVG9TaWduKSB7XG4gICAgYXdhaXQgdGhpcy5yb2xlcz8udmVyaWZ5KFtcIm1pbnRlclwiXSwgYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0U2lnbmVyQWRkcmVzcygpKTtcbiAgICBjb25zdCBwYXJzZWRSZXF1ZXN0cyA9IHBheWxvYWRzVG9TaWduLm1hcChtID0+IFNpZ25hdHVyZTExNTVQYXlsb2FkSW5wdXRXaXRoVG9rZW5JZC5wYXJzZShtKSk7XG4gICAgY29uc3QgbWV0YWRhdGFzID0gcGFyc2VkUmVxdWVzdHMubWFwKHIgPT4gci5tZXRhZGF0YSk7XG4gICAgY29uc3QgdXJpcyA9IGF3YWl0IHVwbG9hZE9yRXh0cmFjdFVSSXMobWV0YWRhdGFzLCB0aGlzLnN0b3JhZ2UpO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRDaGFpbklEKCk7XG4gICAgY29uc3Qgc2lnbmVyID0gdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0U2lnbmVyKCk7XG4gICAgaW52YXJpYW50KHNpZ25lciwgXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIGNvbnN0IGNvbnRyYWN0SW5mbyA9IGF3YWl0IGdldFByZWJ1aWx0SW5mbyh0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuYWRkcmVzcywgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJvdmlkZXIoKSk7XG4gICAgY29uc3QgaXNMZWdhY3lDb250cmFjdCA9IGNvbnRyYWN0SW5mbz8udHlwZSA9PT0gXCJUb2tlbkVSQzExNTVcIjtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocGFyc2VkUmVxdWVzdHMubWFwKGFzeW5jIChtLCBpKSA9PiB7XG4gICAgICBjb25zdCB1cmkgPSB1cmlzW2ldO1xuICAgICAgY29uc3QgZmluYWxQYXlsb2FkID0gU2lnbmF0dXJlMTE1NVBheWxvYWRPdXRwdXQucGFyc2Uoe1xuICAgICAgICAuLi5tLFxuICAgICAgICB1cmlcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuc2lnblR5cGVkRGF0YShzaWduZXIsIHtcbiAgICAgICAgbmFtZTogaXNMZWdhY3lDb250cmFjdCA/IFwiVG9rZW5FUkMxMTU1XCIgOiBcIlNpZ25hdHVyZU1pbnRFUkMxMTU1XCIsXG4gICAgICAgIHZlcnNpb246IFwiMVwiLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICB2ZXJpZnlpbmdDb250cmFjdDogdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmFkZHJlc3NcbiAgICAgIH0sIHtcbiAgICAgICAgTWludFJlcXVlc3Q6IE1pbnRSZXF1ZXN0MTE1NVxuICAgICAgfSxcbiAgICAgIC8vIFRZUEVIQVNIXG4gICAgICBhd2FpdCB0aGlzLm1hcFBheWxvYWRUb0NvbnRyYWN0U3RydWN0KGZpbmFsUGF5bG9hZCkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF5bG9hZDogZmluYWxQYXlsb2FkLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZS50b1N0cmluZygpXG4gICAgICB9O1xuICAgIH0pKTtcbiAgfVxuXG4gIC8qKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICogUFJJVkFURSBGVU5DVElPTlNcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIE1hcHMgYSBwYXlsb2FkIHRvIHRoZSBmb3JtYXQgZXhwZWN0ZWQgYnkgdGhlIGNvbnRyYWN0XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBAcGFyYW0gbWludFJlcXVlc3QgLSBUaGUgcGF5bG9hZCB0byBtYXAuXG4gICAqIEByZXR1cm5zIC0gVGhlIG1hcHBlZCBwYXlsb2FkLlxuICAgKi9cbiAgYXN5bmMgbWFwUGF5bG9hZFRvQ29udHJhY3RTdHJ1Y3QobWludFJlcXVlc3QpIHtcbiAgICBjb25zdCBub3JtYWxpemVkUHJpY2VQZXJUb2tlbiA9IGF3YWl0IG5vcm1hbGl6ZVByaWNlVmFsdWUodGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJvdmlkZXIoKSwgbWludFJlcXVlc3QucHJpY2UsIG1pbnRSZXF1ZXN0LmN1cnJlbmN5QWRkcmVzcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvOiBtaW50UmVxdWVzdC50byxcbiAgICAgIHRva2VuSWQ6IG1pbnRSZXF1ZXN0LnRva2VuSWQsXG4gICAgICB1cmk6IG1pbnRSZXF1ZXN0LnVyaSxcbiAgICAgIHF1YW50aXR5OiBtaW50UmVxdWVzdC5xdWFudGl0eSxcbiAgICAgIHByaWNlUGVyVG9rZW46IG5vcm1hbGl6ZWRQcmljZVBlclRva2VuLFxuICAgICAgY3VycmVuY3k6IG1pbnRSZXF1ZXN0LmN1cnJlbmN5QWRkcmVzcyxcbiAgICAgIHZhbGlkaXR5U3RhcnRUaW1lc3RhbXA6IG1pbnRSZXF1ZXN0Lm1pbnRTdGFydFRpbWUsXG4gICAgICB2YWxpZGl0eUVuZFRpbWVzdGFtcDogbWludFJlcXVlc3QubWludEVuZFRpbWUsXG4gICAgICB1aWQ6IG1pbnRSZXF1ZXN0LnVpZCxcbiAgICAgIHJveWFsdHlSZWNpcGllbnQ6IG1pbnRSZXF1ZXN0LnJveWFsdHlSZWNpcGllbnQsXG4gICAgICByb3lhbHR5QnBzOiBtaW50UmVxdWVzdC5yb3lhbHR5QnBzLFxuICAgICAgcHJpbWFyeVNhbGVSZWNpcGllbnQ6IG1pbnRSZXF1ZXN0LnByaW1hcnlTYWxlUmVjaXBpZW50XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFN0YW5kYXJkIEVSQzExNTUgTkZUIGZ1bmN0aW9uc1xuICogQHJlbWFya3MgQmFzaWMgZnVuY3Rpb25hbGl0eSBmb3IgYSBFUkMxMTU1IGNvbnRyYWN0IHRoYXQgaGFuZGxlcyBJUEZTIHN0b3JhZ2UgZm9yIHlvdS5cbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBjb250cmFjdCA9IGF3YWl0IHNkay5nZXRDb250cmFjdChcInt7Y29udHJhY3RfYWRkcmVzc319XCIpO1xuICogYXdhaXQgY29udHJhY3QuZXJjMTE1NS50cmFuc2Zlcih3YWxsZXRBZGRyZXNzLCB0b2tlbklkLCBxdWFudGl0eSk7XG4gKiBgYGBcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgRXJjMTE1NSB7XG4gIGdldCBjaGFpbklkKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFpbklkO1xuICB9XG4gIGNvbnN0cnVjdG9yKGNvbnRyYWN0V3JhcHBlciwgc3RvcmFnZSwgY2hhaW5JZCkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZlYXR1cmVOYW1lXCIsIEZFQVRVUkVfRURJVElPTi5uYW1lKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJxdWVyeVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1pbnRhYmxlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYnVybmFibGVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJsYXp5TWludGFibGVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaWduYXR1cmVNaW50YWJsZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRyYWN0V3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3JhZ2VcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY2hhaW5JZFwiLCB2b2lkIDApO1xuICAgIHRoaXMuY29udHJhY3RXcmFwcGVyID0gY29udHJhY3RXcmFwcGVyO1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgdGhpcy5xdWVyeSA9IHRoaXMuZGV0ZWN0RXJjMTE1NUVudW1lcmFibGUoKTtcbiAgICB0aGlzLm1pbnRhYmxlID0gdGhpcy5kZXRlY3RFcmMxMTU1TWludGFibGUoKTtcbiAgICB0aGlzLmJ1cm5hYmxlID0gdGhpcy5kZXRlY3RFcmMxMTU1QnVybmFibGUoKTtcbiAgICB0aGlzLmxhenlNaW50YWJsZSA9IHRoaXMuZGV0ZWN0RXJjMTE1NUxhenlNaW50YWJsZSgpO1xuICAgIHRoaXMuc2lnbmF0dXJlTWludGFibGUgPSB0aGlzLmRldGVjdEVyYzExNTVTaWduYXR1cmVNaW50YWJsZSgpO1xuICAgIHRoaXMuX2NoYWluSWQgPSBjaGFpbklkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb25OZXR3b3JrVXBkYXRlZChuZXR3b3JrKSB7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIudXBkYXRlU2lnbmVyT3JQcm92aWRlcihuZXR3b3JrKTtcbiAgfVxuICBnZXRBZGRyZXNzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuYWRkcmVzcztcbiAgfVxuXG4gIC8vLy8vLyBTdGFuZGFyZCBFUkMxMTU1IGZ1bmN0aW9ucyAvLy8vLy9cblxuICAvKipcbiAgICogR2V0IGEgc2luZ2xlIE5GVCBNZXRhZGF0YVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IG5mdCA9IGF3YWl0IGNvbnRyYWN0LmVyYzExNTUuZ2V0KDApO1xuICAgKiBgYGBcbiAgICogQHBhcmFtIHRva2VuSWQgLSB0aGUgdG9rZW5JZCBvZiB0aGUgTkZUIHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm5zIFRoZSBORlQgbWV0YWRhdGFcbiAgICogQHR3ZmVhdHVyZSBFUkMxMTU1XG4gICAqL1xuICBhc3luYyBnZXQodG9rZW5JZCkge1xuICAgIGNvbnN0IFtzdXBwbHksIG1ldGFkYXRhXSA9IGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QudG90YWxTdXBwbHkodG9rZW5JZCkuY2F0Y2goKCkgPT4gQmlnTnVtYmVyLmZyb20oMCkpLCB0aGlzLmdldFRva2VuTWV0YWRhdGEodG9rZW5JZCkuY2F0Y2goKCkgPT4gKHtcbiAgICAgIGlkOiB0b2tlbklkLnRvU3RyaW5nKCksXG4gICAgICB1cmk6IFwiXCIsXG4gICAgICAuLi5GQUxMQkFDS19NRVRBREFUQVxuICAgIH0pKV0pO1xuICAgIHJldHVybiB7XG4gICAgICBvd25lcjogZXRoZXJzLmNvbnN0YW50cy5BZGRyZXNzWmVybyxcbiAgICAgIG1ldGFkYXRhLFxuICAgICAgdHlwZTogXCJFUkMxMTU1XCIsXG4gICAgICBzdXBwbHk6IHN1cHBseS50b051bWJlcigpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0b3RhbCBzdXBwbHkgb2YgYSBzcGVjaWZpYyB0b2tlblxuICAgKiBAcGFyYW0gdG9rZW5JZCAtIFRoZSB0b2tlbiBJRCB0byBnZXQgdGhlIHRvdGFsIHN1cHBseSBvZlxuICAgKiBAcmV0dXJucyB0aGUgdG90YWwgc3VwcGx5XG4gICAqL1xuICBhc3luYyB0b3RhbFN1cHBseSh0b2tlbklkKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC50b3RhbFN1cHBseSh0b2tlbklkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgTkZUIEJhbGFuY2VcbiAgICpcbiAgICogQHJlbWFya3MgR2V0IGEgd2FsbGV0cyBORlQgYmFsYW5jZSAobnVtYmVyIG9mIE5GVHMgaW4gdGhpcyBjb250cmFjdCBvd25lZCBieSB0aGUgd2FsbGV0KS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBBZGRyZXNzIG9mIHRoZSB3YWxsZXQgdG8gY2hlY2sgTkZUIGJhbGFuY2VcbiAgICogY29uc3Qgd2FsbGV0QWRkcmVzcyA9IFwie3t3YWxsZXRfYWRkcmVzc319XCI7XG4gICAqIGNvbnN0IHRva2VuSWQgPSAwOyAvLyBJZCBvZiB0aGUgTkZUIHRvIGNoZWNrXG4gICAqIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjb250cmFjdC5lcmMxMTU1LmJhbGFuY2VPZih3YWxsZXRBZGRyZXNzLCB0b2tlbklkKTtcbiAgICogYGBgXG4gICAqIEB0d2ZlYXR1cmUgRVJDMTE1NVxuICAgKi9cbiAgYXN5bmMgYmFsYW5jZU9mKGFkZHJlc3MsIHRva2VuSWQpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmJhbGFuY2VPZihhZGRyZXNzLCB0b2tlbklkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgTkZUIEJhbGFuY2UgZm9yIHRoZSBjdXJyZW50bHkgY29ubmVjdGVkIHdhbGxldFxuICAgKi9cbiAgYXN5bmMgYmFsYW5jZSh0b2tlbklkKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYmFsYW5jZU9mKGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFNpZ25lckFkZHJlc3MoKSwgdG9rZW5JZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgdGhpcyB3YWxsZXQgaGFzIGFwcHJvdmVkIHRyYW5zZmVycyBmcm9tIHRoZSBnaXZlbiBvcGVyYXRvclxuICAgKiBAcGFyYW0gYWRkcmVzcyAtIHRoZSB3YWxsZXQgYWRkcmVzc1xuICAgKiBAcGFyYW0gb3BlcmF0b3IgLSB0aGUgb3BlcmF0b3IgYWRkcmVzc1xuICAgKi9cbiAgYXN5bmMgaXNBcHByb3ZlZChhZGRyZXNzLCBvcGVyYXRvcikge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuaXNBcHByb3ZlZEZvckFsbChhZGRyZXNzLCBvcGVyYXRvcik7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmZXIgYSBzaW5nbGUgTkZUXG4gICAqXG4gICAqIEByZW1hcmtzIFRyYW5zZmVyIGFuIE5GVCBmcm9tIHRoZSBjb25uZWN0ZWQgd2FsbGV0IHRvIGFub3RoZXIgd2FsbGV0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIEFkZHJlc3Mgb2YgdGhlIHdhbGxldCB5b3Ugd2FudCB0byBzZW5kIHRoZSBORlQgdG9cbiAgICogY29uc3QgdG9BZGRyZXNzID0gXCJ7e3dhbGxldF9hZGRyZXNzfX1cIjtcbiAgICogY29uc3QgdG9rZW5JZCA9IFwiMFwiOyAvLyBUaGUgdG9rZW4gSUQgb2YgdGhlIE5GVCB5b3Ugd2FudCB0byBzZW5kXG4gICAqIGNvbnN0IGFtb3VudCA9IDM7IC8vIEhvdyBtYW55IGNvcGllcyBvZiB0aGUgTkZUcyB0byB0cmFuc2ZlclxuICAgKiBhd2FpdCBjb250cmFjdC5lcmMxMTU1LnRyYW5zZmVyKHRvQWRkcmVzcywgdG9rZW5JZCwgYW1vdW50KTtcbiAgICogYGBgXG4gICAqIEB0d2ZlYXR1cmUgRVJDMTE1NVxuICAgKi9cbiAgYXN5bmMgdHJhbnNmZXIodG8sIHRva2VuSWQsIGFtb3VudCkge1xuICAgIGxldCBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBbMF07XG4gICAgY29uc3QgZnJvbSA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFNpZ25lckFkZHJlc3MoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjZWlwdDogYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuc2VuZFRyYW5zYWN0aW9uKFwic2FmZVRyYW5zZmVyRnJvbVwiLCBbZnJvbSwgdG8sIHRva2VuSWQsIGFtb3VudCwgZGF0YV0pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHByb3ZlIG9yIHJlbW92ZSBvcGVyYXRvciBhcyBhbiBvcGVyYXRvciBmb3IgdGhlIGNhbGxlci4gT3BlcmF0b3JzIGNhbiBjYWxsIHRyYW5zZmVyRnJvbSBvciBzYWZlVHJhbnNmZXJGcm9tIGZvciBhbnkgdG9rZW4gb3duZWQgYnkgdGhlIGNhbGxlci5cbiAgICogQHBhcmFtIG9wZXJhdG9yIC0gdGhlIG9wZXJhdG9yJ3MgYWRkcmVzc1xuICAgKiBAcGFyYW0gYXBwcm92ZWQgLSB3aGV0aGVyIHRvIGFwcHJvdmUgb3IgcmVtb3ZlXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgc2V0QXBwcm92YWxGb3JBbGwob3BlcmF0b3IsIGFwcHJvdmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNlbmRUcmFuc2FjdGlvbihcInNldEFwcHJvdmFsRm9yQWxsXCIsIFtvcGVyYXRvciwgYXBwcm92ZWRdKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWlyZHJvcCBtdWx0aXBsZSBORlRzXG4gICAqXG4gICAqIEByZW1hcmtzIEFpcmRyb3Agb25lIG9yIG11bHRpcGxlIE5GVHMgdG8gdGhlIHByb3ZpZGVkIHdhbGxldCBhZGRyZXNzZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gVGhlIHRva2VuIElEIG9mIHRoZSBORlQgeW91IHdhbnQgdG8gYWlyZHJvcFxuICAgKiBjb25zdCB0b2tlbklkID0gXCIwXCI7XG4gICAqIC8vIEFycmF5IG9mIG9iamVjdHMgb2YgYWRkcmVzc2VzIGFuZCBxdWFudGl0aWVzIHRvIGFpcmRyb3AgTkZUcyB0b1xuICAgKiBjb25zdCBhZGRyZXNzZXMgPSBbXG4gICAqICB7XG4gICAqICAgIGFkZHJlc3M6IFwiMHguLi5cIixcbiAgICogICAgcXVhbnRpdHk6IDIsXG4gICAqICB9LFxuICAgKiAge1xuICAgKiAgIGFkZHJlc3M6IFwiMHguLi5cIixcbiAgICogICAgcXVhbnRpdHk6IDMsXG4gICAqICB9LFxuICAgKiBdO1xuICAgKiBhd2FpdCBjb250cmFjdC5haXJkcm9wKHRva2VuSWQsIGFkZHJlc3Nlcyk7XG4gICAqXG4gICAqIC8vIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGFycmF5IG9mIGFkZHJlc3NlcywgaXQgd2lsbCBhaXJkcm9wIDEgTkZUIHBlciBhZGRyZXNzXG4gICAqIGNvbnN0IHRva2VuSWQgPSBcIjBcIjtcbiAgICogY29uc3QgYWRkcmVzc2VzID0gW1xuICAgKiAgXCIweC4uLlwiLCBcIjB4Li4uXCIsIFwiMHguLi5cIixcbiAgICogXVxuICAgKiBhd2FpdCBjb250cmFjdC5lcmMxMTU1LmFpcmRyb3AodG9rZW5JZCwgYWRkcmVzc2VzKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBhaXJkcm9wKHRva2VuSWQsIGFkZHJlc3Nlcykge1xuICAgIGxldCBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbMF07XG4gICAgY29uc3QgZnJvbSA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFNpZ25lckFkZHJlc3MoKTtcbiAgICBjb25zdCBiYWxhbmNlT2YgPSBhd2FpdCB0aGlzLmJhbGFuY2VPZihmcm9tLCB0b2tlbklkKTtcbiAgICBjb25zdCBpbnB1dCA9IEFpcmRyb3BJbnB1dFNjaGVtYS5wYXJzZShhZGRyZXNzZXMpO1xuICAgIGNvbnN0IHRvdGFsVG9BaXJkcm9wID0gaW5wdXQucmVkdWNlKChwcmV2LCBjdXJyKSA9PiB7XG4gICAgICByZXR1cm4gcHJldiArIE51bWJlcihjdXJyPy5xdWFudGl0eSB8fCAxKTtcbiAgICB9LCAwKTtcbiAgICBpZiAoYmFsYW5jZU9mLnRvTnVtYmVyKCkgPCB0b3RhbFRvQWlyZHJvcCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgY2FsbGVyIG93bnMgJHtiYWxhbmNlT2YudG9OdW1iZXIoKX0gTkZUcywgYnV0IHdhbnRzIHRvIGFpcmRyb3AgJHt0b3RhbFRvQWlyZHJvcH0gTkZUcy5gKTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RlZCA9IGlucHV0Lm1hcChfcmVmID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGFkZHJlc3M6IHRvLFxuICAgICAgICBxdWFudGl0eVxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoXCJzYWZlVHJhbnNmZXJGcm9tXCIsIFtmcm9tLCB0bywgdG9rZW5JZCwgcXVhbnRpdHksIGRhdGFdKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjZWlwdDogYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIubXVsdGlDYWxsKGVuY29kZWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5leHQgYXZhaWxhYmxlIHRva2VuIElEIHRvIG1pbnRcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBuZXh0VG9rZW5JZFRvTWludCgpIHtcbiAgICBpZiAoaGFzRnVuY3Rpb24oXCJuZXh0VG9rZW5JZFRvTWludFwiLCB0aGlzLmNvbnRyYWN0V3JhcHBlcikpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QubmV4dFRva2VuSWRUb01pbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udHJhY3QgcmVxdWlyZXMgdGhlIGBuZXh0VG9rZW5JZFRvTWludGAgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGRldGVybWluZSB0aGUgbmV4dCB0b2tlbiBJRCB0byBtaW50XCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vLy8vLyBFUkMxMTU1IEVudW1lcmFibGUgRXh0ZW5zaW9uIC8vLy8vL1xuXG4gIC8qKlxuICAgKiBHZXQgQWxsIE5GVHNcbiAgICpcbiAgICogQHJlbWFya3MgR2V0IGFsbCB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggZXZlcnkgTkZUIGluIHRoaXMgY29udHJhY3QuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHJldHVybnMgdGhlIGZpcnN0IDEwMCBORlRzLCB1c2UgcXVlcnlQYXJhbXMgdG8gZmV0Y2ggbW9yZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBuZnRzID0gYXdhaXQgY29udHJhY3QuZXJjMTE1NS5nZXRBbGwoKTtcbiAgICogYGBgXG4gICAqIEBwYXJhbSBxdWVyeVBhcmFtcyAtIG9wdGlvbmFsIGZpbHRlcmluZyB0byBvbmx5IGZldGNoIGEgc3Vic2V0IG9mIHJlc3VsdHMuXG4gICAqIEByZXR1cm5zIFRoZSBORlQgbWV0YWRhdGEgZm9yIGFsbCBORlRzIHF1ZXJpZWQuXG4gICAqIEB0d2ZlYXR1cmUgRVJDMTE1NUVudW1lcmFibGVcbiAgICovXG4gIGFzeW5jIGdldEFsbChxdWVyeVBhcmFtcykge1xuICAgIHJldHVybiBhc3NlcnRFbmFibGVkKHRoaXMucXVlcnksIEZFQVRVUkVfRURJVElPTl9FTlVNRVJBQkxFKS5hbGwocXVlcnlQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyIG9mIE5GVHMgbWludGVkXG4gICAqIEByZW1hcmtzIFRoaXMgcmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIE5GVHMgbWludGVkIGluIHRoaXMgY29udHJhY3QsICoqbm90KiogdGhlIHRvdGFsIHN1cHBseSBvZiBhIGdpdmVuIHRva2VuLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIE5GVHMgbWludGVkIGluIHRoaXMgY29udHJhY3RcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYXN5bmMgdG90YWxDb3VudCgpIHtcbiAgICByZXR1cm4gYXNzZXJ0RW5hYmxlZCh0aGlzLnF1ZXJ5LCBGRUFUVVJFX0VESVRJT05fRU5VTUVSQUJMRSkudG90YWxDb3VudCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3VwcGx5IG9mIHRva2VuIGZvciBhIGdpdmVuIHRva2VuSWQuXG4gICAqIEByZW1hcmtzIFRoaXMgaXMgKipub3QqKiB0aGUgc3VtIG9mIHN1cHBseSBvZiBhbGwgTkZUcyBpbiB0aGUgY29udHJhY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2YgTkZUcyBtaW50ZWQgaW4gdGhpcyBjb250cmFjdFxuICAgKiBAcHVibGljXG4gICAqL1xuICBhc3luYyB0b3RhbENpcmN1bGF0aW5nU3VwcGx5KHRva2VuSWQpIHtcbiAgICByZXR1cm4gYXNzZXJ0RW5hYmxlZCh0aGlzLnF1ZXJ5LCBGRUFUVVJFX0VESVRJT05fRU5VTUVSQUJMRSkudG90YWxDaXJjdWxhdGluZ1N1cHBseSh0b2tlbklkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgT3duZWQgTkZUc1xuICAgKlxuICAgKiBAcmVtYXJrcyBHZXQgYWxsIHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgTkZUcyBvd25lZCBieSBhIHNwZWNpZmljIHdhbGxldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBBZGRyZXNzIG9mIHRoZSB3YWxsZXQgdG8gZ2V0IHRoZSBORlRzIG9mXG4gICAqIGNvbnN0IGFkZHJlc3MgPSBcInt7d2FsbGV0X2FkZHJlc3N9fVwiO1xuICAgKiBjb25zdCBuZnRzID0gYXdhaXQgY29udHJhY3QuZXJjMTE1NS5nZXRPd25lZChhZGRyZXNzKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBORlQgbWV0YWRhdGEgZm9yIGFsbCBORlRzIGluIHRoZSBjb250cmFjdC5cbiAgICogQHR3ZmVhdHVyZSBFUkMxMTU1RW51bWVyYWJsZVxuICAgKi9cbiAgYXN5bmMgZ2V0T3duZWQod2FsbGV0QWRkcmVzcykge1xuICAgIHJldHVybiBhc3NlcnRFbmFibGVkKHRoaXMucXVlcnksIEZFQVRVUkVfRURJVElPTl9FTlVNRVJBQkxFKS5vd25lZCh3YWxsZXRBZGRyZXNzKTtcbiAgfVxuXG4gIC8vLy8vLyBFUkMxMTU1IE1pbnRhYmxlIEV4dGVuc2lvbiAvLy8vLy9cblxuICAvKipcbiAgICogTWludCBhbiBORlQgd2l0aCBhIGxpbWl0ZWQgc3VwcGx5XG4gICAqXG4gICAqIEByZW1hcmtzIE1pbnQgYW4gTkZUIHdpdGggYSBsaW1pdGVkIHN1cHBseSB0byB0aGUgY29ubmVjdGVkIHdhbGxldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBBZGRyZXNzIG9mIHRoZSB3YWxsZXQgeW91IHdhbnQgdG8gbWludCB0aGUgTkZUIHRvXG4gICAqIGNvbnN0IHRvQWRkcmVzcyA9IFwie3t3YWxsZXRfYWRkcmVzc319XCJcbiAgICpcbiAgICogLy8gQ3VzdG9tIG1ldGFkYXRhIG9mIHRoZSBORlQsIG5vdGUgdGhhdCB5b3UgY2FuIGZ1bGx5IGN1c3RvbWl6ZSB0aGlzIG1ldGFkYXRhIHdpdGggb3RoZXIgcHJvcGVydGllcy5cbiAgICogY29uc3QgbWV0YWRhdGEgPSB7XG4gICAqICAgbmFtZTogXCJDb29sIE5GVFwiLFxuICAgKiAgIGRlc2NyaXB0aW9uOiBcIlRoaXMgaXMgYSBjb29sIE5GVFwiLFxuICAgKiAgIGltYWdlOiBmcy5yZWFkRmlsZVN5bmMoXCJwYXRoL3RvL2ltYWdlLnBuZ1wiKSwgLy8gVGhpcyBjYW4gYmUgYW4gaW1hZ2UgdXJsIG9yIGZpbGVcbiAgICogfVxuICAgKlxuICAgKiBjb25zdCBtZXRhZGF0YVdpdGhTdXBwbHkgPSB7XG4gICAqICAgbWV0YWRhdGEsXG4gICAqICAgc3VwcGx5OiAxMDAwLCAvLyBUaGUgbnVtYmVyIG9mIHRoaXMgTkZUIHlvdSB3YW50IHRvIG1pbnRcbiAgICogfVxuICAgKlxuICAgKiBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmVyYzExNTUubWludCh0b0FkZHJlc3MsIG1ldGFkYXRhV2l0aFN1cHBseSk7XG4gICAqIGNvbnN0IHJlY2VpcHQgPSB0eC5yZWNlaXB0OyAvLyB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdFxuICAgKiBjb25zdCB0b2tlbklkID0gdHguaWQ7IC8vIHRoZSBpZCBvZiB0aGUgTkZUIG1pbnRlZFxuICAgKiBjb25zdCBuZnQgPSBhd2FpdCB0eC5kYXRhKCk7IC8vIChvcHRpb25hbCkgZmV0Y2ggZGV0YWlscyBvZiBtaW50ZWQgTkZUXG4gICAqIGBgYFxuICAgKiBAdHdmZWF0dXJlIEVSQzExNTVNaW50YWJsZVxuICAgKi9cbiAgYXN5bmMgbWludChtZXRhZGF0YVdpdGhTdXBwbHkpIHtcbiAgICByZXR1cm4gdGhpcy5taW50VG8oYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0U2lnbmVyQWRkcmVzcygpLCBtZXRhZGF0YVdpdGhTdXBwbHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1pbnQgYW4gTkZUIHdpdGggYSBsaW1pdGVkIHN1cHBseVxuICAgKlxuICAgKiBAcmVtYXJrcyBNaW50IGFuIE5GVCB3aXRoIGEgbGltaXRlZCBzdXBwbHkgdG8gYSBzcGVjaWZpZWQgd2FsbGV0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIEFkZHJlc3Mgb2YgdGhlIHdhbGxldCB5b3Ugd2FudCB0byBtaW50IHRoZSBORlQgdG9cbiAgICogY29uc3QgdG9BZGRyZXNzID0gXCJ7e3dhbGxldF9hZGRyZXNzfX1cIlxuICAgKlxuICAgKiAvLyBDdXN0b20gbWV0YWRhdGEgb2YgdGhlIE5GVCwgbm90ZSB0aGF0IHlvdSBjYW4gZnVsbHkgY3VzdG9taXplIHRoaXMgbWV0YWRhdGEgd2l0aCBvdGhlciBwcm9wZXJ0aWVzLlxuICAgKiBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICogICBuYW1lOiBcIkNvb2wgTkZUXCIsXG4gICAqICAgZGVzY3JpcHRpb246IFwiVGhpcyBpcyBhIGNvb2wgTkZUXCIsXG4gICAqICAgaW1hZ2U6IGZzLnJlYWRGaWxlU3luYyhcInBhdGgvdG8vaW1hZ2UucG5nXCIpLCAvLyBUaGlzIGNhbiBiZSBhbiBpbWFnZSB1cmwgb3IgZmlsZVxuICAgKiB9XG4gICAqXG4gICAqIGNvbnN0IG1ldGFkYXRhV2l0aFN1cHBseSA9IHtcbiAgICogICBtZXRhZGF0YSxcbiAgICogICBzdXBwbHk6IDEwMDAsIC8vIFRoZSBudW1iZXIgb2YgdGhpcyBORlQgeW91IHdhbnQgdG8gbWludFxuICAgKiB9XG4gICAqXG4gICAqIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuZXJjMTE1NS5taW50VG8odG9BZGRyZXNzLCBtZXRhZGF0YVdpdGhTdXBwbHkpO1xuICAgKiBjb25zdCByZWNlaXB0ID0gdHgucmVjZWlwdDsgLy8gdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRcbiAgICogY29uc3QgdG9rZW5JZCA9IHR4LmlkOyAvLyB0aGUgaWQgb2YgdGhlIE5GVCBtaW50ZWRcbiAgICogY29uc3QgbmZ0ID0gYXdhaXQgdHguZGF0YSgpOyAvLyAob3B0aW9uYWwpIGZldGNoIGRldGFpbHMgb2YgbWludGVkIE5GVFxuICAgKiBgYGBcbiAgICogQHR3ZmVhdHVyZSBFUkMxMTU1TWludGFibGVcbiAgICovXG4gIGFzeW5jIG1pbnRUbyhyZWNlaXZlciwgbWV0YWRhdGFXaXRoU3VwcGx5KSB7XG4gICAgcmV0dXJuIGFzc2VydEVuYWJsZWQodGhpcy5taW50YWJsZSwgRkVBVFVSRV9FRElUSU9OX01JTlRBQkxFKS50byhyZWNlaXZlciwgbWV0YWRhdGFXaXRoU3VwcGx5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNyZWFzZSB0aGUgc3VwcGx5IG9mIGFuIGV4aXN0aW5nIE5GVFxuICAgKiBAcmVtYXJrcyBJbmNyZWFzZSB0aGUgc3VwcGx5IG9mIGFuIGV4aXN0aW5nIE5GVCBhbmQgbWludCBpdCB0byB0aGUgY29ubmVjdGVkIHdhbGxldCBhZGRyZXNzXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgdG9rZW5JZCA9IDA7XG4gICAqIGNvbnN0IGFkZGl0aW9uYWxTdXBwbHkgPSAxMDAwO1xuICAgKiBhd2FpdCBjb250cmFjdC5lcmMxMTU1Lm1pbnRBZGRpdGlvbmFsU3VwcGx5KHRva2VuSWQsIGFkZGl0aW9uYWxTdXBwbHkpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHRva2VuSWQgLSB0aGUgdG9rZW4gaWQgb2YgdGhlIE5GVCB0byBpbmNyZWFzZSBzdXBwbHkgb2ZcbiAgICogQHBhcmFtIGFkZGl0aW9uYWxTdXBwbHkgLSB0aGUgYWRkaXRpb25hbCBhbW91bnQgdG8gbWludFxuICAgKiBAdHdmZWF0dXJlIEVSQzExNTVNaW50YWJsZVxuICAgKi9cbiAgYXN5bmMgbWludEFkZGl0aW9uYWxTdXBwbHkodG9rZW5JZCwgYWRkaXRpb25hbFN1cHBseSkge1xuICAgIHJldHVybiBhc3NlcnRFbmFibGVkKHRoaXMubWludGFibGUsIEZFQVRVUkVfRURJVElPTl9NSU5UQUJMRSkuYWRkaXRpb25hbFN1cHBseVRvKGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFNpZ25lckFkZHJlc3MoKSwgdG9rZW5JZCwgYWRkaXRpb25hbFN1cHBseSk7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVhc2UgdGhlIHN1cHBseSBvZiBhbiBleGlzdGluZyBORlQgYW5kIG1pbnQgaXQgdG8gYSBnaXZlbiB3YWxsZXQgYWRkcmVzc1xuICAgKlxuICAgKiBAcGFyYW0gdG8gLSB0aGUgYWRkcmVzcyB0byBtaW50IHRvXG4gICAqIEBwYXJhbSB0b2tlbklkIC0gdGhlIHRva2VuIGlkIG9mIHRoZSBORlQgdG8gaW5jcmVhc2Ugc3VwcGx5IG9mXG4gICAqIEBwYXJhbSBhZGRpdGlvbmFsU3VwcGx5IC0gdGhlIGFkZGl0aW9uYWwgYW1vdW50IHRvIG1pbnRcbiAgICovXG4gIGFzeW5jIG1pbnRBZGRpdGlvbmFsU3VwcGx5VG8ocmVjZWl2ZXIsIHRva2VuSWQsIGFkZGl0aW9uYWxTdXBwbHkpIHtcbiAgICByZXR1cm4gYXNzZXJ0RW5hYmxlZCh0aGlzLm1pbnRhYmxlLCBGRUFUVVJFX0VESVRJT05fTUlOVEFCTEUpLmFkZGl0aW9uYWxTdXBwbHlUbyhyZWNlaXZlciwgdG9rZW5JZCwgYWRkaXRpb25hbFN1cHBseSk7XG4gIH1cblxuICAvLy8vLy8gRVJDMTE1NSBCYXRjaE1pbnRhYmxlIEV4dGVuc2lvbiAvLy8vLy9cblxuICAvKipcbiAgICogTWludCBNYW55IE5GVHMgd2l0aCBsaW1pdGVkIHN1cHBsaWVzXG4gICAqXG4gICAqIEByZW1hcmtzIE1pbnQgbWFueSBkaWZmZXJlbnQgTkZUcyB3aXRoIGxpbWl0ZWQgc3VwcGxpZXMgdG8gdGhlIGNvbm5lY3RlZCB3YWxsZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gQ3VzdG9tIG1ldGFkYXRhIGFuZCBzdXBwbGllcyBvZiB5b3VyIE5GVHNcbiAgICogY29uc3QgbWV0YWRhdGFXaXRoU3VwcGx5ID0gW3tcbiAgICogICBzdXBwbHk6IDUwLCAvLyBUaGUgbnVtYmVyIG9mIHRoaXMgTkZUIHlvdSB3YW50IHRvIG1pbnRcbiAgICogICBtZXRhZGF0YToge1xuICAgKiAgICAgbmFtZTogXCJDb29sIE5GVCAjMVwiLFxuICAgKiAgICAgZGVzY3JpcHRpb246IFwiVGhpcyBpcyBhIGNvb2wgTkZUXCIsXG4gICAqICAgICBpbWFnZTogZnMucmVhZEZpbGVTeW5jKFwicGF0aC90by9pbWFnZS5wbmdcIiksIC8vIFRoaXMgY2FuIGJlIGFuIGltYWdlIHVybCBvciBmaWxlXG4gICAqICAgfSxcbiAgICogfSwge1xuICAgKiAgIHN1cHBseTogMTAwLFxuICAgKiAgIG1ldGFkYXRhOiB7XG4gICAqICAgICBuYW1lOiBcIkNvb2wgTkZUICMyXCIsXG4gICAqICAgICBkZXNjcmlwdGlvbjogXCJUaGlzIGlzIGEgY29vbCBORlRcIixcbiAgICogICAgIGltYWdlOiBmcy5yZWFkRmlsZVN5bmMoXCJwYXRoL3RvL2ltYWdlLnBuZ1wiKSwgLy8gVGhpcyBjYW4gYmUgYW4gaW1hZ2UgdXJsIG9yIGZpbGVcbiAgICogICB9LFxuICAgKiB9XTtcbiAgICpcbiAgICogY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5lcmMxMTU1Lm1pbnRCYXRjaChtZXRhZGF0YVdpdGhTdXBwbHkpO1xuICAgKiBjb25zdCByZWNlaXB0ID0gdHhbMF0ucmVjZWlwdDsgLy8gc2FtZSB0cmFuc2FjdGlvbiByZWNlaXB0IGZvciBhbGwgbWludGVkIE5GVHNcbiAgICogY29uc3QgZmlyc3RUb2tlbklkID0gdHhbMF0uaWQ7IC8vIHRva2VuIGlkIG9mIHRoZSBmaXJzdCBtaW50ZWQgTkZUXG4gICAqIGNvbnN0IGZpcnN0TkZUID0gYXdhaXQgdHhbMF0uZGF0YSgpOyAvLyAob3B0aW9uYWwpIGZldGNoIGRldGFpbHMgb2YgdGhlIGZpcnN0IG1pbnRlZCBORlRcbiAgICogYGBgXG4gICAqIEB0d2ZlYXR1cmUgRVJDMTE1NUJhdGNoTWludGFibGVcbiAgICovXG4gIGFzeW5jIG1pbnRCYXRjaChtZXRhZGF0YVdpdGhTdXBwbHkpIHtcbiAgICByZXR1cm4gdGhpcy5taW50QmF0Y2hUbyhhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRTaWduZXJBZGRyZXNzKCksIG1ldGFkYXRhV2l0aFN1cHBseSk7XG4gIH1cblxuICAvKipcbiAgICogTWludCBNYW55IE5GVHMgd2l0aCBsaW1pdGVkIHN1cHBsaWVzXG4gICAqXG4gICAqIEByZW1hcmtzIE1pbnQgbWFueSBkaWZmZXJlbnQgTkZUcyB3aXRoIGxpbWl0ZWQgc3VwcGxpZXMgdG8gYSBzcGVjaWZpZWQgd2FsbGV0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIEFkZHJlc3Mgb2YgdGhlIHdhbGxldCB5b3Ugd2FudCB0byBtaW50IHRoZSBORlQgdG9cbiAgICogY29uc3QgdG9BZGRyZXNzID0gXCJ7e3dhbGxldF9hZGRyZXNzfX1cIlxuICAgKlxuICAgKiAvLyBDdXN0b20gbWV0YWRhdGEgYW5kIHN1cHBsaWVzIG9mIHlvdXIgTkZUc1xuICAgKiBjb25zdCBtZXRhZGF0YVdpdGhTdXBwbHkgPSBbe1xuICAgKiAgIHN1cHBseTogNTAsIC8vIFRoZSBudW1iZXIgb2YgdGhpcyBORlQgeW91IHdhbnQgdG8gbWludFxuICAgKiAgIG1ldGFkYXRhOiB7XG4gICAqICAgICBuYW1lOiBcIkNvb2wgTkZUICMxXCIsXG4gICAqICAgICBkZXNjcmlwdGlvbjogXCJUaGlzIGlzIGEgY29vbCBORlRcIixcbiAgICogICAgIGltYWdlOiBmcy5yZWFkRmlsZVN5bmMoXCJwYXRoL3RvL2ltYWdlLnBuZ1wiKSwgLy8gVGhpcyBjYW4gYmUgYW4gaW1hZ2UgdXJsIG9yIGZpbGVcbiAgICogICB9LFxuICAgKiB9LCB7XG4gICAqICAgc3VwcGx5OiAxMDAsXG4gICAqICAgbWV0YWRhdGE6IHtcbiAgICogICAgIG5hbWU6IFwiQ29vbCBORlQgIzJcIixcbiAgICogICAgIGRlc2NyaXB0aW9uOiBcIlRoaXMgaXMgYSBjb29sIE5GVFwiLFxuICAgKiAgICAgaW1hZ2U6IGZzLnJlYWRGaWxlU3luYyhcInBhdGgvdG8vaW1hZ2UucG5nXCIpLCAvLyBUaGlzIGNhbiBiZSBhbiBpbWFnZSB1cmwgb3IgZmlsZVxuICAgKiAgIH0sXG4gICAqIH1dO1xuICAgKlxuICAgKiBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmVyYzExNTUubWludEJhdGNoVG8odG9BZGRyZXNzLCBtZXRhZGF0YVdpdGhTdXBwbHkpO1xuICAgKiBjb25zdCByZWNlaXB0ID0gdHhbMF0ucmVjZWlwdDsgLy8gc2FtZSB0cmFuc2FjdGlvbiByZWNlaXB0IGZvciBhbGwgbWludGVkIE5GVHNcbiAgICogY29uc3QgZmlyc3RUb2tlbklkID0gdHhbMF0uaWQ7IC8vIHRva2VuIGlkIG9mIHRoZSBmaXJzdCBtaW50ZWQgTkZUXG4gICAqIGNvbnN0IGZpcnN0TkZUID0gYXdhaXQgdHhbMF0uZGF0YSgpOyAvLyAob3B0aW9uYWwpIGZldGNoIGRldGFpbHMgb2YgdGhlIGZpcnN0IG1pbnRlZCBORlRcbiAgICogYGBgXG4gICAqIEB0d2ZlYXR1cmUgRVJDMTE1NUJhdGNoTWludGFibGVcbiAgICovXG4gIGFzeW5jIG1pbnRCYXRjaFRvKHJlY2VpdmVyLCBtZXRhZGF0YVdpdGhTdXBwbHkpIHtcbiAgICByZXR1cm4gYXNzZXJ0RW5hYmxlZCh0aGlzLm1pbnRhYmxlPy5iYXRjaCwgRkVBVFVSRV9FRElUSU9OX0JBVENIX01JTlRBQkxFKS50byhyZWNlaXZlciwgbWV0YWRhdGFXaXRoU3VwcGx5KTtcbiAgfVxuXG4gIC8vLy8vLyBFUkMxMTU1IEJ1cm5hYmxlIEV4dGVuc2lvbiAvLy8vLy9cblxuICAvKipcbiAgICogQnVybiBhIHNwZWNpZmllZCBhbW91bnQgb2YgYSBORlRzXG4gICAqXG4gICAqIEByZW1hcmtzIEJ1cm4gdGhlIHNwZWNpZmllZCBORlRzIGZyb20gdGhlIGNvbm5lY3RlZCB3YWxsZXRcbiAgICpcbiAgICogQHBhcmFtIHRva2VuSWQgLSB0aGUgdG9rZW4gSWQgdG8gYnVyblxuICAgKiBAcGFyYW0gYW1vdW50IC0gYW1vdW50IHRvIGJ1cm5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBUaGUgdG9rZW4gSUQgdG8gYnVybiBORlRzIG9mXG4gICAqIGNvbnN0IHRva2VuSWQgPSAwO1xuICAgKiAvLyBUaGUgYW1vdW50IG9mIHRoZSBORlQgeW91IHdhbnQgdG8gYnVyblxuICAgKiBjb25zdCBhbW91bnQgPSAyO1xuICAgKlxuICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBjb250cmFjdC5lcmMxMTU1LmJ1cm4odG9rZW5JZCwgYW1vdW50KTtcbiAgICogYGBgXG4gICAqIEB0d2ZlYXR1cmUgRVJDMTE1NUJ1cm5hYmxlXG4gICAqL1xuICBhc3luYyBidXJuKHRva2VuSWQsIGFtb3VudCkge1xuICAgIHJldHVybiBhc3NlcnRFbmFibGVkKHRoaXMuYnVybmFibGUsIEZFQVRVUkVfRURJVElPTl9CVVJOQUJMRSkudG9rZW5zKHRva2VuSWQsIGFtb3VudCk7XG4gIH1cblxuICAvKipcbiAgICogQnVybiBhIHNwZWNpZmllZCBhbW91bnQgb2YgYSBORlRzXG4gICAqXG4gICAqIEByZW1hcmtzIEJ1cm4gdGhlIHNwZWNpZmllZCBORlRzIGZyb20gYSBzcGVjaWZpZWQgd2FsbGV0XG4gICAqXG4gICAqIEBwYXJhbSBhY2NvdW50IC0gdGhlIGFkZHJlc3MgdG8gYnVybiBORlRzIGZyb21cbiAgICogQHBhcmFtIHRva2VuSWQgLSB0aGUgdG9rZW5JZCB0byBidXJuXG4gICAqIEBwYXJhbSBhbW91bnQgLSBhbW91bnQgdG8gYnVyblxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIFRoZSBhZGRyZXNzIG9mIHRoZSB3YWxsZXQgdG8gYnVybiBORlRTIGZyb21cbiAgICogY29uc3QgYWNjb3VudCA9IFwiMHguLi5cIjtcbiAgICogLy8gVGhlIHRva2VuIElEIHRvIGJ1cm4gTkZUcyBvZlxuICAgKiBjb25zdCB0b2tlbklkID0gMDtcbiAgICogLy8gVGhlIGFtb3VudCBvZiB0aGlzIE5GVCB5b3Ugd2FudCB0byBidXJuXG4gICAqIGNvbnN0IGFtb3VudCA9IDI7XG4gICAqXG4gICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbnRyYWN0LmVyYzExNTUuYnVybkZyb20oYWNjb3VudCwgdG9rZW5JZCwgYW1vdW50KTtcbiAgICogYGBgXG4gICAqIEB0d2ZlYXR1cmUgRVJDMTE1NUJ1cm5hYmxlXG4gICAqL1xuICBhc3luYyBidXJuRnJvbShhY2NvdW50LCB0b2tlbklkLCBhbW91bnQpIHtcbiAgICByZXR1cm4gYXNzZXJ0RW5hYmxlZCh0aGlzLmJ1cm5hYmxlLCBGRUFUVVJFX0VESVRJT05fQlVSTkFCTEUpLmZyb20oYWNjb3VudCwgdG9rZW5JZCwgYW1vdW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdXJuIGEgYmF0Y2ggb2YgTkZUc1xuICAgKlxuICAgKiBAcmVtYXJrcyBCdXJuIHRoZSBiYXRjaCBORlRzIGZyb20gdGhlIGNvbm5lY3RlZCB3YWxsZXRcbiAgICpcbiAgICogQHBhcmFtIHRva2VuSWRzIC0gdGhlIHRva2VuSWRzIHRvIGJ1cm5cbiAgICogQHBhcmFtIGFtb3VudHMgLSBhbW91bnQgb2YgZWFjaCB0b2tlbiB0byBidXJuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gVGhlIHRva2VuIElEcyB0byBidXJuIE5GVHMgb2ZcbiAgICogY29uc3QgdG9rZW5JZHMgPSBbMCwgMV07XG4gICAqIC8vIFRoZSBhbW91bnRzIG9mIGVhY2ggTkZUIHlvdSB3YW50IHRvIGJ1cm5cbiAgICogY29uc3QgYW1vdW50cyA9IFsyLCAyXTtcbiAgICpcbiAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgY29udHJhY3QuZXJjMTE1NS5idXJuQmF0Y2godG9rZW5JZHMsIGFtb3VudHMpO1xuICAgKiBgYGBcbiAgICogQHR3ZmVhdHVyZSBFUkMxMTU1QnVybmFibGVcbiAgICovXG4gIGFzeW5jIGJ1cm5CYXRjaCh0b2tlbklkcywgYW1vdW50cykge1xuICAgIHJldHVybiBhc3NlcnRFbmFibGVkKHRoaXMuYnVybmFibGUsIEZFQVRVUkVfRURJVElPTl9CVVJOQUJMRSkuYmF0Y2godG9rZW5JZHMsIGFtb3VudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1cm4gYSBiYXRjaCBvZiBORlRzXG4gICAqXG4gICAqIEByZW1hcmtzIEJ1cm4gdGhlIGJhdGNoIE5GVHMgZnJvbSB0aGUgc3BlY2lmaWVkIHdhbGxldFxuICAgKlxuICAgKiBAcGFyYW0gYWNjb3VudCAtIHRoZSBhZGRyZXNzIHRvIGJ1cm4gTkZUcyBmcm9tXG4gICAqIEBwYXJhbSB0b2tlbklkcyAtIHRoZSB0b2tlbklkcyB0byBidXJuXG4gICAqIEBwYXJhbSBhbW91bnRzIC0gYW1vdW50IG9mIGVhY2ggdG9rZW4gdG8gYnVyblxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIFRoZSBhZGRyZXNzIG9mIHRoZSB3YWxsZXQgdG8gYnVybiBORlRTIGZyb21cbiAgICogY29uc3QgYWNjb3VudCA9IFwiMHguLi5cIjtcbiAgICogLy8gVGhlIHRva2VuIElEcyB0byBidXJuIE5GVHMgb2ZcbiAgICogY29uc3QgdG9rZW5JZHMgPSBbMCwgMV07XG4gICAqIC8vIFRoZSBhbW91bnRzIG9mIGVhY2ggTkZUIHlvdSB3YW50IHRvIGJ1cm5cbiAgICogY29uc3QgYW1vdW50cyA9IFsyLCAyXTtcbiAgICpcbiAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgY29udHJhY3QuZXJjMTE1NS5idXJuQmF0Y2hGcm9tKGFjY291bnQsIHRva2VuSWRzLCBhbW91bnRzKTtcbiAgICogYGBgXG4gICAqIEB0d2ZlYXR1cmUgRVJDMTE1NUJ1cm5hYmxlXG4gICAqL1xuICBhc3luYyBidXJuQmF0Y2hGcm9tKGFjY291bnQsIHRva2VuSWRzLCBhbW91bnRzKSB7XG4gICAgcmV0dXJuIGFzc2VydEVuYWJsZWQodGhpcy5idXJuYWJsZSwgRkVBVFVSRV9FRElUSU9OX0JVUk5BQkxFKS5iYXRjaEZyb20oYWNjb3VudCwgdG9rZW5JZHMsIGFtb3VudHMpO1xuICB9XG5cbiAgLy8vLy8vIEVSQzcyMSBMYXp5TWludCBFeHRlbnNpb24gLy8vLy8vXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGJhdGNoIG9mIE5GVHMgdG8gYmUgY2xhaW1lZCBpbiB0aGUgZnV0dXJlXG4gICAqXG4gICAqIEByZW1hcmtzIENyZWF0ZSBiYXRjaCBhbGxvd3MgeW91IHRvIGNyZWF0ZSBhIGJhdGNoIG9mIG1hbnkgTkZUcyBpbiBvbmUgdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gQ3VzdG9tIG1ldGFkYXRhIG9mIHRoZSBORlRzIHRvIGNyZWF0ZVxuICAgKiBjb25zdCBtZXRhZGF0YXMgPSBbe1xuICAgKiAgIG5hbWU6IFwiQ29vbCBORlRcIixcbiAgICogICBkZXNjcmlwdGlvbjogXCJUaGlzIGlzIGEgY29vbCBORlRcIixcbiAgICogICBpbWFnZTogZnMucmVhZEZpbGVTeW5jKFwicGF0aC90by9pbWFnZS5wbmdcIiksIC8vIFRoaXMgY2FuIGJlIGFuIGltYWdlIHVybCBvciBmaWxlXG4gICAqIH0sIHtcbiAgICogICBuYW1lOiBcIkNvb2wgTkZUXCIsXG4gICAqICAgZGVzY3JpcHRpb246IFwiVGhpcyBpcyBhIGNvb2wgTkZUXCIsXG4gICAqICAgaW1hZ2U6IGZzLnJlYWRGaWxlU3luYyhcInBhdGgvdG8vaW1hZ2UucG5nXCIpLFxuICAgKiB9XTtcbiAgICpcbiAgICogY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNvbnRyYWN0LmVyYzExNTUubGF6eU1pbnQobWV0YWRhdGFzKTsgLy8gdXBsb2FkcyBhbmQgY3JlYXRlcyB0aGUgTkZUcyBvbiBjaGFpblxuICAgKiBjb25zdCBmaXJzdFRva2VuSWQgPSByZXN1bHRzWzBdLmlkOyAvLyB0b2tlbiBpZCBvZiB0aGUgZmlyc3QgY3JlYXRlZCBORlRcbiAgICogY29uc3QgZmlyc3RORlQgPSBhd2FpdCByZXN1bHRzWzBdLmRhdGEoKTsgLy8gKG9wdGlvbmFsKSBmZXRjaCBkZXRhaWxzIG9mIHRoZSBmaXJzdCBjcmVhdGVkIE5GVFxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIG1ldGFkYXRhcyAtIFRoZSBtZXRhZGF0YSB0byBpbmNsdWRlIGluIHRoZSBiYXRjaC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBvcHRpb25hbCB1cGxvYWQgcHJvZ3Jlc3MgY2FsbGJhY2tcbiAgICogQHR3ZmVhdHVyZSBFUkMxMTU1TGF6eU1pbnRhYmxlXG4gICAqL1xuICBhc3luYyBsYXp5TWludChtZXRhZGF0YXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXNzZXJ0RW5hYmxlZCh0aGlzLmxhenlNaW50YWJsZSwgRkVBVFVSRV9FRElUSU9OX0xBWllfTUlOVEFCTEVfVjIpLmxhenlNaW50KG1ldGFkYXRhcywgb3B0aW9ucyk7XG4gIH1cblxuICAvLy8vLy8gRVJDMTE1NSBDbGFpbWFibGUgRXh0ZW5zaW9uIC8vLy8vL1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBjbGFpbSB0cmFuc2FjdGlvbiB3aXRob3V0IGV4ZWN1dGluZyBpdC5cbiAgICogVGhpcyBpcyB1c2VmdWwgZm9yIGVzdGltYXRpbmcgdGhlIGdhcyBjb3N0IG9mIGEgY2xhaW0gdHJhbnNhY3Rpb24sIG92ZXJyaWRpbmcgdHJhbnNhY3Rpb24gb3B0aW9ucyBhbmQgaGF2aW5nIGZpbmUgZ3JhaW5lZCBjb250cm9sIG92ZXIgdGhlIHRyYW5zYWN0aW9uIGV4ZWN1dGlvbi5cbiAgICogQHBhcmFtIGRlc3RpbmF0aW9uQWRkcmVzcyAtIEFkZHJlc3MgeW91IHdhbnQgdG8gc2VuZCB0aGUgdG9rZW4gdG9cbiAgICogQHBhcmFtIHRva2VuSWQgLSBJZCBvZiB0aGUgdG9rZW4geW91IHdhbnQgdG8gY2xhaW1cbiAgICogQHBhcmFtIHF1YW50aXR5IC0gUXVhbnRpdHkgb2YgdGhlIHRva2VucyB5b3Ugd2FudCB0byBjbGFpbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIGNsYWltIHZlcmlmaWNhdGlvbiBkYXRhIChlLmcuIHByaWNlLCBjdXJyZW5jeSwgZXRjLi4uKVxuICAgKi9cbiAgYXN5bmMgZ2V0Q2xhaW1UcmFuc2FjdGlvbihkZXN0aW5hdGlvbkFkZHJlc3MsIHRva2VuSWQsIHF1YW50aXR5LCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2xhaW1XaXRoQ29uZGl0aW9ucyA9IHRoaXMubGF6eU1pbnRhYmxlPy5jbGFpbVdpdGhDb25kaXRpb25zO1xuICAgIGNvbnN0IGNsYWltID0gdGhpcy5sYXp5TWludGFibGU/LmNsYWltO1xuICAgIGlmIChjbGFpbVdpdGhDb25kaXRpb25zKSB7XG4gICAgICByZXR1cm4gY2xhaW1XaXRoQ29uZGl0aW9ucy5jb25kaXRpb25zLmdldENsYWltVHJhbnNhY3Rpb24oZGVzdGluYXRpb25BZGRyZXNzLCB0b2tlbklkLCBxdWFudGl0eSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChjbGFpbSkge1xuICAgICAgcmV0dXJuIGNsYWltLmdldENsYWltVHJhbnNhY3Rpb24oZGVzdGluYXRpb25BZGRyZXNzLCB0b2tlbklkLCBxdWFudGl0eSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFeHRlbnNpb25Ob3RJbXBsZW1lbnRlZEVycm9yKEZFQVRVUkVfRURJVElPTl9DTEFJTV9DVVNUT00pO1xuICB9XG5cbiAgLyoqXG4gICAqIENsYWltIE5GVHNcbiAgICpcbiAgICogQHJlbWFya3MgTGV0IHRoZSBjb25uZWN0ZWQgd2FsbGV0IGNsYWltIE5GVHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgdG9rZW5JZCA9IDA7IC8vIHRoZSBpZCBvZiB0aGUgTkZUIHlvdSB3YW50IHRvIGNsYWltXG4gICAqIGNvbnN0IHF1YW50aXR5ID0gMTsgLy8gaG93IG1hbnkgTkZUcyB5b3Ugd2FudCB0byBjbGFpbVxuICAgKlxuICAgKiBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmVyYzExNTUuY2xhaW0odG9rZW5JZCwgcXVhbnRpdHkpO1xuICAgKiBjb25zdCByZWNlaXB0ID0gdHgucmVjZWlwdDsgLy8gdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB0b2tlbklkIC0gSWQgb2YgdGhlIHRva2VuIHlvdSB3YW50IHRvIGNsYWltXG4gICAqIEBwYXJhbSBxdWFudGl0eSAtIFF1YW50aXR5IG9mIHRoZSB0b2tlbnMgeW91IHdhbnQgdG8gY2xhaW1cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBjbGFpbSB2ZXJpZmljYXRpb24gZGF0YSAoZS5nLiBwcmljZSwgY3VycmVuY3ksIGV0Yy4uLilcbiAgICpcbiAgICogQHJldHVybnMgLSBSZWNlaXB0IGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHR3ZmVhdHVyZSBFUkMxMTU1Q2xhaW1hYmxlXG4gICAqL1xuICBhc3luYyBjbGFpbSh0b2tlbklkLCBxdWFudGl0eSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNsYWltVG8oYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0U2lnbmVyQWRkcmVzcygpLCB0b2tlbklkLCBxdWFudGl0eSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xhaW0gTkZUcyB0byBhIHNwZWNpZmljIFdhbGxldFxuICAgKlxuICAgKiBAcmVtYXJrcyBMZXQgdGhlIHNwZWNpZmllZCB3YWxsZXQgY2xhaW0gTkZUcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBhZGRyZXNzID0gXCJ7e3dhbGxldF9hZGRyZXNzfX1cIjsgLy8gYWRkcmVzcyBvZiB0aGUgd2FsbGV0IHlvdSB3YW50IHRvIGNsYWltIHRoZSBORlRzXG4gICAqIGNvbnN0IHRva2VuSWQgPSAwOyAvLyB0aGUgaWQgb2YgdGhlIE5GVCB5b3Ugd2FudCB0byBjbGFpbVxuICAgKiBjb25zdCBxdWFudGl0eSA9IDE7IC8vIGhvdyBtYW55IE5GVHMgeW91IHdhbnQgdG8gY2xhaW1cbiAgICpcbiAgICogY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5lcmMxMTU1LmNsYWltVG8oYWRkcmVzcywgdG9rZW5JZCwgcXVhbnRpdHkpO1xuICAgKiBjb25zdCByZWNlaXB0ID0gdHgucmVjZWlwdDsgLy8gdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBkZXN0aW5hdGlvbkFkZHJlc3MgLSBBZGRyZXNzIHlvdSB3YW50IHRvIHNlbmQgdGhlIHRva2VuIHRvXG4gICAqIEBwYXJhbSB0b2tlbklkIC0gSWQgb2YgdGhlIHRva2VuIHlvdSB3YW50IHRvIGNsYWltXG4gICAqIEBwYXJhbSBxdWFudGl0eSAtIFF1YW50aXR5IG9mIHRoZSB0b2tlbnMgeW91IHdhbnQgdG8gY2xhaW1cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBjbGFpbSB2ZXJpZmljYXRpb24gZGF0YSAoZS5nLiBwcmljZSwgY3VycmVuY3ksIGV0Yy4uLilcbiAgICpcbiAgICogQHJldHVybnMgLSBSZWNlaXB0IGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHR3ZmVhdHVyZSBFUkMxMTU1Q2xhaW1hYmxlXG4gICAqL1xuICBhc3luYyBjbGFpbVRvKGRlc3RpbmF0aW9uQWRkcmVzcywgdG9rZW5JZCwgcXVhbnRpdHksIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjbGFpbVdpdGhDb25kaXRpb25zID0gdGhpcy5sYXp5TWludGFibGU/LmNsYWltV2l0aENvbmRpdGlvbnM7XG4gICAgY29uc3QgY2xhaW0gPSB0aGlzLmxhenlNaW50YWJsZT8uY2xhaW07XG4gICAgaWYgKGNsYWltV2l0aENvbmRpdGlvbnMpIHtcbiAgICAgIHJldHVybiBjbGFpbVdpdGhDb25kaXRpb25zLnRvKGRlc3RpbmF0aW9uQWRkcmVzcywgdG9rZW5JZCwgcXVhbnRpdHksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoY2xhaW0pIHtcbiAgICAgIHJldHVybiBjbGFpbS50byhkZXN0aW5hdGlvbkFkZHJlc3MsIHRva2VuSWQsIHF1YW50aXR5LCBvcHRpb25zKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEV4dGVuc2lvbk5vdEltcGxlbWVudGVkRXJyb3IoRkVBVFVSRV9FRElUSU9OX0NMQUlNX0NVU1RPTSk7XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJlIGNsYWltIGNvbmRpdGlvbnNcbiAgICogQHJlbWFya3MgRGVmaW5lIHdobyBjYW4gY2xhaW0gTkZUcyBpbiB0aGUgY29sbGVjdGlvbiwgd2hlbiBhbmQgaG93IG1hbnkuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgcHJlc2FsZVN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAqIGNvbnN0IHB1YmxpY1NhbGVTdGFydFRpbWUgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgNjAgKiA2MCAqIDI0ICogMTAwMCk7XG4gICAqIGNvbnN0IGNsYWltQ29uZGl0aW9ucyA9IFtcbiAgICogICB7XG4gICAqICAgICBzdGFydFRpbWU6IHByZXNhbGVTdGFydFRpbWUsIC8vIHN0YXJ0IHRoZSBwcmVzYWxlIG5vd1xuICAgKiAgICAgbWF4UXVhbnRpdHk6IDIsIC8vIGxpbWl0IGhvdyBtYW55IG1pbnRzIGZvciB0aGlzIHByZXNhbGVcbiAgICogICAgIHByaWNlOiAwLjAxLCAvLyBwcmVzYWxlIHByaWNlXG4gICAqICAgICBzbmFwc2hvdDogWycweC4uLicsICcweC4uLiddLCAvLyBsaW1pdCBtaW50aW5nIHRvIG9ubHkgY2VydGFpbiBhZGRyZXNzZXNcbiAgICogICB9LFxuICAgKiAgIHtcbiAgICogICAgIHN0YXJ0VGltZTogcHVibGljU2FsZVN0YXJ0VGltZSwgLy8gMjRoIGFmdGVyIHByZXNhbGUsIHN0YXJ0IHB1YmxpYyBzYWxlXG4gICAqICAgICBwcmljZTogMC4wOCwgLy8gcHVibGljIHNhbGUgcHJpY2VcbiAgICogICB9XG4gICAqIF0pO1xuICAgKiBhd2FpdCBjb250cmFjdC5lcmMxMTU1LmNsYWltQ29uZGl0aW9ucy5zZXQodG9rZW5JZCwgY2xhaW1Db25kaXRpb25zKTtcbiAgICogYGBgXG4gICAqIEB0d2ZlYXR1cmUgRVJDMTE1NUNsYWltYWJsZVdpdGhDb25kaXRpb25zXG4gICAqL1xuICBnZXQgY2xhaW1Db25kaXRpb25zKCkge1xuICAgIHJldHVybiBhc3NlcnRFbmFibGVkKHRoaXMubGF6eU1pbnRhYmxlPy5jbGFpbVdpdGhDb25kaXRpb25zLCBGRUFUVVJFX0VESVRJT05fQ0xBSU1fQ09ORElUSU9OU19WMikuY29uZGl0aW9ucztcbiAgfVxuXG4gIC8vLy8vLyBFUkMxMTU1IFNpZ25hdHVyZU1pbnRhYmxlIEV4dGVuc2lvbiAvLy8vLy9cblxuICAvKipcbiAgICogU2lnbmF0dXJlIE1pbnRpbmdcbiAgICogQHJlbWFya3MgR2VuZXJhdGUgZHluYW1pYyBORlRzIHdpdGggeW91ciBvd24gc2lnbmF0dXJlLCBhbmQgbGV0IG90aGVycyBtaW50IHRoZW0gdXNpbmcgdGhhdCBzaWduYXR1cmUuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gc2VlIGhvdyB0byBjcmFmdCBhIHBheWxvYWQgdG8gc2lnbiBpbiB0aGUgYGNvbnRyYWN0LmVyYzExNTUuc2lnbmF0dXJlLmdlbmVyYXRlKClgIGRvY3VtZW50YXRpb25cbiAgICogY29uc3Qgc2lnbmVkUGF5bG9hZCA9IGNvbnRyYWN0LmVyYzExNTUuc2lnbmF0dXJlKCkuZ2VuZXJhdGUocGF5bG9hZCk7XG4gICAqXG4gICAqIC8vIG5vdyBhbnlvbmUgY2FuIG1pbnQgdGhlIE5GVFxuICAgKiBjb25zdCB0eCA9IGNvbnRyYWN0LmVyYzExNTUuc2lnbmF0dXJlLm1pbnQoc2lnbmVkUGF5bG9hZCk7XG4gICAqIGNvbnN0IHJlY2VpcHQgPSB0eC5yZWNlaXB0OyAvLyB0aGUgbWludCB0cmFuc2FjdGlvbiByZWNlaXB0XG4gICAqIGNvbnN0IG1pbnRlZElkID0gdHguaWQ7IC8vIHRoZSBpZCBvZiB0aGUgTkZUIG1pbnRlZFxuICAgKiBgYGBcbiAgICogQHR3ZmVhdHVyZSBFUkMxMTU1U2lnbmF0dXJlTWludGFibGVcbiAgICovXG4gIGdldCBzaWduYXR1cmUoKSB7XG4gICAgcmV0dXJuIGFzc2VydEVuYWJsZWQodGhpcy5zaWduYXR1cmVNaW50YWJsZSwgRkVBVFVSRV9FRElUSU9OX1NJR05BVFVSRV9NSU5UQUJMRSk7XG4gIH1cblxuICAvLy8vLy8gRVJDMTE1NSBEZWxheWVkUmV2ZWFsIEV4dGVuc2lvbiAvLy8vLy9cblxuICAvKipcbiAgICogRGVsYXllZCByZXZlYWxcbiAgICogQHJlbWFya3MgQ3JlYXRlIGEgYmF0Y2ggb2YgZW5jcnlwdGVkIE5GVHMgdGhhdCBjYW4gYmUgcmV2ZWFsZWQgYXQgYSBsYXRlciB0aW1lLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIHRoZSByZWFsIE5GVHMsIHRoZXNlIHdpbGwgYmUgZW5jcnlwdGVkIHVudGlsIHlvdSByZXZlYWwgdGhlbVxuICAgKiBjb25zdCByZWFsTkZUcyA9IFt7XG4gICAqICAgbmFtZTogXCJDb21tb24gTkZUICMxXCIsXG4gICAqICAgZGVzY3JpcHRpb246IFwiQ29tbW9uIE5GVCwgb25lIG9mIG1hbnkuXCIsXG4gICAqICAgaW1hZ2U6IGZzLnJlYWRGaWxlU3luYyhcInBhdGgvdG8vaW1hZ2UucG5nXCIpLFxuICAgKiB9LCB7XG4gICAqICAgbmFtZTogXCJTdXBlciBSYXJlIE5GVCAjMlwiLFxuICAgKiAgIGRlc2NyaXB0aW9uOiBcIllvdSBnb3QgYSBTdXBlciBSYXJlIE5GVCFcIixcbiAgICogICBpbWFnZTogZnMucmVhZEZpbGVTeW5jKFwicGF0aC90by9pbWFnZS5wbmdcIiksXG4gICAqIH1dO1xuICAgKiAvLyBBIHBsYWNlaG9sZGVyIE5GVCB0aGF0IHBlb3BsZSB3aWxsIGdldCBpbW1lZGlhdGVseSBpbiB0aGVpciB3YWxsZXQsIGFuZCB3aWxsIGJlIGNvbnZlcnRlZCB0byB0aGUgcmVhbCBORlQgYXQgcmV2ZWFsIHRpbWVcbiAgICogY29uc3QgcGxhY2Vob2xkZXJORlQgPSB7XG4gICAqICAgbmFtZTogXCJIaWRkZW4gTkZUXCIsXG4gICAqICAgZGVzY3JpcHRpb246IFwiV2lsbCBiZSByZXZlYWxlZCBuZXh0IHdlZWshXCJcbiAgICogfTtcbiAgICogLy8gQ3JlYXRlIGFuZCBlbmNyeXB0IHRoZSBORlRzXG4gICAqIGF3YWl0IGNvbnRyYWN0LmVyYzExNTUuZHJvcC5yZXZlYWxlci5jcmVhdGVEZWxheWVkUmV2ZWFsQmF0Y2goXG4gICAqICAgcGxhY2Vob2xkZXJORlQsXG4gICAqICAgcmVhbE5GVHMsXG4gICAqICAgXCJteSBzZWNyZXQgcGFzc3dvcmRcIixcbiAgICogKTtcbiAgICogLy8gV2hlbmV2ZXIgeW91J3JlIHJlYWR5LCByZXZlYWwgeW91ciBORlRzIGF0IGFueSB0aW1lXG4gICAqIGNvbnN0IGJhdGNoSWQgPSAwOyAvLyB0aGUgYmF0Y2ggdG8gcmV2ZWFsXG4gICAqIGF3YWl0IGNvbnRyYWN0LmVyYzExNTUucmV2ZWFsZXIucmV2ZWFsKGJhdGNoSWQsIFwibXkgc2VjcmV0IHBhc3N3b3JkXCIpO1xuICAgKiBgYGBcbiAgICogQHR3ZmVhdHVyZSBFUkMxMTU1UmV2ZWFsYWJsZVxuICAgKi9cbiAgZ2V0IHJldmVhbGVyKCkge1xuICAgIHJldHVybiBhc3NlcnRFbmFibGVkKHRoaXMubGF6eU1pbnRhYmxlPy5yZXZlYWxlciwgRkVBVFVSRV9FRElUSU9OX1JFVkVBTEFCTEUpO1xuICB9XG5cbiAgLyoqICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBQUklWQVRFIEZVTkNUSU9OU1xuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB0b2tlbklkIC0gdGhlIHRva2VuIElkIHRvIGZldGNoXG4gICAqL1xuICBhc3luYyBnZXRUb2tlbk1ldGFkYXRhKHRva2VuSWQpIHtcbiAgICBjb25zdCB0b2tlblVyaSA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC51cmkodG9rZW5JZCk7XG4gICAgaWYgKCF0b2tlblVyaSkge1xuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZldGNoVG9rZW5NZXRhZGF0YSh0b2tlbklkLCB0b2tlblVyaSwgdGhpcy5zdG9yYWdlKTtcbiAgfVxuICBkZXRlY3RFcmMxMTU1RW51bWVyYWJsZSgpIHtcbiAgICBpZiAoZGV0ZWN0Q29udHJhY3RGZWF0dXJlKHRoaXMuY29udHJhY3RXcmFwcGVyLCBcIkVSQzExNTVFbnVtZXJhYmxlXCIpKSB7XG4gICAgICByZXR1cm4gbmV3IEVyYzExNTVFbnVtZXJhYmxlKHRoaXMsIHRoaXMuY29udHJhY3RXcmFwcGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBkZXRlY3RFcmMxMTU1TWludGFibGUoKSB7XG4gICAgaWYgKGRldGVjdENvbnRyYWN0RmVhdHVyZSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgXCJFUkMxMTU1TWludGFibGVcIikpIHtcbiAgICAgIHJldHVybiBuZXcgRXJjMTE1NU1pbnRhYmxlKHRoaXMsIHRoaXMuY29udHJhY3RXcmFwcGVyLCB0aGlzLnN0b3JhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGRldGVjdEVyYzExNTVCdXJuYWJsZSgpIHtcbiAgICBpZiAoZGV0ZWN0Q29udHJhY3RGZWF0dXJlKHRoaXMuY29udHJhY3RXcmFwcGVyLCBcIkVSQzExNTVCdXJuYWJsZVwiKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcmMxMTU1QnVybmFibGUodGhpcy5jb250cmFjdFdyYXBwZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGRldGVjdEVyYzExNTVMYXp5TWludGFibGUoKSB7XG4gICAgaWYgKGRldGVjdENvbnRyYWN0RmVhdHVyZSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgXCJFUkMxMTU1TGF6eU1pbnRhYmxlVjFcIikgfHwgZGV0ZWN0Q29udHJhY3RGZWF0dXJlKHRoaXMuY29udHJhY3RXcmFwcGVyLCBcIkVSQzExNTVMYXp5TWludGFibGVWMlwiKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcmMxMTU1TGF6eU1pbnRhYmxlKHRoaXMsIHRoaXMuY29udHJhY3RXcmFwcGVyLCB0aGlzLnN0b3JhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGRldGVjdEVyYzExNTVTaWduYXR1cmVNaW50YWJsZSgpIHtcbiAgICBpZiAoZGV0ZWN0Q29udHJhY3RGZWF0dXJlKHRoaXMuY29udHJhY3RXcmFwcGVyLCBcIkVSQzExNTVTaWduYXR1cmVNaW50YWJsZVwiKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcmMxMTU1U2lnbmF0dXJlTWludGFibGUodGhpcy5jb250cmFjdFdyYXBwZXIsIHRoaXMuc3RvcmFnZSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTdGFuZGFyZCBFUkMxMTU1IE5GVCBmdW5jdGlvbnNcbiAqIEByZW1hcmtzIEJhc2ljIGZ1bmN0aW9uYWxpdHkgZm9yIGEgRVJDMTE1NSBjb250cmFjdCB0aGF0IGhhbmRsZXMgSVBGUyBzdG9yYWdlIGZvciB5b3UuXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgY29udHJhY3QgPSBhd2FpdCBzZGsuZ2V0Q29udHJhY3QoXCJ7e2NvbnRyYWN0X2FkZHJlc3N9fVwiKTtcbiAqIGF3YWl0IGNvbnRyYWN0LmVkaXRpb24udHJhbnNmZXIod2FsbGV0QWRkcmVzcywgdG9rZW5JZCwgcXVhbnRpdHkpO1xuICogYGBgXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFN0YW5kYXJkRXJjMTE1NSB7XG4gIGdldCBjaGFpbklkKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFpbklkO1xuICB9XG4gIGNvbnN0cnVjdG9yKGNvbnRyYWN0V3JhcHBlciwgc3RvcmFnZSwgY2hhaW5JZCkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRyYWN0V3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3JhZ2VcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlcmMxMTU1XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NoYWluSWRcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlciA9IGNvbnRyYWN0V3JhcHBlcjtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgIHRoaXMuZXJjMTE1NSA9IG5ldyBFcmMxMTU1KHRoaXMuY29udHJhY3RXcmFwcGVyLCB0aGlzLnN0b3JhZ2UsIGNoYWluSWQpO1xuICAgIHRoaXMuX2NoYWluSWQgPSBjaGFpbklkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb25OZXR3b3JrVXBkYXRlZChuZXR3b3JrKSB7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIudXBkYXRlU2lnbmVyT3JQcm92aWRlcihuZXR3b3JrKTtcbiAgfVxuICBnZXRBZGRyZXNzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuYWRkcmVzcztcbiAgfVxuXG4gIC8vLy8vLyBTdGFuZGFyZCBFUkMxMTU1IGZ1bmN0aW9ucyAvLy8vLy9cblxuICAvKipcbiAgICogR2V0IGEgc2luZ2xlIE5GVCBNZXRhZGF0YVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IG5mdCA9IGF3YWl0IGNvbnRyYWN0LmdldChcIjBcIik7XG4gICAqIGBgYFxuICAgKiBAcGFyYW0gdG9rZW5JZCAtIHRoZSB0b2tlbklkIG9mIHRoZSBORlQgdG8gcmV0cmlldmVcbiAgICogQHJldHVybnMgVGhlIE5GVCBtZXRhZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0KHRva2VuSWQpIHtcbiAgICByZXR1cm4gdGhpcy5lcmMxMTU1LmdldCh0b2tlbklkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0b3RhbCBzdXBwbHkgb2YgYSBzcGVjaWZpYyB0b2tlblxuICAgKiBAcGFyYW0gdG9rZW5JZCAtIFRoZSB0b2tlbiBJRCB0byBnZXQgdGhlIHRvdGFsIHN1cHBseSBvZlxuICAgKiBAcmV0dXJucyB0aGUgdG90YWwgc3VwcGx5XG4gICAqL1xuICBhc3luYyB0b3RhbFN1cHBseSh0b2tlbklkKSB7XG4gICAgcmV0dXJuIHRoaXMuZXJjMTE1NS50b3RhbFN1cHBseSh0b2tlbklkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgTkZUIEJhbGFuY2VcbiAgICpcbiAgICogQHJlbWFya3MgR2V0IGEgd2FsbGV0cyBORlQgYmFsYW5jZSAobnVtYmVyIG9mIE5GVHMgaW4gdGhpcyBjb250cmFjdCBvd25lZCBieSB0aGUgd2FsbGV0KS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBBZGRyZXNzIG9mIHRoZSB3YWxsZXQgdG8gY2hlY2sgTkZUIGJhbGFuY2VcbiAgICogY29uc3Qgd2FsbGV0QWRkcmVzcyA9IFwie3t3YWxsZXRfYWRkcmVzc319XCI7XG4gICAqIGNvbnN0IHRva2VuSWQgPSAwOyAvLyBJZCBvZiB0aGUgTkZUIHRvIGNoZWNrXG4gICAqIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjb250cmFjdC5iYWxhbmNlT2Yod2FsbGV0QWRkcmVzcywgdG9rZW5JZCk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgYmFsYW5jZU9mKGFkZHJlc3MsIHRva2VuSWQpIHtcbiAgICByZXR1cm4gdGhpcy5lcmMxMTU1LmJhbGFuY2VPZihhZGRyZXNzLCB0b2tlbklkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgTkZUIEJhbGFuY2UgZm9yIHRoZSBjdXJyZW50bHkgY29ubmVjdGVkIHdhbGxldFxuICAgKi9cbiAgYXN5bmMgYmFsYW5jZSh0b2tlbklkKSB7XG4gICAgcmV0dXJuIHRoaXMuZXJjMTE1NS5iYWxhbmNlKHRva2VuSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB3aGV0aGVyIHRoaXMgd2FsbGV0IGhhcyBhcHByb3ZlZCB0cmFuc2ZlcnMgZnJvbSB0aGUgZ2l2ZW4gb3BlcmF0b3JcbiAgICogQHBhcmFtIGFkZHJlc3MgLSB0aGUgd2FsbGV0IGFkZHJlc3NcbiAgICogQHBhcmFtIG9wZXJhdG9yIC0gdGhlIG9wZXJhdG9yIGFkZHJlc3NcbiAgICovXG4gIGFzeW5jIGlzQXBwcm92ZWQoYWRkcmVzcywgb3BlcmF0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5lcmMxMTU1LmlzQXBwcm92ZWQoYWRkcmVzcywgb3BlcmF0b3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZmVyIGEgc2luZ2xlIE5GVFxuICAgKlxuICAgKiBAcmVtYXJrcyBUcmFuc2ZlciBhbiBORlQgZnJvbSB0aGUgY29ubmVjdGVkIHdhbGxldCB0byBhbm90aGVyIHdhbGxldC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBBZGRyZXNzIG9mIHRoZSB3YWxsZXQgeW91IHdhbnQgdG8gc2VuZCB0aGUgTkZUIHRvXG4gICAqIGNvbnN0IHRvQWRkcmVzcyA9IFwie3t3YWxsZXRfYWRkcmVzc319XCI7XG4gICAqIGNvbnN0IHRva2VuSWQgPSBcIjBcIjsgLy8gVGhlIHRva2VuIElEIG9mIHRoZSBORlQgeW91IHdhbnQgdG8gc2VuZFxuICAgKiBjb25zdCBhbW91bnQgPSAzOyAvLyBIb3cgbWFueSBjb3BpZXMgb2YgdGhlIE5GVHMgdG8gdHJhbnNmZXJcbiAgICogYXdhaXQgY29udHJhY3QudHJhbnNmZXIodG9BZGRyZXNzLCB0b2tlbklkLCBhbW91bnQpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHRyYW5zZmVyKHRvLCB0b2tlbklkLCBhbW91bnQpIHtcbiAgICBsZXQgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogWzBdO1xuICAgIHJldHVybiB0aGlzLmVyYzExNTUudHJhbnNmZXIodG8sIHRva2VuSWQsIGFtb3VudCwgZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQXBwcm92ZSBvciByZW1vdmUgb3BlcmF0b3IgYXMgYW4gb3BlcmF0b3IgZm9yIHRoZSBjYWxsZXIuIE9wZXJhdG9ycyBjYW4gY2FsbCB0cmFuc2ZlckZyb20gb3Igc2FmZVRyYW5zZmVyRnJvbSBmb3IgYW55IHRva2VuIG93bmVkIGJ5IHRoZSBjYWxsZXIuXG4gICAqIEBwYXJhbSBvcGVyYXRvciAtIHRoZSBvcGVyYXRvcidzIGFkZHJlc3NcbiAgICogQHBhcmFtIGFwcHJvdmVkIC0gd2hldGhlciB0byBhcHByb3ZlIG9yIHJlbW92ZVxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIHNldEFwcHJvdmFsRm9yQWxsKG9wZXJhdG9yLCBhcHByb3ZlZCkge1xuICAgIHJldHVybiB0aGlzLmVyYzExNTUuc2V0QXBwcm92YWxGb3JBbGwob3BlcmF0b3IsIGFwcHJvdmVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBaXJkcm9wIG11bHRpcGxlIE5GVHNcbiAgICpcbiAgICogQHJlbWFya3MgQWlyZHJvcCBvbmUgb3IgbXVsdGlwbGUgTkZUcyB0byB0aGUgcHJvdmlkZWQgd2FsbGV0IGFkZHJlc3Nlcy5cbiAgICogQHR3ZmVhdHVyZSBFUkMxMTU1XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gVGhlIHRva2VuIElEIG9mIHRoZSBORlQgeW91IHdhbnQgdG8gYWlyZHJvcFxuICAgKiBjb25zdCB0b2tlbklkID0gXCIwXCI7XG4gICAqIC8vIEFycmF5IG9mIG9iamVjdHMgb2YgYWRkcmVzc2VzIGFuZCBxdWFudGl0aWVzIHRvIGFpcmRyb3AgTkZUcyB0b1xuICAgKiBjb25zdCBhZGRyZXNzZXMgPSBbXG4gICAqICB7XG4gICAqICAgIGFkZHJlc3M6IFwiMHguLi5cIixcbiAgICogICAgcXVhbnRpdHk6IDIsXG4gICAqICB9LFxuICAgKiAge1xuICAgKiAgIGFkZHJlc3M6IFwiMHguLi5cIixcbiAgICogICAgcXVhbnRpdHk6IDMsXG4gICAqICB9LFxuICAgKiBdO1xuICAgKiBhd2FpdCBjb250cmFjdC5haXJkcm9wKHRva2VuSWQsIGFkZHJlc3Nlcyk7XG4gICAqXG4gICAqIC8vIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGFycmF5IG9mIGFkZHJlc3NlcywgaXQgd2lsbCBhaXJkcm9wIDEgTkZUIHBlciBhZGRyZXNzXG4gICAqIGNvbnN0IHRva2VuSWQgPSBcIjBcIjtcbiAgICogY29uc3QgYWRkcmVzc2VzID0gW1xuICAgKiAgXCIweC4uLlwiLCBcIjB4Li4uXCIsIFwiMHguLi5cIixcbiAgICogXVxuICAgKiBhd2FpdCBjb250cmFjdC5haXJkcm9wKHRva2VuSWQsIGFkZHJlc3Nlcyk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgYWlyZHJvcCh0b2tlbklkLCBhZGRyZXNzZXMpIHtcbiAgICBsZXQgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogWzBdO1xuICAgIHJldHVybiB0aGlzLmVyYzExNTUuYWlyZHJvcCh0b2tlbklkLCBhZGRyZXNzZXMsIGRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY2hlY2tzIGlmIHRoZSBnaXZlbiB0b2tlbiBpcyBhcHByb3ZlZCBmb3IgdGhlIHRyYW5zZmVycmVyQ29udHJhY3RBZGRyZXNzIGNvbnRyYWN0LlxuICogVGhpcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBjb250cmFjdHMgdGhhdCBuZWVkIHRvIHRyYW5zZmVyIE5GVHMgb24gdGhlIHVzZXJzJyBiZWhhbGZcbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBwcm92aWRlciAtIFRoZSBjb25uZWN0ZWQgcHJvdmlkZXJcbiAqIEBwYXJhbSB0cmFuc2ZlcnJlckNvbnRyYWN0QWRkcmVzcyAtIFRoZSBhZGRyZXNzIG9mIHRoZSBtYXJrZXRwbGFjZSBjb250cmFjdFxuICogQHBhcmFtIGFzc2V0Q29udHJhY3QgLSBUaGUgYWRkcmVzcyBvZiB0aGUgYXNzZXQgY29udHJhY3QuXG4gKiBAcGFyYW0gdG9rZW5JZCAtIFRoZSB0b2tlbiBpZCBvZiB0aGUgdG9rZW4uXG4gKiBAcGFyYW0gb3duZXIgLSBUaGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCB0aGF0IG93bnMgdGhlIHRva2VuLlxuICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSB0cmFuc2ZlcnJlckNvbnRyYWN0QWRkcmVzcyBpcyBhcHByb3ZlZCBvbiB0aGUgdG9rZW4sIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaXNUb2tlbkFwcHJvdmVkRm9yVHJhbnNmZXIocHJvdmlkZXIsIHRyYW5zZmVycmVyQ29udHJhY3RBZGRyZXNzLCBhc3NldENvbnRyYWN0LCB0b2tlbklkLCBvd25lcikge1xuICB0cnkge1xuICAgIGNvbnN0IGVyYzE2NSA9IG5ldyBDb250cmFjdChhc3NldENvbnRyYWN0LCBFUkMxNjVBYmksIHByb3ZpZGVyKTtcbiAgICBjb25zdCBpc0VSQzcyMSA9IGF3YWl0IGVyYzE2NS5zdXBwb3J0c0ludGVyZmFjZShJbnRlcmZhY2VJZF9JRVJDNzIxKTtcbiAgICBjb25zdCBpc0VSQzExNTUgPSBhd2FpdCBlcmMxNjUuc3VwcG9ydHNJbnRlcmZhY2UoSW50ZXJmYWNlSWRfSUVSQzExNTUpO1xuICAgIGlmIChpc0VSQzcyMSkge1xuICAgICAgY29uc3QgYXNzZXQgPSBuZXcgQ29udHJhY3QoYXNzZXRDb250cmFjdCwgRXJjNzIxQWJpLCBwcm92aWRlcik7XG4gICAgICBjb25zdCBhcHByb3ZlZCA9IGF3YWl0IGFzc2V0LmlzQXBwcm92ZWRGb3JBbGwob3duZXIsIHRyYW5zZmVycmVyQ29udHJhY3RBZGRyZXNzKTtcbiAgICAgIGlmIChhcHByb3ZlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoYXdhaXQgYXNzZXQuZ2V0QXBwcm92ZWQodG9rZW5JZCkpLnRvTG93ZXJDYXNlKCkgPT09IHRyYW5zZmVycmVyQ29udHJhY3RBZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmIChpc0VSQzExNTUpIHtcbiAgICAgIGNvbnN0IGFzc2V0ID0gbmV3IENvbnRyYWN0KGFzc2V0Q29udHJhY3QsIEVyYzExNTVBYmksIHByb3ZpZGVyKTtcbiAgICAgIHJldHVybiBhd2FpdCBhc3NldC5pc0FwcHJvdmVkRm9yQWxsKG93bmVyLCB0cmFuc2ZlcnJlckNvbnRyYWN0QWRkcmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgRVJDIDExNTUgb3IgRVJDIDcyMS5cIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNoZWNrIGlmIHRva2VuIGlzIGFwcHJvdmVkXCIsIGVycik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBtYXJrZXRwbGFjZSBpcyBhcHByb3ZlZCB0byBtYWtlIHRyYW5zZmVycyBvbiB0aGUgYXNzZXRDb250cmFjdFxuICogSWYgbm90LCBpdCB0cmllcyB0byBzZXQgdGhlIGFwcHJvdmFsLlxuICogQHBhcmFtIHNpZ25lck9yUHJvdmlkZXJcbiAqIEBwYXJhbSBtYXJrZXRwbGFjZUFkZHJlc3NcbiAqIEBwYXJhbSBhc3NldENvbnRyYWN0XG4gKiBAcGFyYW0gdG9rZW5JZFxuICogQHBhcmFtIGZyb21cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaGFuZGxlVG9rZW5BcHByb3ZhbChzaWduZXJPclByb3ZpZGVyLCBtYXJrZXRwbGFjZUFkZHJlc3MsIGFzc2V0Q29udHJhY3QsIHRva2VuSWQsIGZyb20pIHtcbiAgY29uc3QgZXJjMTY1ID0gbmV3IENvbnRyYWN0KGFzc2V0Q29udHJhY3QsIEVSQzE2NUFiaSwgc2lnbmVyT3JQcm92aWRlcik7XG4gIGNvbnN0IGlzRVJDNzIxID0gYXdhaXQgZXJjMTY1LnN1cHBvcnRzSW50ZXJmYWNlKEludGVyZmFjZUlkX0lFUkM3MjEpO1xuICBjb25zdCBpc0VSQzExNTUgPSBhd2FpdCBlcmMxNjUuc3VwcG9ydHNJbnRlcmZhY2UoSW50ZXJmYWNlSWRfSUVSQzExNTUpO1xuICAvLyBjaGVjayBmb3IgdG9rZW4gYXBwcm92YWxcbiAgaWYgKGlzRVJDNzIxKSB7XG4gICAgY29uc3QgYXNzZXQgPSBuZXcgQ29udHJhY3RXcmFwcGVyKHNpZ25lck9yUHJvdmlkZXIsIGFzc2V0Q29udHJhY3QsIEVyYzcyMUFiaSwge30pO1xuICAgIGNvbnN0IGFwcHJvdmVkID0gYXdhaXQgYXNzZXQucmVhZENvbnRyYWN0LmlzQXBwcm92ZWRGb3JBbGwoZnJvbSwgbWFya2V0cGxhY2VBZGRyZXNzKTtcbiAgICBpZiAoIWFwcHJvdmVkKSB7XG4gICAgICBjb25zdCBpc1Rva2VuQXBwcm92ZWQgPSAoYXdhaXQgYXNzZXQucmVhZENvbnRyYWN0LmdldEFwcHJvdmVkKHRva2VuSWQpKS50b0xvd2VyQ2FzZSgpID09PSBtYXJrZXRwbGFjZUFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghaXNUb2tlbkFwcHJvdmVkKSB7XG4gICAgICAgIGF3YWl0IGFzc2V0LnNlbmRUcmFuc2FjdGlvbihcInNldEFwcHJvdmFsRm9yQWxsXCIsIFttYXJrZXRwbGFjZUFkZHJlc3MsIHRydWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFUkMxMTU1KSB7XG4gICAgY29uc3QgYXNzZXQgPSBuZXcgQ29udHJhY3RXcmFwcGVyKHNpZ25lck9yUHJvdmlkZXIsIGFzc2V0Q29udHJhY3QsIEVyYzExNTVBYmksIHt9KTtcbiAgICBjb25zdCBhcHByb3ZlZCA9IGF3YWl0IGFzc2V0LnJlYWRDb250cmFjdC5pc0FwcHJvdmVkRm9yQWxsKGZyb20sIG1hcmtldHBsYWNlQWRkcmVzcyk7XG4gICAgaWYgKCFhcHByb3ZlZCkge1xuICAgICAgYXdhaXQgYXNzZXQuc2VuZFRyYW5zYWN0aW9uKFwic2V0QXBwcm92YWxGb3JBbGxcIiwgW21hcmtldHBsYWNlQWRkcmVzcywgdHJ1ZV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihcIkNvbnRyYWN0IG11c3QgaW1wbGVtZW50IEVSQyAxMTU1IG9yIEVSQyA3MjEuXCIpO1xuICB9XG59XG5cbi8qKlxuICogVXNlZCB0byB2ZXJpZnkgZmllbGRzIGluIG5ldyBsaXN0aW5nLlxuICogQGludGVybmFsXG4gKi9cbi8vIFRPRE8gdGhpcyBzaG91bGQgYmUgZG9uZSBpbiB6b2RcbmZ1bmN0aW9uIHZhbGlkYXRlTmV3TGlzdGluZ1BhcmFtKHBhcmFtKSB7XG4gIGludmFyaWFudChwYXJhbS5hc3NldENvbnRyYWN0QWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmIHBhcmFtLmFzc2V0Q29udHJhY3RBZGRyZXNzICE9PSBudWxsLCBcIkFzc2V0IGNvbnRyYWN0IGFkZHJlc3MgaXMgcmVxdWlyZWRcIik7XG4gIGludmFyaWFudChwYXJhbS5idXlvdXRQcmljZVBlclRva2VuICE9PSB1bmRlZmluZWQgJiYgcGFyYW0uYnV5b3V0UHJpY2VQZXJUb2tlbiAhPT0gbnVsbCwgXCJCdXlvdXQgcHJpY2UgaXMgcmVxdWlyZWRcIik7XG4gIGludmFyaWFudChwYXJhbS5saXN0aW5nRHVyYXRpb25JblNlY29uZHMgIT09IHVuZGVmaW5lZCAmJiBwYXJhbS5saXN0aW5nRHVyYXRpb25JblNlY29uZHMgIT09IG51bGwsIFwiTGlzdGluZyBkdXJhdGlvbiBpcyByZXF1aXJlZFwiKTtcbiAgaW52YXJpYW50KHBhcmFtLnN0YXJ0VGltZXN0YW1wICE9PSB1bmRlZmluZWQgJiYgcGFyYW0uc3RhcnRUaW1lc3RhbXAgIT09IG51bGwsIFwiU3RhcnQgdGltZSBpcyByZXF1aXJlZFwiKTtcbiAgaW52YXJpYW50KHBhcmFtLnRva2VuSWQgIT09IHVuZGVmaW5lZCAmJiBwYXJhbS50b2tlbklkICE9PSBudWxsLCBcIlRva2VuIElEIGlzIHJlcXVpcmVkXCIpO1xuICBpbnZhcmlhbnQocGFyYW0ucXVhbnRpdHkgIT09IHVuZGVmaW5lZCAmJiBwYXJhbS5xdWFudGl0eSAhPT0gbnVsbCwgXCJRdWFudGl0eSBpcyByZXF1aXJlZFwiKTtcbiAgc3dpdGNoIChwYXJhbS50eXBlKSB7XG4gICAgY2FzZSBcIk5ld0F1Y3Rpb25MaXN0aW5nXCI6XG4gICAgICB7XG4gICAgICAgIGludmFyaWFudChwYXJhbS5yZXNlcnZlUHJpY2VQZXJUb2tlbiAhPT0gdW5kZWZpbmVkICYmIHBhcmFtLnJlc2VydmVQcmljZVBlclRva2VuICE9PSBudWxsLCBcIlJlc2VydmUgcHJpY2UgaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNYXBzIGEgY29udHJhY3Qgb2ZmZXIgdG8gdGhlIHN0cmljdCBpbnRlcmZhY2VcbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBvZmZlclxuICogQHJldHVybnMgLSBBbiBgT2ZmZXJgIG9iamVjdFxuICovXG5hc3luYyBmdW5jdGlvbiBtYXBPZmZlcihwcm92aWRlciwgbGlzdGluZ0lkLCBvZmZlcikge1xuICByZXR1cm4ge1xuICAgIHF1YW50aXR5OiBvZmZlci5xdWFudGl0eURlc2lyZWQsXG4gICAgcHJpY2VQZXJUb2tlbjogb2ZmZXIucHJpY2VQZXJUb2tlbixcbiAgICBjdXJyZW5jeUNvbnRyYWN0QWRkcmVzczogb2ZmZXIuY3VycmVuY3ksXG4gICAgYnV5ZXJBZGRyZXNzOiBvZmZlci5vZmZlcm9yLFxuICAgIHF1YW50aXR5RGVzaXJlZDogb2ZmZXIucXVhbnRpdHlXYW50ZWQsXG4gICAgY3VycmVuY3lWYWx1ZTogYXdhaXQgZmV0Y2hDdXJyZW5jeVZhbHVlKHByb3ZpZGVyLCBvZmZlci5jdXJyZW5jeSwgb2ZmZXIucXVhbnRpdHlXYW50ZWQubXVsKG9mZmVyLnByaWNlUGVyVG9rZW4pKSxcbiAgICBsaXN0aW5nSWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzV2lubmluZ0JpZCh3aW5uaW5nUHJpY2UsIG5ld0JpZFByaWNlLCBiaWRCdWZmZXIpIHtcbiAgYmlkQnVmZmVyID0gQmlnTnVtYmVyLmZyb20oYmlkQnVmZmVyKTtcbiAgd2lubmluZ1ByaWNlID0gQmlnTnVtYmVyLmZyb20od2lubmluZ1ByaWNlKTtcbiAgbmV3QmlkUHJpY2UgPSBCaWdOdW1iZXIuZnJvbShuZXdCaWRQcmljZSk7XG4gIGlmICh3aW5uaW5nUHJpY2UuZXEoQmlnTnVtYmVyLmZyb20oMCkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGJ1ZmZlciA9IG5ld0JpZFByaWNlLnN1Yih3aW5uaW5nUHJpY2UpLm11bChNQVhfQlBTKS5kaXYod2lubmluZ1ByaWNlKTtcbiAgcmV0dXJuIGJ1ZmZlci5ndGUoYmlkQnVmZmVyKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGRpcmVjdCBsaXN0aW5nc1xuICogQHB1YmxpY1xuICovXG5jbGFzcyBNYXJrZXRwbGFjZURpcmVjdCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRyYWN0V3JhcHBlciwgc3RvcmFnZSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRyYWN0V3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3JhZ2VcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlciA9IGNvbnRyYWN0V3JhcHBlcjtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICB9XG4gIGdldEFkZHJlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5hZGRyZXNzO1xuICB9XG5cbiAgLyoqICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBSRUFEIEZVTkNUSU9OU1xuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKipcbiAgICogR2V0IGEgZGlyZWN0IGxpc3RpbmcgYnkgaWRcbiAgICpcbiAgICogQHBhcmFtIGxpc3RpbmdJZCAtIHRoZSBsaXN0aW5nIGlkXG4gICAqIEByZXR1cm5zIHRoZSBEaXJlY3QgbGlzdGluZyBvYmplY3RcbiAgICovXG4gIGFzeW5jIGdldExpc3RpbmcobGlzdGluZ0lkKSB7XG4gICAgY29uc3QgbGlzdGluZyA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5saXN0aW5ncyhsaXN0aW5nSWQpO1xuICAgIGlmIChsaXN0aW5nLmFzc2V0Q29udHJhY3QgPT09IGNvbnN0YW50cy5BZGRyZXNzWmVybykge1xuICAgICAgdGhyb3cgbmV3IExpc3RpbmdOb3RGb3VuZEVycm9yKHRoaXMuZ2V0QWRkcmVzcygpLCBsaXN0aW5nSWQudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmIChsaXN0aW5nLmxpc3RpbmdUeXBlICE9PSBMaXN0aW5nVHlwZS5EaXJlY3QpIHtcbiAgICAgIHRocm93IG5ldyBXcm9uZ0xpc3RpbmdUeXBlRXJyb3IodGhpcy5nZXRBZGRyZXNzKCksIGxpc3RpbmdJZC50b1N0cmluZygpLCBcIkF1Y3Rpb25cIiwgXCJEaXJlY3RcIik7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLm1hcExpc3RpbmcobGlzdGluZyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBhY3RpdmUgb2ZmZXIgb24gYSBsaXN0aW5nXG4gICAqIEBwYXJhbSBsaXN0aW5nSWQgLSB0aGUgbGlzdGluZyBpZFxuICAgKiBAcGFyYW0gYWRkcmVzcyAtIHRoZSBhZGRyZXNzIHRoYXQgbWFkZSB0aGUgb2ZmZXJcbiAgICovXG4gIGFzeW5jIGdldEFjdGl2ZU9mZmVyKGxpc3RpbmdJZCwgYWRkcmVzcykge1xuICAgIGF3YWl0IHRoaXMudmFsaWRhdGVMaXN0aW5nKEJpZ051bWJlci5mcm9tKGxpc3RpbmdJZCkpO1xuICAgIGludmFyaWFudCh1dGlscy5pc0FkZHJlc3MoYWRkcmVzcyksIFwiQWRkcmVzcyBtdXN0IGJlIGEgdmFsaWQgYWRkcmVzc1wiKTtcbiAgICBjb25zdCBvZmZlcnMgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3Qub2ZmZXJzKGxpc3RpbmdJZCwgYWRkcmVzcyk7XG4gICAgaWYgKG9mZmVycy5vZmZlcm9yID09PSBjb25zdGFudHMuQWRkcmVzc1plcm8pIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBtYXBPZmZlcih0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRQcm92aWRlcigpLCBCaWdOdW1iZXIuZnJvbShsaXN0aW5nSWQpLCBvZmZlcnMpO1xuICB9XG5cbiAgLyoqICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBXUklURSBGVU5DVElPTlNcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBEaXJlY3QgTGlzdGluZ1xuICAgKlxuICAgKiBAcmVtYXJrcyBDcmVhdGUgYSBuZXcgbGlzdGluZyBvbiB0aGUgbWFya2V0cGxhY2Ugd2hlcmUgcGVvcGxlIGNhbiBidXkgYW4gYXNzZXQgZGlyZWN0bHkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gRGF0YSBvZiB0aGUgbGlzdGluZyB5b3Ugd2FudCB0byBjcmVhdGVcbiAgICogY29uc3QgbGlzdGluZyA9IHtcbiAgICogICAvLyBhZGRyZXNzIG9mIHRoZSBjb250cmFjdCB0aGUgYXNzZXQgeW91IHdhbnQgdG8gbGlzdCBpcyBvblxuICAgKiAgIGFzc2V0Q29udHJhY3RBZGRyZXNzOiBcIjB4Li4uXCIsXG4gICAqICAgLy8gdG9rZW4gSUQgb2YgdGhlIGFzc2V0IHlvdSB3YW50IHRvIGxpc3RcbiAgICogICB0b2tlbklkOiBcIjBcIixcbiAgICogICAvLyB3aGVuIHNob3VsZCB0aGUgbGlzdGluZyBvcGVuIHVwIGZvciBvZmZlcnNcbiAgICogICBzdGFydFRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICogICAvLyBob3cgbG9uZyB0aGUgbGlzdGluZyB3aWxsIGJlIG9wZW4gZm9yXG4gICAqICAgbGlzdGluZ0R1cmF0aW9uSW5TZWNvbmRzOiA4NjQwMCxcbiAgICogICAvLyBob3cgbWFueSBvZiB0aGUgYXNzZXQgeW91IHdhbnQgdG8gbGlzdFxuICAgKiAgIHF1YW50aXR5OiAxLFxuICAgKiAgIC8vIGFkZHJlc3Mgb2YgdGhlIGN1cnJlbmN5IGNvbnRyYWN0IHRoYXQgd2lsbCBiZSB1c2VkIHRvIHBheSBmb3IgdGhlIGxpc3RpbmdcbiAgICogICBjdXJyZW5jeUNvbnRyYWN0QWRkcmVzczogTkFUSVZFX1RPS0VOX0FERFJFU1MsXG4gICAqICAgLy8gaG93IG11Y2ggdGhlIGFzc2V0IHdpbGwgYmUgc29sZCBmb3JcbiAgICogICBidXlvdXRQcmljZVBlclRva2VuOiBcIjEuNVwiLFxuICAgKiB9XG4gICAqXG4gICAqIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuZGlyZWN0LmNyZWF0ZUxpc3RpbmcobGlzdGluZyk7XG4gICAqIGNvbnN0IHJlY2VpcHQgPSB0eC5yZWNlaXB0OyAvLyB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdFxuICAgKiBjb25zdCBpZCA9IHR4LmlkOyAvLyB0aGUgaWQgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgbGlzdGluZ1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUxpc3RpbmcobGlzdGluZykge1xuICAgIHZhbGlkYXRlTmV3TGlzdGluZ1BhcmFtKGxpc3RpbmcpO1xuICAgIGF3YWl0IGhhbmRsZVRva2VuQXBwcm92YWwodGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0U2lnbmVyT3JQcm92aWRlcigpLCB0aGlzLmdldEFkZHJlc3MoKSwgbGlzdGluZy5hc3NldENvbnRyYWN0QWRkcmVzcywgbGlzdGluZy50b2tlbklkLCBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRTaWduZXJBZGRyZXNzKCkpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRQcmljZVBlclRva2VuID0gYXdhaXQgbm9ybWFsaXplUHJpY2VWYWx1ZSh0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRQcm92aWRlcigpLCBsaXN0aW5nLmJ1eW91dFByaWNlUGVyVG9rZW4sIGxpc3RpbmcuY3VycmVuY3lDb250cmFjdEFkZHJlc3MpO1xuICAgIGxldCBsaXN0aW5nU3RhcnRUaW1lID0gTWF0aC5mbG9vcihsaXN0aW5nLnN0YXJ0VGltZXN0YW1wLmdldFRpbWUoKSAvIDEwMDApO1xuICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJvdmlkZXIoKS5nZXRCbG9jayhcImxhdGVzdFwiKTtcbiAgICBjb25zdCBibG9ja1RpbWUgPSBibG9jay50aW1lc3RhbXA7XG4gICAgaWYgKGxpc3RpbmdTdGFydFRpbWUgPCBibG9ja1RpbWUpIHtcbiAgICAgIGxpc3RpbmdTdGFydFRpbWUgPSBibG9ja1RpbWU7XG4gICAgfVxuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJjcmVhdGVMaXN0aW5nXCIsIFt7XG4gICAgICBhc3NldENvbnRyYWN0OiBsaXN0aW5nLmFzc2V0Q29udHJhY3RBZGRyZXNzLFxuICAgICAgdG9rZW5JZDogbGlzdGluZy50b2tlbklkLFxuICAgICAgYnV5b3V0UHJpY2VQZXJUb2tlbjogbm9ybWFsaXplZFByaWNlUGVyVG9rZW4sXG4gICAgICBjdXJyZW5jeVRvQWNjZXB0OiBjbGVhbkN1cnJlbmN5QWRkcmVzcyhsaXN0aW5nLmN1cnJlbmN5Q29udHJhY3RBZGRyZXNzKSxcbiAgICAgIGxpc3RpbmdUeXBlOiBMaXN0aW5nVHlwZS5EaXJlY3QsXG4gICAgICBxdWFudGl0eVRvTGlzdDogbGlzdGluZy5xdWFudGl0eSxcbiAgICAgIHJlc2VydmVQcmljZVBlclRva2VuOiBub3JtYWxpemVkUHJpY2VQZXJUb2tlbixcbiAgICAgIHNlY29uZHNVbnRpbEVuZFRpbWU6IGxpc3RpbmcubGlzdGluZ0R1cmF0aW9uSW5TZWNvbmRzLFxuICAgICAgc3RhcnRUaW1lOiBCaWdOdW1iZXIuZnJvbShsaXN0aW5nU3RhcnRUaW1lKVxuICAgIH1dLCB7XG4gICAgICAvLyBIaWdoZXIgZ2FzIGxpbWl0IGZvciBjcmVhdGUgbGlzdGluZ1xuICAgICAgZ2FzTGltaXQ6IDUwMDAwMFxuICAgIH0pO1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5jb250cmFjdFdyYXBwZXIucGFyc2VMb2dzKFwiTGlzdGluZ0FkZGVkXCIsIHJlY2VpcHQ/LmxvZ3MpO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogZXZlbnRbMF0uYXJncy5saXN0aW5nSWQsXG4gICAgICByZWNlaXB0XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGFuIG9mZmVyIGZvciBhIERpcmVjdCBMaXN0aW5nXG4gICAqXG4gICAqIEByZW1hcmtzIE1ha2UgYW4gb2ZmZXIgb24gYSBkaXJlY3QgbGlzdGluZ1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGltcG9ydCB7IENoYWluSWQsIE5BVElWRV9UT0tFTlMgfSBmcm9tIFwiQHRoaXJkd2ViLWRldi9zZGtcIjtcbiAgICpcbiAgICogLy8gVGhlIGxpc3RpbmcgSUQgb2YgdGhlIGFzc2V0IHlvdSB3YW50IHRvIG9mZmVyIG9uXG4gICAqIGNvbnN0IGxpc3RpbmdJZCA9IDA7XG4gICAqIC8vIFRoZSBwcmljZSB5b3UgYXJlIHdpbGxpbmcgdG8gb2ZmZXIgcGVyIHRva2VuXG4gICAqIGNvbnN0IHByaWNlUGVyVG9rZW4gPSAxO1xuICAgKiAvLyBUaGUgcXVhbnRpdHkgb2YgdG9rZW5zIHlvdSB3YW50IHRvIHJlY2VpdmUgZm9yIHRoaXMgb2ZmZXJcbiAgICogY29uc3QgcXVhbnRpdHkgPSAxO1xuICAgKiAvLyBUaGUgYWRkcmVzcyBvZiB0aGUgY3VycmVuY3kgeW91IGFyZSBtYWtpbmcgdGhlIG9mZmVyIGluIChtdXN0IGJlIEVSQy0yMClcbiAgICogY29uc3QgY3VycmVuY3lDb250cmFjdEFkZHJlc3MgPSBOQVRJVkVfVE9LRU5TW0NoYWluSWQuUmlua2VieV0ud3JhcHBlZC5hZGRyZXNzXG4gICAqXG4gICAqIGF3YWl0IGNvbnRyYWN0LmRpcmVjdC5tYWtlT2ZmZXIoXG4gICAqICAgbGlzdGluZ0lkLFxuICAgKiAgIHF1YW50aXR5LFxuICAgKiAgIGN1cnJlbmN5Q29udHJhY3RBZGRyZXNzLFxuICAgKiAgIHByaWNlUGVyVG9rZW5cbiAgICogKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBtYWtlT2ZmZXIobGlzdGluZ0lkLCBxdWFudGl0eURlc2lyZWQsIGN1cnJlbmN5Q29udHJhY3RBZGRyZXNzLCBwcmljZVBlclRva2VuLCBleHBpcmF0aW9uRGF0ZSkge1xuICAgIGlmIChpc05hdGl2ZVRva2VuKGN1cnJlbmN5Q29udHJhY3RBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgdXNlIHRoZSB3cmFwcGVkIG5hdGl2ZSB0b2tlbiBhZGRyZXNzIHdoZW4gbWFraW5nIGFuIG9mZmVyIHdpdGggYSBuYXRpdmUgdG9rZW5cIik7XG4gICAgfVxuICAgIGNvbnN0IG5vcm1hbGl6ZWRQcmljZSA9IGF3YWl0IG5vcm1hbGl6ZVByaWNlVmFsdWUodGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJvdmlkZXIoKSwgcHJpY2VQZXJUb2tlbiwgY3VycmVuY3lDb250cmFjdEFkZHJlc3MpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmdldExpc3RpbmcobGlzdGluZ0lkKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZ2V0IGxpc3RpbmcsIGVyciA9XCIsIGVycik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGdldHRpbmcgdGhlIGxpc3Rpbmcgd2l0aCBpZCAke2xpc3RpbmdJZH1gKTtcbiAgICB9XG4gICAgY29uc3QgcXVhbnRpdHkgPSBCaWdOdW1iZXIuZnJvbShxdWFudGl0eURlc2lyZWQpO1xuICAgIGNvbnN0IHZhbHVlID0gQmlnTnVtYmVyLmZyb20obm9ybWFsaXplZFByaWNlKS5tdWwocXVhbnRpdHkpO1xuICAgIGNvbnN0IG92ZXJyaWRlcyA9IChhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRDYWxsT3ZlcnJpZGVzKCkpIHx8IHt9O1xuICAgIGF3YWl0IHNldEVyYzIwQWxsb3dhbmNlKHRoaXMuY29udHJhY3RXcmFwcGVyLCB2YWx1ZSwgY3VycmVuY3lDb250cmFjdEFkZHJlc3MsIG92ZXJyaWRlcyk7XG4gICAgbGV0IGV4cGlyYXRpb25UaW1lc3RhbXAgPSBldGhlcnMuY29uc3RhbnRzLk1heFVpbnQyNTY7XG4gICAgaWYgKGV4cGlyYXRpb25EYXRlKSB7XG4gICAgICBleHBpcmF0aW9uVGltZXN0YW1wID0gQmlnTnVtYmVyLmZyb20oTWF0aC5mbG9vcihleHBpcmF0aW9uRGF0ZS5nZXRUaW1lKCkgLyAxMDAwKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWNlaXB0OiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJvZmZlclwiLCBbbGlzdGluZ0lkLCBxdWFudGl0eURlc2lyZWQsIGN1cnJlbmN5Q29udHJhY3RBZGRyZXNzLCBub3JtYWxpemVkUHJpY2UsIGV4cGlyYXRpb25UaW1lc3RhbXBdLCBvdmVycmlkZXMpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHQgYW4gb2ZmZXIgb24gYSBkaXJlY3QgbGlzdGluZ1xuICAgKlxuICAgKiBAcmVtYXJrcyBBY2NlcHQgYW4gb2ZmZXIgb24gYSBkaXJlY3QgbGlzdGluZ1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIFRoZSBsaXN0aW5nIElEIG9mIHRoZSBhc3NldCB5b3Ugd2FudCB0byBiaWQgb25cbiAgICogY29uc3QgbGlzdGluZ0lkID0gMDtcbiAgICogLy8gVGhlIHByaWNlIHlvdSBhcmUgd2lsbGluZyB0byBiaWQgZm9yIGEgc2luZ2xlIHRva2VuIG9mIHRoZSBsaXN0aW5nXG4gICAqIGNvbnN0IG9mZmVyb3IgPSBcIjB4Li4uXCI7XG4gICAqXG4gICAqIGF3YWl0IGNvbnRyYWN0LmRpcmVjdC5hY2NlcHRPZmZlcihsaXN0aW5nSWQsIG9mZmVyb3IpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGFjY2VwdE9mZmVyKGxpc3RpbmdJZCwgYWRkcmVzc09mT2ZmZXJvcikge1xuICAgIC8qKlxuICAgICAqIFRPRE86XG4gICAgICogLSBQcm92aWRlIGJldHRlciBlcnJvciBoYW5kbGluZyBpZiBvZmZlciBpcyB0b28gbG93LlxuICAgICAqL1xuICAgIGF3YWl0IHRoaXMudmFsaWRhdGVMaXN0aW5nKEJpZ051bWJlci5mcm9tKGxpc3RpbmdJZCkpO1xuICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0Lm9mZmVycyhsaXN0aW5nSWQsIGFkZHJlc3NPZk9mZmVyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICByZWNlaXB0OiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJhY2NlcHRPZmZlclwiLCBbbGlzdGluZ0lkLCBhZGRyZXNzT2ZPZmZlcm9yLCBvZmZlci5jdXJyZW5jeSwgb2ZmZXIucHJpY2VQZXJUb2tlbl0pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdXkgYSBMaXN0aW5nXG4gICAqXG4gICAqIEByZW1hcmtzIEJ1eSBhIHNwZWNpZmljIGRpcmVjdCBsaXN0aW5nIGZyb20gdGhlIG1hcmtldHBsYWNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIFRoZSBsaXN0aW5nIElEIG9mIHRoZSBhc3NldCB5b3Ugd2FudCB0byBidXlcbiAgICogY29uc3QgbGlzdGluZ0lkID0gMDtcbiAgICogLy8gUXVhbnRpdHkgb2YgdGhlIGFzc2V0IHlvdSB3YW50IHRvIGJ1eVxuICAgKiBjb25zdCBxdWFudGl0eURlc2lyZWQgPSAxO1xuICAgKlxuICAgKiBhd2FpdCBjb250cmFjdC5kaXJlY3QuYnV5b3V0TGlzdGluZyhsaXN0aW5nSWQsIHF1YW50aXR5RGVzaXJlZCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gbGlzdGluZ0lkIC0gVGhlIGxpc3RpbmcgaWQgdG8gYnV5XG4gICAqIEBwYXJhbSBxdWFudGl0eURlc2lyZWQgLSB0aGUgcXVhbnRpdHkgdG8gYnV5XG4gICAqIEBwYXJhbSByZWNlaXZlciAtIG9wdGlvbmFsIHJlY2VpdmVyIG9mIHRoZSBib3VnaHQgbGlzdGluZyBpZiBkaWZmZXJlbnQgZnJvbSB0aGUgY29ubmVjdGVkIHdhbGxldFxuICAgKi9cbiAgYXN5bmMgYnV5b3V0TGlzdGluZyhsaXN0aW5nSWQsIHF1YW50aXR5RGVzaXJlZCwgcmVjZWl2ZXIpIHtcbiAgICBjb25zdCBsaXN0aW5nID0gYXdhaXQgdGhpcy52YWxpZGF0ZUxpc3RpbmcoQmlnTnVtYmVyLmZyb20obGlzdGluZ0lkKSk7XG4gICAgY29uc3Qge1xuICAgICAgdmFsaWQsXG4gICAgICBlcnJvclxuICAgIH0gPSBhd2FpdCB0aGlzLmlzU3RpbGxWYWxpZExpc3RpbmcobGlzdGluZywgcXVhbnRpdHlEZXNpcmVkKTtcbiAgICBpZiAoIXZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYExpc3RpbmcgJHtsaXN0aW5nSWR9IGlzIG5vIGxvbmdlciB2YWxpZC4gJHtlcnJvcn1gKTtcbiAgICB9XG4gICAgY29uc3QgYnV5Rm9yID0gcmVjZWl2ZXIgPyByZWNlaXZlciA6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFNpZ25lckFkZHJlc3MoKTtcbiAgICBjb25zdCBxdWFudGl0eSA9IEJpZ051bWJlci5mcm9tKHF1YW50aXR5RGVzaXJlZCk7XG4gICAgY29uc3QgdmFsdWUgPSBCaWdOdW1iZXIuZnJvbShsaXN0aW5nLmJ1eW91dFByaWNlKS5tdWwocXVhbnRpdHkpO1xuICAgIGNvbnN0IG92ZXJyaWRlcyA9IChhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRDYWxsT3ZlcnJpZGVzKCkpIHx8IHt9O1xuICAgIGF3YWl0IHNldEVyYzIwQWxsb3dhbmNlKHRoaXMuY29udHJhY3RXcmFwcGVyLCB2YWx1ZSwgbGlzdGluZy5jdXJyZW5jeUNvbnRyYWN0QWRkcmVzcywgb3ZlcnJpZGVzKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjZWlwdDogYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuc2VuZFRyYW5zYWN0aW9uKFwiYnV5XCIsIFtsaXN0aW5nSWQsIGJ1eUZvciwgcXVhbnRpdHksIGxpc3RpbmcuY3VycmVuY3lDb250cmFjdEFkZHJlc3MsIHZhbHVlXSwgb3ZlcnJpZGVzKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGEgRGlyZWN0IGxpc3Rpbmcgd2l0aCBuZXcgbWV0YWRhdGEuXG4gICAqXG4gICAqIE5vdGU6IGNhbm5vdCB1cGRhdGUgYSBsaXN0aW5nIHdpdGggYSBuZXcgcXVhbnRpdHkgb2YgMC4gVXNlIGBjYW5jZWxEaXJlY3RMaXN0aW5nYCB0byByZW1vdmUgYSBsaXN0aW5nIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSBsaXN0aW5nIC0gdGhlIG5ldyBsaXN0aW5nIGluZm9ybWF0aW9uXG4gICAqL1xuICBhc3luYyB1cGRhdGVMaXN0aW5nKGxpc3RpbmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjZWlwdDogYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuc2VuZFRyYW5zYWN0aW9uKFwidXBkYXRlTGlzdGluZ1wiLCBbbGlzdGluZy5pZCwgbGlzdGluZy5xdWFudGl0eSwgbGlzdGluZy5idXlvdXRQcmljZSxcbiAgICAgIC8vIHJlc2VydmUgcHJpY2UsIGRvZXNuJ3QgbWF0dGVyIGZvciBkaXJlY3QgbGlzdGluZ1xuICAgICAgbGlzdGluZy5idXlvdXRQcmljZSwgbGlzdGluZy5jdXJyZW5jeUNvbnRyYWN0QWRkcmVzcywgbGlzdGluZy5zdGFydFRpbWVJblNlY29uZHMsIGxpc3Rpbmcuc2Vjb25kc1VudGlsRW5kXSlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCBEaXJlY3QgTGlzdGluZ1xuICAgKlxuICAgKiBAcmVtYXJrcyBDYW5jZWwgYSBkaXJlY3QgbGlzdGluZyBvbiB0aGUgbWFya2V0cGxhY2VcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBUaGUgbGlzdGluZyBJRCBvZiB0aGUgZGlyZWN0IGxpc3RpbmcgeW91IHdhbnQgdG8gY2FuY2VsXG4gICAqIGNvbnN0IGxpc3RpbmdJZCA9IFwiMFwiO1xuICAgKlxuICAgKiBhd2FpdCBjb250cmFjdC5kaXJlY3QuY2FuY2VsTGlzdGluZyhsaXN0aW5nSWQpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGNhbmNlbExpc3RpbmcobGlzdGluZ0lkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNlbmRUcmFuc2FjdGlvbihcImNhbmNlbERpcmVjdExpc3RpbmdcIiwgW2xpc3RpbmdJZF0pXG4gICAgfTtcbiAgfVxuXG4gIC8qKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICogUFJJVkFURSBGVU5DVElPTlNcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIFRocm93cyBlcnJvciBpZiBsaXN0aW5nIGNvdWxkIG5vdCBiZSBmb3VuZFxuICAgKlxuICAgKiBAcGFyYW0gbGlzdGluZ0lkIC0gTGlzdGluZyB0byBjaGVjayBmb3JcbiAgICovXG4gIGFzeW5jIHZhbGlkYXRlTGlzdGluZyhsaXN0aW5nSWQpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0TGlzdGluZyhsaXN0aW5nSWQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZ2V0dGluZyB0aGUgbGlzdGluZyB3aXRoIGlkICR7bGlzdGluZ0lkfWApO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIG1hcHMgdGhlIGF1Y3Rpb24gbGlzdGluZyB0byB0aGUgZGlyZWN0IGxpc3RpbmcgaW50ZXJmYWNlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIGxpc3RpbmcgLSBUaGUgbGlzdGluZyB0byBtYXAsIGFzIHJldHVybmVkIGZyb20gdGhlIGNvbnRyYWN0LlxuICAgKiBAcmV0dXJucyAtIFRoZSBtYXBwZWQgaW50ZXJmYWNlLlxuICAgKi9cbiAgYXN5bmMgbWFwTGlzdGluZyhsaXN0aW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzc2V0Q29udHJhY3RBZGRyZXNzOiBsaXN0aW5nLmFzc2V0Q29udHJhY3QsXG4gICAgICBidXlvdXRQcmljZTogQmlnTnVtYmVyLmZyb20obGlzdGluZy5idXlvdXRQcmljZVBlclRva2VuKSxcbiAgICAgIGN1cnJlbmN5Q29udHJhY3RBZGRyZXNzOiBsaXN0aW5nLmN1cnJlbmN5LFxuICAgICAgYnV5b3V0Q3VycmVuY3lWYWx1ZVBlclRva2VuOiBhd2FpdCBmZXRjaEN1cnJlbmN5VmFsdWUodGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJvdmlkZXIoKSwgbGlzdGluZy5jdXJyZW5jeSwgbGlzdGluZy5idXlvdXRQcmljZVBlclRva2VuKSxcbiAgICAgIGlkOiBsaXN0aW5nLmxpc3RpbmdJZC50b1N0cmluZygpLFxuICAgICAgdG9rZW5JZDogbGlzdGluZy50b2tlbklkLFxuICAgICAgcXVhbnRpdHk6IGxpc3RpbmcucXVhbnRpdHksXG4gICAgICBzdGFydFRpbWVJblNlY29uZHM6IGxpc3Rpbmcuc3RhcnRUaW1lLFxuICAgICAgYXNzZXQ6IGF3YWl0IGZldGNoVG9rZW5NZXRhZGF0YUZvckNvbnRyYWN0KGxpc3RpbmcuYXNzZXRDb250cmFjdCwgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJvdmlkZXIoKSwgbGlzdGluZy50b2tlbklkLCB0aGlzLnN0b3JhZ2UpLFxuICAgICAgc2Vjb25kc1VudGlsRW5kOiBsaXN0aW5nLmVuZFRpbWUsXG4gICAgICBzZWxsZXJBZGRyZXNzOiBsaXN0aW5nLnRva2VuT3duZXIsXG4gICAgICB0eXBlOiBMaXN0aW5nVHlwZS5EaXJlY3RcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjaGVjayBpZiBhIGRpcmVjdCBsaXN0aW5nIGlzIHN0aWxsIHZhbGlkLlxuICAgKlxuICAgKiBXYXlzIGEgZGlyZWN0IGxpc3RpbmcgY2FuIGJlY29tZSBpbnZhbGlkOlxuICAgKiAxLiBUaGUgYXNzZXQgaG9sZGVyIHRyYW5zZmVycmVkIHRoZSBhc3NldCB0byBhbm90aGVyIHdhbGxldFxuICAgKiAyLiBUaGUgYXNzZXQgaG9sZGVyIGJ1cm5lZCB0aGUgYXNzZXRcbiAgICogMy4gVGhlIGFzc2V0IGhvbGRlciByZW1vdmVkIHRoZSBhcHByb3ZhbCBvbiB0aGUgbWFya2V0cGxhY2VcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSBsaXN0aW5nIC0gVGhlIGxpc3RpbmcgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgbGlzdGluZyBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgYXN5bmMgaXNTdGlsbFZhbGlkTGlzdGluZyhsaXN0aW5nLCBxdWFudGl0eSkge1xuICAgIGNvbnN0IGFwcHJvdmVkID0gYXdhaXQgaXNUb2tlbkFwcHJvdmVkRm9yVHJhbnNmZXIodGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJvdmlkZXIoKSwgdGhpcy5nZXRBZGRyZXNzKCksIGxpc3RpbmcuYXNzZXRDb250cmFjdEFkZHJlc3MsIGxpc3RpbmcudG9rZW5JZCwgbGlzdGluZy5zZWxsZXJBZGRyZXNzKTtcbiAgICBpZiAoIWFwcHJvdmVkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgIGVycm9yOiBgVG9rZW4gJyR7bGlzdGluZy50b2tlbklkfScgZnJvbSBjb250cmFjdCAnJHtsaXN0aW5nLmFzc2V0Q29udHJhY3RBZGRyZXNzfScgaXMgbm90IGFwcHJvdmVkIGZvciB0cmFuc2ZlcmBcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJvdmlkZXIoKTtcbiAgICBjb25zdCBlcmMxNjUgPSBuZXcgQ29udHJhY3QobGlzdGluZy5hc3NldENvbnRyYWN0QWRkcmVzcywgRVJDMTY1QWJpLCBwcm92aWRlcik7XG4gICAgY29uc3QgaXNFUkM3MjEgPSBhd2FpdCBlcmMxNjUuc3VwcG9ydHNJbnRlcmZhY2UoSW50ZXJmYWNlSWRfSUVSQzcyMSk7XG4gICAgY29uc3QgaXNFUkMxMTU1ID0gYXdhaXQgZXJjMTY1LnN1cHBvcnRzSW50ZXJmYWNlKEludGVyZmFjZUlkX0lFUkMxMTU1KTtcbiAgICBpZiAoaXNFUkM3MjEpIHtcbiAgICAgIGNvbnN0IGFzc2V0ID0gbmV3IENvbnRyYWN0KGxpc3RpbmcuYXNzZXRDb250cmFjdEFkZHJlc3MsIEVyYzcyMUFiaSwgcHJvdmlkZXIpO1xuICAgICAgY29uc3QgdmFsaWQgPSAoYXdhaXQgYXNzZXQub3duZXJPZihsaXN0aW5nLnRva2VuSWQpKS50b0xvd2VyQ2FzZSgpID09PSBsaXN0aW5nLnNlbGxlckFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbGlkLFxuICAgICAgICBlcnJvcjogdmFsaWQgPyB1bmRlZmluZWQgOiBgU2VsbGVyIGlzIG5vdCB0aGUgb3duZXIgb2YgVG9rZW4gJyR7bGlzdGluZy50b2tlbklkfScgZnJvbSBjb250cmFjdCAnJHtsaXN0aW5nLmFzc2V0Q29udHJhY3RBZGRyZXNzfSBhbnltb3JlJ2BcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpc0VSQzExNTUpIHtcbiAgICAgIGNvbnN0IGFzc2V0ID0gbmV3IENvbnRyYWN0KGxpc3RpbmcuYXNzZXRDb250cmFjdEFkZHJlc3MsIEVyYzExNTVBYmksIHByb3ZpZGVyKTtcbiAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBhc3NldC5iYWxhbmNlT2YobGlzdGluZy5zZWxsZXJBZGRyZXNzLCBsaXN0aW5nLnRva2VuSWQpO1xuICAgICAgY29uc3QgdmFsaWQgPSBiYWxhbmNlLmd0ZShxdWFudGl0eSB8fCBsaXN0aW5nLnF1YW50aXR5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbGlkLFxuICAgICAgICBlcnJvcjogdmFsaWQgPyB1bmRlZmluZWQgOiBgU2VsbGVyIGRvZXMgbm90IGhhdmUgZW5vdWdoIGJhbGFuY2Ugb2YgVG9rZW4gJyR7bGlzdGluZy50b2tlbklkfScgZnJvbSBjb250cmFjdCAnJHtsaXN0aW5nLmFzc2V0Q29udHJhY3RBZGRyZXNzfSB0byBmdWxmaWxsIHRoZSBsaXN0aW5nYFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcjogXCJDb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgRVJDIDExNTUgb3IgRVJDIDcyMS5cIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGVzIGF1Y3Rpb24gbGlzdGluZ3NcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgTWFya2V0cGxhY2VBdWN0aW9uIHtcbiAgY29uc3RydWN0b3IoY29udHJhY3RXcmFwcGVyLCBzdG9yYWdlKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcmFnZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVuY29kZXJcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlciA9IGNvbnRyYWN0V3JhcHBlcjtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgIHRoaXMuZW5jb2RlciA9IG5ldyBDb250cmFjdEVuY29kZXIoY29udHJhY3RXcmFwcGVyKTtcbiAgfVxuICBnZXRBZGRyZXNzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuYWRkcmVzcztcbiAgfVxuXG4gIC8qKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICogUkVBRCBGVU5DVElPTlNcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIEdldCBhbiBBdWN0aW9uIGxpc3RpbmcgYnkgaWRcbiAgICpcbiAgICogQHBhcmFtIGxpc3RpbmdJZCAtIHRoZSBsaXN0aW5nIElkXG4gICAqIEByZXR1cm5zIHRoZSBBdWN0aW9uIGxpc3Rpbmcgb2JqZWN0XG4gICAqL1xuICBhc3luYyBnZXRMaXN0aW5nKGxpc3RpbmdJZCkge1xuICAgIGNvbnN0IGxpc3RpbmcgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QubGlzdGluZ3MobGlzdGluZ0lkKTtcbiAgICBpZiAobGlzdGluZy5saXN0aW5nSWQudG9TdHJpbmcoKSAhPT0gbGlzdGluZ0lkLnRvU3RyaW5nKCkpIHtcbiAgICAgIHRocm93IG5ldyBMaXN0aW5nTm90Rm91bmRFcnJvcih0aGlzLmdldEFkZHJlc3MoKSwgbGlzdGluZ0lkLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpZiAobGlzdGluZy5saXN0aW5nVHlwZSAhPT0gTGlzdGluZ1R5cGUuQXVjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IFdyb25nTGlzdGluZ1R5cGVFcnJvcih0aGlzLmdldEFkZHJlc3MoKSwgbGlzdGluZ0lkLnRvU3RyaW5nKCksIFwiRGlyZWN0XCIsIFwiQXVjdGlvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMubWFwTGlzdGluZyhsaXN0aW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgSGlnaGVzdCBCaWRcbiAgICpcbiAgICogQHJlbWFya3MgR2V0IHRoZSBjdXJyZW50IGhpZ2hlc3QgYmlkIG9mIGFuIGFjdGl2ZSBhdWN0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIFRoZSBsaXN0aW5nIElEIG9mIHRoZSBhdWN0aW9uIHRoYXQgY2xvc2VkXG4gICAqIGNvbnN0IGxpc3RpbmdJZCA9IDA7XG4gICAqXG4gICAqIGNvbnRyYWN0LmF1Y3Rpb24uXG4gICAqICAgLmdldFdpbm5pbmdCaWQobGlzdGluZ0lkKVxuICAgKiAgIC50aGVuKChvZmZlcikgPT4gY29uc29sZS5sb2cob2ZmZXIpKVxuICAgKiAgIC5jYXRjaCgoZXJyKSA9PiBjb25zb2xlLmVycm9yKGVycikpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGdldFdpbm5pbmdCaWQobGlzdGluZ0lkKSB7XG4gICAgYXdhaXQgdGhpcy52YWxpZGF0ZUxpc3RpbmcoQmlnTnVtYmVyLmZyb20obGlzdGluZ0lkKSk7XG4gICAgY29uc3Qgb2ZmZXJzID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0Lndpbm5pbmdCaWQobGlzdGluZ0lkKTtcbiAgICBpZiAob2ZmZXJzLm9mZmVyb3IgPT09IGNvbnN0YW50cy5BZGRyZXNzWmVybykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IG1hcE9mZmVyKHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFByb3ZpZGVyKCksIEJpZ051bWJlci5mcm9tKGxpc3RpbmdJZCksIG9mZmVycyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IEF1Y3Rpb24gV2lubmVyXG4gICAqXG4gICAqIEByZW1hcmtzIEdldCB0aGUgd2lubmVyIG9mIHRoZSBhdWN0aW9uIGFmdGVyIGFuIGF1Y3Rpb24gZW5kcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBUaGUgbGlzdGluZyBJRCBvZiB0aGUgYXVjdGlvbiB0aGF0IGNsb3NlZFxuICAgKiBjb25zdCBsaXN0aW5nSWQgPSAwO1xuICAgKlxuICAgKiBjb250cmFjdC5hdWN0aW9uLlxuICAgKiAgIC5nZXRXaW5uZXIobGlzdGluZ0lkKVxuICAgKiAgIC50aGVuKChhdWN0aW9uV2lubmVyKSA9PiBjb25zb2xlLmxvZyhhdWN0aW9uV2lubmVyKSlcbiAgICogICAuY2F0Y2goKGVycikgPT4gY29uc29sZS5lcnJvcihlcnIpKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBnZXRXaW5uZXIobGlzdGluZ0lkKSB7XG4gICAgY29uc3QgbGlzdGluZyA9IGF3YWl0IHRoaXMudmFsaWRhdGVMaXN0aW5nKEJpZ051bWJlci5mcm9tKGxpc3RpbmdJZCkpO1xuICAgIGNvbnN0IG9mZmVycyA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC53aW5uaW5nQmlkKGxpc3RpbmdJZCk7XG4gICAgY29uc3Qgbm93ID0gQmlnTnVtYmVyLmZyb20oTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkpO1xuICAgIGNvbnN0IGVuZFRpbWUgPSBCaWdOdW1iZXIuZnJvbShsaXN0aW5nLmVuZFRpbWVJbkVwb2NoU2Vjb25kcyk7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGEgd2lubmVyIGluIHRoZSBtYXAgYW5kIHRoZSBjdXJyZW50IHRpbWUgaXMgcGFzdCB0aGUgZW5kdGltZSBvZiB0aGUgYXVjdGlvbiByZXR1cm4gdGhlIGFkZHJlc3Mgb2YgdGhlIHdpbm5lclxuICAgIGlmIChub3cuZ3QoZW5kVGltZSkgJiYgb2ZmZXJzLm9mZmVyb3IgIT09IGNvbnN0YW50cy5BZGRyZXNzWmVybykge1xuICAgICAgcmV0dXJuIG9mZmVycy5vZmZlcm9yO1xuICAgIH1cbiAgICAvLyBvdGhlcndpc2UgZmFsbCBiYWNrIHRvIHF1ZXJ5IGZpbHRlciB0aGluZ3NcblxuICAgIC8vIFRPRE8gdGhpcyBzaG91bGQgYmUgdmlhIGluZGV4ZXIgb3IgZGlyZWN0IGNvbnRyYWN0IGNhbGxcbiAgICBjb25zdCBjbG9zZWRBdWN0aW9ucyA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5xdWVyeUZpbHRlcih0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuZmlsdGVycy5BdWN0aW9uQ2xvc2VkKCkpO1xuICAgIGNvbnN0IGF1Y3Rpb24gPSBjbG9zZWRBdWN0aW9ucy5maW5kKGEgPT4gYS5hcmdzLmxpc3RpbmdJZC5lcShCaWdOdW1iZXIuZnJvbShsaXN0aW5nSWQpKSk7XG4gICAgaWYgKCFhdWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGF1Y3Rpb24gd2l0aCBsaXN0aW5nSWQgJHtsaXN0aW5nSWR9IGluIGNsb3NlZCBhdWN0aW9uc2ApO1xuICAgIH1cbiAgICByZXR1cm4gYXVjdGlvbi5hcmdzLndpbm5pbmdCaWRkZXI7XG4gIH1cblxuICAvKiogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIFdSSVRFIEZVTkNUSU9OU1xuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKipcbiAgICogQ3JlYXRlIEF1Y3Rpb25cbiAgICpcbiAgICogQHJlbWFya3MgQ3JlYXRlIGEgbmV3IGF1Y3Rpb24gd2hlcmUgcGVvcGxlIGNhbiBiaWQgb24gYW4gYXNzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gRGF0YSBvZiB0aGUgYXVjdGlvbiB5b3Ugd2FudCB0byBjcmVhdGVcbiAgICogY29uc3QgYXVjdGlvbiA9IHtcbiAgICogICAvLyBhZGRyZXNzIG9mIHRoZSBjb250cmFjdCB0aGUgYXNzZXQgeW91IHdhbnQgdG8gbGlzdCBpcyBvblxuICAgKiAgIGFzc2V0Q29udHJhY3RBZGRyZXNzOiBcIjB4Li4uXCIsXG4gICAqICAgLy8gdG9rZW4gSUQgb2YgdGhlIGFzc2V0IHlvdSB3YW50IHRvIGxpc3RcbiAgICogICB0b2tlbklkOiBcIjBcIixcbiAgICogIC8vIHdoZW4gc2hvdWxkIHRoZSBsaXN0aW5nIG9wZW4gdXAgZm9yIG9mZmVyc1xuICAgKiAgIHN0YXJ0VGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgKiAgIC8vIGhvdyBsb25nIHRoZSBsaXN0aW5nIHdpbGwgYmUgb3BlbiBmb3JcbiAgICogICBsaXN0aW5nRHVyYXRpb25JblNlY29uZHM6IDg2NDAwLFxuICAgKiAgIC8vIGhvdyBtYW55IG9mIHRoZSBhc3NldCB5b3Ugd2FudCB0byBsaXN0XG4gICAqICAgcXVhbnRpdHk6IDEsXG4gICAqICAgLy8gYWRkcmVzcyBvZiB0aGUgY3VycmVuY3kgY29udHJhY3QgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcGF5IGZvciB0aGUgbGlzdGluZ1xuICAgKiAgIGN1cnJlbmN5Q29udHJhY3RBZGRyZXNzOiBOQVRJVkVfVE9LRU5fQUREUkVTUyxcbiAgICogICAvLyBob3cgbXVjaCBwZW9wbGUgd291bGQgaGF2ZSB0byBiaWQgdG8gaW5zdGFudGx5IGJ1eSB0aGUgYXNzZXRcbiAgICogICBidXlvdXRQcmljZVBlclRva2VuOiBcIjEwXCIsXG4gICAqICAgLy8gdGhlIG1pbmltdW0gYmlkIHRoYXQgd2lsbCBiZSBhY2NlcHRlZCBmb3IgdGhlIHRva2VuXG4gICAqICAgcmVzZXJ2ZVByaWNlUGVyVG9rZW46IFwiMS41XCIsXG4gICAqIH1cbiAgICpcbiAgICogY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5hdWN0aW9uLmNyZWF0ZUxpc3RpbmcoYXVjdGlvbik7XG4gICAqIGNvbnN0IHJlY2VpcHQgPSB0eC5yZWNlaXB0OyAvLyB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdFxuICAgKiBjb25zdCBpZCA9IHR4LmlkOyAvLyB0aGUgaWQgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgbGlzdGluZ1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUxpc3RpbmcobGlzdGluZykge1xuICAgIHZhbGlkYXRlTmV3TGlzdGluZ1BhcmFtKGxpc3RpbmcpO1xuICAgIGF3YWl0IGhhbmRsZVRva2VuQXBwcm92YWwodGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0U2lnbmVyT3JQcm92aWRlcigpLCB0aGlzLmdldEFkZHJlc3MoKSwgbGlzdGluZy5hc3NldENvbnRyYWN0QWRkcmVzcywgbGlzdGluZy50b2tlbklkLCBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRTaWduZXJBZGRyZXNzKCkpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRQcmljZVBlclRva2VuID0gYXdhaXQgbm9ybWFsaXplUHJpY2VWYWx1ZSh0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRQcm92aWRlcigpLCBsaXN0aW5nLmJ1eW91dFByaWNlUGVyVG9rZW4sIGxpc3RpbmcuY3VycmVuY3lDb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRSZXNlcnZlUHJpY2UgPSBhd2FpdCBub3JtYWxpemVQcmljZVZhbHVlKHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFByb3ZpZGVyKCksIGxpc3RpbmcucmVzZXJ2ZVByaWNlUGVyVG9rZW4sIGxpc3RpbmcuY3VycmVuY3lDb250cmFjdEFkZHJlc3MpO1xuICAgIGxldCBsaXN0aW5nU3RhcnRUaW1lID0gTWF0aC5mbG9vcihsaXN0aW5nLnN0YXJ0VGltZXN0YW1wLmdldFRpbWUoKSAvIDEwMDApO1xuICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJvdmlkZXIoKS5nZXRCbG9jayhcImxhdGVzdFwiKTtcbiAgICBjb25zdCBibG9ja1RpbWUgPSBibG9jay50aW1lc3RhbXA7XG4gICAgaWYgKGxpc3RpbmdTdGFydFRpbWUgPCBibG9ja1RpbWUpIHtcbiAgICAgIGxpc3RpbmdTdGFydFRpbWUgPSBibG9ja1RpbWU7XG4gICAgfVxuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJjcmVhdGVMaXN0aW5nXCIsIFt7XG4gICAgICBhc3NldENvbnRyYWN0OiBsaXN0aW5nLmFzc2V0Q29udHJhY3RBZGRyZXNzLFxuICAgICAgdG9rZW5JZDogbGlzdGluZy50b2tlbklkLFxuICAgICAgYnV5b3V0UHJpY2VQZXJUb2tlbjogbm9ybWFsaXplZFByaWNlUGVyVG9rZW4sXG4gICAgICBjdXJyZW5jeVRvQWNjZXB0OiBjbGVhbkN1cnJlbmN5QWRkcmVzcyhsaXN0aW5nLmN1cnJlbmN5Q29udHJhY3RBZGRyZXNzKSxcbiAgICAgIGxpc3RpbmdUeXBlOiBMaXN0aW5nVHlwZS5BdWN0aW9uLFxuICAgICAgcXVhbnRpdHlUb0xpc3Q6IGxpc3RpbmcucXVhbnRpdHksXG4gICAgICByZXNlcnZlUHJpY2VQZXJUb2tlbjogbm9ybWFsaXplZFJlc2VydmVQcmljZSxcbiAgICAgIHNlY29uZHNVbnRpbEVuZFRpbWU6IGxpc3RpbmcubGlzdGluZ0R1cmF0aW9uSW5TZWNvbmRzLFxuICAgICAgc3RhcnRUaW1lOiBCaWdOdW1iZXIuZnJvbShsaXN0aW5nU3RhcnRUaW1lKVxuICAgIH1dLCB7XG4gICAgICAvLyBIaWdoZXIgZ2FzIGxpbWl0IGZvciBjcmVhdGUgbGlzdGluZ1xuICAgICAgZ2FzTGltaXQ6IDUwMDAwMFxuICAgIH0pO1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5jb250cmFjdFdyYXBwZXIucGFyc2VMb2dzKFwiTGlzdGluZ0FkZGVkXCIsIHJlY2VpcHQ/LmxvZ3MpO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogZXZlbnRbMF0uYXJncy5saXN0aW5nSWQsXG4gICAgICByZWNlaXB0XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdXlvdXQgQXVjdGlvblxuICAgKlxuICAgKiBAcmVtYXJrcyBCdXkgYSBzcGVjaWZpYyBkaXJlY3QgbGlzdGluZyBmcm9tIHRoZSBtYXJrZXRwbGFjZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBUaGUgbGlzdGluZyBJRCBvZiB0aGUgYXNzZXQgeW91IHdhbnQgdG8gYnV5XG4gICAqIGNvbnN0IGxpc3RpbmdJZCA9IDA7XG4gICAqXG4gICAqIGF3YWl0IGNvbnRyYWN0LmF1Y3Rpb24uYnV5b3V0TGlzdGluZyhsaXN0aW5nSWQpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGJ1eW91dExpc3RpbmcobGlzdGluZ0lkKSB7XG4gICAgY29uc3QgbGlzdGluZyA9IGF3YWl0IHRoaXMudmFsaWRhdGVMaXN0aW5nKEJpZ051bWJlci5mcm9tKGxpc3RpbmdJZCkpO1xuICAgIGNvbnN0IGN1cnJlbmN5TWV0YWRhdGEgPSBhd2FpdCBmZXRjaEN1cnJlbmN5TWV0YWRhdGEodGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJvdmlkZXIoKSwgbGlzdGluZy5jdXJyZW5jeUNvbnRyYWN0QWRkcmVzcyk7XG4gICAgcmV0dXJuIHRoaXMubWFrZUJpZChsaXN0aW5nSWQsIGV0aGVycy51dGlscy5mb3JtYXRVbml0cyhsaXN0aW5nLmJ1eW91dFByaWNlLCBjdXJyZW5jeU1ldGFkYXRhLmRlY2ltYWxzKSk7XG4gIH1cblxuICAvKipcbiAgICogQmlkIE9uIEF1Y3Rpb25cbiAgICpcbiAgICogQHJlbWFya3MgTWFrZSBhIGJpZCBvbiBhbiBhdWN0aW9uIGxpc3RpbmdcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBUaGUgbGlzdGluZyBJRCBvZiB0aGUgYXNzZXQgeW91IHdhbnQgdG8gYmlkIG9uXG4gICAqIGNvbnN0IGxpc3RpbmdJZCA9IDA7XG4gICAqIC8vIFRoZSBwcmljZSB5b3UgYXJlIHdpbGxpbmcgdG8gYmlkIGZvciBhIHNpbmdsZSB0b2tlbiBvZiB0aGUgbGlzdGluZ1xuICAgKiBjb25zdCBwcmljZVBlclRva2VuID0gMTtcbiAgICpcbiAgICogYXdhaXQgY29udHJhY3QuYXVjdGlvbi5tYWtlQmlkKGxpc3RpbmdJZCwgcHJpY2VQZXJUb2tlbik7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgbWFrZUJpZChsaXN0aW5nSWQsIHByaWNlUGVyVG9rZW4pIHtcbiAgICBjb25zdCBsaXN0aW5nID0gYXdhaXQgdGhpcy52YWxpZGF0ZUxpc3RpbmcoQmlnTnVtYmVyLmZyb20obGlzdGluZ0lkKSk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFByaWNlID0gYXdhaXQgbm9ybWFsaXplUHJpY2VWYWx1ZSh0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRQcm92aWRlcigpLCBwcmljZVBlclRva2VuLCBsaXN0aW5nLmN1cnJlbmN5Q29udHJhY3RBZGRyZXNzKTtcbiAgICBpZiAobm9ybWFsaXplZFByaWNlLmVxKEJpZ051bWJlci5mcm9tKDApKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1ha2UgYSBiaWQgd2l0aCAwIHZhbHVlXCIpO1xuICAgIH1cbiAgICBjb25zdCBiaWRCdWZmZXIgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuYmlkQnVmZmVyQnBzKCk7XG4gICAgY29uc3Qgd2lubmluZ0JpZCA9IGF3YWl0IHRoaXMuZ2V0V2lubmluZ0JpZChsaXN0aW5nSWQpO1xuICAgIGlmICh3aW5uaW5nQmlkKSB7XG4gICAgICBjb25zdCBpc1dpbm5uZXIgPSBpc1dpbm5pbmdCaWQod2lubmluZ0JpZC5wcmljZVBlclRva2VuLCBub3JtYWxpemVkUHJpY2UsIGJpZEJ1ZmZlcik7XG4gICAgICBpbnZhcmlhbnQoaXNXaW5ubmVyLCBcIkJpZCBwcmljZSBpcyB0b28gbG93IGJhc2VkIG9uIHRoZSBjdXJyZW50IHdpbm5pbmcgYmlkIGFuZCB0aGUgYmlkIGJ1ZmZlclwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdG9rZW5QcmljZSA9IG5vcm1hbGl6ZWRQcmljZTtcbiAgICAgIGNvbnN0IHJlc2VydmVQcmljZSA9IEJpZ051bWJlci5mcm9tKGxpc3RpbmcucmVzZXJ2ZVByaWNlKTtcbiAgICAgIGludmFyaWFudCh0b2tlblByaWNlLmd0ZShyZXNlcnZlUHJpY2UpLCBcIkJpZCBwcmljZSBpcyB0b28gbG93IGJhc2VkIG9uIHJlc2VydmUgcHJpY2VcIik7XG4gICAgfVxuICAgIGNvbnN0IHF1YW50aXR5ID0gQmlnTnVtYmVyLmZyb20obGlzdGluZy5xdWFudGl0eSk7XG4gICAgY29uc3QgdmFsdWUgPSBub3JtYWxpemVkUHJpY2UubXVsKHF1YW50aXR5KTtcbiAgICBjb25zdCBvdmVycmlkZXMgPSAoYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0Q2FsbE92ZXJyaWRlcygpKSB8fCB7fTtcbiAgICBhd2FpdCBzZXRFcmMyMEFsbG93YW5jZSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgdmFsdWUsIGxpc3RpbmcuY3VycmVuY3lDb250cmFjdEFkZHJlc3MsIG92ZXJyaWRlcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNlbmRUcmFuc2FjdGlvbihcIm9mZmVyXCIsIFtsaXN0aW5nSWQsIGxpc3RpbmcucXVhbnRpdHksIGxpc3RpbmcuY3VycmVuY3lDb250cmFjdEFkZHJlc3MsIG5vcm1hbGl6ZWRQcmljZSwgZXRoZXJzLmNvbnN0YW50cy5NYXhVaW50MjU2XSwgb3ZlcnJpZGVzKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIEF1Y3Rpb24gTGlzdGluZ1xuICAgKlxuICAgKiBAcmVtYXJrcyBDYW5jZWwgYW4gYXVjdGlvbiBsaXN0aW5nIG9uIHRoZSBtYXJrZXRwbGFjZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIFRoZSBsaXN0aW5nIElEIG9mIHRoZSBhdWN0aW9uIGxpc3RpbmcgeW91IHdhbnQgdG8gY2FuY2VsXG4gICAqIGNvbnN0IGxpc3RpbmdJZCA9IFwiMFwiO1xuICAgKlxuICAgKiBhd2FpdCBjb250cmFjdC5hdWN0aW9uLmNhbmNlbExpc3RpbmcobGlzdGluZ0lkKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBjYW5jZWxMaXN0aW5nKGxpc3RpbmdJZCkge1xuICAgIGNvbnN0IGxpc3RpbmcgPSBhd2FpdCB0aGlzLnZhbGlkYXRlTGlzdGluZyhCaWdOdW1iZXIuZnJvbShsaXN0aW5nSWQpKTtcbiAgICBjb25zdCBub3cgPSBCaWdOdW1iZXIuZnJvbShNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSk7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gQmlnTnVtYmVyLmZyb20obGlzdGluZy5zdGFydFRpbWVJbkVwb2NoU2Vjb25kcyk7XG4gICAgY29uc3Qgb2ZmZXJzID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0Lndpbm5pbmdCaWQobGlzdGluZ0lkKTtcbiAgICBpZiAobm93Lmd0KHN0YXJ0VGltZSkgJiYgb2ZmZXJzLm9mZmVyb3IgIT09IGNvbnN0YW50cy5BZGRyZXNzWmVybykge1xuICAgICAgdGhyb3cgbmV3IEF1Y3Rpb25BbHJlYWR5U3RhcnRlZEVycm9yKGxpc3RpbmdJZC50b1N0cmluZygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnNlbmRUcmFuc2FjdGlvbihcImNsb3NlQXVjdGlvblwiLCBbQmlnTnVtYmVyLmZyb20obGlzdGluZ0lkKSwgYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0U2lnbmVyQWRkcmVzcygpXSlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlIHRoZSBBdWN0aW9uIGZvciB0aGUgYnV5ZXIgb3IgdGhlIHNlbGxlclxuICAgKlxuICAgKiBAcmVtYXJrcyBDbG9zZXMgdGhlIEF1Y3Rpb24gYW5kIGV4ZWN1dGVzIHRoZSBzYWxlIGZvciB0aGUgYnV5ZXIgb3IgdGhlIHNlbGxlci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBUaGUgbGlzdGluZyBJRCBvZiB0aGUgYXVjdGlvbiBsaXN0aW5nIHlvdSB3YW50IHRvIGNsb3NlXG4gICAqIGNvbnN0IGxpc3RpbmdJZCA9IFwiMFwiO1xuICAgKiBhd2FpdCBjb250cmFjdC5hdWN0aW9uLmNsb3NlTGlzdGluZyhsaXN0aW5nSWQpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGxpc3RpbmdJZCAtIHRoZSBhdWN0aW9uICBsaXN0aW5nIHVkIHRvIGNsb3NlXG4gICAqIEBwYXJhbSBjbG9zZUZvciAtIG9wdGlvbmFsbHkgcGFzcyB0aGUgYXVjdGlvbiBjcmVhdG9yIGFkZHJlc3Mgb3Igd2lubmluZyBiaWQgb2ZmZXJvciBhZGRyZXNzIHRvIGNsb3NlIHRoZSBhdWN0aW9uIG9uIHRoZWlyIGJlaGFsZlxuICAgKi9cbiAgYXN5bmMgY2xvc2VMaXN0aW5nKGxpc3RpbmdJZCwgY2xvc2VGb3IpIHtcbiAgICBpZiAoIWNsb3NlRm9yKSB7XG4gICAgICBjbG9zZUZvciA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFNpZ25lckFkZHJlc3MoKTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGluZyA9IGF3YWl0IHRoaXMudmFsaWRhdGVMaXN0aW5nKEJpZ051bWJlci5mcm9tKGxpc3RpbmdJZCkpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWNlaXB0OiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJjbG9zZUF1Y3Rpb25cIiwgW0JpZ051bWJlci5mcm9tKGxpc3RpbmdJZCksIGNsb3NlRm9yXSlcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJjYW5ub3QgY2xvc2UgYXVjdGlvbiBiZWZvcmUgaXQgaGFzIGVuZGVkXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBBdWN0aW9uSGFzTm90RW5kZWRFcnJvcihsaXN0aW5nSWQudG9TdHJpbmcoKSwgbGlzdGluZy5lbmRUaW1lSW5FcG9jaFNlY29uZHMudG9TdHJpbmcoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgdGhlIEF1Y3Rpb24gU2FsZVxuICAgKlxuICAgKiBAcmVtYXJrcyBDbG9zZXMgdGhlIEF1Y3Rpb24gYW5kIGV4ZWN1dGVzIHRoZSBzYWxlIGZvciBib3RoIHBhcnRpZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gVGhlIGxpc3RpbmcgSUQgb2YgdGhlIGF1Y3Rpb24gbGlzdGluZyB5b3Ugd2FudCB0byBjbG9zZVxuICAgKiBjb25zdCBsaXN0aW5nSWQgPSBcIjBcIjtcbiAgICogYXdhaXQgY29udHJhY3QuYXVjdGlvbi5leGVjdXRlU2FsZShsaXN0aW5nSWQpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGxpc3RpbmdJZCAtIHRoZSBhdWN0aW9uICBsaXN0aW5nIHVkIHRvIGNsb3NlXG4gICAqL1xuICBhc3luYyBleGVjdXRlU2FsZShsaXN0aW5nSWQpIHtcbiAgICBjb25zdCBsaXN0aW5nID0gYXdhaXQgdGhpcy52YWxpZGF0ZUxpc3RpbmcoQmlnTnVtYmVyLmZyb20obGlzdGluZ0lkKSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHdpbm5pbmdCaWQgPSBhd2FpdCB0aGlzLmdldFdpbm5pbmdCaWQobGlzdGluZ0lkKTtcbiAgICAgIGludmFyaWFudCh3aW5uaW5nQmlkLCBcIk5vIHdpbm5pbmcgYmlkIGZvdW5kXCIpO1xuICAgICAgY29uc3QgY2xvc2VGb3JTZWxsZXIgPSB0aGlzLmVuY29kZXIuZW5jb2RlKFwiY2xvc2VBdWN0aW9uXCIsIFtsaXN0aW5nSWQsIGxpc3Rpbmcuc2VsbGVyQWRkcmVzc10pO1xuICAgICAgY29uc3QgY2xvc2VGb3JCdXllciA9IHRoaXMuZW5jb2Rlci5lbmNvZGUoXCJjbG9zZUF1Y3Rpb25cIiwgW2xpc3RpbmdJZCwgd2lubmluZ0JpZC5idXllckFkZHJlc3NdKTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5tdWx0aUNhbGwoW2Nsb3NlRm9yU2VsbGVyLCBjbG9zZUZvckJ1eWVyXSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJjYW5ub3QgY2xvc2UgYXVjdGlvbiBiZWZvcmUgaXQgaGFzIGVuZGVkXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBBdWN0aW9uSGFzTm90RW5kZWRFcnJvcihsaXN0aW5nSWQudG9TdHJpbmcoKSwgbGlzdGluZy5lbmRUaW1lSW5FcG9jaFNlY29uZHMudG9TdHJpbmcoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhbiBBdWN0aW9uIGxpc3Rpbmcgd2l0aCBuZXcgbWV0YWRhdGFcbiAgICogQHBhcmFtIGxpc3RpbmcgLSB0aGUgbGlzdGluZyBpZCB0byB1cGRhdGVcbiAgICovXG4gIGFzeW5jIHVwZGF0ZUxpc3RpbmcobGlzdGluZykge1xuICAgIHJldHVybiB7XG4gICAgICByZWNlaXB0OiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJ1cGRhdGVMaXN0aW5nXCIsIFtsaXN0aW5nLmlkLCBsaXN0aW5nLnF1YW50aXR5LCBsaXN0aW5nLnJlc2VydmVQcmljZSwgbGlzdGluZy5idXlvdXRQcmljZSwgbGlzdGluZy5jdXJyZW5jeUNvbnRyYWN0QWRkcmVzcywgbGlzdGluZy5zdGFydFRpbWVJbkVwb2NoU2Vjb25kcywgbGlzdGluZy5lbmRUaW1lSW5FcG9jaFNlY29uZHNdKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBidWZmZXIgaW4gYmFzaXMgcG9pbnRzIGJldHdlZW4gb2ZmZXJzXG4gICAqL1xuICBhc3luYyBnZXRCaWRCdWZmZXJCcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5iaWRCdWZmZXJCcHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSBtaW5pbXVtIGJpZCBhIHVzZXIgY2FuIHBsYWNlIHRvIG91dGJpZCB0aGUgcHJldmlvdXMgaGlnaGVzdCBiaWRcbiAgICogQHBhcmFtIGxpc3RpbmdJZCAtIHRoZSBsaXN0aW5nIGlkIG9mIHRoZSBhdWN0aW9uXG4gICAqL1xuICBhc3luYyBnZXRNaW5pbXVtTmV4dEJpZChsaXN0aW5nSWQpIHtcbiAgICAvLyB3ZSBjYW4gZmV0Y2ggYWxsIG9mIHRoZXNlIGF0IHRoZSBzYW1lIHRpbWUgdXNpbmcgcHJvbWlzZS5hbGxcbiAgICBjb25zdCBbY3VycmVudEJpZEJ1ZmZlckJwcywgd2lubmluZ0JpZCwgbGlzdGluZ10gPSBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5nZXRCaWRCdWZmZXJCcHMoKSwgdGhpcy5nZXRXaW5uaW5nQmlkKGxpc3RpbmdJZCksIGF3YWl0IHRoaXMudmFsaWRhdGVMaXN0aW5nKEJpZ051bWJlci5mcm9tKGxpc3RpbmdJZCkpXSk7XG4gICAgY29uc3QgY3VycmVudEJpZE9yUmVzZXJ2ZVByaWNlID0gd2lubmluZ0JpZCA/XG4gICAgLy8gaWYgdGhlcmUgaXMgYSB3aW5uaW5nIGJpZCB1c2UgdGhlIHZhbHVlIG9mIGl0XG4gICAgd2lubmluZ0JpZC5jdXJyZW5jeVZhbHVlLnZhbHVlIDpcbiAgICAvLyBpZiB0aGVyZSBpcyBubyB3aW5uaW5nIGJpZCB1c2UgdGhlIHJlc2VydmUgcHJpY2VcbiAgICBsaXN0aW5nLnJlc2VydmVQcmljZTtcbiAgICBjb25zdCBtaW5pbXVtTmV4dEJpZCA9IGN1cnJlbnRCaWRPclJlc2VydmVQcmljZS5hZGQoXG4gICAgLy8gdGhlIGFkZGl0aW9uIG9mIHRoZSBjdXJyZW50IGJpZCBhbmQgdGhlIGJ1ZmZlclxuICAgIC8vIChoYXZlIHRvIGRpdmlkZSBieSAxMDAwMCB0byBnZXQgdGhlIGZyYWN0aW9uIG9mIHRoZSBidWZmZXIgKHNpbmNlIGl0J3MgaW4gYmFzaXMgcG9pbnRzKSlcbiAgICBjdXJyZW50QmlkT3JSZXNlcnZlUHJpY2UubXVsKGN1cnJlbnRCaWRCdWZmZXJCcHMpLmRpdigxMDAwMCkpO1xuXG4gICAgLy8gaXQncyBtb3JlIHVzZWZ1bCB0byByZXR1cm4gYSBjdXJyZW5jeSB2YWx1ZSBoZXJlXG4gICAgcmV0dXJuIGZldGNoQ3VycmVuY3lWYWx1ZSh0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRQcm92aWRlcigpLCBsaXN0aW5nLmN1cnJlbmN5Q29udHJhY3RBZGRyZXNzLCBtaW5pbXVtTmV4dEJpZCk7XG4gIH1cblxuICAvKiogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIFBSSVZBVEUgRlVOQ1RJT05TXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiBUaHJvd3MgZXJyb3IgaWYgbGlzdGluZyBjb3VsZCBub3QgYmUgZm91bmRcbiAgICpcbiAgICogQHBhcmFtIGxpc3RpbmdJZCAtIExpc3RpbmcgdG8gY2hlY2sgZm9yXG4gICAqL1xuICBhc3luYyB2YWxpZGF0ZUxpc3RpbmcobGlzdGluZ0lkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldExpc3RpbmcobGlzdGluZ0lkKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGdldHRpbmcgdGhlIGxpc3Rpbmcgd2l0aCBpZCAke2xpc3RpbmdJZH1gKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCBtYXBzIHRoZSBhdWN0aW9uIGxpc3RpbmcgdG8gdGhlIGF1Y3Rpb24gbGlzdGluZyBpbnRlcmZhY2UuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0gbGlzdGluZyAtIFRoZSBsaXN0aW5nIHRvIG1hcCwgYXMgcmV0dXJuZWQgZnJvbSB0aGUgY29udHJhY3QuXG4gICAqIEByZXR1cm5zIC0gVGhlIG1hcHBlZCBpbnRlcmZhY2UuXG4gICAqL1xuICBhc3luYyBtYXBMaXN0aW5nKGxpc3RpbmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYXNzZXRDb250cmFjdEFkZHJlc3M6IGxpc3RpbmcuYXNzZXRDb250cmFjdCxcbiAgICAgIGJ1eW91dFByaWNlOiBCaWdOdW1iZXIuZnJvbShsaXN0aW5nLmJ1eW91dFByaWNlUGVyVG9rZW4pLFxuICAgICAgY3VycmVuY3lDb250cmFjdEFkZHJlc3M6IGxpc3RpbmcuY3VycmVuY3ksXG4gICAgICBidXlvdXRDdXJyZW5jeVZhbHVlUGVyVG9rZW46IGF3YWl0IGZldGNoQ3VycmVuY3lWYWx1ZSh0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRQcm92aWRlcigpLCBsaXN0aW5nLmN1cnJlbmN5LCBsaXN0aW5nLmJ1eW91dFByaWNlUGVyVG9rZW4pLFxuICAgICAgaWQ6IGxpc3RpbmcubGlzdGluZ0lkLnRvU3RyaW5nKCksXG4gICAgICB0b2tlbklkOiBsaXN0aW5nLnRva2VuSWQsXG4gICAgICBxdWFudGl0eTogbGlzdGluZy5xdWFudGl0eSxcbiAgICAgIHN0YXJ0VGltZUluRXBvY2hTZWNvbmRzOiBsaXN0aW5nLnN0YXJ0VGltZSxcbiAgICAgIGFzc2V0OiBhd2FpdCBmZXRjaFRva2VuTWV0YWRhdGFGb3JDb250cmFjdChsaXN0aW5nLmFzc2V0Q29udHJhY3QsIHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFByb3ZpZGVyKCksIGxpc3RpbmcudG9rZW5JZCwgdGhpcy5zdG9yYWdlKSxcbiAgICAgIHJlc2VydmVQcmljZUN1cnJlbmN5VmFsdWVQZXJUb2tlbjogYXdhaXQgZmV0Y2hDdXJyZW5jeVZhbHVlKHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFByb3ZpZGVyKCksIGxpc3RpbmcuY3VycmVuY3ksIGxpc3RpbmcucmVzZXJ2ZVByaWNlUGVyVG9rZW4pLFxuICAgICAgcmVzZXJ2ZVByaWNlOiBCaWdOdW1iZXIuZnJvbShsaXN0aW5nLnJlc2VydmVQcmljZVBlclRva2VuKSxcbiAgICAgIGVuZFRpbWVJbkVwb2NoU2Vjb25kczogbGlzdGluZy5lbmRUaW1lLFxuICAgICAgc2VsbGVyQWRkcmVzczogbGlzdGluZy50b2tlbk93bmVyLFxuICAgICAgdHlwZTogTGlzdGluZ1R5cGUuQXVjdGlvblxuICAgIH07XG4gIH1cbn1cblxuY29uc3QgRHJvcEVyYzIwQ29udHJhY3RJbnB1dCA9IENvbW1vbkNvbnRyYWN0U2NoZW1hLm1lcmdlKE1lcmtsZVNjaGVtYSkubWVyZ2UoQ29tbW9uU3ltYm9sU2NoZW1hKTtcbmNvbnN0IERyb3BFcmMyMENvbnRyYWN0T3V0cHV0ID0gQ29tbW9uQ29udHJhY3RPdXRwdXRTY2hlbWEubWVyZ2UoTWVya2xlU2NoZW1hKS5tZXJnZShDb21tb25TeW1ib2xTY2hlbWEpO1xuY29uc3QgRHJvcEVyYzIwQ29udHJhY3REZXBsb3kgPSBEcm9wRXJjMjBDb250cmFjdElucHV0Lm1lcmdlKENvbW1vblBsYXRmb3JtRmVlU2NoZW1hKS5tZXJnZShDb21tb25QcmltYXJ5U2FsZVNjaGVtYSkubWVyZ2UoQ29tbW9uVHJ1c3RlZEZvcndhcmRlclNjaGVtYSk7XG5jb25zdCBEcm9wRXJjMjBDb250cmFjdFNjaGVtYSA9IHtcbiAgZGVwbG95OiBEcm9wRXJjMjBDb250cmFjdERlcGxveSxcbiAgb3V0cHV0OiBEcm9wRXJjMjBDb250cmFjdE91dHB1dCxcbiAgaW5wdXQ6IERyb3BFcmMyMENvbnRyYWN0SW5wdXRcbn07XG5cbmNvbnN0IE11bHRpd3JhcENvbnRyYWN0SW5wdXQgPSBDb21tb25Db250cmFjdFNjaGVtYS5tZXJnZShDb21tb25Sb3lhbHR5U2NoZW1hKS5tZXJnZShDb21tb25TeW1ib2xTY2hlbWEpO1xuY29uc3QgTXVsdGl3cmFwQ29udHJhY3RPdXRwdXQgPSBDb21tb25Db250cmFjdE91dHB1dFNjaGVtYS5tZXJnZShDb21tb25Sb3lhbHR5U2NoZW1hKS5tZXJnZShDb21tb25TeW1ib2xTY2hlbWEpO1xuY29uc3QgTXVsdGl3cmFwQ29udHJhY3REZXBsb3kgPSBNdWx0aXdyYXBDb250cmFjdElucHV0Lm1lcmdlKENvbW1vblRydXN0ZWRGb3J3YXJkZXJTY2hlbWEpO1xuY29uc3QgTXVsdGl3cmFwQ29udHJhY3RTY2hlbWEgPSB7XG4gIGRlcGxveTogTXVsdGl3cmFwQ29udHJhY3REZXBsb3ksXG4gIG91dHB1dDogTXVsdGl3cmFwQ29udHJhY3RPdXRwdXQsXG4gIGlucHV0OiBNdWx0aXdyYXBDb250cmFjdElucHV0XG59O1xuXG5jb25zdCBFZGl0aW9uRHJvcEluaXRpYWxpemVyID0ge1xuICBuYW1lOiBcIkRyb3BFUkMxMTU1XCIsXG4gIGNvbnRyYWN0VHlwZTogXCJlZGl0aW9uLWRyb3BcIixcbiAgc2NoZW1hOiBEcm9wRXJjMTE1NUNvbnRyYWN0U2NoZW1hLFxuICByb2xlczogW1wiYWRtaW5cIiwgXCJtaW50ZXJcIiwgXCJ0cmFuc2ZlclwiXSxcbiAgaW5pdGlhbGl6ZTogYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBfcmVmID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgX3JlZltfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgbGV0IFtuZXR3b3JrLCBhZGRyZXNzLCBzdG9yYWdlLCBvcHRpb25zXSA9IF9yZWY7XG4gICAgY29uc3QgWywgcHJvdmlkZXJdID0gZ2V0U2lnbmVyQW5kUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgY29uc3QgW2FiaSwgY29udHJhY3QsIF9uZXR3b3JrXSA9IGF3YWl0IFByb21pc2UuYWxsKFthd2FpdCBFZGl0aW9uRHJvcEluaXRpYWxpemVyLmdldEFiaShhZGRyZXNzLCBwcm92aWRlciksIGltcG9ydCgnLi9lZGl0aW9uLWRyb3AtZmQxNGZlMGUuZXNtLmpzJyksIHByb3ZpZGVyLmdldE5ldHdvcmsoKV0pO1xuICAgIHJldHVybiBuZXcgY29udHJhY3QuRWRpdGlvbkRyb3AobmV0d29yaywgYWRkcmVzcywgc3RvcmFnZSwgb3B0aW9ucywgYWJpLCBfbmV0d29yay5jaGFpbklkKTtcbiAgfSxcbiAgZ2V0QWJpOiBhc3luYyAoYWRkcmVzcywgcHJvdmlkZXIpID0+IHtcbiAgICBjb25zdCBjb250cmFjdEluZm8gPSBhd2FpdCBhc3NlcnRDb250cmFjdFR5cGUoYWRkcmVzcywgcHJvdmlkZXIsIFwiZWRpdGlvbi1kcm9wXCIpO1xuICAgIHJldHVybiBjb250cmFjdEluZm8udmVyc2lvbiA+IDIgPyAoYXdhaXQgaW1wb3J0KCdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvRHJvcEVSQzExNTUuanNvbicpKS5kZWZhdWx0IDogKGF3YWl0IGltcG9ydCgnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0Ryb3BFUkMxMTU1X1YyLmpzb24nKSkuZGVmYXVsdDtcbiAgfVxufTtcbmNvbnN0IEVkaXRpb25Jbml0aWFsaXplciA9IHtcbiAgbmFtZTogXCJUb2tlbkVSQzExNTVcIixcbiAgY29udHJhY3RUeXBlOiBcImVkaXRpb25cIixcbiAgc2NoZW1hOiBUb2tlbkVyYzExNTVDb250cmFjdFNjaGVtYSxcbiAgcm9sZXM6IFtcImFkbWluXCIsIFwibWludGVyXCIsIFwidHJhbnNmZXJcIl0sXG4gIGluaXRpYWxpemU6IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIF9yZWYyID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBfcmVmMltfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICBsZXQgW25ldHdvcmssIGFkZHJlc3MsIHN0b3JhZ2UsIG9wdGlvbnNdID0gX3JlZjI7XG4gICAgY29uc3QgWywgcHJvdmlkZXJdID0gZ2V0U2lnbmVyQW5kUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgY29uc3QgW2FiaSwgY29udHJhY3QsIF9uZXR3b3JrXSA9IGF3YWl0IFByb21pc2UuYWxsKFtFZGl0aW9uSW5pdGlhbGl6ZXIuZ2V0QWJpKGFkZHJlc3MsIHByb3ZpZGVyKSwgaW1wb3J0KCcuL2VkaXRpb24tZjNmNDNjZWUuZXNtLmpzJyksIHByb3ZpZGVyLmdldE5ldHdvcmsoKV0pO1xuICAgIHJldHVybiBuZXcgY29udHJhY3QuRWRpdGlvbihuZXR3b3JrLCBhZGRyZXNzLCBzdG9yYWdlLCBvcHRpb25zLCBhYmksIF9uZXR3b3JrLmNoYWluSWQpO1xuICB9LFxuICBnZXRBYmk6IGFzeW5jIChhZGRyZXNzLCBwcm92aWRlcikgPT4ge1xuICAgIGF3YWl0IGFzc2VydENvbnRyYWN0VHlwZShhZGRyZXNzLCBwcm92aWRlciwgXCJlZGl0aW9uXCIpO1xuICAgIHJldHVybiAoYXdhaXQgaW1wb3J0KCdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvVG9rZW5FUkMxMTU1Lmpzb24nKSkuZGVmYXVsdDtcbiAgfVxufTtcbmNvbnN0IE1hcmtldHBsYWNlSW5pdGlhbGl6ZXIgPSB7XG4gIG5hbWU6IFwiTWFya2V0cGxhY2VcIixcbiAgY29udHJhY3RUeXBlOiBcIm1hcmtldHBsYWNlXCIsXG4gIHNjaGVtYTogTWFya2V0cGxhY2VDb250cmFjdFNjaGVtYSxcbiAgcm9sZXM6IFtcImFkbWluXCIsIFwibGlzdGVyXCIsIFwiYXNzZXRcIl0sXG4gIGluaXRpYWxpemU6IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIF9yZWYzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICBfcmVmM1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cbiAgICBsZXQgW25ldHdvcmssIGFkZHJlc3MsIHN0b3JhZ2UsIG9wdGlvbnNdID0gX3JlZjM7XG4gICAgY29uc3QgWywgcHJvdmlkZXJdID0gZ2V0U2lnbmVyQW5kUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgY29uc3QgW2FiaSwgY29udHJhY3QsIF9uZXR3b3JrXSA9IGF3YWl0IFByb21pc2UuYWxsKFtNYXJrZXRwbGFjZUluaXRpYWxpemVyLmdldEFiaShhZGRyZXNzLCBwcm92aWRlciksIGltcG9ydCgnLi9tYXJrZXRwbGFjZS05YmY3YTAyNy5lc20uanMnKSwgcHJvdmlkZXIuZ2V0TmV0d29yaygpXSk7XG4gICAgcmV0dXJuIG5ldyBjb250cmFjdC5NYXJrZXRwbGFjZShuZXR3b3JrLCBhZGRyZXNzLCBzdG9yYWdlLCBvcHRpb25zLCBhYmksIF9uZXR3b3JrLmNoYWluSWQpO1xuICB9LFxuICBnZXRBYmk6IGFzeW5jIChhZGRyZXNzLCBwcm92aWRlcikgPT4ge1xuICAgIGF3YWl0IGFzc2VydENvbnRyYWN0VHlwZShhZGRyZXNzLCBwcm92aWRlciwgXCJtYXJrZXRwbGFjZVwiKTtcbiAgICByZXR1cm4gKGF3YWl0IGltcG9ydCgnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL01hcmtldHBsYWNlLmpzb24nKSkuZGVmYXVsdDtcbiAgfVxufTtcbmNvbnN0IE11bHRpd3JhcEluaXRpYWxpemVyID0ge1xuICBuYW1lOiBcIk11bHRpd3JhcFwiLFxuICBjb250cmFjdFR5cGU6IFwibXVsdGl3cmFwXCIsXG4gIHNjaGVtYTogTXVsdGl3cmFwQ29udHJhY3RTY2hlbWEsXG4gIHJvbGVzOiBbXCJhZG1pblwiLCBcInRyYW5zZmVyXCIsIFwibWludGVyXCIsIFwidW53cmFwXCIsIFwiYXNzZXRcIl0sXG4gIGluaXRpYWxpemU6IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIF9yZWY0ID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICBfcmVmNFtfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgIH1cbiAgICBsZXQgW25ldHdvcmssIGFkZHJlc3MsIHN0b3JhZ2UsIG9wdGlvbnNdID0gX3JlZjQ7XG4gICAgY29uc3QgWywgcHJvdmlkZXJdID0gZ2V0U2lnbmVyQW5kUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgY29uc3QgW2FiaSwgY29udHJhY3QsIF9uZXR3b3JrXSA9IGF3YWl0IFByb21pc2UuYWxsKFtNdWx0aXdyYXBJbml0aWFsaXplci5nZXRBYmkoYWRkcmVzcywgcHJvdmlkZXIpLCBpbXBvcnQoJy4vbXVsdGl3cmFwLTk2Y2NmZDZiLmVzbS5qcycpLCBwcm92aWRlci5nZXROZXR3b3JrKCldKTtcbiAgICByZXR1cm4gbmV3IGNvbnRyYWN0Lk11bHRpd3JhcChuZXR3b3JrLCBhZGRyZXNzLCBzdG9yYWdlLCBvcHRpb25zLCBhYmksIF9uZXR3b3JrLmNoYWluSWQpO1xuICB9LFxuICBnZXRBYmk6IGFzeW5jIChhZGRyZXNzLCBwcm92aWRlcikgPT4ge1xuICAgIGF3YWl0IGFzc2VydENvbnRyYWN0VHlwZShhZGRyZXNzLCBwcm92aWRlciwgXCJtdWx0aXdyYXBcIik7XG4gICAgcmV0dXJuIChhd2FpdCBpbXBvcnQoJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9NdWx0aXdyYXAuanNvbicpKS5kZWZhdWx0O1xuICB9XG59O1xuY29uc3QgTkZUQ29sbGVjdGlvbkluaXRpYWxpemVyID0ge1xuICBuYW1lOiBcIlRva2VuRVJDNzIxXCIsXG4gIGNvbnRyYWN0VHlwZTogXCJuZnQtY29sbGVjdGlvblwiLFxuICBzY2hlbWE6IFRva2VuRXJjNzIxQ29udHJhY3RTY2hlbWEsXG4gIHJvbGVzOiBbXCJhZG1pblwiLCBcIm1pbnRlclwiLCBcInRyYW5zZmVyXCJdLFxuICBpbml0aWFsaXplOiBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBfcmVmNSA9IG5ldyBBcnJheShfbGVuNSksIF9rZXk1ID0gMDsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgICAgX3JlZjVbX2tleTVdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgICB9XG4gICAgbGV0IFtuZXR3b3JrLCBhZGRyZXNzLCBzdG9yYWdlLCBvcHRpb25zXSA9IF9yZWY1O1xuICAgIGNvbnN0IFssIHByb3ZpZGVyXSA9IGdldFNpZ25lckFuZFByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgIGNvbnN0IFthYmksIGNvbnRyYWN0LCBfbmV0d29ya10gPSBhd2FpdCBQcm9taXNlLmFsbChbTkZUQ29sbGVjdGlvbkluaXRpYWxpemVyLmdldEFiaShhZGRyZXNzLCBwcm92aWRlciksIGltcG9ydCgnLi9uZnQtY29sbGVjdGlvbi1hZDdiY2NkNy5lc20uanMnKSwgcHJvdmlkZXIuZ2V0TmV0d29yaygpXSk7XG4gICAgcmV0dXJuIG5ldyBjb250cmFjdC5ORlRDb2xsZWN0aW9uKG5ldHdvcmssIGFkZHJlc3MsIHN0b3JhZ2UsIG9wdGlvbnMsIGFiaSwgX25ldHdvcmsuY2hhaW5JZCk7XG4gIH0sXG4gIGdldEFiaTogYXN5bmMgKGFkZHJlc3MsIHByb3ZpZGVyKSA9PiB7XG4gICAgYXdhaXQgYXNzZXJ0Q29udHJhY3RUeXBlKGFkZHJlc3MsIHByb3ZpZGVyLCBcIm5mdC1jb2xsZWN0aW9uXCIpO1xuICAgIHJldHVybiAoYXdhaXQgaW1wb3J0KCdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvVG9rZW5FUkM3MjEuanNvbicpKS5kZWZhdWx0O1xuICB9XG59O1xuY29uc3QgTkZURHJvcEluaXRpYWxpemVyID0ge1xuICBuYW1lOiBcIkRyb3BFUkM3MjFcIixcbiAgY29udHJhY3RUeXBlOiBcIm5mdC1kcm9wXCIsXG4gIHNjaGVtYTogRHJvcEVyYzcyMUNvbnRyYWN0U2NoZW1hLFxuICByb2xlczogW1wiYWRtaW5cIiwgXCJtaW50ZXJcIiwgXCJ0cmFuc2ZlclwiXSxcbiAgaW5pdGlhbGl6ZTogYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgX3JlZjYgPSBuZXcgQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICAgIF9yZWY2W19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gICAgfVxuICAgIGxldCBbbmV0d29yaywgYWRkcmVzcywgc3RvcmFnZSwgb3B0aW9uc10gPSBfcmVmNjtcbiAgICBjb25zdCBbLCBwcm92aWRlcl0gPSBnZXRTaWduZXJBbmRQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICBjb25zdCBbYWJpLCBjb250cmFjdCwgX25ldHdvcmtdID0gYXdhaXQgUHJvbWlzZS5hbGwoW05GVERyb3BJbml0aWFsaXplci5nZXRBYmkoYWRkcmVzcywgcHJvdmlkZXIpLCBpbXBvcnQoJy4vbmZ0LWRyb3AtMzdmNmJhM2EuZXNtLmpzJyksIHByb3ZpZGVyLmdldE5ldHdvcmsoKV0pO1xuICAgIHJldHVybiBuZXcgY29udHJhY3QuTkZURHJvcChuZXR3b3JrLCBhZGRyZXNzLCBzdG9yYWdlLCBvcHRpb25zLCBhYmksIF9uZXR3b3JrLmNoYWluSWQpO1xuICB9LFxuICBnZXRBYmk6IGFzeW5jIChhZGRyZXNzLCBwcm92aWRlcikgPT4ge1xuICAgIGNvbnN0IGNvbnRyYWN0SW5mbyA9IGF3YWl0IGFzc2VydENvbnRyYWN0VHlwZShhZGRyZXNzLCBwcm92aWRlciwgXCJuZnQtZHJvcFwiKTtcbiAgICByZXR1cm4gY29udHJhY3RJbmZvLnZlcnNpb24gPiAzID8gKGF3YWl0IGltcG9ydCgnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0Ryb3BFUkM3MjEuanNvbicpKS5kZWZhdWx0IDogKGF3YWl0IGltcG9ydCgnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0Ryb3BFUkM3MjFfVjMuanNvbicpKS5kZWZhdWx0O1xuICB9XG59O1xuY29uc3QgUGFja0luaXRpYWxpemVyID0ge1xuICBuYW1lOiBcIlBhY2tcIixcbiAgY29udHJhY3RUeXBlOiBcInBhY2tcIixcbiAgc2NoZW1hOiBQYWNrQ29udHJhY3RTY2hlbWEsXG4gIHJvbGVzOiBbXCJhZG1pblwiLCBcIm1pbnRlclwiLCBcImFzc2V0XCIsIFwidHJhbnNmZXJcIl0sXG4gIGluaXRpYWxpemU6IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuNyA9IGFyZ3VtZW50cy5sZW5ndGgsIF9yZWY3ID0gbmV3IEFycmF5KF9sZW43KSwgX2tleTcgPSAwOyBfa2V5NyA8IF9sZW43OyBfa2V5NysrKSB7XG4gICAgICBfcmVmN1tfa2V5N10gPSBhcmd1bWVudHNbX2tleTddO1xuICAgIH1cbiAgICBsZXQgW25ldHdvcmssIGFkZHJlc3MsIHN0b3JhZ2UsIG9wdGlvbnNdID0gX3JlZjc7XG4gICAgY29uc3QgWywgcHJvdmlkZXJdID0gZ2V0U2lnbmVyQW5kUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgY29uc3QgW2FiaSwgY29udHJhY3QsIF9uZXR3b3JrXSA9IGF3YWl0IFByb21pc2UuYWxsKFtQYWNrSW5pdGlhbGl6ZXIuZ2V0QWJpKGFkZHJlc3MsIHByb3ZpZGVyKSwgaW1wb3J0KCcuL3BhY2stNGMxODdjNTAuZXNtLmpzJyksIHByb3ZpZGVyLmdldE5ldHdvcmsoKV0pO1xuICAgIHJldHVybiBuZXcgY29udHJhY3QuUGFjayhuZXR3b3JrLCBhZGRyZXNzLCBzdG9yYWdlLCBvcHRpb25zLCBhYmksIF9uZXR3b3JrLmNoYWluSWQpO1xuICB9LFxuICBnZXRBYmk6IGFzeW5jIChhZGRyZXNzLCBwcm92aWRlcikgPT4ge1xuICAgIGF3YWl0IGFzc2VydENvbnRyYWN0VHlwZShhZGRyZXNzLCBwcm92aWRlciwgXCJwYWNrXCIpO1xuICAgIHJldHVybiAoYXdhaXQgaW1wb3J0KCdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvUGFjay5qc29uJykpLmRlZmF1bHQ7XG4gIH1cbn07XG5jb25zdCBTaWduYXR1cmVEcm9wSW5pdGlhbGl6ZXIgPSB7XG4gIG5hbWU6IFwiU2lnbmF0dXJlRHJvcFwiLFxuICBjb250cmFjdFR5cGU6IFwic2lnbmF0dXJlLWRyb3BcIixcbiAgc2NoZW1hOiBEcm9wRXJjNzIxQ29udHJhY3RTY2hlbWEsXG4gIHJvbGVzOiBbXCJhZG1pblwiLCBcIm1pbnRlclwiLCBcInRyYW5zZmVyXCJdLFxuICBpbml0aWFsaXplOiBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbjggPSBhcmd1bWVudHMubGVuZ3RoLCBfcmVmOCA9IG5ldyBBcnJheShfbGVuOCksIF9rZXk4ID0gMDsgX2tleTggPCBfbGVuODsgX2tleTgrKykge1xuICAgICAgX3JlZjhbX2tleThdID0gYXJndW1lbnRzW19rZXk4XTtcbiAgICB9XG4gICAgbGV0IFtuZXR3b3JrLCBhZGRyZXNzLCBzdG9yYWdlLCBvcHRpb25zXSA9IF9yZWY4O1xuICAgIGNvbnN0IFssIHByb3ZpZGVyXSA9IGdldFNpZ25lckFuZFByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgIGNvbnN0IFthYmksIGNvbnRyYWN0LCBfbmV0d29ya10gPSBhd2FpdCBQcm9taXNlLmFsbChbU2lnbmF0dXJlRHJvcEluaXRpYWxpemVyLmdldEFiaShhZGRyZXNzLCBwcm92aWRlciksIGltcG9ydCgnLi9zaWduYXR1cmUtZHJvcC0zZWNkZDBmMC5lc20uanMnKSwgcHJvdmlkZXIuZ2V0TmV0d29yaygpXSk7XG4gICAgcmV0dXJuIG5ldyBjb250cmFjdC5TaWduYXR1cmVEcm9wKG5ldHdvcmssIGFkZHJlc3MsIHN0b3JhZ2UsIG9wdGlvbnMsIGFiaSwgX25ldHdvcmsuY2hhaW5JZCk7XG4gIH0sXG4gIGdldEFiaTogYXN5bmMgKGFkZHJlc3MsIHByb3ZpZGVyKSA9PiB7XG4gICAgY29uc3QgY29udHJhY3RJbmZvID0gYXdhaXQgYXNzZXJ0Q29udHJhY3RUeXBlKGFkZHJlc3MsIHByb3ZpZGVyLCBcInNpZ25hdHVyZS1kcm9wXCIpO1xuICAgIHJldHVybiBjb250cmFjdEluZm8udmVyc2lvbiA+IDQgPyAoYXdhaXQgaW1wb3J0KCdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvU2lnbmF0dXJlRHJvcC5qc29uJykpLmRlZmF1bHQgOiAoYXdhaXQgaW1wb3J0KCdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvU2lnbmF0dXJlRHJvcF9WNC5qc29uJykpLmRlZmF1bHQ7XG4gIH1cbn07XG5jb25zdCBTcGxpdEluaXRpYWxpemVyID0ge1xuICBuYW1lOiBcIlNwbGl0XCIsXG4gIGNvbnRyYWN0VHlwZTogXCJzcGxpdFwiLFxuICBzY2hlbWE6IFNwbGl0c0NvbnRyYWN0U2NoZW1hLFxuICByb2xlczogW1wiYWRtaW5cIl0sXG4gIGluaXRpYWxpemU6IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuOSA9IGFyZ3VtZW50cy5sZW5ndGgsIF9yZWY5ID0gbmV3IEFycmF5KF9sZW45KSwgX2tleTkgPSAwOyBfa2V5OSA8IF9sZW45OyBfa2V5OSsrKSB7XG4gICAgICBfcmVmOVtfa2V5OV0gPSBhcmd1bWVudHNbX2tleTldO1xuICAgIH1cbiAgICBsZXQgW25ldHdvcmssIGFkZHJlc3MsIHN0b3JhZ2UsIG9wdGlvbnNdID0gX3JlZjk7XG4gICAgY29uc3QgWywgcHJvdmlkZXJdID0gZ2V0U2lnbmVyQW5kUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgY29uc3QgW2FiaSwgY29udHJhY3QsIF9uZXR3b3JrXSA9IGF3YWl0IFByb21pc2UuYWxsKFtTcGxpdEluaXRpYWxpemVyLmdldEFiaShhZGRyZXNzLCBwcm92aWRlciksIGltcG9ydCgnLi9zcGxpdC1jNDZmMWY1ZC5lc20uanMnKSwgcHJvdmlkZXIuZ2V0TmV0d29yaygpXSk7XG4gICAgcmV0dXJuIG5ldyBjb250cmFjdC5TcGxpdChuZXR3b3JrLCBhZGRyZXNzLCBzdG9yYWdlLCBvcHRpb25zLCBhYmksIF9uZXR3b3JrLmNoYWluSWQpO1xuICB9LFxuICBnZXRBYmk6IGFzeW5jIChhZGRyZXNzLCBwcm92aWRlcikgPT4ge1xuICAgIGF3YWl0IGFzc2VydENvbnRyYWN0VHlwZShhZGRyZXNzLCBwcm92aWRlciwgXCJzcGxpdFwiKTtcbiAgICByZXR1cm4gKGF3YWl0IGltcG9ydCgnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL1NwbGl0Lmpzb24nKSkuZGVmYXVsdDtcbiAgfVxufTtcbmNvbnN0IFRva2VuRHJvcEluaXRpYWxpemVyID0ge1xuICBuYW1lOiBcIkRyb3BFUkMyMFwiLFxuICBjb250cmFjdFR5cGU6IFwidG9rZW4tZHJvcFwiLFxuICBzY2hlbWE6IERyb3BFcmMyMENvbnRyYWN0U2NoZW1hLFxuICByb2xlczogW1wiYWRtaW5cIiwgXCJ0cmFuc2ZlclwiXSxcbiAgaW5pdGlhbGl6ZTogYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4xMCA9IGFyZ3VtZW50cy5sZW5ndGgsIF9yZWYxMCA9IG5ldyBBcnJheShfbGVuMTApLCBfa2V5MTAgPSAwOyBfa2V5MTAgPCBfbGVuMTA7IF9rZXkxMCsrKSB7XG4gICAgICBfcmVmMTBbX2tleTEwXSA9IGFyZ3VtZW50c1tfa2V5MTBdO1xuICAgIH1cbiAgICBsZXQgW25ldHdvcmssIGFkZHJlc3MsIHN0b3JhZ2UsIG9wdGlvbnNdID0gX3JlZjEwO1xuICAgIGNvbnN0IFssIHByb3ZpZGVyXSA9IGdldFNpZ25lckFuZFByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgIGNvbnN0IFthYmksIGNvbnRyYWN0LCBfbmV0d29ya10gPSBhd2FpdCBQcm9taXNlLmFsbChbVG9rZW5Ecm9wSW5pdGlhbGl6ZXIuZ2V0QWJpKGFkZHJlc3MsIHByb3ZpZGVyKSwgaW1wb3J0KCcuL3Rva2VuLWRyb3AtZmIxYmRmOWMuZXNtLmpzJyksIHByb3ZpZGVyLmdldE5ldHdvcmsoKV0pO1xuICAgIHJldHVybiBuZXcgY29udHJhY3QuVG9rZW5Ecm9wKG5ldHdvcmssIGFkZHJlc3MsIHN0b3JhZ2UsIG9wdGlvbnMsIGFiaSwgX25ldHdvcmsuY2hhaW5JZCk7XG4gIH0sXG4gIGdldEFiaTogYXN5bmMgKGFkZHJlc3MsIHByb3ZpZGVyKSA9PiB7XG4gICAgY29uc3QgY29udHJhY3RJbmZvID0gYXdhaXQgYXNzZXJ0Q29udHJhY3RUeXBlKGFkZHJlc3MsIHByb3ZpZGVyLCBcInRva2VuLWRyb3BcIik7XG4gICAgcmV0dXJuIGNvbnRyYWN0SW5mby52ZXJzaW9uID4gMiA/IChhd2FpdCBpbXBvcnQoJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9Ecm9wRVJDMjAuanNvbicpKS5kZWZhdWx0IDogKGF3YWl0IGltcG9ydCgnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0Ryb3BFUkMyMF9WMi5qc29uJykpLmRlZmF1bHQ7XG4gIH1cbn07XG5jb25zdCBUb2tlbkluaXRpYWxpemVyID0ge1xuICBuYW1lOiBcIlRva2VuRVJDMjBcIixcbiAgY29udHJhY3RUeXBlOiBcInRva2VuXCIsXG4gIHNjaGVtYTogVG9rZW5FcmMyMENvbnRyYWN0U2NoZW1hLFxuICByb2xlczogW1wiYWRtaW5cIiwgXCJtaW50ZXJcIiwgXCJ0cmFuc2ZlclwiXSxcbiAgaW5pdGlhbGl6ZTogYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4xMSA9IGFyZ3VtZW50cy5sZW5ndGgsIF9yZWYxMSA9IG5ldyBBcnJheShfbGVuMTEpLCBfa2V5MTEgPSAwOyBfa2V5MTEgPCBfbGVuMTE7IF9rZXkxMSsrKSB7XG4gICAgICBfcmVmMTFbX2tleTExXSA9IGFyZ3VtZW50c1tfa2V5MTFdO1xuICAgIH1cbiAgICBsZXQgW25ldHdvcmssIGFkZHJlc3MsIHN0b3JhZ2UsIG9wdGlvbnNdID0gX3JlZjExO1xuICAgIGNvbnN0IFssIHByb3ZpZGVyXSA9IGdldFNpZ25lckFuZFByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgIGNvbnN0IFthYmksIGNvbnRyYWN0LCBfbmV0d29ya10gPSBhd2FpdCBQcm9taXNlLmFsbChbVG9rZW5Jbml0aWFsaXplci5nZXRBYmkoYWRkcmVzcywgcHJvdmlkZXIpLCBpbXBvcnQoJy4vdG9rZW4tOGMxOGJiNzEuZXNtLmpzJyksIHByb3ZpZGVyLmdldE5ldHdvcmsoKV0pO1xuICAgIHJldHVybiBuZXcgY29udHJhY3QuVG9rZW4obmV0d29yaywgYWRkcmVzcywgc3RvcmFnZSwgb3B0aW9ucywgYWJpLCBfbmV0d29yay5jaGFpbklkKTtcbiAgfSxcbiAgZ2V0QWJpOiBhc3luYyAoYWRkcmVzcywgcHJvdmlkZXIpID0+IHtcbiAgICBhd2FpdCBhc3NlcnRDb250cmFjdFR5cGUoYWRkcmVzcywgcHJvdmlkZXIsIFwidG9rZW5cIik7XG4gICAgcmV0dXJuIChhd2FpdCBpbXBvcnQoJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9Ub2tlbkVSQzIwLmpzb24nKSkuZGVmYXVsdDtcbiAgfVxufTtcbmNvbnN0IFZvdGVJbml0aWFsaXplciA9IHtcbiAgbmFtZTogXCJWb3RlRVJDMjBcIixcbiAgY29udHJhY3RUeXBlOiBcInZvdGVcIixcbiAgc2NoZW1hOiBWb3RlQ29udHJhY3RTY2hlbWEsXG4gIHJvbGVzOiBbXSxcbiAgaW5pdGlhbGl6ZTogYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4xMiA9IGFyZ3VtZW50cy5sZW5ndGgsIF9yZWYxMiA9IG5ldyBBcnJheShfbGVuMTIpLCBfa2V5MTIgPSAwOyBfa2V5MTIgPCBfbGVuMTI7IF9rZXkxMisrKSB7XG4gICAgICBfcmVmMTJbX2tleTEyXSA9IGFyZ3VtZW50c1tfa2V5MTJdO1xuICAgIH1cbiAgICBsZXQgW25ldHdvcmssIGFkZHJlc3MsIHN0b3JhZ2UsIG9wdGlvbnNdID0gX3JlZjEyO1xuICAgIGNvbnN0IFssIHByb3ZpZGVyXSA9IGdldFNpZ25lckFuZFByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgIGNvbnN0IFthYmksIGNvbnRyYWN0LCBfbmV0d29ya10gPSBhd2FpdCBQcm9taXNlLmFsbChbVm90ZUluaXRpYWxpemVyLmdldEFiaShhZGRyZXNzLCBwcm92aWRlciksIGltcG9ydCgnLi92b3RlLWY4Njk5NjJhLmVzbS5qcycpLCBwcm92aWRlci5nZXROZXR3b3JrKCldKTtcbiAgICByZXR1cm4gbmV3IGNvbnRyYWN0LlZvdGUobmV0d29yaywgYWRkcmVzcywgc3RvcmFnZSwgb3B0aW9ucywgYWJpLCBfbmV0d29yay5jaGFpbklkKTtcbiAgfSxcbiAgZ2V0QWJpOiBhc3luYyAoYWRkcmVzcywgcHJvdmlkZXIpID0+IHtcbiAgICBhd2FpdCBhc3NlcnRDb250cmFjdFR5cGUoYWRkcmVzcywgcHJvdmlkZXIsIFwidm90ZVwiKTtcbiAgICByZXR1cm4gKGF3YWl0IGltcG9ydCgnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL1ZvdGVFUkMyMC5qc29uJykpLmRlZmF1bHQ7XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBhc3NlcnRDb250cmFjdFR5cGUoYWRkcmVzcywgcHJvdmlkZXIsIHR5cGUpIHtcbiAgY29uc3QgY29udHJhY3RJbmZvID0gYXdhaXQgZ2V0UHJlYnVpbHRJbmZvKGFkZHJlc3MsIHByb3ZpZGVyKTtcbiAgaWYgKCFjb250cmFjdEluZm8gfHwgY29udHJhY3RJbmZvLnR5cGUgIT09IGdldENvbnRyYWN0TmFtZSh0eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ29udHJhY3QgaXMgbm90IGEgJHt0eXBlfWApO1xuICB9XG4gIHJldHVybiBjb250cmFjdEluZm87XG59XG5cbi8qKlxuICogYSBtYXAgZnJvbSBjb250cmFjdFR5cGUgLT4gY29udHJhY3QgbWV0YWRhdGFcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBQUkVCVUlMVF9DT05UUkFDVFNfTUFQID0ge1xuICBbRWRpdGlvbkRyb3BJbml0aWFsaXplci5jb250cmFjdFR5cGVdOiBFZGl0aW9uRHJvcEluaXRpYWxpemVyLFxuICBbRWRpdGlvbkluaXRpYWxpemVyLmNvbnRyYWN0VHlwZV06IEVkaXRpb25Jbml0aWFsaXplcixcbiAgW01hcmtldHBsYWNlSW5pdGlhbGl6ZXIuY29udHJhY3RUeXBlXTogTWFya2V0cGxhY2VJbml0aWFsaXplcixcbiAgW011bHRpd3JhcEluaXRpYWxpemVyLmNvbnRyYWN0VHlwZV06IE11bHRpd3JhcEluaXRpYWxpemVyLFxuICBbTkZUQ29sbGVjdGlvbkluaXRpYWxpemVyLmNvbnRyYWN0VHlwZV06IE5GVENvbGxlY3Rpb25Jbml0aWFsaXplcixcbiAgW05GVERyb3BJbml0aWFsaXplci5jb250cmFjdFR5cGVdOiBORlREcm9wSW5pdGlhbGl6ZXIsXG4gIFtQYWNrSW5pdGlhbGl6ZXIuY29udHJhY3RUeXBlXTogUGFja0luaXRpYWxpemVyLFxuICBbU2lnbmF0dXJlRHJvcEluaXRpYWxpemVyLmNvbnRyYWN0VHlwZV06IFNpZ25hdHVyZURyb3BJbml0aWFsaXplcixcbiAgW1NwbGl0SW5pdGlhbGl6ZXIuY29udHJhY3RUeXBlXTogU3BsaXRJbml0aWFsaXplcixcbiAgW1Rva2VuRHJvcEluaXRpYWxpemVyLmNvbnRyYWN0VHlwZV06IFRva2VuRHJvcEluaXRpYWxpemVyLFxuICBbVG9rZW5Jbml0aWFsaXplci5jb250cmFjdFR5cGVdOiBUb2tlbkluaXRpYWxpemVyLFxuICBbVm90ZUluaXRpYWxpemVyLmNvbnRyYWN0VHlwZV06IFZvdGVJbml0aWFsaXplclxufTtcbmNvbnN0IFNtYXJ0Q29udHJhY3QkMSA9IHtcbiAgbmFtZTogXCJTbWFydENvbnRyYWN0XCIsXG4gIGNvbnRyYWN0VHlwZTogXCJjdXN0b21cIixcbiAgc2NoZW1hOiBDdXN0b21Db250cmFjdFNjaGVtYSxcbiAgcm9sZXM6IEFMTF9ST0xFU1xufTtcbmNvbnN0IENPTlRSQUNUU19NQVAgPSB7XG4gIC4uLlBSRUJVSUxUX0NPTlRSQUNUU19NQVAsXG4gIFtTbWFydENvbnRyYWN0JDEuY29udHJhY3RUeXBlXTogU21hcnRDb250cmFjdCQxXG59O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRDb250cmFjdFR5cGVGb3JSZW1vdGVOYW1lKG5hbWUpIHtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoQ09OVFJBQ1RTX01BUCkuZmluZChjb250cmFjdCA9PiBjb250cmFjdC5uYW1lID09PSBuYW1lKT8uY29udHJhY3RUeXBlIHx8IFwiY3VzdG9tXCI7XG59XG5mdW5jdGlvbiBnZXRDb250cmFjdE5hbWUodHlwZSkge1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhDT05UUkFDVFNfTUFQKS5maW5kKGNvbnRyYWN0ID0+IGNvbnRyYWN0LmNvbnRyYWN0VHlwZSA9PT0gdHlwZSk/Lm5hbWU7XG59XG5cbi8qKlxuICogSGF2ZSBhbiBvZmZpY2lhbCBBcHBsaWNhdGlvbiBVUkkgZm9yIHRoaXMgY29udHJhY3QuXG4gKiBAcmVtYXJrcyBDb25maWd1cmUgYW4gb2ZmaWNpYWwgQXBwbGljYXRpb24gVVJJIGZvciB0aGlzIGNvbnRyYWN0LlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgc2RrLmdldENvbnRyYWN0KFwie3tjb250cmFjdF9hZGRyZXNzfX1cIik7XG4gKiBjb25zdCBhcHBVUkkgPSBhd2FpdCBjb250cmFjdC5hcHB1cmkuZ2V0KCk7XG4gKiBhcHBVUkkgPSBcImlwZnM6Ly9zb21lX2lwZnNfaGFzaFwiO1xuICpcbiAqIGF3YWl0IGNvbnRyYWN0LmFwcHVyaS5zZXQoYXBwVVJJKVxuICogYGBgXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIENvbnRyYWN0QXBwVVJJIHtcbiAgY29uc3RydWN0b3IoY29udHJhY3RXcmFwcGVyLCBtZXRhZGF0YSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZlYXR1cmVOYW1lXCIsIEZFQVRVUkVfQVBQVVJJLm5hbWUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRyYWN0V3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFkYXRhXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIgPSBjb250cmFjdFdyYXBwZXI7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYXBwVVJJIGZvciB0aGUgY29udHJhY3RcbiAgICogQHJldHVybnMgdGhlIGFwcFVSSSBvYmplY3RcbiAgICovXG4gIGFzeW5jIGdldCgpIHtcbiAgICBpZiAoZGV0ZWN0Q29udHJhY3RGZWF0dXJlKHRoaXMuY29udHJhY3RXcmFwcGVyLCBcIkFwcFVSSVwiKSkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5hcHBVUkkoKTtcbiAgICB9XG4gICAgcmV0dXJuIChhd2FpdCB0aGlzLm1ldGFkYXRhLmdldCgpKS5hcHBVUkkgfHwgXCJcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGFwcFVSSSBmb3IgdGhlIGNvbnRyYWN0XG4gICAqIEBwYXJhbSBhcHBVUkkgLSB0aGUgdXJpIHRvIHNldCAodHlwaWNhbGx5IGFuIElQRlMgaGFzaClcbiAgICovXG4gIGFzeW5jIHNldChhcHBVUkkpIHtcbiAgICBpZiAoZGV0ZWN0Q29udHJhY3RGZWF0dXJlKHRoaXMuY29udHJhY3RXcmFwcGVyLCBcIkFwcFVSSVwiKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVjZWlwdDogYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIuc2VuZFRyYW5zYWN0aW9uKFwic2V0QXBwVVJJXCIsIFthcHBVUkldKVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMubWV0YWRhdGEudXBkYXRlKHtcbiAgICAgIGFwcFVSSVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogTGlzdGVuIHRvIENvbnRyYWN0IGV2ZW50cyBpbiByZWFsIHRpbWVcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgQ29udHJhY3RFdmVudHMge1xuICBjb25zdHJ1Y3Rvcihjb250cmFjdFdyYXBwZXIpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250cmFjdFdyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlciA9IGNvbnRyYWN0V3JhcHBlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gdHJhbnNhY3Rpb25zIGluIHRoaXMgY29udHJhY3QuXG4gICAqIEByZW1hcmtzIFdpbGwgZW1pdCBhbiBcImV2ZW50XCIgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRyYW5zYWN0aW9uIHN0YXR1cyAoJ3N1Ym1pdHRlZCcgYW5kICdjb21wbGV0ZWQnKSBhbmQgaGFzaFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnRyYWN0LmV2ZW50cy5hZGRUcmFuc2FjdGlvbkxpc3RlbmVyKChldmVudCkgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKGV2ZW50KTtcbiAgICogfVxuICAgKiBgYGBcbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb24gZXZlcnkgdHJhbnNhY3Rpb25cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkVHJhbnNhY3Rpb25MaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuY29udHJhY3RXcmFwcGVyLmFkZExpc3RlbmVyKEV2ZW50VHlwZS5UcmFuc2FjdGlvbiwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHRyYW5zYWN0aW9uIGxpc3RlbmVyXG4gICAqIEByZW1hcmtzIFJlbW92ZSBhIGxpc3RlbmVyIHRoYXQgd2FzIGFkZGVkIHdpdGggYWRkVHJhbnNhY3Rpb25MaXN0ZW5lclxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnRyYWN0LmV2ZW50cy5yZW1vdmVUcmFuc2FjdGlvbkxpc3RlbmVyKChldmVudCkgPT4ge1xuICAgKiAgY29uc29sZS5sb2coZXZlbnQpO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcmVtb3ZlXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlbW92ZVRyYW5zYWN0aW9uTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlci5vZmYoRXZlbnRUeXBlLlRyYW5zYWN0aW9uLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIGNvbnRyYWN0IGV2ZW50c1xuICAgKiBAcmVtYXJrcyBZb3UgY2FuIGFkZCBhIGxpc3RlbmVyIGZvciBhbnkgY29udHJhY3QgZXZlbnQgdG8gcnVuIGEgZnVuY3Rpb24gd2hlblxuICAgKiB0aGUgZXZlbnQgaXMgZW1pdHRlZC4gRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50ZWQgdG8gbGlzdGVuIGZvciBhIFwiVG9rZW5zTWludGVkXCIgZXZlbnQsXG4gICAqIHlvdSBjb3VsZCBkbyB0aGUgZm9sbG93aW5nOlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnRyYWN0LmV2ZW50cy5hZGRFdmVudExpc3RlbmVyKFwiVG9rZW5zTWludGVkXCIsIChldmVudCkgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKGV2ZW50KTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSBldmVudE5hbWUgLSB0aGUgZXZlbnQgbmFtZSBhcyBkZWZpbmVkIGluIHRoZSBjb250cmFjdFxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBvbiBldmVyeSBuZXcgZXZlbnRcbiAgICogQHJldHVybnMgYSBmdW5jdGlvbiB0byB1bi1zdWJzY3JpYmUgZnJvbSB0aGUgZXZlbnRcbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIC8vIHZhbGlkYXRlcyBldmVudCwgdGhyb3dzIGVycm9yIGlmIG5vdCBmb3VuZFxuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChldmVudE5hbWUpO1xuICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuYWRkcmVzcztcbiAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICBhZGRyZXNzLFxuICAgICAgdG9waWNzOiBbdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudFRvcGljKGV2ZW50KV1cbiAgICB9O1xuICAgIGNvbnN0IHdyYXBwZWRMaXN0ZW5lciA9IGxvZyA9PiB7XG4gICAgICBjb25zdCBwYXJzZWRMb2cgPSB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuaW50ZXJmYWNlLnBhcnNlTG9nKGxvZyk7XG4gICAgICBsaXN0ZW5lcih0aGlzLnRvQ29udHJhY3RFdmVudChwYXJzZWRMb2cuZXZlbnRGcmFnbWVudCwgcGFyc2VkTG9nLmFyZ3MsIGxvZykpO1xuICAgIH07XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIuZ2V0UHJvdmlkZXIoKS5vbihmaWx0ZXIsIHdyYXBwZWRMaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFByb3ZpZGVyKCkub2ZmKGZpbHRlciwgd3JhcHBlZExpc3RlbmVyKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBhbGwgZXZlbnRzIGVtaXR0ZWQgZnJvbSB0aGlzIGNvbnRyYWN0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29udHJhY3QuZXZlbnRzLmxpc3RlblRvQWxsRXZlbnRzKChldmVudCkgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKGV2ZW50LmV2ZW50TmFtZSkgLy8gdGhlIG5hbWUgb2YgdGhlIGVtaXR0ZWQgZXZlbnRcbiAgICogICBjb25zb2xlLmxvZyhldmVudC5kYXRhKSAvLyBldmVudCBwYXlsb2FkXG4gICAqIH1cbiAgICogYGBgXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb24gZXZlcnkgbmV3IGV2ZW50XG4gICAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgY2FsbGVkIHRvIHN0b3AgbGlzdGVuaW5nIHRvIGV2ZW50c1xuICAgKi9cbiAgbGlzdGVuVG9BbGxFdmVudHMobGlzdGVuZXIpIHtcbiAgICBjb25zdCBhZGRyZXNzID0gdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmFkZHJlc3M7XG4gICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgYWRkcmVzc1xuICAgIH07XG4gICAgY29uc3Qgd3JhcHBlZExpc3RlbmVyID0gbG9nID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZExvZyA9IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5pbnRlcmZhY2UucGFyc2VMb2cobG9nKTtcbiAgICAgICAgbGlzdGVuZXIodGhpcy50b0NvbnRyYWN0RXZlbnQocGFyc2VkTG9nLmV2ZW50RnJhZ21lbnQsIHBhcnNlZExvZy5hcmdzLCBsb2cpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBwYXJzZSBldmVudDpcIiwgbG9nLCBlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFByb3ZpZGVyKCkub24oZmlsdGVyLCB3cmFwcGVkTGlzdGVuZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRQcm92aWRlcigpLm9mZihmaWx0ZXIsIHdyYXBwZWRMaXN0ZW5lcik7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSB0aGlzIGNvbnRyYWN0XG4gICAqIEByZW1hcmtzIFJlbW92ZSBhIGxpc3RlbmVyIHRoYXQgd2FzIGFkZGVkIHdpdGggYWRkRXZlbnRMaXN0ZW5lclxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnRyYWN0LmV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyKFwiVG9rZW5zTWludGVkXCIsIChldmVudCkgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKGV2ZW50KTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSBldmVudE5hbWUgLSB0aGUgZXZlbnQgbmFtZSBhcyBkZWZpbmVkIGluIHRoZSBjb250cmFjdFxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSB0aGUgbGlzdGVuZXIgdG8gdW5yZWdpc3RlclxuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgLy8gdmFsaWRhdGVzIGV2ZW50LCB0aHJvd3MgZXJyb3IgaWYgbm90IGZvdW5kXG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KGV2ZW50TmFtZSk7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0Lm9mZihldmVudC5uYW1lLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb24gdGhpcyBjb250cmFjdFxuICAgKiBAcmVtYXJrcyBSZW1vdmUgYWxsIGxpc3RlbmVycyBmcm9tIGEgY29udHJhY3RcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb250cmFjdC5ldmVudHMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAqIGBgYFxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuYWRkcmVzcztcbiAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICBhZGRyZXNzXG4gICAgfTtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRQcm92aWRlcigpLnJlbW92ZUFsbExpc3RlbmVycyhmaWx0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBBbGwgRXZlbnRzXG4gICAqIEByZW1hcmtzIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSBldmVudHMgZW1pdHRlZCBmcm9tIHRoaXMgY29udHJhY3QgZHVyaW5nIHRoZSBzcGVjaWZpZWQgdGltZSBwZXJpb2RcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBPcHRpb25hbGx5IHBhc3MgaW4gZmlsdGVycyB0byBsaW1pdCB0aGUgYmxvY2tzIGZyb20gd2hpY2ggZXZlbnRzIGFyZSByZXRyaWV2ZWRcbiAgICogY29uc3QgZmlsdGVycyA9IHtcbiAgICogICBmcm9tQmxvY2s6IDAsXG4gICAqICAgdG9CbG9jazogMTAwMDAwMCxcbiAgICogfVxuICAgKiBjb25zdCBldmVudHMgPSBhd2FpdCBjb250cmFjdC5ldmVudHMuZ2V0QWxsRXZlbnRzKGZpbHRlcnMpO1xuICAgKiBjb25zb2xlLmxvZyhldmVudHNbMF0uZXZlbnROYW1lKTtcbiAgICogY29uc29sZS5sb2coZXZlbnRzWzBdLmRhdGEpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGZpbHRlcnMgLSBTcGVjaWZ5IHRoZSBmcm9tIGFuZCB0byBibG9jayBudW1iZXJzIHRvIGdldCBldmVudHMgZm9yLCBkZWZhdWx0cyB0byBhbGwgYmxvY2tzXG4gICAqIEByZXR1cm5zIFRoZSBldmVudCBvYmplY3RzIG9mIHRoZSBldmVudHMgZW1pdHRlZCB3aXRoIGV2ZW50IG5hbWVzIGFuZCBkYXRhIGZvciBlYWNoIGV2ZW50XG4gICAqL1xuICBhc3luYyBnZXRBbGxFdmVudHMoKSB7XG4gICAgbGV0IGZpbHRlcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHtcbiAgICAgIGZyb21CbG9jazogMCxcbiAgICAgIHRvQmxvY2s6IFwibGF0ZXN0XCIsXG4gICAgICBvcmRlcjogXCJkZXNjXCJcbiAgICB9O1xuICAgIGNvbnN0IGV2ZW50cyA9IGF3YWl0IHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5xdWVyeUZpbHRlcih7fSwgZmlsdGVycy5mcm9tQmxvY2ssIGZpbHRlcnMudG9CbG9jayk7XG4gICAgY29uc3Qgb3JkZXJlZEV2ZW50cyA9IGV2ZW50cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICByZXR1cm4gZmlsdGVycy5vcmRlciA9PT0gXCJkZXNjXCIgPyBiLmJsb2NrTnVtYmVyIC0gYS5ibG9ja051bWJlciA6IGEuYmxvY2tOdW1iZXIgLSBiLmJsb2NrTnVtYmVyO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRXZlbnRzKG9yZGVyZWRFdmVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBFdmVudHNcbiAgICogQHJlbWFya3MgR2V0IGEgbGlzdCBvZiB0aGUgZXZlbnRzIG9mIGEgc3BlY2lmaWMgdHlwZSBlbWl0dGVkIGZyb20gdGhpcyBjb250cmFjdCBkdXJpbmcgdGhlIHNwZWNpZmllZCB0aW1lIHBlcmlvZFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBnZXQgbG9ncyBmb3JcbiAgICogY29uc3QgZXZlbnROYW1lID0gXCJUcmFuc2ZlclwiO1xuICAgKlxuICAgKiAvLyBPcHRpb25hbGx5IHBhc3MgaW4gb3B0aW9ucyB0byBsaW1pdCB0aGUgYmxvY2tzIGZyb20gd2hpY2ggZXZlbnRzIGFyZSByZXRyaWV2ZWRcbiAgICogY29uc3Qgb3B0aW9ucyA9IHtcbiAgICogICBmcm9tQmxvY2s6IDAsXG4gICAqICAgdG9CbG9jazogMTAwMDAwMCwgLy8gY2FuIGFsc28gcGFzcyBcImxhdGVzdFwiXG4gICAqICAgb3JkZXI6IFwiZGVzY1wiLFxuICAgKiAgIC8vIENvbmZpZ3VyZSBldmVudCBmaWx0ZXJzIChmaWx0ZXIgb24gaW5kZXhlZCBldmVudCBwYXJhbWV0ZXJzKVxuICAgKiAgIGZpbHRlcnM6IHtcbiAgICogICAgIGZyb206IFwiMHguLi5cIixcbiAgICogICAgIHRvOiBcIjB4Li4uXCJcbiAgICogICB9XG4gICAqIH07XG4gICAqXG4gICAqIGNvbnN0IGV2ZW50cyA9IGF3YWl0IGNvbnRyYWN0LmV2ZW50cy5nZXRFdmVudHMoZXZlbnROYW1lLCBvcHRpb25zKTtcbiAgICogY29uc29sZS5sb2coZXZlbnRzWzBdLmV2ZW50TmFtZSk7XG4gICAqIGNvbnNvbGUubG9nKGV2ZW50c1swXS5kYXRhKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZ2V0IGxvZ3MgZm9yXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gU3BlY2lmeSB0aGUgZnJvbSBhbmQgdG8gYmxvY2sgbnVtYmVycyB0byBnZXQgZXZlbnRzIGZvciwgZGVmYXVsdHMgdG8gYWxsIGJsb2Nrcy4gQHNlZSBFdmVudFF1ZXJ5T3B0aW9uc1xuICAgKiBAcmV0dXJucyBUaGUgcmVxdWVzdGVkIGV2ZW50IG9iamVjdHMgd2l0aCBldmVudCBkYXRhXG4gICAqL1xuICBhc3luYyBnZXRFdmVudHMoZXZlbnROYW1lKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICAgIGZyb21CbG9jazogMCxcbiAgICAgIHRvQmxvY2s6IFwibGF0ZXN0XCIsXG4gICAgICBvcmRlcjogXCJkZXNjXCJcbiAgICB9O1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChldmVudE5hbWUpO1xuICAgIGNvbnN0IGV2ZW50SW50ZXJmYWNlID0gdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChldmVudE5hbWUpO1xuICAgIGNvbnN0IGFyZ3MgPSBvcHRpb25zLmZpbHRlcnMgPyBldmVudEludGVyZmFjZS5pbnB1dHMubWFwKGUgPT4gb3B0aW9ucy5maWx0ZXJzW2UubmFtZV0pIDogW107XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmZpbHRlcnNbZXZlbnQubmFtZV0oLi4uYXJncyk7XG4gICAgY29uc3QgZXZlbnRzID0gYXdhaXQgdGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LnF1ZXJ5RmlsdGVyKGZpbHRlciwgb3B0aW9ucy5mcm9tQmxvY2ssIG9wdGlvbnMudG9CbG9jayk7XG4gICAgY29uc3Qgb3JkZXJlZEV2ZW50cyA9IGV2ZW50cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5vcmRlciA9PT0gXCJkZXNjXCIgPyBiLmJsb2NrTnVtYmVyIC0gYS5ibG9ja051bWJlciA6IGEuYmxvY2tOdW1iZXIgLSBiLmJsb2NrTnVtYmVyO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRXZlbnRzKG9yZGVyZWRFdmVudHMpO1xuICB9XG4gIHBhcnNlRXZlbnRzKGV2ZW50cykge1xuICAgIHJldHVybiBldmVudHMubWFwKGUgPT4ge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoZSkuZmlsdGVyKGEgPT4gdHlwZW9mIGFbMV0gIT09IFwiZnVuY3Rpb25cIiAmJiBhWzBdICE9PSBcImFyZ3NcIikpO1xuICAgICAgaWYgKGUuYXJncykge1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZS5hcmdzKTtcbiAgICAgICAgY29uc3QgYXJncyA9IGVudHJpZXMuc2xpY2UoZW50cmllcy5sZW5ndGggLyAyLCBlbnRyaWVzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYXJncykge1xuICAgICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXZlbnROYW1lOiBlLmV2ZW50IHx8IFwiXCIsXG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICB0cmFuc2FjdGlvblxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXZlbnROYW1lOiBlLmV2ZW50IHx8IFwiXCIsXG4gICAgICAgIGRhdGE6IHt9LFxuICAgICAgICB0cmFuc2FjdGlvblxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICB0b0NvbnRyYWN0RXZlbnQoZXZlbnQsIGFyZ3MsIHJhd0xvZykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHJhd0xvZykuZmlsdGVyKGEgPT4gdHlwZW9mIGFbMV0gIT09IFwiZnVuY3Rpb25cIiAmJiBhWzBdICE9PSBcImFyZ3NcIikpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgICBldmVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzW2luZGV4XSkpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBwYXJhbS5jb21wb25lbnRzO1xuICAgICAgICBpZiAoY29tcG9uZW50cykge1xuICAgICAgICAgIGNvbnN0IGFyciA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbXBvbmVudHNbaV0ubmFtZTtcbiAgICAgICAgICAgIG9ialtuYW1lXSA9IGFycltpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0c1twYXJhbS5uYW1lXSA9IG9iajtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0c1twYXJhbS5uYW1lXSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBldmVudE5hbWU6IGV2ZW50Lm5hbWUsXG4gICAgICBkYXRhOiByZXN1bHRzLFxuICAgICAgdHJhbnNhY3Rpb25cbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQWxsb3dzIG92ZXJyaWRpbmcgdHJhbnNhY3Rpb24gYmVoYXZpb3IgZm9yIHRoaXMgY29udHJhY3RcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgQ29udHJhY3RJbnRlcmNlcHRvciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRyYWN0V3JhcHBlcikge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRyYWN0V3JhcHBlclwiLCB2b2lkIDApO1xuICAgIHRoaXMuY29udHJhY3RXcmFwcGVyID0gY29udHJhY3RXcmFwcGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBuZXh0IHRyYW5zYWN0aW9uIGV4ZWN1dGVkIHdpbGwgYWRkL3JlcGxhY2UgYW55IG92ZXJyaWRlcyBwYXNzZWQgdmlhIHRoZSBwYXNzZWQgaW4gaG9vay5cbiAgICogQHJlbWFya3MgT3ZlcnJpZGRlbiB2YWx1ZXMgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBuZXh0IHRyYW5zYWN0aW9uIGV4ZWN1dGVkLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnRyYWN0LmludGVyY2VwdG9yLm92ZXJyaWRlTmV4dFRyYW5zYWN0aW9uKCgpID0+ICh7XG4gICAqICAgZ2FzTGltaXQ6IDMwMDAwMDAsXG4gICAqIH0pKTtcbiAgICogYGBgXG4gICAqIEBwYXJhbSBob29rIC0gdGhlIGhvb2sgdG8gYWRkIG9yIHJlcGxhY2UgYW55IENhbGxPdmVycmlkZXMgKGdhcyBsaW1pdCwgZ2FzIHByaWNlLCBub25jZSwgZnJvbSwgdmFsdWUsIGV0Yy4uLilcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgb3ZlcnJpZGVOZXh0VHJhbnNhY3Rpb24oaG9vaykge1xuICAgIHRoaXMuY29udHJhY3RXcmFwcGVyLndpdGhUcmFuc2FjdGlvbk92ZXJyaWRlKGhvb2spO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIHBsYXRmb3JtIGZlZXMgYW5kIHJlY2lwaWVudHNcbiAqIEByZW1hcmtzIENvbmZpZ3VyZSBwbGF0Zm9ybSBmZWVzIGZvciBhIGNvbnRyYWN0LCB3aGljaCBjYW4gYmUgYXBwbGllZCBvbiBjZXJ0YWluIHBhaWQgdHJhbnNhY3Rpb25zXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgY29udHJhY3QgPSBhd2FpdCBzZGsuZ2V0Q29udHJhY3QoXCJ7e2NvbnRyYWN0X2FkZHJlc3N9fVwiKTtcbiAqIGNvbnN0IGZlZUluZm8gPSBhd2FpdCBjb250cmFjdC5wbGF0Zm9ybUZlZS5nZXQoKTtcbiAqIGF3YWl0IGNvbnRyYWN0LnBsYXRmb3JtRmVlLnNldCh7XG4gKiAgIHBsYXRmb3JtX2ZlZV9iYXNpc19wb2ludHM6IDEwMCwgLy8gMSUgZmVlXG4gKiAgIHBsYXRmb3JtX2ZlZV9yZWNpcGllbnQ6IFwiMHguLi5cIiAvLyB0aGUgZmVlIHJlY2lwaWVudFxuICogfSlcbiAqIGBgYFxuICogQHB1YmxpY1xuICovXG5jbGFzcyBDb250cmFjdFBsYXRmb3JtRmVlIHtcbiAgY29uc3RydWN0b3IoY29udHJhY3RXcmFwcGVyKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZmVhdHVyZU5hbWVcIiwgRkVBVFVSRV9QTEFURk9STV9GRUUubmFtZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIgPSBjb250cmFjdFdyYXBwZXI7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwbGF0Zm9ybSBmZWUgcmVjaXBpZW50IGFuZCBiYXNpcyBwb2ludHNcbiAgICogICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBmZWVJbmZvID0gYXdhaXQgY29udHJhY3QucGxhdGZvcm1GZWUuZ2V0KCk7XG4gICAqIGBgYFxuICAgKiBAdHdmZWF0dXJlIFBsYXRmb3JtRmVlXG4gICAqL1xuICBhc3luYyBnZXQoKSB7XG4gICAgY29uc3QgW3BsYXRmb3JtRmVlUmVjaXBpZW50LCBwbGF0Zm9ybUZlZUJwc10gPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5yZWFkQ29udHJhY3QuZ2V0UGxhdGZvcm1GZWVJbmZvKCk7XG4gICAgcmV0dXJuIENvbW1vblBsYXRmb3JtRmVlU2NoZW1hLnBhcnNlKHtcbiAgICAgIHBsYXRmb3JtX2ZlZV9yZWNpcGllbnQ6IHBsYXRmb3JtRmVlUmVjaXBpZW50LFxuICAgICAgcGxhdGZvcm1fZmVlX2Jhc2lzX3BvaW50czogcGxhdGZvcm1GZWVCcHNcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHBsYXRmb3JtIGZlZSByZWNpcGllbnQgYW5kIGJhc2lzIHBvaW50c1xuICAgKiBAcGFyYW0gcGxhdGZvcm1GZWVJbmZvIC0gdGhlIHBsYXRmb3JtIGZlZSBpbmZvcm1hdGlvblxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGF3YWl0IGNvbnRyYWN0LnBsYXRmb3JtRmVlLnNldCh7XG4gICAqICAgcGxhdGZvcm1fZmVlX2Jhc2lzX3BvaW50czogMTAwLCAvLyAxJSBmZWVcbiAgICogICBwbGF0Zm9ybV9mZWVfcmVjaXBpZW50OiBcIjB4Li4uXCIgLy8gdGhlIGZlZSByZWNpcGllbnRcbiAgICogfSlcbiAgICogYGBgXG4gICAqIEB0d2ZlYXR1cmUgUGxhdGZvcm1GZWVcbiAgICovXG4gIGFzeW5jIHNldChwbGF0Zm9ybUZlZUluZm8pIHtcbiAgICBjb25zdCBwYXJzZWQgPSBDb21tb25QbGF0Zm9ybUZlZVNjaGVtYS5wYXJzZShwbGF0Zm9ybUZlZUluZm8pO1xuICAgIHJldHVybiB7XG4gICAgICByZWNlaXB0OiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJzZXRQbGF0Zm9ybUZlZUluZm9cIiwgW3BhcnNlZC5wbGF0Zm9ybV9mZWVfcmVjaXBpZW50LCBwYXJzZWQucGxhdGZvcm1fZmVlX2Jhc2lzX3BvaW50c10pXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZXMgcHVibGlzaCBtZXRhZGF0YSBmb3IgYSBjb250cmFjdFxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIENvbnRyYWN0UHVibGlzaGVkTWV0YWRhdGEge1xuICBjb25zdHJ1Y3Rvcihjb250cmFjdFdyYXBwZXIsIHN0b3JhZ2UpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250cmFjdFdyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yYWdlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NhY2hlZE1ldGFkYXRhXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5jb250cmFjdFdyYXBwZXIgPSBjb250cmFjdFdyYXBwZXI7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHB1Ymxpc2hlZCBtZXRhZGF0YSBmb3IgdGhpcyBjb250cmFjdFxuICAgKiBAcHVibGljXG4gICAqL1xuICBhc3luYyBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZE1ldGFkYXRhKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YWRhdGE7XG4gICAgfVxuICAgIHRoaXMuX2NhY2hlZE1ldGFkYXRhID0gYXdhaXQgZmV0Y2hDb250cmFjdE1ldGFkYXRhRnJvbUFkZHJlc3ModGhpcy5jb250cmFjdFdyYXBwZXIucmVhZENvbnRyYWN0LmFkZHJlc3MsIHRoaXMuY29udHJhY3RXcmFwcGVyLmdldFByb3ZpZGVyKCksIHRoaXMuc3RvcmFnZSk7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGFkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFzeW5jIGV4dHJhY3RGdW5jdGlvbnMoKSB7XG4gICAgbGV0IHB1Ymxpc2hlZE1ldGFkYXRhO1xuICAgIHRyeSB7XG4gICAgICBwdWJsaXNoZWRNZXRhZGF0YSA9IGF3YWl0IHRoaXMuZ2V0KCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWdub3JlIGZvciBidWlsdC1pbiBjb250cmFjdHNcbiAgICB9XG4gICAgLy8gdG8gY29uc3RydWN0IGEgY29udHJhY3Qgd2UgYWxyZWFkeSAqKmhhdmUqKiB0byBoYXZlIHRoZSBhYmkgb24gdGhlIGNvbnRyYWN0IHdyYXBwZXIsIHNvIHRoZXJlIGlzIG5vIHJlYXNvbiB0byBsb29rIGZldGNoIGl0IGFnYWluIChtZWFucyB0aGlzIGZ1bmN0aW9uIGNhbiBiZWNvbWUgc3luY2hyb25vdXMgYXMgd2VsbCEpXG4gICAgcmV0dXJuIGV4dHJhY3RGdW5jdGlvbnNGcm9tQWJpKEFiaVNjaGVtYS5wYXJzZSh0aGlzLmNvbnRyYWN0V3JhcHBlci5hYmkpLCBwdWJsaXNoZWRNZXRhZGF0YT8ubWV0YWRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFzeW5jIGV4dHJhY3RFdmVudHMoKSB7XG4gICAgbGV0IHB1Ymxpc2hlZE1ldGFkYXRhO1xuICAgIHRyeSB7XG4gICAgICBwdWJsaXNoZWRNZXRhZGF0YSA9IGF3YWl0IHRoaXMuZ2V0KCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWdub3JlIGZvciBidWlsdC1pbiBjb250cmFjdHNcbiAgICB9XG4gICAgLy8gdG8gY29uc3RydWN0IGEgY29udHJhY3Qgd2UgYWxyZWFkeSAqKmhhdmUqKiB0byBoYXZlIHRoZSBhYmkgb24gdGhlIGNvbnRyYWN0IHdyYXBwZXIsIHNvIHRoZXJlIGlzIG5vIHJlYXNvbiB0byBsb29rIGZldGNoIGl0IGFnYWluIChtZWFucyB0aGlzIGZ1bmN0aW9uIGNhbiBiZWNvbWUgc3luY2hyb25vdXMgYXMgd2VsbCEpXG4gICAgcmV0dXJuIGV4dHJhY3RFdmVudHNGcm9tQWJpKEFiaVNjaGVtYS5wYXJzZSh0aGlzLmNvbnRyYWN0V3JhcHBlci5hYmkpLCBwdWJsaXNoZWRNZXRhZGF0YT8ubWV0YWRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogQ3VzdG9tIGNvbnRyYWN0IGR5bmFtaWMgY2xhc3Mgd2l0aCBmZWF0dXJlIGRldGVjdGlvblxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHsgVGhpcmR3ZWJTREsgfSBmcm9tIFwiQHRoaXJkd2ViLWRldi9zZGtcIjtcbiAqXG4gKiBjb25zdCBzZGsgPSBuZXcgVGhpcmR3ZWJTREsocHJvdmlkZXIpO1xuICogY29uc3QgY29udHJhY3QgPSBhd2FpdCBzZGsuZ2V0Q29udHJhY3QoXCJ7e2NvbnRyYWN0X2FkZHJlc3N9fVwiKTtcbiAqXG4gKiAvLyBjYWxsIGFueSBmdW5jdGlvbiBpbiB5b3VyIGNvbnRyYWN0XG4gKiBhd2FpdCBjb250cmFjdC5jYWxsKFwibXlDdXN0b21GdW5jdGlvblwiLCBwYXJhbTEsIHBhcmFtMik7XG4gKlxuICogLy8gaWYgeW91ciBjb250cmFjdCBmb2xsb3dzIHRoZSBFUkM3MjEgc3RhbmRhcmQsIGNvbnRyYWN0Lm5mdCB3aWxsIGJlIHByZXNlbnRcbiAqIGNvbnN0IGFsbE5GVHMgPSBhd2FpdCBjb250cmFjdC5lcmM3MjEucXVlcnkuYWxsKClcbiAqXG4gKiAvLyBpZiB5b3VyIGNvbnRyYWN0IGV4dGVuZHMgSU1pbnRhYmxlRVJDNzIxLCBjb250cmFjdC5uZnQubWludCgpIHdpbGwgYmUgYXZhaWxhYmxlXG4gKiBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmVyYzcyMS5taW50KHtcbiAqICAgICBuYW1lOiBcIkNvb2wgTkZUXCIsXG4gKiAgICAgaW1hZ2U6IHJlYWRGaWxlU3luYyhcInNvbWVfaW1hZ2UucG5nXCIpLFxuICogICB9KTtcbiAqIGBgYFxuICpcbiAqIEBiZXRhXG4gKi9cbmNsYXNzIFNtYXJ0Q29udHJhY3Qge1xuICAvLyB1dGlsaXRpZXNcblxuICAvKipcbiAgICogSGFuZGxlIHJveWFsdGllc1xuICAgKi9cbiAgZ2V0IHJveWFsdGllcygpIHtcbiAgICByZXR1cm4gYXNzZXJ0RW5hYmxlZCh0aGlzLmRldGVjdFJveWFsdGllcygpLCBGRUFUVVJFX1JPWUFMVFkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwZXJtaXNzaW9uc1xuICAgKi9cbiAgZ2V0IHJvbGVzKCkge1xuICAgIHJldHVybiBhc3NlcnRFbmFibGVkKHRoaXMuZGV0ZWN0Um9sZXMoKSwgRkVBVFVSRV9QRVJNSVNTSU9OUyk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHByaW1hcnkgc2FsZXNcbiAgICovXG4gIGdldCBzYWxlcygpIHtcbiAgICByZXR1cm4gYXNzZXJ0RW5hYmxlZCh0aGlzLmRldGVjdFByaW1hcnlTYWxlcygpLCBGRUFUVVJFX1BSSU1BUllfU0FMRSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBsYXRmb3JtIGZlZXNcbiAgICovXG4gIGdldCBwbGF0Zm9ybUZlZXMoKSB7XG4gICAgcmV0dXJuIGFzc2VydEVuYWJsZWQodGhpcy5kZXRlY3RQbGF0Zm9ybUZlZXMoKSwgRkVBVFVSRV9QTEFURk9STV9GRUUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhbmQgZ2V0IHRoZSBvd25lciBvZiB0aGUgY29udHJhY3RcbiAgICovXG4gIGdldCBvd25lcigpIHtcbiAgICByZXR1cm4gYXNzZXJ0RW5hYmxlZCh0aGlzLmRldGVjdE93bmFibGUoKSwgRkVBVFVSRV9PV05FUik7XG4gIH1cblxuICAvKipcbiAgICogQXV0by1kZXRlY3RzIEVSQzIwIHN0YW5kYXJkIGZ1bmN0aW9ucy5cbiAgICovXG4gIGdldCBlcmMyMCgpIHtcbiAgICByZXR1cm4gYXNzZXJ0RW5hYmxlZCh0aGlzLmRldGVjdEVyYzIwKCksIEZFQVRVUkVfVE9LRU4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEF1dG8tZGV0ZWN0cyBFUkM3MjEgc3RhbmRhcmQgZnVuY3Rpb25zLlxuICAgKi9cbiAgZ2V0IGVyYzcyMSgpIHtcbiAgICByZXR1cm4gYXNzZXJ0RW5hYmxlZCh0aGlzLmRldGVjdEVyYzcyMSgpLCBGRUFUVVJFX05GVCk7XG4gIH1cblxuICAvKipcbiAgICogQXV0by1kZXRlY3RzIEVSQzExNTUgc3RhbmRhcmQgZnVuY3Rpb25zLlxuICAgKi9cbiAgZ2V0IGVyYzExNTUoKSB7XG4gICAgcmV0dXJuIGFzc2VydEVuYWJsZWQodGhpcy5kZXRlY3RFcmMxMTU1KCksIEZFQVRVUkVfRURJVElPTik7XG4gIH1cbiAgZ2V0IGNoYWluSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYWluSWQ7XG4gIH1cbiAgY29uc3RydWN0b3IobmV0d29yaywgYWRkcmVzcywgYWJpLCBzdG9yYWdlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuICAgIGxldCBjaGFpbklkID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgPyBhcmd1bWVudHNbNV0gOiB1bmRlZmluZWQ7XG4gICAgbGV0IGNvbnRyYWN0V3JhcHBlciA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogbmV3IENvbnRyYWN0V3JhcHBlcihuZXR3b3JrLCBhZGRyZXNzLCBhYmksIG9wdGlvbnMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRyYWN0V3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3JhZ2VcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJldmVudHNcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnRlcmNlcHRvclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVuY29kZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlc3RpbWF0b3JcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwdWJsaXNoZWRNZXRhZGF0YVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFiaVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFkYXRhXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYXBwVVJJXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NoYWluSWRcIiwgdm9pZCAwKTtcbiAgICB0aGlzLl9jaGFpbklkID0gY2hhaW5JZDtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgIHRoaXMuY29udHJhY3RXcmFwcGVyID0gY29udHJhY3RXcmFwcGVyO1xuICAgIHRoaXMuYWJpID0gYWJpO1xuICAgIHRoaXMuZXZlbnRzID0gbmV3IENvbnRyYWN0RXZlbnRzKHRoaXMuY29udHJhY3RXcmFwcGVyKTtcbiAgICB0aGlzLmVuY29kZXIgPSBuZXcgQ29udHJhY3RFbmNvZGVyKHRoaXMuY29udHJhY3RXcmFwcGVyKTtcbiAgICB0aGlzLmludGVyY2VwdG9yID0gbmV3IENvbnRyYWN0SW50ZXJjZXB0b3IodGhpcy5jb250cmFjdFdyYXBwZXIpO1xuICAgIHRoaXMuZXN0aW1hdG9yID0gbmV3IEdhc0Nvc3RFc3RpbWF0b3IodGhpcy5jb250cmFjdFdyYXBwZXIpO1xuICAgIHRoaXMucHVibGlzaGVkTWV0YWRhdGEgPSBuZXcgQ29udHJhY3RQdWJsaXNoZWRNZXRhZGF0YSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgdGhpcy5zdG9yYWdlKTtcbiAgICB0aGlzLm1ldGFkYXRhID0gbmV3IENvbnRyYWN0TWV0YWRhdGEodGhpcy5jb250cmFjdFdyYXBwZXIsIEN1c3RvbUNvbnRyYWN0U2NoZW1hLCB0aGlzLnN0b3JhZ2UpO1xuICAgIHRoaXMuYXBwVVJJID0gbmV3IENvbnRyYWN0QXBwVVJJKHRoaXMuY29udHJhY3RXcmFwcGVyLCB0aGlzLm1ldGFkYXRhKTtcbiAgfVxuICBvbk5ldHdvcmtVcGRhdGVkKG5ldHdvcmspIHtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlci51cGRhdGVTaWduZXJPclByb3ZpZGVyKG5ldHdvcmspO1xuICB9XG4gIGdldEFkZHJlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5hZGRyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgYW55IGZ1bmN0aW9uIG9uIHRoaXMgY29udHJhY3RcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyByZWFkIGZ1bmN0aW9ucyB3aWxsIHJldHVybiB0aGUgZGF0YSBmcm9tIHRoZSBjb250cmFjdFxuICAgKiBjb25zdCBteVZhbHVlID0gYXdhaXQgY29udHJhY3QuY2FsbChcIm15UmVhZEZ1bmN0aW9uXCIpO1xuICAgKiBjb25zb2xlLmxvZyhteVZhbHVlKTtcbiAgICpcbiAgICogLy8gd3JpdGUgZnVuY3Rpb25zIHdpbGwgcmV0dXJuIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0XG4gICAqIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuY2FsbChcIm15V3JpdGVGdW5jdGlvblwiLCBhcmcxLCBhcmcyKTtcbiAgICogY29uc3QgcmVjZWlwdCA9IHR4LnJlY2VpcHQ7XG4gICAqXG4gICAqIC8vIE9wdGlvbmFsbHkgb3ZlcnJpZGUgdHJhbnNhY3Rpb24gb3B0aW9uc1xuICAgKiBhd2FpdCBjb250cmFjdC5jYWxsKFwibXlXcml0ZUZ1bmN0aW9uXCIsIGFyZzEsIGFyZzIsIHtcbiAgICogIGdhc0xpbWl0OiAxMDAwMDAwLCAvLyBvdmVycmlkZSBkZWZhdWx0IGdhcyBsaW1pdFxuICAgKiAgdmFsdWU6IGV0aGVycy51dGlscy5wYXJzZUV0aGVyKFwiMC4xXCIpLCAvLyBzZW5kIDAuMSBldGhlciB3aXRoIHRoZSBjb250cmFjdCBjYWxsXG4gICAqIH07XG4gICAqIGBgYFxuICAgKiBAcGFyYW0gZnVuY3Rpb25OYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGxcbiAgICogQHBhcmFtIGFyZ3MgLSB0aGUgYXJndW1lbnRzIG9mIHRoZSBmdW5jdGlvblxuICAgKi9cbiAgYXN5bmMgY2FsbChmdW5jdGlvbk5hbWUpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udHJhY3RXcmFwcGVyLmNhbGwoZnVuY3Rpb25OYW1lLCAuLi5hcmdzKTtcbiAgfVxuXG4gIC8qKiAqKioqKioqKioqKioqKioqKioqKlxuICAgKiBGRUFUVVJFIERFVEVDVElPTlxuICAgKiAqKioqKioqKioqKioqKioqKioqKi9cblxuICBkZXRlY3RSb3lhbHRpZXMoKSB7XG4gICAgaWYgKGRldGVjdENvbnRyYWN0RmVhdHVyZSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgXCJSb3lhbHR5XCIpKSB7XG4gICAgICAvLyBDb250cmFjdE1ldGFkYXRhIGlzIHN0YXRlbGVzcywgaXQncyBmaW5lIHRvIGNyZWF0ZSBhIG5ldyBvbmUgaGVyZVxuICAgICAgLy8gVGhpcyBhbHNvIG1ha2VzIGl0IG5vdCBvcmRlciBkZXBlbmRlbnQgaW4gdGhlIGZlYXR1cmUgZGV0ZWN0aW9uIHByb2Nlc3NcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gbmV3IENvbnRyYWN0TWV0YWRhdGEodGhpcy5jb250cmFjdFdyYXBwZXIsIEN1c3RvbUNvbnRyYWN0U2NoZW1hLCB0aGlzLnN0b3JhZ2UpO1xuICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFJveWFsdHkodGhpcy5jb250cmFjdFdyYXBwZXIsIG1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBkZXRlY3RSb2xlcygpIHtcbiAgICBpZiAoZGV0ZWN0Q29udHJhY3RGZWF0dXJlKHRoaXMuY29udHJhY3RXcmFwcGVyLCBcIlBlcm1pc3Npb25zXCIpKSB7XG4gICAgICByZXR1cm4gbmV3IENvbnRyYWN0Um9sZXModGhpcy5jb250cmFjdFdyYXBwZXIsIEFMTF9ST0xFUyk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgZGV0ZWN0UHJpbWFyeVNhbGVzKCkge1xuICAgIGlmIChkZXRlY3RDb250cmFjdEZlYXR1cmUodGhpcy5jb250cmFjdFdyYXBwZXIsIFwiUHJpbWFyeVNhbGVcIikpIHtcbiAgICAgIHJldHVybiBuZXcgQ29udHJhY3RQcmltYXJ5U2FsZSh0aGlzLmNvbnRyYWN0V3JhcHBlcik7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgZGV0ZWN0UGxhdGZvcm1GZWVzKCkge1xuICAgIGlmIChkZXRlY3RDb250cmFjdEZlYXR1cmUodGhpcy5jb250cmFjdFdyYXBwZXIsIFwiUGxhdGZvcm1GZWVcIikpIHtcbiAgICAgIHJldHVybiBuZXcgQ29udHJhY3RQbGF0Zm9ybUZlZSh0aGlzLmNvbnRyYWN0V3JhcHBlcik7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgZGV0ZWN0RXJjMjAoKSB7XG4gICAgaWYgKGRldGVjdENvbnRyYWN0RmVhdHVyZSh0aGlzLmNvbnRyYWN0V3JhcHBlciwgXCJFUkMyMFwiKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcmMyMCh0aGlzLmNvbnRyYWN0V3JhcHBlciwgdGhpcy5zdG9yYWdlLCB0aGlzLmNoYWluSWQpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGRldGVjdEVyYzcyMSgpIHtcbiAgICBpZiAoZGV0ZWN0Q29udHJhY3RGZWF0dXJlKHRoaXMuY29udHJhY3RXcmFwcGVyLCBcIkVSQzcyMVwiKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcmM3MjEodGhpcy5jb250cmFjdFdyYXBwZXIsIHRoaXMuc3RvcmFnZSwgdGhpcy5jaGFpbklkKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBkZXRlY3RFcmMxMTU1KCkge1xuICAgIGlmIChkZXRlY3RDb250cmFjdEZlYXR1cmUodGhpcy5jb250cmFjdFdyYXBwZXIsIFwiRVJDMTE1NVwiKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcmMxMTU1KHRoaXMuY29udHJhY3RXcmFwcGVyLCB0aGlzLnN0b3JhZ2UsIHRoaXMuY2hhaW5JZCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgZGV0ZWN0T3duYWJsZSgpIHtcbiAgICBpZiAoZGV0ZWN0Q29udHJhY3RGZWF0dXJlKHRoaXMuY29udHJhY3RXcmFwcGVyLCBcIk93bmFibGVcIikpIHtcbiAgICAgIHJldHVybiBuZXcgQ29udHJhY3RPd25lcih0aGlzLmNvbnRyYWN0V3JhcHBlcik7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGVzIHB1Ymxpc2hpbmcgY29udHJhY3RzIChFWFBFUklNRU5UQUwpXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgQ29udHJhY3RQdWJsaXNoZXIgZXh0ZW5kcyBSUENDb25uZWN0aW9uSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKG5ldHdvcmssIG9wdGlvbnMsIHN0b3JhZ2UpIHtcbiAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yYWdlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicHVibGlzaGVyXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICB0aGlzLnB1Ymxpc2hlciA9IG5ldyBDb250cmFjdFdyYXBwZXIobmV0d29yaywgZ2V0Q29udHJhY3RQdWJsaXNoZXJBZGRyZXNzKCksIENvbnRyYWN0UHVibGlzaGVyQWJpLCBvcHRpb25zKTtcbiAgfVxuICB1cGRhdGVTaWduZXJPclByb3ZpZGVyKG5ldHdvcmspIHtcbiAgICBzdXBlci51cGRhdGVTaWduZXJPclByb3ZpZGVyKG5ldHdvcmspO1xuICAgIHRoaXMucHVibGlzaGVyLnVwZGF0ZVNpZ25lck9yUHJvdmlkZXIobmV0d29yayk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSBtZXRhZGF0YVVyaVxuICAgKi9cbiAgYXN5bmMgZXh0cmFjdENvbnN0cnVjdG9yUGFyYW1zKG1ldGFkYXRhVXJpKSB7XG4gICAgcmV0dXJuIGV4dHJhY3RDb25zdHJ1Y3RvclBhcmFtcyhtZXRhZGF0YVVyaSwgdGhpcy5zdG9yYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHByZWRlcGxveU1ldGFkYXRhVXJpXG4gICAqL1xuICBhc3luYyBleHRyYWN0RnVuY3Rpb25zKHByZWRlcGxveU1ldGFkYXRhVXJpKSB7XG4gICAgcmV0dXJuIGV4dHJhY3RGdW5jdGlvbnMocHJlZGVwbG95TWV0YWRhdGFVcmksIHRoaXMuc3RvcmFnZSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSBwcmVkZXBsb3lVcmlcbiAgICovXG4gIGFzeW5jIGZldGNoQ29tcGlsZXJNZXRhZGF0YUZyb21QcmVkZXBsb3lVUkkocHJlZGVwbG95VXJpKSB7XG4gICAgcmV0dXJuIGZldGNoUHJlRGVwbG95TWV0YWRhdGEocHJlZGVwbG95VXJpLCB0aGlzLnN0b3JhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0gcHJlcHVibGlzaFVyaVxuICAgKiBAcGFyYW0gcHVibGlzaGVyQWRkcmVzc1xuICAgKi9cbiAgYXN5bmMgZmV0Y2hQcmVQdWJsaXNoTWV0YWRhdGEocHJlcHVibGlzaFVyaSwgcHVibGlzaGVyQWRkcmVzcykge1xuICAgIGNvbnN0IHByZURlcGxveU1ldGFkYXRhRmV0Y2hlZCA9IGF3YWl0IGZldGNoUHJlRGVwbG95TWV0YWRhdGEocHJlcHVibGlzaFVyaSwgdGhpcy5zdG9yYWdlKTtcbiAgICBjb25zdCBsYXRlc3RQdWJsaXNoZWRDb250cmFjdCA9IHB1Ymxpc2hlckFkZHJlc3MgPyBhd2FpdCB0aGlzLmdldExhdGVzdChwdWJsaXNoZXJBZGRyZXNzLCBwcmVEZXBsb3lNZXRhZGF0YUZldGNoZWQubmFtZSkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbGF0ZXN0UHVibGlzaGVkQ29udHJhY3RNZXRhZGF0YSA9IGxhdGVzdFB1Ymxpc2hlZENvbnRyYWN0ID8gYXdhaXQgdGhpcy5mZXRjaFB1Ymxpc2hlZENvbnRyYWN0SW5mbyhsYXRlc3RQdWJsaXNoZWRDb250cmFjdCkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByZURlcGxveU1ldGFkYXRhOiBwcmVEZXBsb3lNZXRhZGF0YUZldGNoZWQsXG4gICAgICBsYXRlc3RQdWJsaXNoZWRDb250cmFjdE1ldGFkYXRhXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICovXG4gIGFzeW5jIGZldGNoQ29tcGlsZXJNZXRhZGF0YUZyb21BZGRyZXNzKGFkZHJlc3MpIHtcbiAgICByZXR1cm4gZmV0Y2hDb250cmFjdE1ldGFkYXRhRnJvbUFkZHJlc3MoYWRkcmVzcywgdGhpcy5nZXRQcm92aWRlcigpLCB0aGlzLnN0b3JhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBHZXQgdGhlIGZ1bGwgaW5mb3JtYXRpb24gYWJvdXQgYSBwdWJsaXNoZWQgY29udHJhY3RcbiAgICogQHBhcmFtIGNvbnRyYWN0XG4gICAqL1xuICBhc3luYyBmZXRjaFB1Ymxpc2hlZENvbnRyYWN0SW5mbyhjb250cmFjdCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBjb250cmFjdC5pZCxcbiAgICAgIHB1Ymxpc2hlZFRpbWVzdGFtcDogY29udHJhY3QudGltZXN0YW1wLFxuICAgICAgcHVibGlzaGVkTWV0YWRhdGE6IGF3YWl0IHRoaXMuZmV0Y2hGdWxsUHVibGlzaE1ldGFkYXRhKGNvbnRyYWN0Lm1ldGFkYXRhVXJpKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSBwdWJsaXNoZWRNZXRhZGF0YVVyaVxuICAgKi9cbiAgYXN5bmMgZmV0Y2hGdWxsUHVibGlzaE1ldGFkYXRhKHB1Ymxpc2hlZE1ldGFkYXRhVXJpKSB7XG4gICAgcmV0dXJuIGZldGNoRXh0ZW5kZWRSZWxlYXNlTWV0YWRhdGEocHVibGlzaGVkTWV0YWRhdGFVcmksIHRoaXMuc3RvcmFnZSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIC8vIFRPRE8gZXhwb3NlIGEgcmVzb2x2ZVB1Ymxpc2hNZXRhZGF0YShjb250cmFjdEFkZHJlc3MsIGNoYWluSWQpIHRoYXQgaGFuZGxlcyB0aGUgZHVhbCBjaGFpbiBjYXNlXG4gICAqIC8vIFRPRE8gd2lsbCBiZSBlYXN5IHRvIGRvIHdpdGggdGhlIG11bHRpY2hhaW4gcGF0dGVybiBvZiAzLjBcbiAgICogQHBhcmFtIGNvbXBpbGVyTWV0YWRhdGFVcmlcbiAgICovXG4gIGFzeW5jIHJlc29sdmVQdWJsaXNoTWV0YWRhdGFGcm9tQ29tcGlsZXJNZXRhZGF0YShjb21waWxlck1ldGFkYXRhVXJpKSB7XG4gICAgY29uc3QgcHVibGlzaGVkTWV0YWRhdGFVcmkgPSBhd2FpdCB0aGlzLnB1Ymxpc2hlci5yZWFkQ29udHJhY3QuZ2V0UHVibGlzaGVkVXJpRnJvbUNvbXBpbGVyVXJpKGNvbXBpbGVyTWV0YWRhdGFVcmkpO1xuICAgIGlmIChwdWJsaXNoZWRNZXRhZGF0YVVyaS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IEVycm9yKGBDb3VsZCBub3QgcmVzb2x2ZSBwdWJsaXNoZWQgbWV0YWRhdGEgVVJJIGZyb20gJHtjb21waWxlck1ldGFkYXRhVXJpfWApO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocHVibGlzaGVkTWV0YWRhdGFVcmkuZmlsdGVyKHVyaSA9PiB1cmkubGVuZ3RoID4gMCkubWFwKHVyaSA9PiB0aGlzLmZldGNoRnVsbFB1Ymxpc2hNZXRhZGF0YSh1cmkpKSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFRPRE8gY2xlYW4gdGhpcyB1cCAoc2VlIG1ldGhvZCBhYm92ZSwgdG9vKVxuICAgKi9cbiAgYXN5bmMgcmVzb2x2ZUNvbnRyYWN0VXJpRnJvbUFkZHJlc3MoYWRkcmVzcykge1xuICAgIGNvbnN0IGNvbnRyYWN0VXJpID0gYXdhaXQgcmVzb2x2ZUNvbnRyYWN0VXJpRnJvbUFkZHJlc3MoYWRkcmVzcywgdGhpcy5nZXRQcm92aWRlcigpKTtcbiAgICBpbnZhcmlhbnQoY29udHJhY3RVcmksIFwiQ291bGQgbm90IHJlc29sdmUgY29udHJhY3QgVVJJIGZyb20gYWRkcmVzc1wiKTtcbiAgICByZXR1cm4gY29udHJhY3RVcmk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSBhZGRyZXNzXG4gICAqL1xuICBhc3luYyBmZXRjaENvbnRyYWN0U291cmNlc0Zyb21BZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuZmV0Y2hDb21waWxlck1ldGFkYXRhRnJvbUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgcmV0dXJuIGF3YWl0IGZldGNoU291cmNlRmlsZXNGcm9tTWV0YWRhdGEobWV0YWRhdGEsIHRoaXMuc3RvcmFnZSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSBwcm9maWxlTWV0YWRhdGFcbiAgICovXG4gIGFzeW5jIHVwZGF0ZVB1Ymxpc2hlclByb2ZpbGUocHJvZmlsZU1ldGFkYXRhKSB7XG4gICAgY29uc3Qgc2lnbmVyID0gdGhpcy5nZXRTaWduZXIoKTtcbiAgICBpbnZhcmlhbnQoc2lnbmVyLCBcIkEgc2lnbmVyIGlzIHJlcXVpcmVkXCIpO1xuICAgIGNvbnN0IHB1Ymxpc2hlciA9IGF3YWl0IHNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgY29uc3QgcHJvZmlsZVVyaSA9IGF3YWl0IHRoaXMuc3RvcmFnZS51cGxvYWQocHJvZmlsZU1ldGFkYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjZWlwdDogYXdhaXQgdGhpcy5wdWJsaXNoZXIuc2VuZFRyYW5zYWN0aW9uKFwic2V0UHVibGlzaGVyUHJvZmlsZVVyaVwiLCBbcHVibGlzaGVyLCBwcm9maWxlVXJpXSlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0gcHVibGlzaGVyQWRkcmVzc1xuICAgKi9cbiAgYXN5bmMgZ2V0UHVibGlzaGVyUHJvZmlsZShwdWJsaXNoZXJBZGRyZXNzKSB7XG4gICAgY29uc3QgcHJvZmlsZVVyaSA9IGF3YWl0IHRoaXMucHVibGlzaGVyLnJlYWRDb250cmFjdC5nZXRQdWJsaXNoZXJQcm9maWxlVXJpKHB1Ymxpc2hlckFkZHJlc3MpO1xuICAgIGlmICghcHJvZmlsZVVyaSB8fCBwcm9maWxlVXJpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByZXR1cm4gUHJvZmlsZVNjaGVtYU91dHB1dC5wYXJzZShhd2FpdCB0aGlzLnN0b3JhZ2UuZG93bmxvYWRKU09OKHByb2ZpbGVVcmkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHB1Ymxpc2hlckFkZHJlc3NcbiAgICovXG4gIGFzeW5jIGdldEFsbChwdWJsaXNoZXJBZGRyZXNzKSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMucHVibGlzaGVyLnJlYWRDb250cmFjdC5nZXRBbGxQdWJsaXNoZWRDb250cmFjdHMocHVibGlzaGVyQWRkcmVzcyk7XG4gICAgLy8gc2luY2Ugd2UgY2FuIGZldGNoIGZyb20gbXVsdGlwbGUgcHVibGlzaGVyIGNvbnRyYWN0cywganVzdCBrZWVwIHRoZSBsYXRlc3Qgb25lIGluIHRoZSBsaXN0XG4gICAgY29uc3QgbWFwID0gZGF0YS5yZWR1Y2UoKGFjYywgY3VycikgPT4ge1xuICAgICAgLy8gcmVwbGFjZXMgdGhlIHByZXZpb3VzIGNvbnRyYWN0IHdpdGggdGhlIGxhdGVzdCBvbmVcbiAgICAgIGFjY1tjdXJyLmNvbnRyYWN0SWRdID0gY3VycjtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhtYXApLm1hcChfcmVmID0+IHtcbiAgICAgIGxldCBbLCBzdHJ1Y3RdID0gX3JlZjtcbiAgICAgIHJldHVybiB0aGlzLnRvUHVibGlzaGVkQ29udHJhY3Qoc3RydWN0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHB1Ymxpc2hlckFkZHJlc3NcbiAgICogQHBhcmFtIGNvbnRyYWN0SWRcbiAgICovXG4gIGFzeW5jIGdldEFsbFZlcnNpb25zKHB1Ymxpc2hlckFkZHJlc3MsIGNvbnRyYWN0SWQpIHtcbiAgICBjb25zdCBjb250cmFjdFN0cnVjdHMgPSBhd2FpdCB0aGlzLnB1Ymxpc2hlci5yZWFkQ29udHJhY3QuZ2V0UHVibGlzaGVkQ29udHJhY3RWZXJzaW9ucyhwdWJsaXNoZXJBZGRyZXNzLCBjb250cmFjdElkKTtcbiAgICBpZiAoY29udHJhY3RTdHJ1Y3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJOb3QgZm91bmRcIik7XG4gICAgfVxuICAgIHJldHVybiBjb250cmFjdFN0cnVjdHMubWFwKGQgPT4gdGhpcy50b1B1Ymxpc2hlZENvbnRyYWN0KGQpKTtcbiAgfVxuICBhc3luYyBnZXRWZXJzaW9uKHB1Ymxpc2hlckFkZHJlc3MsIGNvbnRyYWN0SWQpIHtcbiAgICBsZXQgdmVyc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJsYXRlc3RcIjtcbiAgICBpZiAodmVyc2lvbiA9PT0gXCJsYXRlc3RcIikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KHB1Ymxpc2hlckFkZHJlc3MsIGNvbnRyYWN0SWQpO1xuICAgIH1cbiAgICBjb25zdCBhbGxWZXJzaW9ucyA9IGF3YWl0IHRoaXMuZ2V0QWxsVmVyc2lvbnMocHVibGlzaGVyQWRkcmVzcywgY29udHJhY3RJZCk7XG4gICAgLy8gZ2V0IHRoZSBtZXRhZGF0YSBmb3IgZWFjaCB2ZXJzaW9uXG4gICAgY29uc3QgdmVyc2lvbk1ldGFkYXRhID0gYXdhaXQgUHJvbWlzZS5hbGwoYWxsVmVyc2lvbnMubWFwKGNvbnRyYWN0ID0+IHRoaXMuZmV0Y2hQdWJsaXNoZWRDb250cmFjdEluZm8oY29udHJhY3QpKSk7XG4gICAgLy8gZmluZCB0aGUgdmVyc2lvbiB0aGF0IG1hdGNoZXMgdGhlIHZlcnNpb24gc3RyaW5nXG4gICAgY29uc3QgdmVyc2lvbk1hdGNoID0gdmVyc2lvbk1ldGFkYXRhLmZpbmQobWV0YWRhdGEgPT4gbWV0YWRhdGEucHVibGlzaGVkTWV0YWRhdGEudmVyc2lvbiA9PT0gdmVyc2lvbik7XG4gICAgaW52YXJpYW50KHZlcnNpb25NYXRjaCwgXCJDb250cmFjdCB2ZXJzaW9uIG5vdCBmb3VuZFwiKTtcbiAgICAvLyBtYXRjaCB0aGUgdmVyc2lvbiBiYWNrIHRvIHRoZSBjb250cmFjdCBiYXNlZCBvbiB0aGUgcmVsZWFzZSB0aW1lc3RhbXBcbiAgICByZXR1cm4gYWxsVmVyc2lvbnMuZmluZChjb250cmFjdCA9PiBjb250cmFjdC50aW1lc3RhbXAgPT09IHZlcnNpb25NYXRjaC5wdWJsaXNoZWRUaW1lc3RhbXApO1xuICB9XG4gIGFzeW5jIGdldExhdGVzdChwdWJsaXNoZXJBZGRyZXNzLCBjb250cmFjdElkKSB7XG4gICAgY29uc3QgbW9kZWwgPSBhd2FpdCB0aGlzLnB1Ymxpc2hlci5yZWFkQ29udHJhY3QuZ2V0UHVibGlzaGVkQ29udHJhY3QocHVibGlzaGVyQWRkcmVzcywgY29udHJhY3RJZCk7XG4gICAgaWYgKG1vZGVsICYmIG1vZGVsLnB1Ymxpc2hNZXRhZGF0YVVyaSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9QdWJsaXNoZWRDb250cmFjdChtb2RlbCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgYXN5bmMgcHVibGlzaChwcmVkZXBsb3lVcmksIGV4dHJhTWV0YWRhdGEpIHtcbiAgICBjb25zdCBzaWduZXIgPSB0aGlzLmdldFNpZ25lcigpO1xuICAgIGludmFyaWFudChzaWduZXIsIFwiQSBzaWduZXIgaXMgcmVxdWlyZWRcIik7XG4gICAgY29uc3QgcHVibGlzaGVyID0gYXdhaXQgc2lnbmVyLmdldEFkZHJlc3MoKTtcbiAgICBjb25zdCBwcmVkZXBsb3lNZXRhZGF0YSA9IGF3YWl0IGZldGNoUmF3UHJlZGVwbG95TWV0YWRhdGEocHJlZGVwbG95VXJpLCB0aGlzLnN0b3JhZ2UpO1xuXG4gICAgLy8gZW5zdXJlIHZlcnNpb24gaXMgaW5jcmVtZW50YWxcbiAgICBjb25zdCBsYXRlc3RDb250cmFjdCA9IGF3YWl0IHRoaXMuZ2V0TGF0ZXN0KHB1Ymxpc2hlciwgcHJlZGVwbG95TWV0YWRhdGEubmFtZSk7XG4gICAgaWYgKGxhdGVzdENvbnRyYWN0ICYmIGxhdGVzdENvbnRyYWN0Lm1ldGFkYXRhVXJpKSB7XG4gICAgICBjb25zdCBsYXRlc3RNZXRhZGF0YSA9IGF3YWl0IHRoaXMuZmV0Y2hQdWJsaXNoZWRDb250cmFjdEluZm8obGF0ZXN0Q29udHJhY3QpO1xuICAgICAgY29uc3QgbGF0ZXN0VmVyc2lvbiA9IGxhdGVzdE1ldGFkYXRhLnB1Ymxpc2hlZE1ldGFkYXRhLnZlcnNpb247XG4gICAgICBpZiAoIWlzSW5jcmVtZW50YWxWZXJzaW9uKGxhdGVzdFZlcnNpb24sIGV4dHJhTWV0YWRhdGEudmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFZlcnNpb24gJHtleHRyYU1ldGFkYXRhLnZlcnNpb259IGlzIG5vdCBncmVhdGVyIHRoYW4gJHtsYXRlc3RWZXJzaW9ufWApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmZXRjaGVkQnl0ZWNvZGUgPSBhd2FpdCAoYXdhaXQgdGhpcy5zdG9yYWdlLmRvd25sb2FkKHByZWRlcGxveU1ldGFkYXRhLmJ5dGVjb2RlVXJpKSkudGV4dCgpO1xuICAgIGNvbnN0IGJ5dGVjb2RlID0gZmV0Y2hlZEJ5dGVjb2RlLnN0YXJ0c1dpdGgoXCIweFwiKSA/IGZldGNoZWRCeXRlY29kZSA6IGAweCR7ZmV0Y2hlZEJ5dGVjb2RlfWA7XG4gICAgY29uc3QgYnl0ZWNvZGVIYXNoID0gdXRpbHMuc29saWRpdHlLZWNjYWsyNTYoW1wiYnl0ZXNcIl0sIFtieXRlY29kZV0pO1xuICAgIGNvbnN0IGNvbnRyYWN0SWQgPSBwcmVkZXBsb3lNZXRhZGF0YS5uYW1lO1xuICAgIGNvbnN0IGZ1bGxNZXRhZGF0YSA9IEZ1bGxQdWJsaXNoTWV0YWRhdGFTY2hlbWFJbnB1dC5wYXJzZSh7XG4gICAgICAuLi5leHRyYU1ldGFkYXRhLFxuICAgICAgbWV0YWRhdGFVcmk6IHByZWRlcGxveU1ldGFkYXRhLm1ldGFkYXRhVXJpLFxuICAgICAgYnl0ZWNvZGVVcmk6IHByZWRlcGxveU1ldGFkYXRhLmJ5dGVjb2RlVXJpLFxuICAgICAgbmFtZTogcHJlZGVwbG95TWV0YWRhdGEubmFtZSxcbiAgICAgIGFuYWx5dGljczogcHJlZGVwbG95TWV0YWRhdGEuYW5hbHl0aWNzLFxuICAgICAgcHVibGlzaGVyXG4gICAgfSk7XG4gICAgY29uc3QgZnVsbE1ldGFkYXRhVXJpID0gYXdhaXQgdGhpcy5zdG9yYWdlLnVwbG9hZChmdWxsTWV0YWRhdGEpO1xuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnB1Ymxpc2hlci5zZW5kVHJhbnNhY3Rpb24oXCJwdWJsaXNoQ29udHJhY3RcIiwgW3B1Ymxpc2hlciwgY29udHJhY3RJZCwgZnVsbE1ldGFkYXRhVXJpLCBwcmVkZXBsb3lNZXRhZGF0YS5tZXRhZGF0YVVyaSwgYnl0ZWNvZGVIYXNoLCBjb25zdGFudHMuQWRkcmVzc1plcm9dKTtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLnB1Ymxpc2hlci5wYXJzZUxvZ3MoXCJDb250cmFjdFB1Ymxpc2hlZFwiLCByZWNlaXB0LmxvZ3MpO1xuICAgIGlmIChldmVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gQ29udHJhY3RQdWJsaXNoZWQgZXZlbnQgZm91bmRcIik7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRyYWN0ID0gZXZlbnRzWzBdLmFyZ3MucHVibGlzaGVkQ29udHJhY3Q7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQsXG4gICAgICBkYXRhOiBhc3luYyAoKSA9PiB0aGlzLnRvUHVibGlzaGVkQ29udHJhY3QoY29udHJhY3QpXG4gICAgfTtcbiAgfVxuICBhc3luYyB1bnB1Ymxpc2gocHVibGlzaGVyLCBjb250cmFjdElkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMucHVibGlzaGVyLnNlbmRUcmFuc2FjdGlvbihcInVucHVibGlzaENvbnRyYWN0XCIsIFtwdWJsaXNoZXIsIGNvbnRyYWN0SWRdKVxuICAgIH07XG4gIH1cbiAgdG9QdWJsaXNoZWRDb250cmFjdChjb250cmFjdE1vZGVsKSB7XG4gICAgcmV0dXJuIFB1Ymxpc2hlZENvbnRyYWN0U2NoZW1hLnBhcnNlKHtcbiAgICAgIGlkOiBjb250cmFjdE1vZGVsLmNvbnRyYWN0SWQsXG4gICAgICB0aW1lc3RhbXA6IGNvbnRyYWN0TW9kZWwucHVibGlzaFRpbWVzdGFtcCxcbiAgICAgIG1ldGFkYXRhVXJpOiBjb250cmFjdE1vZGVsLnB1Ymxpc2hNZXRhZGF0YVVyaVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICpcbiAqIHtAbGluayBVc2VyV2FsbGV0fSBldmVudHMgdGhhdCB5b3UgY2FuIHN1YnNjcmliZSB0byB1c2luZyBgc2RrLndhbGxldC5ldmVudHNgLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIENvbm5lY3QgYW5kIEludGVyYWN0IHdpdGggYSB1c2VyIHdhbGxldFxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBzZGsud2FsbGV0LmJhbGFuY2UoKTtcbiAqIGBgYFxuICogQHB1YmxpY1xuICovXG5jbGFzcyBVc2VyV2FsbGV0IHtcbiAgY29uc3RydWN0b3IobmV0d29yaywgb3B0aW9ucykge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbm5lY3Rpb25cIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcHRpb25zXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZXZlbnRzXCIsIG5ldyBFdmVudEVtaXR0ZXIoKSk7XG4gICAgdGhpcy5jb25uZWN0aW9uID0gbmV3IFJQQ0Nvbm5lY3Rpb25IYW5kbGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5ldmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIH1cblxuICAvLyBUT0RPIGRpc2Nvbm5lY3QoKVxuICAvLyBUT0RPIHN3aXRjaENoYWluKClcbiAgLy8gVE9ETyB0b2tlbnMoKVxuICAvLyBUT0RPIE5GVHMoKVxuXG4gIC8vIFRPRE8gdGhpcyB3aWxsIGJlY29tZSB0aGUgc291cmNlIG9mIHRydXRoIG9mIHRoZSBzaWduZXIgYW5kIGhhdmUgZXZlcnkgY29udHJhY3QgcmVhZCBmcm9tIGl0XG4gIC8vIFRPRE8gc2VwYXJhdGUgc2lnbmVyIGFuZCBwcm92aWRlciBsb2dpY3NcbiAgY29ubmVjdChuZXR3b3JrKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uLnVwZGF0ZVNpZ25lck9yUHJvdmlkZXIobmV0d29yayk7XG4gICAgdGhpcy5ldmVudHMuZW1pdChcInNpZ25lckNoYW5nZWRcIiwgdGhpcy5jb25uZWN0aW9uLmdldFNpZ25lcigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2ZlciBuYXRpdmUgb3IgRVJDMjAgdG9rZW5zIGZyb20gdGhpcyB3YWxsZXQgdG8gYW5vdGhlciB3YWxsZXRcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAgLy8gdHJhbnNmZXIgMC44IEVUSFxuICAgKiBhd2FpdCBzZGsud2FsbGV0LnRyYW5zZmVyKFwiMHguLi5cIiwgMC44KTtcbiAgICogIC8vIHRyYW5zZmVyIDAuOCB0b2tlbnMgb2YgYHRva2VuQ29udHJhY3RBZGRyZXNzYFxuICAgKiBhd2FpdCBzZGsud2FsbGV0LnRyYW5zZmVyKFwiMHguLi5cIiwgMC44LCB0b2tlbkNvbnRyYWN0QWRkcmVzcyk7XG4gICAqIGBgYFxuICAgKiBAcGFyYW0gdG8gLSB0aGUgYWNjb3VudCB0byBzZW5kIGZ1bmRzIHRvXG4gICAqIEBwYXJhbSBhbW91bnQgLSB0aGUgYW1vdW50IGluIHRva2Vuc1xuICAgKiBAcGFyYW0gY3VycmVuY3lBZGRyZXNzIC0gT3B0aW9uYWwgLSBFUkMyMCBjb250cmFjdCBhZGRyZXNzIG9mIHRoZSB0b2tlbiB0byB0cmFuc2ZlclxuICAgKi9cbiAgYXN5bmMgdHJhbnNmZXIodG8sIGFtb3VudCkge1xuICAgIGxldCBjdXJyZW5jeUFkZHJlc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IE5BVElWRV9UT0tFTl9BRERSRVNTO1xuICAgIGNvbnN0IHNpZ25lciA9IHRoaXMucmVxdWlyZVdhbGxldCgpO1xuICAgIGNvbnN0IGFtb3VudEluV2VpID0gYXdhaXQgbm9ybWFsaXplUHJpY2VWYWx1ZSh0aGlzLmNvbm5lY3Rpb24uZ2V0UHJvdmlkZXIoKSwgYW1vdW50LCBjdXJyZW5jeUFkZHJlc3MpO1xuICAgIGlmIChpc05hdGl2ZVRva2VuKGN1cnJlbmN5QWRkcmVzcykpIHtcbiAgICAgIC8vIG5hdGl2ZSB0b2tlbiB0cmFuc2ZlclxuICAgICAgY29uc3QgZnJvbSA9IGF3YWl0IHNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IHNpZ25lci5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICBmcm9tLFxuICAgICAgICB0byxcbiAgICAgICAgdmFsdWU6IGFtb3VudEluV2VpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlY2VpcHQ6IGF3YWl0IHR4LndhaXQoKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRVJDMjAgdG9rZW4gdHJhbnNmZXJcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMuY3JlYXRlRXJjMjAoY3VycmVuY3lBZGRyZXNzKS5zZW5kVHJhbnNhY3Rpb24oXCJ0cmFuc2ZlclwiLCBbdG8sIGFtb3VudEluV2VpXSlcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBuYXRpdmUgb3IgRVJDMjAgdG9rZW4gYmFsYW5jZSBvZiB0aGlzIHdhbGxldFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIG5hdGl2ZSBjdXJyZW5jeSBiYWxhbmNlXG4gICAqIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBzZGsud2FsbGV0LmJhbGFuY2UoKTtcbiAgICogLy8gRVJDMjAgdG9rZW4gYmFsYW5jZVxuICAgKiBjb25zdCBlcmMyMGJhbGFuY2UgPSBhd2FpdCBzZGsud2FsbGV0LmJhbGFuY2UodG9rZW5Db250cmFjdEFkZHJlc3MpO1xuICAgKlxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGJhbGFuY2UoKSB7XG4gICAgbGV0IGN1cnJlbmN5QWRkcmVzcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogTkFUSVZFX1RPS0VOX0FERFJFU1M7XG4gICAgdGhpcy5yZXF1aXJlV2FsbGV0KCk7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmNvbm5lY3Rpb24uZ2V0UHJvdmlkZXIoKTtcbiAgICBsZXQgYmFsYW5jZTtcbiAgICBpZiAoaXNOYXRpdmVUb2tlbihjdXJyZW5jeUFkZHJlc3MpKSB7XG4gICAgICBiYWxhbmNlID0gYXdhaXQgcHJvdmlkZXIuZ2V0QmFsYW5jZShhd2FpdCB0aGlzLmdldEFkZHJlc3MoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhbGFuY2UgPSBhd2FpdCB0aGlzLmNyZWF0ZUVyYzIwKGN1cnJlbmN5QWRkcmVzcykucmVhZENvbnRyYWN0LmJhbGFuY2VPZihhd2FpdCB0aGlzLmdldEFkZHJlc3MoKSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBmZXRjaEN1cnJlbmN5VmFsdWUocHJvdmlkZXIsIGN1cnJlbmN5QWRkcmVzcywgYmFsYW5jZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50bHkgY29ubmVjdGVkIGFkZHJlc3NcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBhZGRyZXNzID0gYXdhaXQgc2RrLndhbGxldC5nZXRBZGRyZXNzKCk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZ2V0QWRkcmVzcygpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXF1aXJlV2FsbGV0KCkuZ2V0QWRkcmVzcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudGx5IGNvbm5lY3RlZCB3YWxsZXQncyBjaGFpbklkXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgZ2V0Q2hhaW5JZCgpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXF1aXJlV2FsbGV0KCkuZ2V0Q2hhaW5JZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZXJlJ3MgYSBzaWduZXIgY29ubmVjdGVkIHdpdGggdGhlIFNES1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGlzQ29ubmVjdGVkKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnJlcXVpcmVXYWxsZXQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBhbnkgbWVzc2FnZSB3aXRoIHRoZSBjb25uZWN0ZWQgd2FsbGV0IHByaXZhdGUga2V5XG4gICAqIEBwYXJhbSBtZXNzYWdlIC0gdGhlIG1lc3NhZ2UgdG8gc2lnblxuICAgKiBAcmV0dXJucyB0aGUgc2lnbmVkIG1lc3NhZ2VcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBUaGlzIGlzIHRoZSBtZXNzYWdlIHRvIGJlIHNpZ25lZFxuICAgKiBjb25zdCBtZXNzYWdlID0gXCJTaWduIHRoaXMgbWVzc2FnZS4uLlwiO1xuICAgKlxuICAgKiAvLyBOb3cgd2UgY2FuIHNpZ24gdGhlIG1lc3NhZ2Ugd2l0aCB0aGUgY29ubmVjdGVkIHdhbGxldFxuICAgKiBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzZGsud2FsbGV0LnNpZ24obWVzc2FnZSk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgc2lnbihtZXNzYWdlKSB7XG4gICAgY29uc3Qgc2lnbmVyID0gdGhpcy5yZXF1aXJlV2FsbGV0KCk7XG4gICAgcmV0dXJuIGF3YWl0IHNpZ25lci5zaWduTWVzc2FnZShtZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvdmVyIHRoZSBzaWduaW5nIGFkZHJlc3MgZnJvbSBhIHNpZ25lZCBtZXNzYWdlXG4gICAqIEBwYXJhbSBtZXNzYWdlIC0gdGhlIG9yaWdpbmFsIG1lc3NhZ2UgdGhhdCB3YXMgc2lnbmVkXG4gICAqIEBwYXJhbSBzaWduYXR1cmUgLSB0aGUgc2lnbmF0dXJlIHRvIHJlY292ZXIgdGhlIGFkZHJlc3MgZnJvbVxuICAgKiBAcmV0dXJucyB0aGUgYWRkcmVzcyB0aGF0IHNpZ25lZCB0aGUgbWVzc2FnZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IG1lc3NhZ2UgPSBcIlNpZ24gdGhpcyBtZXNzYWdlLi4uXCI7XG4gICAqIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNkay53YWxsZXQuc2lnbihtZXNzYWdlKTtcbiAgICpcbiAgICogLy8gTm93IHdlIGNhbiByZWNvdmVyIHRoZSBzaWduaW5nIGFkZHJlc3NcbiAgICogY29uc3QgYWRkcmVzcyA9IHNkay53YWxsZXQucmVjb3ZlckFkZHJlc3MobWVzc2FnZSwgc2lnbmF0dXJlKTtcbiAgICogYGBgXG4gICAqL1xuICByZWNvdmVyQWRkcmVzcyhtZXNzYWdlLCBzaWduYXR1cmUpIHtcbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IGV0aGVycy51dGlscy5oYXNoTWVzc2FnZShtZXNzYWdlKTtcbiAgICBjb25zdCBtZXNzYWdlSGFzaEJ5dGVzID0gZXRoZXJzLnV0aWxzLmFycmF5aWZ5KG1lc3NhZ2VIYXNoKTtcbiAgICByZXR1cm4gZXRoZXJzLnV0aWxzLnJlY292ZXJBZGRyZXNzKG1lc3NhZ2VIYXNoQnl0ZXMsIHNpZ25hdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHJhdyB0cmFuc2FjdGlvbiB0byB0aGUgYmxvY2tjaGFpbiBmcm9tIHRoZSBjb25uZWN0ZWQgd2FsbGV0XG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvblJlcXVlc3QgLSByYXcgdHJhbnNhY3Rpb24gZGF0YSB0byBzZW5kIHRvIHRoZSBibG9ja2NoYWluXG4gICAqL1xuICBhc3luYyBzZW5kUmF3VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25SZXF1ZXN0KSB7XG4gICAgY29uc3Qgc2lnbmVyID0gdGhpcy5yZXF1aXJlV2FsbGV0KCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCBzaWduZXIuc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uUmVxdWVzdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHR4LndhaXQoKVxuICAgIH07XG4gIH1cblxuICAvKiogKioqKioqKioqKioqKioqKioqKioqKipcbiAgICogUFJJVkFURSBGVU5DVElPTlNcbiAgICogKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgcmVxdWlyZVdhbGxldCgpIHtcbiAgICBjb25zdCBzaWduZXIgPSB0aGlzLmNvbm5lY3Rpb24uZ2V0U2lnbmVyKCk7XG4gICAgaW52YXJpYW50KHNpZ25lciwgXCJUaGlzIGFjdGlvbiByZXF1aXJlcyBhIGNvbm5lY3RlZCB3YWxsZXQuIFBsZWFzZSBwYXNzIGEgdmFsaWQgc2lnbmVyIHRvIHRoZSBTREsuXCIpO1xuICAgIHJldHVybiBzaWduZXI7XG4gIH1cbiAgY3JlYXRlRXJjMjAoY3VycmVuY3lBZGRyZXNzKSB7XG4gICAgcmV0dXJuIG5ldyBDb250cmFjdFdyYXBwZXIodGhpcy5jb25uZWN0aW9uLmdldFNpZ25lck9yUHJvdmlkZXIoKSwgY3VycmVuY3lBZGRyZXNzLCBFUkMyMEFiaSwgdGhpcy5vcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBtYWluIGVudHJ5IHBvaW50IGZvciB0aGUgdGhpcmR3ZWIgU0RLXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFRoaXJkd2ViU0RLIGV4dGVuZHMgUlBDQ29ubmVjdGlvbkhhbmRsZXIge1xuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIG9mIHRoZSB0aGlyZHdlYiBTREsgYmFzZWQgb24gYW4gQWJzdHJhY3RXYWxsZXRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBpbXBvcnQgeyBUaGlyZHdlYlNESyB9IGZyb20gXCJAdGhpcmR3ZWItZGV2L3Nka1wiXG4gICAqXG4gICAqIGNvbnN0IHdhbGxldCA9IG5ldyBBYnN0cmFjdFdhbGxldEltcGxlbWVudGF0aW9uKCk7XG4gICAqIGNvbnN0IHNkayA9IGF3YWl0IFRoaXJkd2ViU0RLLmZyb21XYWxsZXQod2FsbGV0LCBcIm1haW5uZXRcIik7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gd2FsbGV0IC0gdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBBYnN0cmFjdFdhbGxldCBjbGFzcyB0byB1c2UgZm9yIHNpZ25pbmdcbiAgICogQHBhcmFtIG5ldHdvcmsgLSB0aGUgbmV0d29yayAoY2hhaW4pIHRvIGNvbm5lY3QgdG8gKGUuZy4gXCJtYWlubmV0XCIsIFwicmlua2VieVwiLCBcInBvbHlnb25cIiwgXCJtdW1iYWlcIi4uLikgb3IgYSBmdWxseSBmb3JtZWQgUlBDIHVybFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHRoZSBTREsgb3B0aW9ucyB0byB1c2VcbiAgICogQHBhcmFtIHN0b3JhZ2UgLSBvcHRpb25hbCBzdG9yYWdlIGltcGxlbWVudGF0aW9uIHRvIHVzZVxuICAgKiBAcmV0dXJucyBhbiBpbnN0YW5jZSBvZiB0aGUgU0RLXG4gICAqXG4gICAqIEBiZXRhXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZnJvbVdhbGxldCh3YWxsZXQsIG5ldHdvcmspIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgbGV0IHN0b3JhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG5ldyBUaGlyZHdlYlN0b3JhZ2UoKTtcbiAgICBjb25zdCBzaWduZXJPclByb3ZpZGVyID0gZ2V0UHJvdmlkZXJGb3JOZXR3b3JrKG5ldHdvcmspO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gU2lnbmVyLmlzU2lnbmVyKHNpZ25lck9yUHJvdmlkZXIpID8gc2lnbmVyT3JQcm92aWRlci5wcm92aWRlciA6IHR5cGVvZiBzaWduZXJPclByb3ZpZGVyID09PSBcInN0cmluZ1wiID8gZ2V0UmVhZE9ubHlQcm92aWRlcihzaWduZXJPclByb3ZpZGVyKSA6IHNpZ25lck9yUHJvdmlkZXI7XG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgd2FsbGV0LmdldFNpZ25lcihwcm92aWRlcik7XG4gICAgcmV0dXJuIFRoaXJkd2ViU0RLLmZyb21TaWduZXIoc2lnbmVyLCBuZXR3b3JrLCBvcHRpb25zLCBzdG9yYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugb2YgdGhlIHRoaXJkd2ViIFNESyBiYXNlZCBvbiBhbiBleGlzdGluZyBldGhlcnMgc2lnbmVyXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gZ2V0IGEgc2lnbmVyIGZyb20gc29tZXdoZXJlIChjcmVhdGVSYW5kb20gaXMgYmVpbmcgdXNlZCBwdXJlbHkgZm9yIGV4YW1wbGUgcHVycG9zZXMpXG4gICAqIGNvbnN0IHNpZ25lciA9IGV0aGVycy5XYWxsZXQuY3JlYXRlUmFuZG9tKCk7XG4gICAqXG4gICAqIC8vIGdldCBhbiBpbnN0YW5jZSBvZiB0aGUgU0RLIHdpdGggdGhlIHNpZ25lciBhbHJlYWR5IHNldHVwXG4gICAqIGNvbnN0IHNkayA9IFRoaXJkd2ViU0RLLmZyb21TaWduZXIoc2lnbmVyLCBcIm1haW5uZXRcIik7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gc2lnbmVyIC0gYSBldGhlcnMgU2lnbmVyIHRvIGJlIHVzZWQgZm9yIHRyYW5zYWN0aW9uc1xuICAgKiBAcGFyYW0gbmV0d29yayAtIHRoZSBuZXR3b3JrIChjaGFpbikgdG8gY29ubmVjdCB0byAoZS5nLiBcIm1haW5uZXRcIiwgXCJyaW5rZWJ5XCIsIFwicG9seWdvblwiLCBcIm11bWJhaVwiLi4uKSBvciBhIGZ1bGx5IGZvcm1lZCBSUEMgdXJsXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gdGhlIFNESyBvcHRpb25zIHRvIHVzZVxuICAgKiBAcGFyYW0gc3RvcmFnZSAtIG9wdGlvbmFsIHN0b3JhZ2UgaW1wbGVtZW50YXRpb24gdG8gdXNlXG4gICAqIEByZXR1cm5zIGFuIGluc3RhbmNlIG9mIHRoZSBTREtcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIHN0YXRpYyBmcm9tU2lnbmVyKHNpZ25lciwgbmV0d29yaykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBsZXQgc3RvcmFnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbmV3IFRoaXJkd2ViU3RvcmFnZSgpO1xuICAgIGNvbnN0IHNkayA9IG5ldyBUaGlyZHdlYlNESyhuZXR3b3JrIHx8IHNpZ25lciwgb3B0aW9ucywgc3RvcmFnZSk7XG4gICAgc2RrLnVwZGF0ZVNpZ25lck9yUHJvdmlkZXIoc2lnbmVyKTtcbiAgICByZXR1cm4gc2RrO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSBvZiB0aGUgdGhpcmR3ZWIgU0RLIGJhc2VkIG9uIGEgcHJpdmF0ZSBrZXkuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgYmFja2VuZCBzZXJ2aWNlcyBvciBzY3JpcHRzLCB3aXRoIHRoZSBwcml2YXRlIGtleSBzdG9yZWQgaW4gYSBzZWN1cmUgd2F5LlxuICAgKiAqKk5FVkVSKiogZXhwb3NlIHlvdXIgcHJpdmF0ZSBrZXkgdG8gdGhlIHB1YmxpYyBpbiBhbnkgd2F5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IHNkayA9IFRoaXJkd2ViU0RLLmZyb21Qcml2YXRlS2V5KFwiU2VjcmV0UHJpdmF0ZUtleVwiLCBcIm1haW5uZXRcIik7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gcHJpdmF0ZUtleSAtIHRoZSBwcml2YXRlIGtleSAtICoqRE8gTk9UIEVYUE9TRSBUSElTIFRPIFRIRSBQVUJMSUMqKlxuICAgKiBAcGFyYW0gbmV0d29yayAtIHRoZSBuZXR3b3JrIChjaGFpbikgdG8gY29ubmVjdCB0byAoZS5nLiBcIm1haW5uZXRcIiwgXCJyaW5rZWJ5XCIsIFwicG9seWdvblwiLCBcIm11bWJhaVwiLi4uKSBvciBhIGZ1bGx5IGZvcm1lZCBSUEMgdXJsXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gdGhlIFNESyBvcHRpb25zIHRvIHVzZVxuICAgKiBAcGFyYW0gc3RvcmFnZSAtIG9wdGlvbmFsIHN0b3JhZ2UgaW1wbGVtZW50YXRpb24gdG8gdXNlXG4gICAqIEByZXR1cm5zIGFuIGluc3RhbmNlIG9mIHRoZSBTREtcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5LCBuZXR3b3JrKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGxldCBzdG9yYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBuZXcgVGhpcmR3ZWJTdG9yYWdlKCk7XG4gICAgY29uc3Qgc2lnbmVyT3JQcm92aWRlciA9IGdldFByb3ZpZGVyRm9yTmV0d29yayhuZXR3b3JrKTtcbiAgICBjb25zdCBwcm92aWRlciA9IFNpZ25lci5pc1NpZ25lcihzaWduZXJPclByb3ZpZGVyKSA/IHNpZ25lck9yUHJvdmlkZXIucHJvdmlkZXIgOiB0eXBlb2Ygc2lnbmVyT3JQcm92aWRlciA9PT0gXCJzdHJpbmdcIiA/IGdldFJlYWRPbmx5UHJvdmlkZXIoc2lnbmVyT3JQcm92aWRlcikgOiBzaWduZXJPclByb3ZpZGVyO1xuICAgIGNvbnN0IHNpZ25lciA9IG5ldyBldGhlcnMuV2FsbGV0KHByaXZhdGVLZXksIHByb3ZpZGVyKTtcbiAgICByZXR1cm4gVGhpcmR3ZWJTREsuZnJvbVNpZ25lcihzaWduZXIsIG5ldHdvcmssIG9wdGlvbnMsIHN0b3JhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiB0aGUgY2FjaGUgb2YgY29udHJhY3RzIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IHNlZW5cbiAgICovXG5cbiAgY29uc3RydWN0b3IobmV0d29yaykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBsZXQgc3RvcmFnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbmV3IFRoaXJkd2ViU3RvcmFnZSgpO1xuICAgIGNvbnN0IHNpZ25lck9yUHJvdmlkZXIgPSBnZXRQcm92aWRlckZvck5ldHdvcmsobmV0d29yayk7XG4gICAgc3VwZXIoc2lnbmVyT3JQcm92aWRlciwgb3B0aW9ucyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RDYWNoZVwiLCBuZXcgTWFwKCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wdWJsaXNoZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yYWdlSGFuZGxlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlcGxveWVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2FsbGV0XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcmFnZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dGhcIiwgdm9pZCAwKTtcbiAgICB0aGlzLnN0b3JhZ2VIYW5kbGVyID0gc3RvcmFnZTtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgIHRoaXMud2FsbGV0ID0gbmV3IFVzZXJXYWxsZXQoc2lnbmVyT3JQcm92aWRlciwgb3B0aW9ucyk7XG4gICAgdGhpcy5kZXBsb3llciA9IG5ldyBDb250cmFjdERlcGxveWVyKHNpZ25lck9yUHJvdmlkZXIsIG9wdGlvbnMsIHN0b3JhZ2UpO1xuICAgIHRoaXMuYXV0aCA9IG5ldyBXYWxsZXRBdXRoZW50aWNhdG9yKHNpZ25lck9yUHJvdmlkZXIsIHRoaXMud2FsbGV0LCBvcHRpb25zKTtcbiAgICB0aGlzLl9wdWJsaXNoZXIgPSBuZXcgQ29udHJhY3RQdWJsaXNoZXIoc2lnbmVyT3JQcm92aWRlciwgdGhpcy5vcHRpb25zLCB0aGlzLnN0b3JhZ2VIYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugb2YgYSBORlQgRHJvcCBjb250cmFjdFxuICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gdGhlIGFkZHJlc3Mgb2YgdGhlIGRlcGxveWVkIGNvbnRyYWN0XG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciB2ZXJzaW9uLiBZb3Ugc2hvdWxkIHVzZSB7QGxpbmsgZ2V0Q29udHJhY3R9IGluc3RlYWQuXG4gICAqIGBgYGRpZmZcbiAgICogLSBjb25zdCBkcm9wQ29udHJhY3QgPSBhd2FpdCBzZGsuZ2V0RHJvcENvbnRyYWN0KFwiMHgxMjM0Li4uXCIpO1xuICAgKiArIGNvbnN0IGRyb3BDb250cmFjdCA9IGF3YWl0IHNkay5nZXRDb250cmFjdChcIjB4MTIzNC4uLlwiLCBcIm5mdC1kcm9wXCIpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGdldE5GVERyb3AoY29udHJhY3RBZGRyZXNzKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0Q29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBcIm5mdC1kcm9wXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSBvZiBhIFNpZ25hdHVyZSBEcm9wIGNvbnRyYWN0XG4gICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSB0aGUgYWRkcmVzcyBvZiB0aGUgZGVwbG95ZWQgY29udHJhY3RcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHZlcnNpb24uIFlvdSBzaG91bGQgdXNlIHtAbGluayBnZXRDb250cmFjdH0gaW5zdGVhZC5cbiAgICogYGBgZGlmZlxuICAgKiAtIGNvbnN0IHNpZ25hdHVyZURyb3AgPSBhd2FpdCBzZGsuZ2V0U2lnbmF0dXJlRHJvcChcIjB4MTIzNC4uLlwiKTtcbiAgICogKyBjb25zdCBzaWduYXR1cmVEcm9wID0gYXdhaXQgc2RrLmdldENvbnRyYWN0KFwiMHgxMjM0Li4uXCIsIFwic2lnbmF0dXJlLWRyb3BcIik7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZ2V0U2lnbmF0dXJlRHJvcChjb250cmFjdEFkZHJlc3MpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRDb250cmFjdChjb250cmFjdEFkZHJlc3MsIFwic2lnbmF0dXJlLWRyb3BcIik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIG9mIGEgTkZUIENvbGxlY3Rpb24gRHJvcCBjb250cmFjdFxuICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gdGhlIGFkZHJlc3Mgb2YgdGhlIGRlcGxveWVkIGNvbnRyYWN0XG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciB2ZXJzaW9uLiBZb3Ugc2hvdWxkIHVzZSB7QGxpbmsgZ2V0Q29udHJhY3R9IGluc3RlYWQuXG4gICAqIGBgYGRpZmZcbiAgICogLSBjb25zdCBzaWduYXR1cmVEcm9wID0gYXdhaXQgc2RrLmdldE5GVENvbGxlY3Rpb24oXCIweDEyMzQuLi5cIik7XG4gICAqICsgY29uc3Qgc2lnbmF0dXJlRHJvcCA9IGF3YWl0IHNkay5nZXRDb250cmFjdChcIjB4MTIzNC4uLlwiLCBcIm5mdC1jb2xsZWN0aW9uXCIpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGdldE5GVENvbGxlY3Rpb24oY29udHJhY3RBZGRyZXNzKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0Q29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBcIm5mdC1jb2xsZWN0aW9uXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSBvZiBhIEVkaXRpb24gRHJvcCBjb250cmFjdFxuICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gdGhlIGFkZHJlc3Mgb2YgdGhlIGRlcGxveWVkIGNvbnRyYWN0XG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciB2ZXJzaW9uLiBZb3Ugc2hvdWxkIHVzZSB7QGxpbmsgZ2V0Q29udHJhY3R9IGluc3RlYWQuXG4gICAqIGBgYGRpZmZcbiAgICogLSBjb25zdCBlZGl0aW9uRHJvcCA9IGF3YWl0IHNkay5nZXRFZGl0aW9uRHJvcChcIjB4MTIzNC4uLlwiKTtcbiAgICogKyBjb25zdCBlZGl0aW9uRHJvcCA9IGF3YWl0IHNkay5nZXRDb250cmFjdChcIjB4MTIzNC4uLlwiLCBcImVkaXRpb24tZHJvcFwiKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBnZXRFZGl0aW9uRHJvcChjb250cmFjdEFkZHJlc3MpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRDb250cmFjdChjb250cmFjdEFkZHJlc3MsIFwiZWRpdGlvbi1kcm9wXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSBvZiBhIEVkaXRpb24gY29udHJhY3RcbiAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIHRoZSBhZGRyZXNzIG9mIHRoZSBkZXBsb3llZCBjb250cmFjdFxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgdmVyc2lvbi4gWW91IHNob3VsZCB1c2Uge0BsaW5rIGdldENvbnRyYWN0fSBpbnN0ZWFkLlxuICAgKiBgYGBkaWZmXG4gICAqIC0gY29uc3QgZWRpdGlvbiA9IGF3YWl0IHNkay5nZXRFZGl0aW9uKFwiMHgxMjM0Li4uXCIpO1xuICAgKiArIGNvbnN0IGVkaXRpb24gPSBhd2FpdCBzZGsuZ2V0Q29udHJhY3QoXCIweDEyMzQuLi5cIiwgXCJlZGl0aW9uXCIpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGdldEVkaXRpb24oY29udHJhY3RBZGRyZXNzKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0Q29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBcImVkaXRpb25cIik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIG9mIGEgVG9rZW4gRHJvcCBjb250cmFjdFxuICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gdGhlIGFkZHJlc3Mgb2YgdGhlIGRlcGxveWVkIGNvbnRyYWN0XG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciB2ZXJzaW9uLiBZb3Ugc2hvdWxkIHVzZSB7QGxpbmsgZ2V0Q29udHJhY3R9IGluc3RlYWQuXG4gICAqIGBgYGRpZmZcbiAgICogLSBjb25zdCB0b2tlbkRyb3AgPSBhd2FpdCBzZGsuZ2V0VG9rZW5Ecm9wKFwiMHgxMjM0Li4uXCIpO1xuICAgKiArIGNvbnN0IHRva2VuRHJvcCA9IGF3YWl0IHNkay5nZXRDb250cmFjdChcIjB4MTIzNC4uLlwiLCBcInRva2VuLWRyb3BcIik7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZ2V0VG9rZW5Ecm9wKGNvbnRyYWN0QWRkcmVzcykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldENvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgXCJ0b2tlbi1kcm9wXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSBvZiBhIFRva2VuIGNvbnRyYWN0XG4gICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSB0aGUgYWRkcmVzcyBvZiB0aGUgZGVwbG95ZWQgY29udHJhY3RcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHZlcnNpb24uIFlvdSBzaG91bGQgdXNlIHtAbGluayBnZXRDb250cmFjdH0gaW5zdGVhZC5cbiAgICogYGBgZGlmZlxuICAgKiAtIGNvbnN0IHRva2VuID0gYXdhaXQgc2RrLmdldFRva2VuKFwiMHgxMjM0Li4uXCIpO1xuICAgKiArIGNvbnN0IHRva2VuID0gYXdhaXQgc2RrLmdldENvbnRyYWN0KFwiMHgxMjM0Li4uXCIsIFwidG9rZW5cIik7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZ2V0VG9rZW4oY29udHJhY3RBZGRyZXNzKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0Q29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBcInRva2VuXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSBvZiBhIFZvdGUgY29udHJhY3RcbiAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIHRoZSBhZGRyZXNzIG9mIHRoZSBkZXBsb3llZCBjb250cmFjdFxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgdmVyc2lvbi4gWW91IHNob3VsZCB1c2Uge0BsaW5rIGdldENvbnRyYWN0fSBpbnN0ZWFkLlxuICAgKiBgYGBkaWZmXG4gICAqIC0gY29uc3Qgdm90ZSA9IGF3YWl0IHNkay5nZXRWb3RlKFwiMHgxMjM0Li4uXCIpO1xuICAgKiArIGNvbnN0IHZvdGUgPSBhd2FpdCBzZGsuZ2V0Q29udHJhY3QoXCIweDEyMzQuLi5cIiwgXCJ2b3RlXCIpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGdldFZvdGUoY29udHJhY3RBZGRyZXNzKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0Q29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBcInZvdGVcIik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIG9mIGEgU3BsaXQgY29udHJhY3RcbiAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIHRoZSBhZGRyZXNzIG9mIHRoZSBkZXBsb3llZCBjb250cmFjdFxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgdmVyc2lvbi4gWW91IHNob3VsZCB1c2Uge0BsaW5rIGdldENvbnRyYWN0fSBpbnN0ZWFkLlxuICAgKiBgYGBkaWZmXG4gICAqIC0gY29uc3Qgc3BsaXQgPSBhd2FpdCBzZGsuZ2V0U3BsaXQoXCIweDEyMzQuLi5cIik7XG4gICAqICsgY29uc3Qgc3BsaXQgPSBhd2FpdCBzZGsuZ2V0Q29udHJhY3QoXCIweDEyMzQuLi5cIiwgXCJzcGxpdFwiKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBnZXRTcGxpdChjb250cmFjdEFkZHJlc3MpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRDb250cmFjdChjb250cmFjdEFkZHJlc3MsIFwic3BsaXRcIik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIG9mIGEgTWFya2V0cGxhY2UgY29udHJhY3RcbiAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIHRoZSBhZGRyZXNzIG9mIHRoZSBkZXBsb3llZCBjb250cmFjdFxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgdmVyc2lvbi4gWW91IHNob3VsZCB1c2Uge0BsaW5rIGdldENvbnRyYWN0fSBpbnN0ZWFkLlxuICAgKiBgYGBkaWZmXG4gICAqIC0gY29uc3QgbWFya2V0cGxhY2UgPSBhd2FpdCBzZGsuZ2V0TWFya2V0cGxhY2UoXCIweDEyMzQuLi5cIik7XG4gICAqICsgY29uc3QgbWFya2V0cGxhY2UgPSBhd2FpdCBzZGsuZ2V0Q29udHJhY3QoXCIweDEyMzQuLi5cIiwgXCJtYXJrZXRwbGFjZVwiKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBnZXRNYXJrZXRwbGFjZShjb250cmFjdEFkZHJlc3MpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRDb250cmFjdChjb250cmFjdEFkZHJlc3MsIFwibWFya2V0cGxhY2VcIik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIG9mIGEgUGFjayBjb250cmFjdFxuICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gdGhlIGFkZHJlc3Mgb2YgdGhlIGRlcGxveWVkIGNvbnRyYWN0XG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciB2ZXJzaW9uLiBZb3Ugc2hvdWxkIHVzZSB7QGxpbmsgZ2V0Q29udHJhY3R9IGluc3RlYWQuXG4gICAqIGBgYGRpZmZcbiAgICogLSBjb25zdCBwYWNrID0gYXdhaXQgc2RrLmdldFBhY2soXCIweDEyMzQuLi5cIik7XG4gICAqICsgY29uc3QgcGFjayA9IGF3YWl0IHNkay5nZXRDb250cmFjdChcIjB4MTIzNC4uLlwiLCBcInBhY2tcIik7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZ2V0UGFjayhjb250cmFjdEFkZHJlc3MpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRDb250cmFjdChjb250cmFjdEFkZHJlc3MsIFwicGFja1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugb2YgYSBQYWNrIGNvbnRyYWN0XG4gICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSB0aGUgYWRkcmVzcyBvZiB0aGUgZGVwbG95ZWQgY29udHJhY3RcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHZlcnNpb24uIFlvdSBzaG91bGQgdXNlIHtAbGluayBnZXRDb250cmFjdH0gaW5zdGVhZC5cbiAgICogYGBgZGlmZlxuICAgKiAtIGNvbnN0IG11bHRpV3JhcCA9IGF3YWl0IHNkay5nZXRNdWx0aXdyYXAoXCIweDEyMzQuLi5cIik7XG4gICAqICsgY29uc3QgbXVsdGlXcmFwID0gYXdhaXQgc2RrLmdldENvbnRyYWN0KFwiMHgxMjM0Li4uXCIsIFwibXVsdGl3cmFwXCIpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGdldE11bHRpd3JhcChjb250cmFjdEFkZHJlc3MpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRDb250cmFjdChjb250cmFjdEFkZHJlc3MsIFwibXVsdGl3cmFwXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSBvZiBhIEN1c3RvbSBUaGlyZHdlYkNvbnRyYWN0XG4gICAqIEBwYXJhbSBhZGRyZXNzIC0gdGhlIGFkZHJlc3Mgb2YgdGhlIGRlcGxveWVkIGNvbnRyYWN0XG4gICAqIEByZXR1cm5zIHRoZSBjb250cmFjdFxuICAgKiBAcHVibGljXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgY29udHJhY3QgPSBhd2FpdCBzZGsuZ2V0Q29udHJhY3QoXCJ7e2NvbnRyYWN0X2FkZHJlc3N9fVwiKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIGFzeW5jIGdldENvbnRyYWN0KGFkZHJlc3MsIGNvbnRyYWN0VHlwZU9yQUJJKSB7XG4gICAgLy8gaWYgd2UgaGF2ZSBhIGNvbnRyYWN0IGluIHRoZSBjYWNoZSB3ZSB3aWxsIHJldHVybiBpdFxuICAgIC8vIHdlIHdpbGwgZG8gdGhpcyAqKndpdGhvdXQqKiBjaGVja2luZyBhbnkgY29udHJhY3QgdHlwZSB0aGluZ3MgZm9yIHNpbXBsaWNpdHksIHRoaXMgbWF5IGhhdmUgdG8gY2hhbmdlIGluIHRoZSBmdXR1cmU/XG4gICAgaWYgKHRoaXMuY29udHJhY3RDYWNoZS5oYXMoYWRkcmVzcykpIHtcbiAgICAgIC8vIHdlIGtub3cgdGhpcyB3aWxsIGJlIHRoZXJlIHNpbmNlIHdlIGNoZWNrIHRoZSBoYXMgYWJvdmVcbiAgICAgIHJldHVybiB0aGlzLmNvbnRyYWN0Q2FjaGUuZ2V0KGFkZHJlc3MpO1xuICAgIH1cbiAgICBsZXQgbmV3Q29udHJhY3Q7XG5cbiAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIGEgY29udHJhY3RUeXBlIG9yIEFCSSB0aGVuIHdlIHdpbGwgaGF2ZSB0byByZXNvbHZlIGl0IHJlZ2FyZGxlc3NcbiAgICAvLyB3ZSBhbHNvIGhhbmRsZSBpdCBiZWluZyBcImN1c3RvbVwiIGp1c3QgaW4gY2FzZS4uLlxuICAgIGlmICghY29udHJhY3RUeXBlT3JBQkkgfHwgY29udHJhY3RUeXBlT3JBQkkgPT09IFwiY3VzdG9tXCIpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVkQ29udHJhY3RUeXBlID0gYXdhaXQgdGhpcy5yZXNvbHZlQ29udHJhY3RUeXBlKGFkZHJlc3MpO1xuICAgICAgaWYgKHJlc29sdmVkQ29udHJhY3RUeXBlID09PSBcImN1c3RvbVwiKSB7XG4gICAgICAgIC8vIGlmIGl0J3MgYSBjdXN0b20gY29udHJhY3Qgd2UgZ290dGEgZmV0Y2ggdGhlIGNvbXBpbGV0IG1ldGFkYXRhXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcHVibGlzaGVyID0gdGhpcy5nZXRQdWJsaXNoZXIoKTtcbiAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHB1Ymxpc2hlci5mZXRjaENvbXBpbGVyTWV0YWRhdGFGcm9tQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgICBuZXdDb250cmFjdCA9IGF3YWl0IHRoaXMuZ2V0Q29udHJhY3RGcm9tQWJpKGFkZHJlc3MsIG1ldGFkYXRhLmFiaSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGZldGNoaW5nIEFCSSBmb3IgdGhpcyBjb250cmFjdFxcblxcbiR7ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGlmIGl0J3MgYSBwcmVidWlsdCBjb250cmFjdCB3ZSBjYW4ganVzdCB1c2UgdGhlIGNvbnRyYWN0IHR5cGVcbiAgICAgICAgY29uc3QgY29udHJhY3RBYmkgPSBhd2FpdCBQUkVCVUlMVF9DT05UUkFDVFNfTUFQW3Jlc29sdmVkQ29udHJhY3RUeXBlXS5nZXRBYmkoYWRkcmVzcywgdGhpcy5nZXRQcm92aWRlcigpKTtcbiAgICAgICAgbmV3Q29udHJhY3QgPSBhd2FpdCB0aGlzLmdldENvbnRyYWN0RnJvbUFiaShhZGRyZXNzLCBjb250cmFjdEFiaSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIGl0J3MgYSBidWlsdGluIGNvbnRyYWN0IHR5cGUgd2UgY2FuIGp1c3QgdXNlIHRoZSBjb250cmFjdCB0eXBlIHRvIGluaXRpYWxpemUgdGhlIGNvbnRyYWN0IGluc3RhbmNlXG4gICAgZWxzZSBpZiAodHlwZW9mIGNvbnRyYWN0VHlwZU9yQUJJID09PSBcInN0cmluZ1wiICYmIGNvbnRyYWN0VHlwZU9yQUJJIGluIFBSRUJVSUxUX0NPTlRSQUNUU19NQVApIHtcbiAgICAgIG5ld0NvbnRyYWN0ID0gYXdhaXQgUFJFQlVJTFRfQ09OVFJBQ1RTX01BUFtjb250cmFjdFR5cGVPckFCSV0uaW5pdGlhbGl6ZSh0aGlzLmdldFNpZ25lck9yUHJvdmlkZXIoKSwgYWRkcmVzcywgdGhpcy5zdG9yYWdlLCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBvdGhlcndpc2UgaXQgaGFzIHRvIGJlIGFuIEFCSVxuICAgIGVsc2Uge1xuICAgICAgbmV3Q29udHJhY3QgPSBhd2FpdCB0aGlzLmdldENvbnRyYWN0RnJvbUFiaShhZGRyZXNzLCBjb250cmFjdFR5cGVPckFCSSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHdoYXRldmVyIHdlIGhhdmUgb24gdGhlIGNhY2hlXG4gICAgdGhpcy5jb250cmFjdENhY2hlLnNldChhZGRyZXNzLCBuZXdDb250cmFjdCk7XG4gICAgLy8gcmV0dXJuIGl0XG4gICAgcmV0dXJuIG5ld0NvbnRyYWN0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rIGdldENvbnRyYWN0fSBkaXJlY3RseSBpbnN0ZWFkXG4gICAqL1xuICBhc3luYyBnZXRCdWlsdEluQ29udHJhY3QoYWRkcmVzcywgY29udHJhY3RUeXBlKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0Q29udHJhY3QoYWRkcmVzcywgY29udHJhY3RUeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gdGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IHRvIGF0dGVtcHQgdG8gcmVzb2x2ZSB0aGUgY29udHJhY3QgdHlwZSBmb3JcbiAgICogQHJldHVybnMgdGhlIHtAbGluayBDb250cmFjdFR5cGV9IGZvciB0aGUgZ2l2ZW4gY29udHJhY3QgYWRkcmVzc1xuICAgKlxuICAgKi9cbiAgYXN5bmMgcmVzb2x2ZUNvbnRyYWN0VHlwZShjb250cmFjdEFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBJVGhpcmR3ZWJDb250cmFjdEFCSSxcbiAgICAgIC8vICFwcm92aWRlciBvbmx5ISAtIHNpZ25lciBjYW4gYnJlYWsgdGhpbmdzIGhlcmUhXG4gICAgICB0aGlzLmdldFByb3ZpZGVyKCkpO1xuICAgICAgY29uc3QgcmVtb3RlQ29udHJhY3RUeXBlID0gZXRoZXJzLnV0aWxzLnRvVXRmOFN0cmluZyhhd2FpdCBjb250cmFjdC5jb250cmFjdFR5cGUoKSlcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgICAucmVwbGFjZSgvXFx4MDAvZywgXCJcIik7XG4gICAgICByZXR1cm4gZ2V0Q29udHJhY3RUeXBlRm9yUmVtb3RlTmFtZShyZW1vdGVDb250cmFjdFR5cGUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFwiY3VzdG9tXCI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgdGhlIGNvbnRyYWN0cyBkZXBsb3llZCBieSB0aGUgc3BlY2lmaWVkIGFkZHJlc3NcbiAgICogQHBhcmFtIHdhbGxldEFkZHJlc3MgLSB0aGUgZGVwbG95ZWQgYWRkcmVzc1xuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IGNvbnRyYWN0cyA9IHNkay5nZXRDb250cmFjdExpc3QoXCJ7e3dhbGxldF9hZGRyZXNzfX1cIik7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZ2V0Q29udHJhY3RMaXN0KHdhbGxldEFkZHJlc3MpIHtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSAoYXdhaXQgKGF3YWl0IHRoaXMuZGVwbG95ZXIuZ2V0UmVnaXN0cnkoKSk/LmdldENvbnRyYWN0QWRkcmVzc2VzKHdhbGxldEFkZHJlc3MpKSB8fCBbXTtcbiAgICBjb25zdCBhZGRyZXNzZXNXaXRoQ29udHJhY3RUeXBlcyA9IGF3YWl0IFByb21pc2UuYWxsKGFkZHJlc3Nlcy5tYXAoYXN5bmMgYWRkcmVzcyA9PiB7XG4gICAgICBsZXQgY29udHJhY3RUeXBlID0gXCJjdXN0b21cIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnRyYWN0VHlwZSA9IGF3YWl0IHRoaXMucmVzb2x2ZUNvbnRyYWN0VHlwZShhZGRyZXNzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gdGhpcyBnb2luZyB0byBoYXBwZW4gZnJlcXVlbnRseSBhbmQgYmUgT0ssIHdlJ2xsIGp1c3QgY2F0Y2ggaXQgYW5kIGlnbm9yZSBpdFxuICAgICAgfVxuICAgICAgbGV0IG1ldGFkYXRhO1xuICAgICAgaWYgKGNvbnRyYWN0VHlwZSA9PT0gXCJjdXN0b21cIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG1ldGFkYXRhID0gKGF3YWl0IHRoaXMuZ2V0Q29udHJhY3QoYWRkcmVzcykpLm1ldGFkYXRhO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZG4ndCBnZXQgY29udHJhY3QgbWV0YWRhdGEgZm9yIGN1c3RvbSBjb250cmFjdDogJHthZGRyZXNzfSAtICR7ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWV0YWRhdGEgPSAoYXdhaXQgdGhpcy5nZXRDb250cmFjdChhZGRyZXNzLCBjb250cmFjdFR5cGUpKS5tZXRhZGF0YTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGNvbnRyYWN0VHlwZSxcbiAgICAgICAgbWV0YWRhdGFcbiAgICAgIH07XG4gICAgfSkpO1xuICAgIHJldHVybiBhZGRyZXNzZXNXaXRoQ29udHJhY3RUeXBlcy5maWx0ZXIoZSA9PiBlLm1ldGFkYXRhKS5tYXAoX3JlZiA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBjb250cmFjdFR5cGUsXG4gICAgICAgIG1ldGFkYXRhXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGludmFyaWFudChtZXRhZGF0YSwgXCJBbGwgVGhpcmR3ZWJDb250cmFjdHMgcmVxdWlyZSBtZXRhZGF0YVwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGNvbnRyYWN0VHlwZSxcbiAgICAgICAgbWV0YWRhdGE6ICgpID0+IG1ldGFkYXRhLmdldCgpXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYWN0aXZlIHNpZ25lciBvciBwcm92aWRlciBmb3IgYWxsIGNvbnRyYWN0c1xuICAgKiBAcGFyYW0gbmV0d29yayAtIHRoZSBuZXcgc2lnbmVyIG9yIHByb3ZpZGVyXG4gICAqL1xuICB1cGRhdGVTaWduZXJPclByb3ZpZGVyKG5ldHdvcmspIHtcbiAgICBzdXBlci51cGRhdGVTaWduZXJPclByb3ZpZGVyKG5ldHdvcmspO1xuICAgIHRoaXMudXBkYXRlQ29udHJhY3RTaWduZXJPclByb3ZpZGVyKCk7XG4gIH1cbiAgdXBkYXRlQ29udHJhY3RTaWduZXJPclByb3ZpZGVyKCkge1xuICAgIHRoaXMud2FsbGV0LmNvbm5lY3QodGhpcy5nZXRTaWduZXJPclByb3ZpZGVyKCkpO1xuICAgIHRoaXMuYXV0aC51cGRhdGVTaWduZXJPclByb3ZpZGVyKHRoaXMuZ2V0U2lnbmVyT3JQcm92aWRlcigpKTtcbiAgICB0aGlzLmRlcGxveWVyLnVwZGF0ZVNpZ25lck9yUHJvdmlkZXIodGhpcy5nZXRTaWduZXJPclByb3ZpZGVyKCkpO1xuICAgIHRoaXMuX3B1Ymxpc2hlci51cGRhdGVTaWduZXJPclByb3ZpZGVyKHRoaXMuZ2V0U2lnbmVyT3JQcm92aWRlcigpKTtcbiAgICBmb3IgKGNvbnN0IFssIGNvbnRyYWN0XSBvZiB0aGlzLmNvbnRyYWN0Q2FjaGUpIHtcbiAgICAgIGNvbnRyYWN0Lm9uTmV0d29ya1VwZGF0ZWQodGhpcy5nZXRTaWduZXJPclByb3ZpZGVyKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugb2YgYSBDdXN0b20gY29udHJhY3QgZnJvbSBhIGpzb24gQUJJXG4gICAqIEBwYXJhbSBhZGRyZXNzIC0gdGhlIGFkZHJlc3Mgb2YgdGhlIGRlcGxveWVkIGNvbnRyYWN0XG4gICAqIEBwYXJhbSBhYmkgLSB0aGUgSlNPTiBhYmlcbiAgICogQHJldHVybnMgdGhlIGNvbnRyYWN0XG4gICAqIEBiZXRhXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gSW1wb3J0IHlvdXIgQUJJIGZyb20gYSBKU09OIGZpbGVcbiAgICogaW1wb3J0IG15QUJJIGZyb20gXCIuL3BhdGgvdG8vbXlBQkkuanNvblwiO1xuICAgKlxuICAgKiBjb25zdCBjb250cmFjdCA9IHNkay5nZXRDb250cmFjdEZyb21BYmkoXG4gICAqICAgXCJ7e2NvbnRyYWN0X2FkZHJlc3N9fVwiLFxuICAgKiAgIC8vIFBhc3MgaW4gdGhlIFwiYWJpXCIgZmllbGQgZnJvbSB0aGUgSlNPTiBmaWxlXG4gICAqICAgbXlBQkkuYWJpXG4gICAqICk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZ2V0Q29udHJhY3RGcm9tQWJpKGFkZHJlc3MsIGFiaSkge1xuICAgIGlmICh0aGlzLmNvbnRyYWN0Q2FjaGUuaGFzKGFkZHJlc3MpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250cmFjdENhY2hlLmdldChhZGRyZXNzKTtcbiAgICB9XG4gICAgY29uc3QgWywgcHJvdmlkZXJdID0gZ2V0U2lnbmVyQW5kUHJvdmlkZXIodGhpcy5nZXRTaWduZXJPclByb3ZpZGVyKCksIHRoaXMub3B0aW9ucyk7XG4gICAgLy8gVE9ETyB3ZSBzdGlsbCBtaWdodCB3YW50IHRvIGxhenktZnkgdGhpc1xuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IFNtYXJ0Q29udHJhY3QodGhpcy5nZXRTaWduZXJPclByb3ZpZGVyKCksIGFkZHJlc3MsIGFiaSwgdGhpcy5zdG9yYWdlSGFuZGxlciwgdGhpcy5vcHRpb25zLCAoYXdhaXQgcHJvdmlkZXIuZ2V0TmV0d29yaygpKS5jaGFpbklkKTtcbiAgICB0aGlzLmNvbnRyYWN0Q2FjaGUuc2V0KGFkZHJlc3MsIGNvbnRyYWN0KTtcbiAgICByZXR1cm4gY29udHJhY3Q7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBuYXRpdmUgYmFsYW5jZSBvZiBhIGdpdmVuIGFkZHJlc3MgKHdhbGxldCBvciBjb250cmFjdClcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBiYWxhbmNlID0gYXdhaXQgc2RrLmdldEJhbGFuY2UoXCIweC4uLlwiKTtcbiAgICogY29uc29sZS5sb2coYmFsYW5jZS5kaXNwbGF5VmFsdWUpO1xuICAgKiBgYGBcbiAgICogQHBhcmFtIGFkZHJlc3MgLSB0aGUgYWRkcmVzcyB0byBjaGVjayB0aGUgYmFsYW5jZSBmb3JcbiAgICovXG4gIGFzeW5jIGdldEJhbGFuY2UoYWRkcmVzcykge1xuICAgIHJldHVybiBmZXRjaEN1cnJlbmN5VmFsdWUodGhpcy5nZXRQcm92aWRlcigpLCBOQVRJVkVfVE9LRU5fQUREUkVTUywgYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpLmdldEJhbGFuY2UoYWRkcmVzcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UHVibGlzaGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wdWJsaXNoZXI7XG4gIH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgQ29udHJhY3RGYWN0b3J5IGV4dGVuZHMgQ29udHJhY3RXcmFwcGVyIHtcbiAgLy8gTWFwIGZyb20gY29udHJhY3QgdHlwZSB0byB2ZXJzaW9uIHRvIGRlcGxveSBzcGVjaWZpYyB2ZXJzaW9ucyBieSBkZWZhdWx0XG5cbiAgY29uc3RydWN0b3IoZmFjdG9yeUFkZHIsIG5ldHdvcmssIHN0b3JhZ2UsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihuZXR3b3JrLCBmYWN0b3J5QWRkciwgVFdGYWN0b3J5QWJpLCBvcHRpb25zKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yYWdlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiREVGQVVMVF9WRVJTSU9OX01BUFwiLCB7XG4gICAgICBbTkZURHJvcEluaXRpYWxpemVyLmNvbnRyYWN0VHlwZV06IDMsXG4gICAgICBbTkZUQ29sbGVjdGlvbkluaXRpYWxpemVyLmNvbnRyYWN0VHlwZV06IDEsXG4gICAgICBbU2lnbmF0dXJlRHJvcEluaXRpYWxpemVyLmNvbnRyYWN0VHlwZV06IDQsXG4gICAgICBbTXVsdGl3cmFwSW5pdGlhbGl6ZXIuY29udHJhY3RUeXBlXTogMSxcbiAgICAgIFtFZGl0aW9uRHJvcEluaXRpYWxpemVyLmNvbnRyYWN0VHlwZV06IDIsXG4gICAgICBbRWRpdGlvbkluaXRpYWxpemVyLmNvbnRyYWN0VHlwZV06IDEsXG4gICAgICBbVG9rZW5Ecm9wSW5pdGlhbGl6ZXIuY29udHJhY3RUeXBlXTogMixcbiAgICAgIFtUb2tlbkluaXRpYWxpemVyLmNvbnRyYWN0VHlwZV06IDEsXG4gICAgICBbVm90ZUluaXRpYWxpemVyLmNvbnRyYWN0VHlwZV06IDEsXG4gICAgICBbU3BsaXRJbml0aWFsaXplci5jb250cmFjdFR5cGVdOiAxLFxuICAgICAgW01hcmtldHBsYWNlSW5pdGlhbGl6ZXIuY29udHJhY3RUeXBlXTogMixcbiAgICAgIFtQYWNrSW5pdGlhbGl6ZXIuY29udHJhY3RUeXBlXTogMlxuICAgIH0pO1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gIH1cbiAgYXN5bmMgZGVwbG95KGNvbnRyYWN0VHlwZSwgY29udHJhY3RNZXRhZGF0YSwgdmVyc2lvbikge1xuICAgIGNvbnN0IGNvbnRyYWN0ID0gUFJFQlVJTFRfQ09OVFJBQ1RTX01BUFtjb250cmFjdFR5cGVdO1xuICAgIGNvbnN0IG1ldGFkYXRhID0gY29udHJhY3Quc2NoZW1hLmRlcGxveS5wYXJzZShjb250cmFjdE1ldGFkYXRhKTtcblxuICAgIC8vIFRPRE86IGlzIHRoZXJlIGFueSBzcGVjaWFsIHByZS1wcm9jZXNzaW5nIHdlIG5lZWQgdG8gZG8gYmVmb3JlIHVwbG9hZGluZz9cbiAgICBjb25zdCBjb250cmFjdFVSSSA9IGF3YWl0IHRoaXMuc3RvcmFnZS51cGxvYWQobWV0YWRhdGEpO1xuICAgIGNvbnN0IGltcGxlbWVudGF0aW9uQWRkcmVzcyA9IGF3YWl0IHRoaXMuZ2V0SW1wbGVtZW50YXRpb24oY29udHJhY3QsIHZlcnNpb24pO1xuICAgIGlmICghaW1wbGVtZW50YXRpb25BZGRyZXNzIHx8IGltcGxlbWVudGF0aW9uQWRkcmVzcyA9PT0gY29uc3RhbnRzLkFkZHJlc3NaZXJvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGltcGxlbWVudGF0aW9uIGZvdW5kIGZvciAke2NvbnRyYWN0VHlwZX1gKTtcbiAgICB9XG4gICAgY29uc3QgQUJJID0gYXdhaXQgY29udHJhY3QuZ2V0QWJpKGltcGxlbWVudGF0aW9uQWRkcmVzcywgdGhpcy5nZXRQcm92aWRlcigpKTtcbiAgICBjb25zdCBlbmNvZGVkRnVuYyA9IENvbnRyYWN0LmdldEludGVyZmFjZShBQkkpLmVuY29kZUZ1bmN0aW9uRGF0YShcImluaXRpYWxpemVcIiwgYXdhaXQgdGhpcy5nZXREZXBsb3lBcmd1bWVudHMoY29udHJhY3RUeXBlLCBtZXRhZGF0YSwgY29udHJhY3RVUkkpKTtcbiAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKS5nZXRCbG9ja051bWJlcigpO1xuICAgIGNvbnN0IHNhbHQgPSBldGhlcnMudXRpbHMuZm9ybWF0Qnl0ZXMzMlN0cmluZyhibG9ja051bWJlci50b1N0cmluZygpKTtcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5zZW5kVHJhbnNhY3Rpb24oXCJkZXBsb3lQcm94eUJ5SW1wbGVtZW50YXRpb25cIiwgW2ltcGxlbWVudGF0aW9uQWRkcmVzcywgZW5jb2RlZEZ1bmMsIHNhbHRdKTtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLnBhcnNlTG9ncyhcIlByb3h5RGVwbG95ZWRcIiwgcmVjZWlwdC5sb2dzKTtcbiAgICBpZiAoZXZlbnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFByb3h5RGVwbG95ZWQgZXZlbnQgZm91bmRcIik7XG4gICAgfVxuICAgIHJldHVybiBldmVudHNbMF0uYXJncy5wcm94eTtcbiAgfVxuXG4gIC8vIFRPRE8gb25jZSBJQ29udHJhY3RGYWN0b3J5IGlzIGltcGxlbWVudGVkLCB0aGlzIGNhbiBiZSBwcm9iYWJseSBiZSBtb3ZlZCB0byBpdHMgb3duIGNsYXNzXG4gIGFzeW5jIGRlcGxveVByb3h5QnlJbXBsZW1lbnRhdGlvbihpbXBsZW1lbnRhdGlvbkFkZHJlc3MsIGltcGxlbWVudGF0aW9uQWJpLCBpbml0aWFsaXplckZ1bmN0aW9uLCBpbml0aWFsaXplckFyZ3MpIHtcbiAgICBjb25zdCBlbmNvZGVkRnVuYyA9IENvbnRyYWN0LmdldEludGVyZmFjZShpbXBsZW1lbnRhdGlvbkFiaSkuZW5jb2RlRnVuY3Rpb25EYXRhKGluaXRpYWxpemVyRnVuY3Rpb24sIGluaXRpYWxpemVyQXJncyk7XG4gICAgY29uc3QgYmxvY2tOdW1iZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCkuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5zZW5kVHJhbnNhY3Rpb24oXCJkZXBsb3lQcm94eUJ5SW1wbGVtZW50YXRpb25cIiwgW2ltcGxlbWVudGF0aW9uQWRkcmVzcywgZW5jb2RlZEZ1bmMsIGV0aGVycy51dGlscy5mb3JtYXRCeXRlczMyU3RyaW5nKGJsb2NrTnVtYmVyLnRvU3RyaW5nKCkpXSk7XG4gICAgY29uc3QgZXZlbnRzID0gdGhpcy5wYXJzZUxvZ3MoXCJQcm94eURlcGxveWVkXCIsIHJlY2VpcHQubG9ncyk7XG4gICAgaWYgKGV2ZW50cy5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBQcm94eURlcGxveWVkIGV2ZW50IGZvdW5kXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzWzBdLmFyZ3MucHJveHk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGNvbnRyYWN0VHlwZVxuICAgKiBAcGFyYW0gbWV0YWRhdGFcbiAgICogQHBhcmFtIGNvbnRyYWN0VVJJXG4gICAqIEByZXR1cm5zXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgZ2V0RGVwbG95QXJndW1lbnRzKGNvbnRyYWN0VHlwZSwgbWV0YWRhdGEsIGNvbnRyYWN0VVJJKSB7XG4gICAgbGV0IHRydXN0ZWRGb3J3YXJkZXJzID0gY29udHJhY3RUeXBlID09PSBQYWNrSW5pdGlhbGl6ZXIuY29udHJhY3RUeXBlID8gW10gOiBhd2FpdCB0aGlzLmdldERlZmF1bHRUcnVzdGVkRm9yd2FyZGVycygpO1xuICAgIC8vIG92ZXJyaWRlIGRlZmF1bHQgZm9yd2FyZGVycyBpZiBjdXN0b20gb25lcyBhcmUgcGFzc2VkIGluXG4gICAgaWYgKG1ldGFkYXRhLnRydXN0ZWRfZm9yd2FyZGVycyAmJiBtZXRhZGF0YS50cnVzdGVkX2ZvcndhcmRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgdHJ1c3RlZEZvcndhcmRlcnMgPSBtZXRhZGF0YS50cnVzdGVkX2ZvcndhcmRlcnM7XG4gICAgfVxuICAgIHN3aXRjaCAoY29udHJhY3RUeXBlKSB7XG4gICAgICBjYXNlIE5GVERyb3BJbml0aWFsaXplci5jb250cmFjdFR5cGU6XG4gICAgICBjYXNlIE5GVENvbGxlY3Rpb25Jbml0aWFsaXplci5jb250cmFjdFR5cGU6XG4gICAgICAgIGNvbnN0IGVyYzcyMW1ldGFkYXRhID0gTkZURHJvcEluaXRpYWxpemVyLnNjaGVtYS5kZXBsb3kucGFyc2UobWV0YWRhdGEpO1xuICAgICAgICByZXR1cm4gW2F3YWl0IHRoaXMuZ2V0U2lnbmVyQWRkcmVzcygpLCBlcmM3MjFtZXRhZGF0YS5uYW1lLCBlcmM3MjFtZXRhZGF0YS5zeW1ib2wsIGNvbnRyYWN0VVJJLCB0cnVzdGVkRm9yd2FyZGVycywgZXJjNzIxbWV0YWRhdGEucHJpbWFyeV9zYWxlX3JlY2lwaWVudCwgZXJjNzIxbWV0YWRhdGEuZmVlX3JlY2lwaWVudCwgZXJjNzIxbWV0YWRhdGEuc2VsbGVyX2ZlZV9iYXNpc19wb2ludHMsIGVyYzcyMW1ldGFkYXRhLnBsYXRmb3JtX2ZlZV9iYXNpc19wb2ludHMsIGVyYzcyMW1ldGFkYXRhLnBsYXRmb3JtX2ZlZV9yZWNpcGllbnRdO1xuICAgICAgY2FzZSBTaWduYXR1cmVEcm9wSW5pdGlhbGl6ZXIuY29udHJhY3RUeXBlOlxuICAgICAgICBjb25zdCBzaWduYXR1cmVEcm9wbWV0YWRhdGEgPSBTaWduYXR1cmVEcm9wSW5pdGlhbGl6ZXIuc2NoZW1hLmRlcGxveS5wYXJzZShtZXRhZGF0YSk7XG4gICAgICAgIHJldHVybiBbYXdhaXQgdGhpcy5nZXRTaWduZXJBZGRyZXNzKCksIHNpZ25hdHVyZURyb3BtZXRhZGF0YS5uYW1lLCBzaWduYXR1cmVEcm9wbWV0YWRhdGEuc3ltYm9sLCBjb250cmFjdFVSSSwgdHJ1c3RlZEZvcndhcmRlcnMsIHNpZ25hdHVyZURyb3BtZXRhZGF0YS5wcmltYXJ5X3NhbGVfcmVjaXBpZW50LCBzaWduYXR1cmVEcm9wbWV0YWRhdGEuZmVlX3JlY2lwaWVudCwgc2lnbmF0dXJlRHJvcG1ldGFkYXRhLnNlbGxlcl9mZWVfYmFzaXNfcG9pbnRzLCBzaWduYXR1cmVEcm9wbWV0YWRhdGEucGxhdGZvcm1fZmVlX2Jhc2lzX3BvaW50cywgc2lnbmF0dXJlRHJvcG1ldGFkYXRhLnBsYXRmb3JtX2ZlZV9yZWNpcGllbnRdO1xuICAgICAgY2FzZSBNdWx0aXdyYXBJbml0aWFsaXplci5jb250cmFjdFR5cGU6XG4gICAgICAgIGNvbnN0IG11bHRpd3JhcE1ldGFkYXRhID0gTXVsdGl3cmFwSW5pdGlhbGl6ZXIuc2NoZW1hLmRlcGxveS5wYXJzZShtZXRhZGF0YSk7XG4gICAgICAgIHJldHVybiBbYXdhaXQgdGhpcy5nZXRTaWduZXJBZGRyZXNzKCksIG11bHRpd3JhcE1ldGFkYXRhLm5hbWUsIG11bHRpd3JhcE1ldGFkYXRhLnN5bWJvbCwgY29udHJhY3RVUkksIHRydXN0ZWRGb3J3YXJkZXJzLCBtdWx0aXdyYXBNZXRhZGF0YS5mZWVfcmVjaXBpZW50LCBtdWx0aXdyYXBNZXRhZGF0YS5zZWxsZXJfZmVlX2Jhc2lzX3BvaW50c107XG4gICAgICBjYXNlIEVkaXRpb25Ecm9wSW5pdGlhbGl6ZXIuY29udHJhY3RUeXBlOlxuICAgICAgY2FzZSBFZGl0aW9uSW5pdGlhbGl6ZXIuY29udHJhY3RUeXBlOlxuICAgICAgICBjb25zdCBlcmMxMTU1bWV0YWRhdGEgPSBFZGl0aW9uRHJvcEluaXRpYWxpemVyLnNjaGVtYS5kZXBsb3kucGFyc2UobWV0YWRhdGEpO1xuICAgICAgICByZXR1cm4gW2F3YWl0IHRoaXMuZ2V0U2lnbmVyQWRkcmVzcygpLCBlcmMxMTU1bWV0YWRhdGEubmFtZSwgZXJjMTE1NW1ldGFkYXRhLnN5bWJvbCwgY29udHJhY3RVUkksIHRydXN0ZWRGb3J3YXJkZXJzLCBlcmMxMTU1bWV0YWRhdGEucHJpbWFyeV9zYWxlX3JlY2lwaWVudCwgZXJjMTE1NW1ldGFkYXRhLmZlZV9yZWNpcGllbnQsIGVyYzExNTVtZXRhZGF0YS5zZWxsZXJfZmVlX2Jhc2lzX3BvaW50cywgZXJjMTE1NW1ldGFkYXRhLnBsYXRmb3JtX2ZlZV9iYXNpc19wb2ludHMsIGVyYzExNTVtZXRhZGF0YS5wbGF0Zm9ybV9mZWVfcmVjaXBpZW50XTtcbiAgICAgIGNhc2UgVG9rZW5Ecm9wSW5pdGlhbGl6ZXIuY29udHJhY3RUeXBlOlxuICAgICAgY2FzZSBUb2tlbkluaXRpYWxpemVyLmNvbnRyYWN0VHlwZTpcbiAgICAgICAgY29uc3QgZXJjMjBtZXRhZGF0YSA9IFRva2VuSW5pdGlhbGl6ZXIuc2NoZW1hLmRlcGxveS5wYXJzZShtZXRhZGF0YSk7XG4gICAgICAgIHJldHVybiBbYXdhaXQgdGhpcy5nZXRTaWduZXJBZGRyZXNzKCksIGVyYzIwbWV0YWRhdGEubmFtZSwgZXJjMjBtZXRhZGF0YS5zeW1ib2wsIGNvbnRyYWN0VVJJLCB0cnVzdGVkRm9yd2FyZGVycywgZXJjMjBtZXRhZGF0YS5wcmltYXJ5X3NhbGVfcmVjaXBpZW50LCBlcmMyMG1ldGFkYXRhLnBsYXRmb3JtX2ZlZV9yZWNpcGllbnQsIGVyYzIwbWV0YWRhdGEucGxhdGZvcm1fZmVlX2Jhc2lzX3BvaW50c107XG4gICAgICBjYXNlIFZvdGVJbml0aWFsaXplci5jb250cmFjdFR5cGU6XG4gICAgICAgIGNvbnN0IHZvdGVNZXRhZGF0YSA9IFZvdGVJbml0aWFsaXplci5zY2hlbWEuZGVwbG95LnBhcnNlKG1ldGFkYXRhKTtcbiAgICAgICAgcmV0dXJuIFt2b3RlTWV0YWRhdGEubmFtZSwgY29udHJhY3RVUkksIHRydXN0ZWRGb3J3YXJkZXJzLCB2b3RlTWV0YWRhdGEudm90aW5nX3Rva2VuX2FkZHJlc3MsIHZvdGVNZXRhZGF0YS52b3RpbmdfZGVsYXlfaW5fYmxvY2tzLCB2b3RlTWV0YWRhdGEudm90aW5nX3BlcmlvZF9pbl9ibG9ja3MsIEJpZ051bWJlci5mcm9tKHZvdGVNZXRhZGF0YS5wcm9wb3NhbF90b2tlbl90aHJlc2hvbGQpLCB2b3RlTWV0YWRhdGEudm90aW5nX3F1b3J1bV9mcmFjdGlvbl07XG4gICAgICBjYXNlIFNwbGl0SW5pdGlhbGl6ZXIuY29udHJhY3RUeXBlOlxuICAgICAgICBjb25zdCBzcGxpdHNNZXRhZGF0YSA9IFNwbGl0SW5pdGlhbGl6ZXIuc2NoZW1hLmRlcGxveS5wYXJzZShtZXRhZGF0YSk7XG4gICAgICAgIHJldHVybiBbYXdhaXQgdGhpcy5nZXRTaWduZXJBZGRyZXNzKCksIGNvbnRyYWN0VVJJLCB0cnVzdGVkRm9yd2FyZGVycywgc3BsaXRzTWV0YWRhdGEucmVjaXBpZW50cy5tYXAocyA9PiBzLmFkZHJlc3MpLCBzcGxpdHNNZXRhZGF0YS5yZWNpcGllbnRzLm1hcChzID0+IEJpZ051bWJlci5mcm9tKHMuc2hhcmVzQnBzKSldO1xuICAgICAgY2FzZSBNYXJrZXRwbGFjZUluaXRpYWxpemVyLmNvbnRyYWN0VHlwZTpcbiAgICAgICAgY29uc3QgbWFya2V0cGxhY2VNZXRhZGF0YSA9IE1hcmtldHBsYWNlSW5pdGlhbGl6ZXIuc2NoZW1hLmRlcGxveS5wYXJzZShtZXRhZGF0YSk7XG4gICAgICAgIHJldHVybiBbYXdhaXQgdGhpcy5nZXRTaWduZXJBZGRyZXNzKCksIGNvbnRyYWN0VVJJLCB0cnVzdGVkRm9yd2FyZGVycywgbWFya2V0cGxhY2VNZXRhZGF0YS5wbGF0Zm9ybV9mZWVfcmVjaXBpZW50LCBtYXJrZXRwbGFjZU1ldGFkYXRhLnBsYXRmb3JtX2ZlZV9iYXNpc19wb2ludHNdO1xuICAgICAgY2FzZSBQYWNrSW5pdGlhbGl6ZXIuY29udHJhY3RUeXBlOlxuICAgICAgICBjb25zdCBwYWNrc01ldGFkYXRhID0gUGFja0luaXRpYWxpemVyLnNjaGVtYS5kZXBsb3kucGFyc2UobWV0YWRhdGEpO1xuICAgICAgICByZXR1cm4gW2F3YWl0IHRoaXMuZ2V0U2lnbmVyQWRkcmVzcygpLCBwYWNrc01ldGFkYXRhLm5hbWUsIHBhY2tzTWV0YWRhdGEuc3ltYm9sLCBjb250cmFjdFVSSSwgdHJ1c3RlZEZvcndhcmRlcnMsIHBhY2tzTWV0YWRhdGEuZmVlX3JlY2lwaWVudCwgcGFja3NNZXRhZGF0YS5zZWxsZXJfZmVlX2Jhc2lzX3BvaW50c107XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldERlZmF1bHRUcnVzdGVkRm9yd2FyZGVycygpIHtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklEKCk7XG4gICAgcmV0dXJuIGdldERlZmF1bHRUcnVzdGVkRm9yd2FyZGVycyhjaGFpbklkKTtcbiAgfVxuICBhc3luYyBnZXRJbXBsZW1lbnRhdGlvbihjb250cmFjdCwgdmVyc2lvbikge1xuICAgIGNvbnN0IGVuY29kZWRUeXBlID0gZXRoZXJzLnV0aWxzLmZvcm1hdEJ5dGVzMzJTdHJpbmcoY29udHJhY3QubmFtZSk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JRCgpO1xuICAgIGNvbnN0IGFwcHJvdmVkSW1wbGVtZW50YXRpb24gPSBnZXRBcHByb3ZlZEltcGxlbWVudGF0aW9uKGNoYWluSWQsIGNvbnRyYWN0LmNvbnRyYWN0VHlwZSk7XG4gICAgLy8gcmV0dXJuIGFwcHJvdmVkIGltcGxlbWVudGF0aW9uIGlmIGl0IGV4aXN0cyBhbmQgd2UncmUgbm90IG92ZXJyaWRpbmcgdGhlIHZlcnNpb25cbiAgICBpZiAoYXBwcm92ZWRJbXBsZW1lbnRhdGlvbiAmJiBhcHByb3ZlZEltcGxlbWVudGF0aW9uLmxlbmd0aCA+IDAgJiYgdmVyc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gYXBwcm92ZWRJbXBsZW1lbnRhdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVhZENvbnRyYWN0LmdldEltcGxlbWVudGF0aW9uKGVuY29kZWRUeXBlLCB2ZXJzaW9uICE9PSB1bmRlZmluZWQgPyB2ZXJzaW9uIDogdGhpcy5ERUZBVUxUX1ZFUlNJT05fTUFQW2NvbnRyYWN0LmNvbnRyYWN0VHlwZV0pO1xuICB9XG4gIGFzeW5jIGdldExhdGVzdFZlcnNpb24oY29udHJhY3RUeXBlKSB7XG4gICAgY29uc3QgbmFtZSA9IGdldENvbnRyYWN0TmFtZShjb250cmFjdFR5cGUpO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbnRyYWN0IHR5cGUgJHtjb250cmFjdFR5cGV9YCk7XG4gICAgfVxuICAgIGNvbnN0IGVuY29kZWRUeXBlID0gZXRoZXJzLnV0aWxzLmZvcm1hdEJ5dGVzMzJTdHJpbmcobmFtZSk7XG4gICAgcmV0dXJuIHRoaXMucmVhZENvbnRyYWN0LmN1cnJlbnRWZXJzaW9uKGVuY29kZWRUeXBlKTtcbiAgfVxufVxuXG5jbGFzcyBGYWN0b3J5RXZlbnRzIGV4dGVuZHMgQ29udHJhY3RFdmVudHMge1xuICBjb25zdHJ1Y3Rvcihjb250cmFjdFdyYXBwZXIpIHtcbiAgICBzdXBlcihjb250cmFjdFdyYXBwZXIpO1xuICB9XG4gIGFkZERlcGxveUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5hZGRUcmFuc2FjdGlvbkxpc3RlbmVyKGFzeW5jIGV2ZW50ID0+IHtcbiAgICAgIGlmICghZXZlbnQudHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRQcm92aWRlcigpLmdldFRyYW5zYWN0aW9uUmVjZWlwdChldmVudC50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgY29uc3QgZXZlbnRzID0gdGhpcy5jb250cmFjdFdyYXBwZXIucGFyc2VMb2dzKFwiUHJveHlEZXBsb3llZFwiLCByZWNlaXB0LmxvZ3MpO1xuICAgICAgaWYgKGV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IGV2ZW50c1swXS5hcmdzLnByb3h5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIENvbnRyYWN0UmVnaXN0cnkgZXh0ZW5kcyBDb250cmFjdFdyYXBwZXIge1xuICBjb25zdHJ1Y3RvcihyZWdpc3RyeUFkZHJlc3MsIG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICBzdXBlcihuZXR3b3JrLCByZWdpc3RyeUFkZHJlc3MsIFRXUmVnaXN0cnlBQkksIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGdldENvbnRyYWN0QWRkcmVzc2VzKHdhbGxldEFkZHJlc3MpIHtcbiAgICAvLyBUT0RPIEBmaXhtZSB0aGUgZmlsdGVyIGhlcmUgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgZm9yIHNvbWUgcmVhc29uIGdldEFsbCByZXR1cm5zIGEgMHgwIGFkZHJlc3MgZm9yIHRoZSBmaXJzdCBlbnRyeVxuICAgIHJldHVybiAoYXdhaXQgdGhpcy5yZWFkQ29udHJhY3QuZ2V0QWxsKHdhbGxldEFkZHJlc3MpKS5maWx0ZXIoYWRyID0+IHV0aWxzLmlzQWRkcmVzcyhhZHIpICYmIGFkci50b0xvd2VyQ2FzZSgpICE9PSBjb25zdGFudHMuQWRkcmVzc1plcm8pO1xuICB9XG4gIGFzeW5jIGFkZENvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkZENvbnRyYWN0cyhbY29udHJhY3RBZGRyZXNzXSk7XG4gIH1cbiAgYXN5bmMgYWRkQ29udHJhY3RzKGNvbnRyYWN0QWRkcmVzc2VzKSB7XG4gICAgY29uc3QgZGVwbG95ZXJBZGRyZXNzID0gYXdhaXQgdGhpcy5nZXRTaWduZXJBZGRyZXNzKCk7XG4gICAgY29uc3QgZW5jb2RlZCA9IFtdO1xuICAgIGNvbnRyYWN0QWRkcmVzc2VzLmZvckVhY2goYWRkcmVzcyA9PiB7XG4gICAgICBlbmNvZGVkLnB1c2godGhpcy5yZWFkQ29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShcImFkZFwiLCBbZGVwbG95ZXJBZGRyZXNzLCBhZGRyZXNzXSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByZWNlaXB0OiBhd2FpdCB0aGlzLm11bHRpQ2FsbChlbmNvZGVkKVxuICAgIH07XG4gIH1cbiAgYXN5bmMgcmVtb3ZlQ29udHJhY3QoY29udHJhY3RBZGRyZXNzKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVtb3ZlQ29udHJhY3RzKFtjb250cmFjdEFkZHJlc3NdKTtcbiAgfVxuICBhc3luYyByZW1vdmVDb250cmFjdHMoY29udHJhY3RBZGRyZXNzZXMpIHtcbiAgICBjb25zdCBkZXBsb3llckFkZHJlc3MgPSBhd2FpdCB0aGlzLmdldFNpZ25lckFkZHJlc3MoKTtcbiAgICBjb25zdCBlbmNvZGVkID0gW107XG4gICAgY29udHJhY3RBZGRyZXNzZXMuZm9yRWFjaChhZGRyZXNzID0+IHtcbiAgICAgIGVuY29kZWQucHVzaCh0aGlzLnJlYWRDb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKFwicmVtb3ZlXCIsIFtkZXBsb3llckFkZHJlc3MsIGFkZHJlc3NdKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHQ6IGF3YWl0IHRoaXMubXVsdGlDYWxsKGVuY29kZWQpXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZXMgZGVwbG95aW5nIG5ldyBjb250cmFjdHNcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgQ29udHJhY3REZXBsb3llciBleHRlbmRzIFJQQ0Nvbm5lY3Rpb25IYW5kbGVyIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBzaG91bGQgbmV2ZXIgYmUgYWNjZXNzZWQgZGlyZWN0bHksIHVzZSB7QGxpbmsgQ29udHJhY3REZXBsb3llci5nZXRGYWN0b3J5fSBpbnN0ZWFkXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogc2hvdWxkIG5ldmVyIGJlIGFjY2Vzc2VkIGRpcmVjdGx5LCB1c2Uge0BsaW5rIENvbnRyYWN0RGVwbG95ZXIuZ2V0UmVnaXN0cnl9IGluc3RlYWRcbiAgICovXG5cbiAgY29uc3RydWN0b3IobmV0d29yaywgb3B0aW9ucywgc3RvcmFnZSkge1xuICAgIHN1cGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9mYWN0b3J5XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3JlZ2lzdHJ5XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZXZlbnRzXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcmFnZVwiLCB2b2lkIDApO1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG5cbiAgICAvLyBJbml0aWFsaXplIGZhY3RvcnkgYW5kIHJlZ2lzdHJ5ICh3ZSBkb24ndCBuZWVkIHRvIG1ha2UgdGhlc2UgY2FsbHMgYXN5bmMpXG4gICAgdGhpcy5nZXRGYWN0b3J5KCk7XG4gICAgdGhpcy5nZXRSZWdpc3RyeSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcGxveXMgYW4gTkZUIENvbGxlY3Rpb24gY29udHJhY3RcbiAgICpcbiAgICogQHJlbWFya3MgRGVwbG95cyBhbiBORlQgQ29sbGVjdGlvbiBjb250cmFjdCBhbmQgcmV0dXJucyB0aGUgYWRkcmVzcyBvZiB0aGUgZGVwbG95ZWQgY29udHJhY3RcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBhd2FpdCBzZGsuZGVwbG95ZXIuZGVwbG95TkZUQ29sbGVjdGlvbih7XG4gICAqICAgbmFtZTogXCJNeSBDb2xsZWN0aW9uXCIsXG4gICAqICAgcHJpbWFyeV9zYWxlX3JlY2lwaWVudDogXCJ5b3VyLWFkZHJlc3NcIixcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAcGFyYW0gbWV0YWRhdGEgLSB0aGUgY29udHJhY3QgbWV0YWRhdGFcbiAgICogQHJldHVybnMgdGhlIGFkZHJlc3Mgb2YgdGhlIGRlcGxveWVkIGNvbnRyYWN0XG4gICAqL1xuICBhc3luYyBkZXBsb3lORlRDb2xsZWN0aW9uKG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGVwbG95QnVpbHRJbkNvbnRyYWN0KE5GVENvbGxlY3Rpb25Jbml0aWFsaXplci5jb250cmFjdFR5cGUsIG1ldGFkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXBsb3lzIGEgbmV3IE5GVERyb3AgY29udHJhY3RcbiAgICpcbiAgICogQHJlbWFya3MgRGVwbG95cyBhbiBORlQgRHJvcCBjb250cmFjdCBhbmQgcmV0dXJucyB0aGUgYWRkcmVzcyBvZiB0aGUgZGVwbG95ZWQgY29udHJhY3RcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBhd2FpdCBzZGsuZGVwbG95ZXIuZGVwbG95TkZURHJvcCh7XG4gICAqICAgbmFtZTogXCJNeSBEcm9wXCIsXG4gICAqICAgcHJpbWFyeV9zYWxlX3JlY2lwaWVudDogXCJ5b3VyLWFkZHJlc3NcIixcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAcGFyYW0gbWV0YWRhdGEgLSB0aGUgY29udHJhY3QgbWV0YWRhdGFcbiAgICogQHJldHVybnMgdGhlIGFkZHJlc3Mgb2YgdGhlIGRlcGxveWVkIGNvbnRyYWN0XG4gICAqL1xuICBhc3luYyBkZXBsb3lORlREcm9wKG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGVwbG95QnVpbHRJbkNvbnRyYWN0KE5GVERyb3BJbml0aWFsaXplci5jb250cmFjdFR5cGUsIG1ldGFkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXBsb3lzIGEgbmV3IFNpZ25hdHVyZURyb3AgY29udHJhY3RcbiAgICpcbiAgICogQHJlbWFya3MgRGVwbG95cyBhIFNpZ25hdHVyZURyb3AgY29udHJhY3QgYW5kIHJldHVybnMgdGhlIGFkZHJlc3Mgb2YgdGhlIGRlcGxveWVkIGNvbnRyYWN0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgY29udHJhY3RBZGRyZXNzID0gYXdhaXQgc2RrLmRlcGxveWVyLmRlcGxveVNpZ25hdHVyZURyb3Aoe1xuICAgKiAgIG5hbWU6IFwiTXkgU2lnbmF0dXJlIERyb3BcIixcbiAgICogICBwcmltYXJ5X3NhbGVfcmVjaXBpZW50OiBcInlvdXItYWRkcmVzc1wiLFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIEBwYXJhbSBtZXRhZGF0YSAtIHRoZSBjb250cmFjdCBtZXRhZGF0YVxuICAgKiBAcmV0dXJucyB0aGUgYWRkcmVzcyBvZiB0aGUgZGVwbG95ZWQgY29udHJhY3RcbiAgICovXG4gIGFzeW5jIGRlcGxveVNpZ25hdHVyZURyb3AobWV0YWRhdGEpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kZXBsb3lCdWlsdEluQ29udHJhY3QoU2lnbmF0dXJlRHJvcEluaXRpYWxpemVyLmNvbnRyYWN0VHlwZSwgbWV0YWRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcGxveXMgYSBuZXcgTXVsdGl3cmFwIGNvbnRyYWN0XG4gICAqXG4gICAqIEByZW1hcmtzIERlcGxveXMgYSBNdWx0aXdyYXAgY29udHJhY3QgYW5kIHJldHVybnMgdGhlIGFkZHJlc3Mgb2YgdGhlIGRlcGxveWVkIGNvbnRyYWN0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgY29udHJhY3RBZGRyZXNzID0gYXdhaXQgc2RrLmRlcGxveWVyLmRlcGxveU11bHRpd3JhcCh7XG4gICAqICAgbmFtZTogXCJNeSBNdWx0aXdyYXBcIixcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAcGFyYW0gbWV0YWRhdGEgLSB0aGUgY29udHJhY3QgbWV0YWRhdGFcbiAgICogQHJldHVybnMgdGhlIGFkZHJlc3Mgb2YgdGhlIGRlcGxveWVkIGNvbnRyYWN0XG4gICAqIEBiZXRhXG4gICAqL1xuICBhc3luYyBkZXBsb3lNdWx0aXdyYXAobWV0YWRhdGEpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kZXBsb3lCdWlsdEluQ29udHJhY3QoTXVsdGl3cmFwSW5pdGlhbGl6ZXIuY29udHJhY3RUeXBlLCBtZXRhZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogRGVwbG95cyBhIG5ldyBFZGl0aW9uIGNvbnRyYWN0XG4gICAqXG4gICAqIEByZW1hcmtzIERlcGxveXMgYW4gRWRpdGlvbiBjb250cmFjdCBhbmQgcmV0dXJucyB0aGUgYWRkcmVzcyBvZiB0aGUgZGVwbG95ZWQgY29udHJhY3RcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBhd2FpdCBzZGsuZGVwbG95ZXIuZGVwbG95RWRpdGlvbih7XG4gICAqICAgbmFtZTogXCJNeSBFZGl0aW9uXCIsXG4gICAqICAgcHJpbWFyeV9zYWxlX3JlY2lwaWVudDogXCJ5b3VyLWFkZHJlc3NcIixcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAcGFyYW0gbWV0YWRhdGEgLSB0aGUgY29udHJhY3QgbWV0YWRhdGFcbiAgICogQHJldHVybnMgdGhlIGFkZHJlc3Mgb2YgdGhlIGRlcGxveWVkIGNvbnRyYWN0XG4gICAqL1xuICBhc3luYyBkZXBsb3lFZGl0aW9uKG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGVwbG95QnVpbHRJbkNvbnRyYWN0KEVkaXRpb25Jbml0aWFsaXplci5jb250cmFjdFR5cGUsIG1ldGFkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXBsb3lzIGEgbmV3IEVkaXRpb25Ecm9wIGNvbnRyYWN0XG4gICAqXG4gICAqIEByZW1hcmtzIERlcGxveXMgYW4gRWRpdGlvbiBEcm9wIGNvbnRyYWN0IGFuZCByZXR1cm5zIHRoZSBhZGRyZXNzIG9mIHRoZSBkZXBsb3llZCBjb250cmFjdFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IGF3YWl0IHNkay5kZXBsb3llci5kZXBsb3lFZGl0aW9uRHJvcCh7XG4gICAqICAgbmFtZTogXCJNeSBFZGl0aW9uIERyb3BcIixcbiAgICogICBwcmltYXJ5X3NhbGVfcmVjaXBpZW50OiBcInlvdXItYWRkcmVzc1wiLFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIEBwYXJhbSBtZXRhZGF0YSAtIHRoZSBjb250cmFjdCBtZXRhZGF0YVxuICAgKiBAcmV0dXJucyB0aGUgYWRkcmVzcyBvZiB0aGUgZGVwbG95ZWQgY29udHJhY3RcbiAgICovXG4gIGFzeW5jIGRlcGxveUVkaXRpb25Ecm9wKG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGVwbG95QnVpbHRJbkNvbnRyYWN0KEVkaXRpb25Ecm9wSW5pdGlhbGl6ZXIuY29udHJhY3RUeXBlLCBtZXRhZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogRGVwbG95cyBhIG5ldyBUb2tlbiBjb250cmFjdFxuICAgKlxuICAgKiBAcmVtYXJrcyBEZXBsb3lzIGEgVG9rZW4gY29udHJhY3QgYW5kIHJldHVybnMgdGhlIGFkZHJlc3Mgb2YgdGhlIGRlcGxveWVkIGNvbnRyYWN0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgY29udHJhY3RBZGRyZXNzID0gYXdhaXQgc2RrLmRlcGxveWVyLmRlcGxveVRva2VuKHtcbiAgICogICBuYW1lOiBcIk15IFRva2VuXCIsXG4gICAqICAgcHJpbWFyeV9zYWxlX3JlY2lwaWVudDogXCJ5b3VyLWFkZHJlc3NcIixcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAcGFyYW0gbWV0YWRhdGEgLSB0aGUgY29udHJhY3QgbWV0YWRhdGFcbiAgICogQHJldHVybnMgdGhlIGFkZHJlc3Mgb2YgdGhlIGRlcGxveWVkIGNvbnRyYWN0XG4gICAqL1xuICBhc3luYyBkZXBsb3lUb2tlbihtZXRhZGF0YSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRlcGxveUJ1aWx0SW5Db250cmFjdChUb2tlbkluaXRpYWxpemVyLmNvbnRyYWN0VHlwZSwgbWV0YWRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcGxveXMgYSBuZXcgVG9rZW4gRHJvcCBjb250cmFjdFxuICAgKlxuICAgKiBAcmVtYXJrcyBEZXBsb3lzIGEgVG9rZW4gRHJvcCBjb250cmFjdCBhbmQgcmV0dXJucyB0aGUgYWRkcmVzcyBvZiB0aGUgZGVwbG95ZWQgY29udHJhY3RcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBhd2FpdCBzZGsuZGVwbG95ZXIuZGVwbG95VG9rZW5Ecm9wKHtcbiAgICogICBuYW1lOiBcIk15IFRva2VuIERyb3BcIixcbiAgICogICBwcmltYXJ5X3NhbGVfcmVjaXBpZW50OiBcInlvdXItYWRkcmVzc1wiLFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIEBwYXJhbSBtZXRhZGF0YSAtIHRoZSBjb250cmFjdCBtZXRhZGF0YVxuICAgKiBAcmV0dXJucyB0aGUgYWRkcmVzcyBvZiB0aGUgZGVwbG95ZWQgY29udHJhY3RcbiAgICovXG4gIGFzeW5jIGRlcGxveVRva2VuRHJvcChtZXRhZGF0YSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRlcGxveUJ1aWx0SW5Db250cmFjdChUb2tlbkRyb3BJbml0aWFsaXplci5jb250cmFjdFR5cGUsIG1ldGFkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXBsb3lzIGEgbmV3IE1hcmtldHBsYWNlIGNvbnRyYWN0XG4gICAqXG4gICAqIEByZW1hcmtzIERlcGxveXMgYSBNYXJrZXRwbGFjZSBjb250cmFjdCBhbmQgcmV0dXJucyB0aGUgYWRkcmVzcyBvZiB0aGUgZGVwbG95ZWQgY29udHJhY3RcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBhd2FpdCBzZGsuZGVwbG95ZXIuZGVwbG95TWFya2V0cGxhY2Uoe1xuICAgKiAgIG5hbWU6IFwiTXkgTWFya2V0cGxhY2VcIixcbiAgICogICBwcmltYXJ5X3NhbGVfcmVjaXBpZW50OiBcInlvdXItYWRkcmVzc1wiLFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIEBwYXJhbSBtZXRhZGF0YSAtIHRoZSBjb250cmFjdCBtZXRhZGF0YVxuICAgKiBAcmV0dXJucyB0aGUgYWRkcmVzcyBvZiB0aGUgZGVwbG95ZWQgY29udHJhY3RcbiAgICovXG4gIGFzeW5jIGRlcGxveU1hcmtldHBsYWNlKG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGVwbG95QnVpbHRJbkNvbnRyYWN0KE1hcmtldHBsYWNlSW5pdGlhbGl6ZXIuY29udHJhY3RUeXBlLCBtZXRhZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogRGVwbG95cyBhIG5ldyBQYWNrIGNvbnRyYWN0XG4gICAqXG4gICAqIEByZW1hcmtzIERlcGxveXMgYSBQYWNrIGNvbnRyYWN0IGFuZCByZXR1cm5zIHRoZSBhZGRyZXNzIG9mIHRoZSBkZXBsb3llZCBjb250cmFjdFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IGF3YWl0IHNkay5kZXBsb3llci5kZXBsb3lQYWNrKHtcbiAgICogICBuYW1lOiBcIk15IFBhY2tcIixcbiAgICogICBwcmltYXJ5X3NhbGVfcmVjaXBpZW50OiBcInlvdXItYWRkcmVzc1wiLFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIEBwYXJhbSBtZXRhZGF0YSAtIHRoZSBjb250cmFjdCBtZXRhZGF0YVxuICAgKiBAcmV0dXJucyB0aGUgYWRkcmVzcyBvZiB0aGUgZGVwbG95ZWQgY29udHJhY3RcbiAgICovXG4gIGFzeW5jIGRlcGxveVBhY2sobWV0YWRhdGEpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kZXBsb3lCdWlsdEluQ29udHJhY3QoUGFja0luaXRpYWxpemVyLmNvbnRyYWN0VHlwZSwgbWV0YWRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcGxveXMgYSBuZXcgU3BsaXQgY29udHJhY3RcbiAgICpcbiAgICogQHJlbWFya3MgRGVwbG95cyBhIFNwbGl0IGNvbnRyYWN0IGFuZCByZXR1cm5zIHRoZSBhZGRyZXNzIG9mIHRoZSBkZXBsb3llZCBjb250cmFjdFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IGF3YWl0IHNkay5kZXBsb3llci5kZXBsb3lTcGxpdCh7XG4gICAqICAgbmFtZTogXCJNeSBTcGxpdFwiLFxuICAgKiAgIHByaW1hcnlfc2FsZV9yZWNpcGllbnQ6IFwieW91ci1hZGRyZXNzXCIsXG4gICAqICAgcmVjaXBpZW50czogW1xuICAgKiAgICB7XG4gICAqICAgICAgYWRkcmVzczogXCJ5b3VyLWFkZHJlc3NcIixcbiAgICogICAgICBzaGFyZXNCcHM6IDgwICogMTAwLCAvLyA4MCVcbiAgICogICAgfSxcbiAgICogICAge1xuICAgKiAgICAgIGFkZHJlc3M6IFwiYW5vdGhlci1hZGRyZXNzXCIsXG4gICAqICAgICAgc2hhcmVzQnBzOiAyMCAqIDEwMCwgLy8gMjAlXG4gICAqICAgIH0sXG4gICAqICAgXSxcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAcGFyYW0gbWV0YWRhdGEgLSB0aGUgY29udHJhY3QgbWV0YWRhdGFcbiAgICogQHJldHVybnMgdGhlIGFkZHJlc3Mgb2YgdGhlIGRlcGxveWVkIGNvbnRyYWN0XG4gICAqL1xuICBhc3luYyBkZXBsb3lTcGxpdChtZXRhZGF0YSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRlcGxveUJ1aWx0SW5Db250cmFjdChTcGxpdEluaXRpYWxpemVyLmNvbnRyYWN0VHlwZSwgbWV0YWRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcGxveXMgYSBuZXcgVm90ZSBjb250cmFjdFxuICAgKlxuICAgKiBAcmVtYXJrcyBEZXBsb3lzIGFuIFZvdGUgY29udHJhY3QgYW5kIHJldHVybnMgdGhlIGFkZHJlc3Mgb2YgdGhlIGRlcGxveWVkIGNvbnRyYWN0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgY29udHJhY3RBZGRyZXNzID0gYXdhaXQgc2RrLmRlcGxveWVyLmRlcGxveVZvdGUoe1xuICAgKiAgIG5hbWU6IFwiTXkgVm90ZVwiLFxuICAgKiAgIHByaW1hcnlfc2FsZV9yZWNpcGllbnQ6IFwieW91ci1hZGRyZXNzXCIsXG4gICAqICAgdm90aW5nX3Rva2VuX2FkZHJlc3M6IFwieW91ci10b2tlbi1jb250cmFjdC1hZGRyZXNzXCIsXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogQHBhcmFtIG1ldGFkYXRhIC0gdGhlIGNvbnRyYWN0IG1ldGFkYXRhXG4gICAqIEByZXR1cm5zIHRoZSBhZGRyZXNzIG9mIHRoZSBkZXBsb3llZCBjb250cmFjdFxuICAgKi9cbiAgYXN5bmMgZGVwbG95Vm90ZShtZXRhZGF0YSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRlcGxveUJ1aWx0SW5Db250cmFjdChWb3RlSW5pdGlhbGl6ZXIuY29udHJhY3RUeXBlLCBtZXRhZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogRGVwbG95cyBhIG5ldyBjb250cmFjdFxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIGNvbnRyYWN0VHlwZSAtIHRoZSB0eXBlIG9mIGNvbnRyYWN0IHRvIGRlcGxveVxuICAgKiBAcGFyYW0gY29udHJhY3RNZXRhZGF0YSAtIHRoZSBtZXRhZGF0YSB0byBkZXBsb3kgdGhlIGNvbnRyYWN0IHdpdGhcbiAgICogQHBhcmFtIHZlcnNpb25cbiAgICogQHJldHVybnMgYSBwcm9taXNlIG9mIHRoZSBhZGRyZXNzIG9mIHRoZSBuZXdseSBkZXBsb3llZCBjb250cmFjdFxuICAgKi9cbiAgYXN5bmMgZGVwbG95QnVpbHRJbkNvbnRyYWN0KGNvbnRyYWN0VHlwZSwgY29udHJhY3RNZXRhZGF0YSkge1xuICAgIGxldCB2ZXJzaW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBcImxhdGVzdFwiO1xuICAgIGNvbnN0IGFjdGl2ZUNoYWluSWQgPSAoYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpLmdldE5ldHdvcmsoKSkuY2hhaW5JZDtcbiAgICBjb25zdCBwYXJzZWRNZXRhZGF0YSA9IFBSRUJVSUxUX0NPTlRSQUNUU19NQVBbY29udHJhY3RUeXBlXS5zY2hlbWEuZGVwbG95LnBhcnNlKGNvbnRyYWN0TWV0YWRhdGEpO1xuICAgIGNvbnN0IGZhY3RvcnkgPSBhd2FpdCB0aGlzLmdldEZhY3RvcnkoKTtcbiAgICBpZiAoYWN0aXZlQ2hhaW5JZCA9PT0gQ2hhaW5JZC5IYXJkaGF0IHx8IGFjdGl2ZUNoYWluSWQgPT09IENoYWluSWQuTG9jYWxob3N0KSB7XG4gICAgICAvL1xuICAgICAgLy8gb2xkIGJlaGF2aW9yIGZvciBoYXJkaGF0IGFuZCBsb2NhbGhvc3QgY2hhaW5zXG4gICAgICAvL1xuXG4gICAgICAvLyBwYXJzZSB2ZXJzaW9uIGludG8gdGhlIGZpcnN0IG51bWJlciBvZiB0aGUgdmVyc2lvbiBzdHJpbmcgKG9yIHVuZGVmaW5lZCBpZiB1bnBhcnNlYWJsZSlcbiAgICAgIGxldCBwYXJzZWRWZXJzaW9uID0gdW5kZWZpbmVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkVmVyc2lvbiA9IHBhcnNlSW50KHZlcnNpb24pO1xuICAgICAgICBpZiAoaXNOYU4ocGFyc2VkVmVyc2lvbikpIHtcbiAgICAgICAgICBwYXJzZWRWZXJzaW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHBhcnNlZFZlcnNpb24gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXdhaXQgZmFjdG9yeS5kZXBsb3koY29udHJhY3RUeXBlLCBwYXJzZWRNZXRhZGF0YSwgcGFyc2VkVmVyc2lvbik7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBuZXcgYmVoYXZpb3IgZm9yIGFsbCBvdGhlciBjaGFpbnNcbiAgICAvL1xuXG4gICAgLy8gcmVzb2x2ZSBjb250cmFjdCBuYW1lIGZyb20gdHlwZVxuICAgIGNvbnN0IGNvbnRyYWN0TmFtZSA9IGdldENvbnRyYWN0TmFtZShjb250cmFjdFR5cGUpO1xuICAgIGludmFyaWFudChjb250cmFjdE5hbWUsIFwiY29udHJhY3QgbmFtZSBub3QgZm91bmRcIik7XG4gICAgLy8gZ2V0IGRlcGxveSBhcnVnbWVudHMgZm9yIHRoZSBjb250cmFjdFR5cGVcbiAgICAvLyBmaXJzdCB1cGxvYWQgdGhlIGNvbnRyYWN0bWV0YWRhdGFcbiAgICBjb25zdCBjb250cmFjdFVSSSA9IGF3YWl0IHRoaXMuc3RvcmFnZS51cGxvYWQocGFyc2VkTWV0YWRhdGEpO1xuICAgIC8vIHRoZSBnZXQgdGhlIGRlcGxveSBhcmd1bWVudHNcbiAgICBjb25zdCBjb25zdHJ1Y3RvclBhcmFtcyA9IGF3YWl0IGZhY3RvcnkuZ2V0RGVwbG95QXJndW1lbnRzKGNvbnRyYWN0VHlwZSwgcGFyc2VkTWV0YWRhdGEsIGNvbnRyYWN0VVJJKTtcbiAgICByZXR1cm4gdGhpcy5kZXBsb3lSZWxlYXNlZENvbnRyYWN0KFxuICAgIC8vIDB4ZGQ5OWI3NWYwOTVkMGM0ZDUxMTJhQ2U5MzhlNGU2ZWQ5NjJmYjAyNCA9PT0gZGVwbG95ZXIudGhpcmR3ZWIuZXRoXG4gICAgXCIweGRkOTliNzVmMDk1ZDBjNGQ1MTEyYUNlOTM4ZTRlNmVkOTYyZmIwMjRcIiwgY29udHJhY3ROYW1lLCBjb25zdHJ1Y3RvclBhcmFtcywgdmVyc2lvbik7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSBjb250cmFjdFR5cGVcbiAgICovXG4gIGFzeW5jIGdldExhdGVzdEJ1aWx0SW5Db250cmFjdFZlcnNpb24oY29udHJhY3RUeXBlKSB7XG4gICAgY29uc3QgZmFjdG9yeSA9IGF3YWl0IHRoaXMuZ2V0RmFjdG9yeSgpO1xuICAgIHJldHVybiBhd2FpdCBmYWN0b3J5LmdldExhdGVzdFZlcnNpb24oY29udHJhY3RUeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXBsb3kgYW55IHJlbGVhc2VkIGNvbnRyYWN0IGJ5IGl0cyBuYW1lXG4gICAqIEBwYXJhbSByZWxlYXNlckFkZHJlc3MgdGhlIGFkZHJlc3Mgb2YgdGhlIHJlbGVhc2VyXG4gICAqIEBwYXJhbSBjb250cmFjdE5hbWUgdGhlIG5hbWUgb2YgdGhlIGNvbnRyYWN0IHRvIGRlcGxveVxuICAgKiBAcGFyYW0gY29uc3RydWN0b3JQYXJhbXMgdGhlIGNvbnN0cnVjdG9yIHBhcmFtcyB0byBwYXNzIHRvIHRoZSBjb250cmFjdFxuICAgKi9cbiAgYXN5bmMgZGVwbG95UmVsZWFzZWRDb250cmFjdChyZWxlYXNlckFkZHJlc3MsIGNvbnRyYWN0TmFtZSwgY29uc3RydWN0b3JQYXJhbXMpIHtcbiAgICBsZXQgdmVyc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCJsYXRlc3RcIjtcbiAgICBjb25zdCByZWxlYXNlID0gYXdhaXQgbmV3IFRoaXJkd2ViU0RLKFwicG9seWdvblwiKS5nZXRQdWJsaXNoZXIoKS5nZXRWZXJzaW9uKHJlbGVhc2VyQWRkcmVzcywgY29udHJhY3ROYW1lLCB2ZXJzaW9uKTtcbiAgICBpZiAoIXJlbGVhc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcmVsZWFzZSBmb3VuZCBmb3IgJyR7Y29udHJhY3ROYW1lfScgYXQgdmVyc2lvbiAnJHt2ZXJzaW9ufScgYnkgJyR7cmVsZWFzZXJBZGRyZXNzfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGVwbG95Q29udHJhY3RGcm9tVXJpKHJlbGVhc2UubWV0YWRhdGFVcmksIGNvbnN0cnVjdG9yUGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXBsb3kgYSBwcm94eSBjb250cmFjdCBvZiBhIGdpdmVuIGltcGxlbWVudGF0aW9uIHZpYSB0aGUgZ2l2ZW4gZmFjdG9yeVxuICAgKiBAcGFyYW0gZmFjdG9yeUFkZHJlc3NcbiAgICogQHBhcmFtIGltcGxlbWVudGF0aW9uQWRkcmVzc1xuICAgKiBAcGFyYW0gaW1wbGVtZW50YXRpb25BYmlcbiAgICogQHBhcmFtIGluaXRpYWxpemVyRnVuY3Rpb25cbiAgICogQHBhcmFtIGluaXRpYWxpemVyQXJnc1xuICAgKi9cbiAgYXN5bmMgZGVwbG95VmlhRmFjdG9yeShmYWN0b3J5QWRkcmVzcywgaW1wbGVtZW50YXRpb25BZGRyZXNzLCBpbXBsZW1lbnRhdGlvbkFiaSwgaW5pdGlhbGl6ZXJGdW5jdGlvbiwgaW5pdGlhbGl6ZXJBcmdzKSB7XG4gICAgY29uc3Qgc2lnbmVyID0gdGhpcy5nZXRTaWduZXIoKTtcbiAgICBpbnZhcmlhbnQoc2lnbmVyLCBcInNpZ25lciBpcyByZXF1aXJlZFwiKTtcbiAgICAvLyBUT0RPIG9ubHkgcmVxdWlyZSBmYWN0b3J5IGludGVyZmFjZSBoZXJlIC0gSVByb3h5RmFjdG9yeVxuICAgIGNvbnN0IHByb3h5RmFjdG9yeSA9IG5ldyBDb250cmFjdEZhY3RvcnkoZmFjdG9yeUFkZHJlc3MsIHRoaXMuZ2V0U2lnbmVyT3JQcm92aWRlcigpLCB0aGlzLnN0b3JhZ2UsIHt9KTtcbiAgICByZXR1cm4gYXdhaXQgcHJveHlGYWN0b3J5LmRlcGxveVByb3h5QnlJbXBsZW1lbnRhdGlvbihpbXBsZW1lbnRhdGlvbkFkZHJlc3MsIGltcGxlbWVudGF0aW9uQWJpLCBpbml0aWFsaXplckZ1bmN0aW9uLCBpbml0aWFsaXplckFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcGxveSBhIHByb3h5IGNvbnRyYWN0IG9mIGEgZ2l2ZW4gaW1wbGVtZW50YXRpb24gZGlyZWN0bHlcbiAgICogQHBhcmFtIGltcGxlbWVudGF0aW9uQWRkcmVzc1xuICAgKiBAcGFyYW0gaW1wbGVtZW50YXRpb25BYmlcbiAgICogQHBhcmFtIGluaXRpYWxpemVyRnVuY3Rpb25cbiAgICogQHBhcmFtIGluaXRpYWxpemVyQXJnc1xuICAgKi9cbiAgYXN5bmMgZGVwbG95UHJveHkoaW1wbGVtZW50YXRpb25BZGRyZXNzLCBpbXBsZW1lbnRhdGlvbkFiaSwgaW5pdGlhbGl6ZXJGdW5jdGlvbiwgaW5pdGlhbGl6ZXJBcmdzKSB7XG4gICAgY29uc3QgZW5jb2RlZEluaXRpYWxpemVyID0gQ29udHJhY3QuZ2V0SW50ZXJmYWNlKGltcGxlbWVudGF0aW9uQWJpKS5lbmNvZGVGdW5jdGlvbkRhdGEoaW5pdGlhbGl6ZXJGdW5jdGlvbiwgaW5pdGlhbGl6ZXJBcmdzKTtcbiAgICBjb25zdCB7XG4gICAgICBUV1Byb3h5X19mYWN0b3J5XG4gICAgfSA9IGF3YWl0IGltcG9ydCgnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZmFjdG9yaWVzL1RXUHJveHlfX2ZhY3RvcnknKTtcbiAgICByZXR1cm4gdGhpcy5kZXBsb3lDb250cmFjdFdpdGhBYmkoVFdQcm94eV9fZmFjdG9yeS5hYmksIFRXUHJveHlfX2ZhY3RvcnkuYnl0ZWNvZGUsIFtpbXBsZW1lbnRhdGlvbkFkZHJlc3MsIGVuY29kZWRJbml0aWFsaXplcl0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgZ2V0UmVnaXN0cnkoKSB7XG4gICAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgcmVnaXN0cnkganVzdCByZXR1cm4gaXQgYmFja1xuICAgIGlmICh0aGlzLl9yZWdpc3RyeSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdHJ5O1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBnZXQgdGhlIHJlZ2lzdHJ5IGFkZHJlc3MgZm9yIHRoZSBhY3RpdmUgY2hhaW4gYW5kIGdldCBhIG5ldyBvbmVcblxuICAgIC8vIGhhdmUgdG8gZG8gaXQgbGlrZSB0aGlzIG90aGVyd2lzZSB3ZSBydW4gaXQgb3ZlciBhbmQgb3ZlciBhbmQgb3ZlclxuICAgIC8vIFwidGhpcy5fcmVnaXN0cnlcIiBoYXMgdG8gYmUgYXNzaWduZWQgdG8gdGhlIHByb21pc2UgdXBmcm9udC5cbiAgICByZXR1cm4gdGhpcy5fcmVnaXN0cnkgPSB0aGlzLmdldFByb3ZpZGVyKCkuZ2V0TmV0d29yaygpLnRoZW4oYXN5bmMgX3JlZiA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBjaGFpbklkXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGNvbnN0IHJlZ2lzdHJ5QWRkcmVzcyA9IGdldENvbnRyYWN0QWRkcmVzc0J5Q2hhaW5JZChjaGFpbklkLCBcInR3UmVnaXN0cnlcIik7XG4gICAgICByZXR1cm4gbmV3IENvbnRyYWN0UmVnaXN0cnkocmVnaXN0cnlBZGRyZXNzLCB0aGlzLmdldFNpZ25lck9yUHJvdmlkZXIoKSwgdGhpcy5vcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXRGYWN0b3J5KCkge1xuICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGZhY3RvcnkganVzdCByZXR1cm4gaXQgYmFja1xuICAgIGlmICh0aGlzLl9mYWN0b3J5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmFjdG9yeTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgZ2V0IHRoZSBmYWN0b3J5IGFkZHJlc3MgZm9yIHRoZSBhY3RpdmUgY2hhaW4gYW5kIGdldCBhIG5ldyBvbmVcblxuICAgIC8vIGhhdmUgdG8gZG8gaXQgbGlrZSB0aGlzIG90aGVyd2lzZSB3ZSBydW4gaXQgb3ZlciBhbmQgb3ZlciBhbmQgb3ZlclxuICAgIC8vIFwidGhpcy5fZmFjdG9yeVwiIGhhcyB0byBiZSBhc3NpZ25lZCB0byB0aGUgcHJvbWlzZSB1cGZyb250LlxuICAgIHJldHVybiB0aGlzLl9mYWN0b3J5ID0gdGhpcy5nZXRQcm92aWRlcigpLmdldE5ldHdvcmsoKS50aGVuKGFzeW5jIF9yZWYyID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGNoYWluSWRcbiAgICAgIH0gPSBfcmVmMjtcbiAgICAgIGNvbnN0IGZhY3RvcnlBZGRyZXNzID0gZ2V0Q29udHJhY3RBZGRyZXNzQnlDaGFpbklkKGNoYWluSWQsIFwidHdGYWN0b3J5XCIpO1xuICAgICAgY29uc3QgZmFjdG9yeSA9IG5ldyBDb250cmFjdEZhY3RvcnkoZmFjdG9yeUFkZHJlc3MsIHRoaXMuZ2V0U2lnbmVyT3JQcm92aWRlcigpLCB0aGlzLnN0b3JhZ2UsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLmV2ZW50cyA9IG5ldyBGYWN0b3J5RXZlbnRzKGZhY3RvcnkpO1xuICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlU2lnbmVyT3JQcm92aWRlcihuZXR3b3JrKSB7XG4gICAgc3VwZXIudXBkYXRlU2lnbmVyT3JQcm92aWRlcihuZXR3b3JrKTtcbiAgICB0aGlzLnVwZGF0ZUNvbnRyYWN0U2lnbmVyT3JQcm92aWRlcigpO1xuICB9XG4gIHVwZGF0ZUNvbnRyYWN0U2lnbmVyT3JQcm92aWRlcigpIHtcbiAgICAvLyBoYXMgdG8gYmUgcHJvbWlzZXMgbm93XG4gICAgdGhpcy5fZmFjdG9yeT8udGhlbihmYWN0b3J5ID0+IHtcbiAgICAgIGZhY3RvcnkudXBkYXRlU2lnbmVyT3JQcm92aWRlcih0aGlzLmdldFNpZ25lck9yUHJvdmlkZXIoKSk7XG4gICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgLy8gaWdub3JlXG4gICAgfSk7XG4gICAgLy8gaGFzIHRvIGJlIHByb21pc2VzIG5vd1xuICAgIHRoaXMuX3JlZ2lzdHJ5Py50aGVuKHJlZ2lzdHJ5ID0+IHtcbiAgICAgIHJlZ2lzdHJ5LnVwZGF0ZVNpZ25lck9yUHJvdmlkZXIodGhpcy5nZXRTaWduZXJPclByb3ZpZGVyKCkpO1xuICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgIC8vIGlnbm9yZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0gcHVibGlzaE1ldGFkYXRhVXJpXG4gICAqIEBwYXJhbSBjb25zdHJ1Y3RvclBhcmFtVmFsdWVzXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBhc3luYyBkZXBsb3lDb250cmFjdEZyb21VcmkocHVibGlzaE1ldGFkYXRhVXJpLCBjb25zdHJ1Y3RvclBhcmFtVmFsdWVzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc2lnbmVyID0gdGhpcy5nZXRTaWduZXIoKTtcbiAgICBpbnZhcmlhbnQoc2lnbmVyLCBcIkEgc2lnbmVyIGlzIHJlcXVpcmVkXCIpO1xuICAgIGNvbnN0IGNvbXBpbGVyTWV0YWRhdGEgPSBhd2FpdCBmZXRjaFByZURlcGxveU1ldGFkYXRhKHB1Ymxpc2hNZXRhZGF0YVVyaSwgdGhpcy5zdG9yYWdlKTtcbiAgICBsZXQgaXNEZXBsb3lhYmxlVmlhRmFjdG9yeTtcbiAgICBsZXQgaXNEZXBsb3lhYmxlVmlhUHJveHk7XG4gICAgbGV0IGZhY3RvcnlEZXBsb3ltZW50RGF0YTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXh0ZW5kZWRNZXRhZGF0YSA9IGF3YWl0IGZldGNoRXh0ZW5kZWRSZWxlYXNlTWV0YWRhdGEocHVibGlzaE1ldGFkYXRhVXJpLCB0aGlzLnN0b3JhZ2UpO1xuICAgICAgaXNEZXBsb3lhYmxlVmlhRmFjdG9yeSA9IGV4dGVuZGVkTWV0YWRhdGEuaXNEZXBsb3lhYmxlVmlhRmFjdG9yeTtcbiAgICAgIGlzRGVwbG95YWJsZVZpYVByb3h5ID0gZXh0ZW5kZWRNZXRhZGF0YS5pc0RlcGxveWFibGVWaWFQcm94eTtcbiAgICAgIGZhY3RvcnlEZXBsb3ltZW50RGF0YSA9IEZhY3RvcnlEZXBsb3ltZW50U2NoZW1hLnBhcnNlKGV4dGVuZGVkTWV0YWRhdGEuZmFjdG9yeURlcGxveW1lbnREYXRhKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBub3QgYSBmYWN0b3J5IGRlcGxveW1lbnQsIGlnbm9yZVxuICAgIH1cbiAgICBjb25zdCBmb3JjZURpcmVjdERlcGxveSA9IG9wdGlvbnM/LmZvcmNlRGlyZWN0RGVwbG95IHx8IGZhbHNlO1xuICAgIGlmIChmYWN0b3J5RGVwbG95bWVudERhdGEgJiYgKGlzRGVwbG95YWJsZVZpYVByb3h5IHx8IGlzRGVwbG95YWJsZVZpYUZhY3RvcnkpICYmICFmb3JjZURpcmVjdERlcGxveSkge1xuICAgICAgY29uc3QgY2hhaW5JZCA9IChhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCkuZ2V0TmV0d29yaygpKS5jaGFpbklkO1xuICAgICAgaW52YXJpYW50KGZhY3RvcnlEZXBsb3ltZW50RGF0YS5pbXBsZW1lbnRhdGlvbkFkZHJlc3NlcywgXCJpbXBsZW1lbnRhdGlvbkFkZHJlc3NlcyBpcyByZXF1aXJlZFwiKTtcbiAgICAgIGNvbnN0IGltcGxlbWVudGF0aW9uQWRkcmVzcyA9IGZhY3RvcnlEZXBsb3ltZW50RGF0YS5pbXBsZW1lbnRhdGlvbkFkZHJlc3Nlc1tjaGFpbklkXTtcbiAgICAgIGludmFyaWFudChpbXBsZW1lbnRhdGlvbkFkZHJlc3MsIGBpbXBsZW1lbnRhdGlvbkFkZHJlc3Mgbm90IGZvdW5kIGZvciBjaGFpbklkICcke2NoYWluSWR9J2ApO1xuICAgICAgaW52YXJpYW50KGZhY3RvcnlEZXBsb3ltZW50RGF0YS5pbXBsZW1lbnRhdGlvbkluaXRpYWxpemVyRnVuY3Rpb24sIGBpbXBsZW1lbnRhdGlvbkluaXRpYWxpemVyRnVuY3Rpb24gbm90IHNldCdgKTtcbiAgICAgIGNvbnN0IGluaXRpYWxpemVyUGFyYW1UeXBlcyA9IGV4dHJhY3RGdW5jdGlvblBhcmFtc0Zyb21BYmkoY29tcGlsZXJNZXRhZGF0YS5hYmksIGZhY3RvcnlEZXBsb3ltZW50RGF0YS5pbXBsZW1lbnRhdGlvbkluaXRpYWxpemVyRnVuY3Rpb24pLm1hcChwID0+IHAudHlwZSk7XG4gICAgICBjb25zdCBwYXJhbVZhbHVlcyA9IHRoaXMuY29udmVydFBhcmFtVmFsdWVzKGluaXRpYWxpemVyUGFyYW1UeXBlcywgY29uc3RydWN0b3JQYXJhbVZhbHVlcyk7XG4gICAgICBpZiAoaXNEZXBsb3lhYmxlVmlhRmFjdG9yeSkge1xuICAgICAgICAvLyBkZXBsb3kgdmlhIGEgZmFjdG9yeSAocHJpb3JpdGlzZSBmYWN0b3J5KVxuICAgICAgICBpbnZhcmlhbnQoZmFjdG9yeURlcGxveW1lbnREYXRhLmZhY3RvcnlBZGRyZXNzZXMsIFwiaXNEZXBsb3lhYmxlVmlhRmFjdG9yeSBpcyB0cnVlIHNvIGZhY3RvcnlBZGRyZXNzZXMgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIGNvbnN0IGZhY3RvcnlBZGRyZXNzID0gZmFjdG9yeURlcGxveW1lbnREYXRhLmZhY3RvcnlBZGRyZXNzZXNbY2hhaW5JZF07XG4gICAgICAgIGludmFyaWFudChmYWN0b3J5QWRkcmVzcywgYGlzRGVwbG95YWJsZVZpYUZhY3RvcnkgaXMgdHJ1ZSBhbmQgZmFjdG9yeUFkZHJlc3Mgbm90IGZvdW5kIGZvciBjaGFpbklkICcke2NoYWluSWR9J2ApO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5kZXBsb3lWaWFGYWN0b3J5KGZhY3RvcnlBZGRyZXNzLCBpbXBsZW1lbnRhdGlvbkFkZHJlc3MsIGNvbXBpbGVyTWV0YWRhdGEuYWJpLCBmYWN0b3J5RGVwbG95bWVudERhdGEuaW1wbGVtZW50YXRpb25Jbml0aWFsaXplckZ1bmN0aW9uLCBwYXJhbVZhbHVlcyk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVwbG95YWJsZVZpYVByb3h5KSB7XG4gICAgICAgIC8vIGRlcGxveSBhIHByb3h5IGRpcmVjdGx5XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRlcGxveVByb3h5KGltcGxlbWVudGF0aW9uQWRkcmVzcywgY29tcGlsZXJNZXRhZGF0YS5hYmksIGZhY3RvcnlEZXBsb3ltZW50RGF0YS5pbXBsZW1lbnRhdGlvbkluaXRpYWxpemVyRnVuY3Rpb24sIHBhcmFtVmFsdWVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYnl0ZWNvZGUgPSBjb21waWxlck1ldGFkYXRhLmJ5dGVjb2RlLnN0YXJ0c1dpdGgoXCIweFwiKSA/IGNvbXBpbGVyTWV0YWRhdGEuYnl0ZWNvZGUgOiBgMHgke2NvbXBpbGVyTWV0YWRhdGEuYnl0ZWNvZGV9YDtcbiAgICBpZiAoIWV0aGVycy51dGlscy5pc0hleFN0cmluZyhieXRlY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udHJhY3QgYnl0ZWNvZGUgaXMgaW52YWxpZC5cXG5cXG4ke2J5dGVjb2RlfWApO1xuICAgIH1cbiAgICBjb25zdCBjb25zdHJ1Y3RvclBhcmFtVHlwZXMgPSBleHRyYWN0Q29uc3RydWN0b3JQYXJhbXNGcm9tQWJpKGNvbXBpbGVyTWV0YWRhdGEuYWJpKS5tYXAocCA9PiBwLnR5cGUpO1xuICAgIGNvbnN0IHBhcmFtVmFsdWVzID0gdGhpcy5jb252ZXJ0UGFyYW1WYWx1ZXMoY29uc3RydWN0b3JQYXJhbVR5cGVzLCBjb25zdHJ1Y3RvclBhcmFtVmFsdWVzKTtcbiAgICByZXR1cm4gdGhpcy5kZXBsb3lDb250cmFjdFdpdGhBYmkoY29tcGlsZXJNZXRhZGF0YS5hYmksIGJ5dGVjb2RlLCBwYXJhbVZhbHVlcyk7XG4gIH1cbiAgY29udmVydFBhcmFtVmFsdWVzKGNvbnN0cnVjdG9yUGFyYW1UeXBlcywgY29uc3RydWN0b3JQYXJhbVZhbHVlcykge1xuICAgIC8vIGNoZWNrIHRoYXQgYm90aCBhcnJheXMgYXJlIHNhbWUgbGVuZ3RoXG4gICAgaWYgKGNvbnN0cnVjdG9yUGFyYW1UeXBlcy5sZW5ndGggIT09IGNvbnN0cnVjdG9yUGFyYW1WYWx1ZXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIlBhc3NlZCB0aGUgd3JvbmcgbnVtYmVyIG9mIGNvbnN0cnVjdG9yIGFyZ3VtZW50c1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yUGFyYW1UeXBlcy5tYXAoKHAsIGluZGV4KSA9PiB7XG4gICAgICBpZiAocCA9PT0gXCJ0dXBsZVwiIHx8IHAuZW5kc1dpdGgoXCJbXVwiKSkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnN0cnVjdG9yUGFyYW1WYWx1ZXNbaW5kZXhdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoY29uc3RydWN0b3JQYXJhbVZhbHVlc1tpbmRleF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3RvclBhcmFtVmFsdWVzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHAgPT09IFwiYnl0ZXMzMlwiKSB7XG4gICAgICAgIGludmFyaWFudChldGhlcnMudXRpbHMuaXNIZXhTdHJpbmcoY29uc3RydWN0b3JQYXJhbVZhbHVlc1tpbmRleF0pLCBgQ291bGQgbm90IHBhcnNlIGJ5dGVzMzIgdmFsdWUuIEV4cGVjdGVkIHZhbGlkIGhleCBzdHJpbmcgYnV0IGdvdCBcIiR7Y29uc3RydWN0b3JQYXJhbVZhbHVlc1tpbmRleF19XCIuYCk7XG4gICAgICAgIHJldHVybiBldGhlcnMudXRpbHMuaGV4WmVyb1BhZChjb25zdHJ1Y3RvclBhcmFtVmFsdWVzW2luZGV4XSwgMzIpO1xuICAgICAgfVxuICAgICAgaWYgKHAuc3RhcnRzV2l0aChcImJ5dGVzXCIpKSB7XG4gICAgICAgIGludmFyaWFudChldGhlcnMudXRpbHMuaXNIZXhTdHJpbmcoY29uc3RydWN0b3JQYXJhbVZhbHVlc1tpbmRleF0pLCBgQ291bGQgbm90IHBhcnNlIGJ5dGVzIHZhbHVlLiBFeHBlY3RlZCB2YWxpZCBoZXggc3RyaW5nIGJ1dCBnb3QgXCIke2NvbnN0cnVjdG9yUGFyYW1WYWx1ZXNbaW5kZXhdfVwiLmApO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3JQYXJhbVZhbHVlc1tpbmRleF07XG4gICAgICB9XG4gICAgICBpZiAocC5zdGFydHNXaXRoKFwidWludFwiKSB8fCBwLnN0YXJ0c1dpdGgoXCJpbnRcIikpIHtcbiAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKGNvbnN0cnVjdG9yUGFyYW1WYWx1ZXNbaW5kZXhdLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yUGFyYW1WYWx1ZXNbaW5kZXhdO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0gYWJpXG4gICAqIEBwYXJhbSBieXRlY29kZVxuICAgKiBAcGFyYW0gY29uc3RydWN0b3JQYXJhbXNcbiAgICovXG4gIGFzeW5jIGRlcGxveUNvbnRyYWN0V2l0aEFiaShhYmksIGJ5dGVjb2RlLCBjb25zdHJ1Y3RvclBhcmFtcykge1xuICAgIGNvbnN0IHNpZ25lciA9IHRoaXMuZ2V0U2lnbmVyKCk7XG4gICAgaW52YXJpYW50KHNpZ25lciwgXCJTaWduZXIgaXMgcmVxdWlyZWQgdG8gZGVwbG95IGNvbnRyYWN0c1wiKTtcbiAgICBjb25zdCBkZXBsb3llciA9IGF3YWl0IG5ldyBldGhlcnMuQ29udHJhY3RGYWN0b3J5KGFiaSwgYnl0ZWNvZGUpLmNvbm5lY3Qoc2lnbmVyKS5kZXBsb3koLi4uY29uc3RydWN0b3JQYXJhbXMpO1xuICAgIGNvbnN0IGRlcGxveWVkQ29udHJhY3QgPSBhd2FpdCBkZXBsb3llci5kZXBsb3llZCgpO1xuICAgIC8vIFRPRE8gcGFyc2UgdHJhbnNhY3Rpb24gcmVjZWlwdFxuICAgIHJldHVybiBkZXBsb3llZENvbnRyYWN0LmFkZHJlc3M7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmNvZGVzIGFuZCBkZWNvZGVzIENvbnRyYWN0IGZ1bmN0aW9uc1xuICogQHB1YmxpY1xuICovXG5jbGFzcyBDb250cmFjdE93bmVyIHtcbiAgY29uc3RydWN0b3IoY29udHJhY3RXcmFwcGVyKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZmVhdHVyZU5hbWVcIiwgRkVBVFVSRV9PV05FUi5uYW1lKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250cmFjdFdyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlciA9IGNvbnRyYWN0V3JhcHBlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgb3duZXIgb2YgdGhlIGNvbnRyYWN0XG4gICAqIEByZXR1cm5zIHRoZSBvd25lciBhZGRyZXNzXG4gICAqL1xuICBhc3luYyBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5vd25lcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbmV3IG93bmVyIG9mIHRoZSBjb250cmFjdFxuICAgKiBAcmVtYXJrcyBDYW4gb25seSBiZSBjYWxsZWQgYnkgdGhlIGN1cnJlbnQgb3duZXIuXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIC0gdGhlIGFkZHJlc3Mgb2YgdGhlIG5ldyBvd25lclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGF3YWl0IGNvbnRyYWN0Lm93bmVyLnNldChcIjB4MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MFwiKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBzZXQoYWRkcmVzcykge1xuICAgIHJldHVybiB7XG4gICAgICByZWNlaXB0OiBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5zZW5kVHJhbnNhY3Rpb24oXCJzZXRPd25lclwiLCBbYWRkcmVzc10pXG4gICAgfTtcbiAgfVxufVxuXG5jb25zdCBQQVBFUl9BUElfQkFTRSA9IGBodHRwczovL3BhcGVyLnh5ei9hcGlgO1xuY29uc3QgUEFQRVJfQVBJX1ZFUlNJT04gPSBgMjAyMi0wOC0xMmA7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFBBUEVSX0FQSV9VUkwgPSBgJHtQQVBFUl9BUElfQkFTRX0vJHtQQVBFUl9BUElfVkVSU0lPTn0vcGxhdGZvcm0vdGhpcmR3ZWJgO1xuY29uc3QgUEFQRVJfQ0hBSU5fSURfTUFQID0ge1xuICBbQ2hhaW5JZC5NYWlubmV0XTogXCJFdGhlcmV1bVwiLFxuICBbQ2hhaW5JZC5Hb2VybGldOiBcIkdvZXJsaVwiLFxuICBbQ2hhaW5JZC5Qb2x5Z29uXTogXCJQb2x5Z29uXCIsXG4gIFtDaGFpbklkLk11bWJhaV06IFwiTXVtYmFpXCIsXG4gIFtDaGFpbklkLkF2YWxhbmNoZV06IFwiQXZhbGFuY2hlXCJcbn07XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ2hhaW5JZFRvUGFwZXJDaGFpbihjaGFpbklkKSB7XG4gIGludmFyaWFudChjaGFpbklkIGluIFBBUEVSX0NIQUlOX0lEX01BUCwgYGNoYWluSWQgbm90IHN1cHBvcnRlZCBieSBwYXBlcjogJHtjaGFpbklkfWApO1xuICByZXR1cm4gUEFQRVJfQ0hBSU5fSURfTUFQW2NoYWluSWRdO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzc1xuICogQHBhcmFtIGNoYWluSWRcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMgdGhlIHBhcGVyIHh5eiBjb250cmFjdCBpZFxuICogQHRocm93cyBpZiB0aGUgY29udHJhY3QgaXMgbm90IHJlZ2lzdGVyZWQgb24gcGFwZXIgeHl6XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoUmVnaXN0ZXJlZENoZWNrb3V0SWQoY29udHJhY3RBZGRyZXNzLCBjaGFpbklkKSB7XG4gIGNvbnN0IHBhcGVyQ2hhaW4gPSBwYXJzZUNoYWluSWRUb1BhcGVyQ2hhaW4oY2hhaW5JZCk7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke1BBUEVSX0FQSV9VUkx9L3JlZ2lzdGVyLWNvbnRyYWN0P2NvbnRyYWN0QWRkcmVzcz0ke2NvbnRyYWN0QWRkcmVzc30mY2hhaW49JHtwYXBlckNoYWlufWApO1xuICBjb25zdCBqc29uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgaW52YXJpYW50KGpzb24ucmVzdWx0LmlkLCBcIkNvbnRyYWN0IGlzIG5vdCByZWdpc3RlcmVkIHdpdGggcGFwZXJcIik7XG4gIHJldHVybiBqc29uLnJlc3VsdC5pZDtcbn1cblxuLyoqXG4gKiBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgYSBwYXBlci54eXogY2hlY2tvdXQgbGluay5cbiAqIEBwdWJsaWNcbiAqL1xuXG5jb25zdCBERUZBVUxUX1BBUkFNUyA9IHtcbiAgZXhwaXJlc0luTWludXRlczogMTUsXG4gIGZlZUJlYXJlcjogXCJCVVlFUlwiLFxuICBzZW5kRW1haWxPblN1Y2Nlc3M6IHRydWUsXG4gIHJlZGlyZWN0QWZ0ZXJQYXltZW50OiBmYWxzZVxufTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ2hlY2tvdXRMaW5rSW50ZW50KGNvbnRyYWN0SWQsIHBhcmFtcykge1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtQQVBFUl9BUElfVVJMfS9jaGVja291dC1saW5rLWludGVudGAsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfSxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBjb250cmFjdElkLFxuICAgICAgLi4uREVGQVVMVF9QQVJBTVMsXG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICAuLi5wYXJhbXMubWV0YWRhdGEsXG4gICAgICAgIHZpYV9wbGF0Zm9ybTogXCJ0aGlyZHdlYlwiXG4gICAgICB9LFxuICAgICAgLy8gb3ZlcnJpZGVzIHRoYXQgYXJlIGhhcmQgY29kZWRcbiAgICAgIGhpZGVOYXRpdmVNaW50OiB0cnVlLFxuICAgICAgaGlkZVBhcGVyV2FsbGV0OiAhIXBhcmFtcy53YWxsZXRBZGRyZXNzLFxuICAgICAgaGlkZUV4dGVybmFsV2FsbGV0OiB0cnVlLFxuICAgICAgaGlkZVBheVdpdGhDcnlwdG86IHRydWUsXG4gICAgICB1c2VQYXBlcktleTogZmFsc2VcbiAgICB9KVxuICB9KTtcbiAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gIGludmFyaWFudChqc29uLmNoZWNrb3V0TGlua0ludGVudFVybCwgXCJGYWlsZWQgdG8gY3JlYXRlIGNoZWNrb3V0IGxpbmsgaW50ZW50XCIpO1xuICByZXR1cm4ganNvbi5jaGVja291dExpbmtJbnRlbnRVcmw7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFBhcGVyQ2hlY2tvdXQge1xuICBjb25zdHJ1Y3Rvcihjb250cmFjdFdyYXBwZXIpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250cmFjdFdyYXBwZXJcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNvbnRyYWN0V3JhcHBlciA9IGNvbnRyYWN0V3JhcHBlcjtcbiAgfVxuICBhc3luYyBnZXRDaGVja291dElkKCkge1xuICAgIHJldHVybiBmZXRjaFJlZ2lzdGVyZWRDaGVja291dElkKHRoaXMuY29udHJhY3RXcmFwcGVyLnJlYWRDb250cmFjdC5hZGRyZXNzLCBhd2FpdCB0aGlzLmNvbnRyYWN0V3JhcHBlci5nZXRDaGFpbklEKCkpO1xuICB9XG4gIGFzeW5jIGlzRW5hYmxlZCgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuICEhKGF3YWl0IHRoaXMuZ2V0Q2hlY2tvdXRJZCgpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY3JlYXRlTGlua0ludGVudChwYXJhbXMpIHtcbiAgICByZXR1cm4gYXdhaXQgY3JlYXRlQ2hlY2tvdXRMaW5rSW50ZW50KGF3YWl0IHRoaXMuZ2V0Q2hlY2tvdXRJZCgpLCBwYXJhbXMpO1xuICB9XG59XG5cbmV4cG9ydCB7IEZhY3RvcnlEZXBsb3ltZW50U2NoZW1hIGFzICQsIE1pbnRSZXF1ZXN0MTE1NSBhcyBBLCBCYXNlU2lnbmF0dXJlUGF5bG9hZElucHV0IGFzIEIsIENvbW1vbkNvbnRyYWN0U2NoZW1hIGFzIEMsIE1pbnRSZXF1ZXN0NzIxd2l0aFF1YW50aXR5IGFzIEQsIEVkaXRpb25NZXRhZGF0YU91dHB1dFNjaGVtYSBhcyBFLCBNZXJrbGVTY2hlbWEgYXMgRiwgR2VuZXJpY1JlcXVlc3QgYXMgRywgU25hcHNob3RFbnRyeUlucHV0IGFzIEgsIFNuYXBzaG90SW5wdXRTY2hlbWEgYXMgSSwgU25hcHNob3RFbnRyeVdpdGhQcm9vZlNjaGVtYSBhcyBKLCBTbmFwc2hvdFNjaGVtYSBhcyBLLCBTbmFwc2hvdEluZm9TY2hlbWEgYXMgTCwgTWludFJlcXVlc3QyMCBhcyBNLCBCWU9DQ29udHJhY3RNZXRhZGF0YVNjaGVtYSBhcyBOLCBPcHRpb25hbFByb3BlcnRpZXNJbnB1dCBhcyBPLCBQYXJ0aWFsQ2xhaW1Db25kaXRpb25JbnB1dFNjaGVtYSBhcyBQLCBDdXN0b21Db250cmFjdElucHV0IGFzIFEsIEN1c3RvbUNvbnRyYWN0T3V0cHV0IGFzIFIsIFNVUFBPUlRFRF9DSEFJTl9JRFMgYXMgUywgVG9rZW5NaW50SW5wdXRTY2hlbWEgYXMgVCwgQ3VzdG9tQ29udHJhY3REZXBsb3kgYXMgVSwgQ3VzdG9tQ29udHJhY3RTY2hlbWEgYXMgViwgQWJpVHlwZVNjaGVtYSBhcyBXLCBBYmlPYmplY3RTY2hlbWEgYXMgWCwgQWJpU2NoZW1hIGFzIFksIFByZURlcGxveU1ldGFkYXRhIGFzIFosIENoYWluSWRUb0FkZHJlc3NTY2hlbWEgYXMgXywgQ2xhaW1Db25kaXRpb25NZXRhZGF0YVNjaGVtYSBhcyBhLCBUaGlyZHdlYlNESyBhcyBhJCwgRXh0cmFQdWJsaXNoTWV0YWRhdGFTY2hlbWFJbnB1dCBhcyBhMCwgRXh0cmFQdWJsaXNoTWV0YWRhdGFTY2hlbWFPdXRwdXQgYXMgYTEsIEZ1bGxQdWJsaXNoTWV0YWRhdGFTY2hlbWFJbnB1dCBhcyBhMiwgRnVsbFB1Ymxpc2hNZXRhZGF0YVNjaGVtYU91dHB1dCBhcyBhMywgUHJvZmlsZVNjaGVtYUlucHV0IGFzIGE0LCBQcm9maWxlU2NoZW1hT3V0cHV0IGFzIGE1LCBQdWJsaXNoZWRDb250cmFjdFNjaGVtYSBhcyBhNiwgQ29udHJhY3RJbmZvU2NoZW1hIGFzIGE3LCBDb21waWxlck1ldGFkYXRhRmV0Y2hlZFNjaGVtYSBhcyBhOCwgUHJlRGVwbG95TWV0YWRhdGFGZXRjaGVkU2NoZW1hIGFzIGE5LCBFcmM3MjFDbGFpbWFibGVXaXRoQ29uZGl0aW9ucyBhcyBhQSwgRXJjNzIxV2l0aFF1YW50aXR5U2lnbmF0dXJlTWludGFibGUgYXMgYUIsIEVyYzcyMVN1cHBseSBhcyBhQywgRXJjNzIxRW51bWVyYWJsZSBhcyBhRCwgRXJjNzIxTWludGFibGUgYXMgYUUsIEVyYzcyMUJhdGNoTWludGFibGUgYXMgYUYsIEVyYzcyMUJ1cm5hYmxlIGFzIGFHLCBTdGFuZGFyZEVyYzcyMSBhcyBhSCwgRXJjMTE1NSBhcyBhSSwgRXJjMTE1NUVudW1lcmFibGUgYXMgYUosIEVyYzExNTVNaW50YWJsZSBhcyBhSywgRXJjMTE1NUJhdGNoTWludGFibGUgYXMgYUwsIEVyYzExNTVTaWduYXR1cmVNaW50YWJsZSBhcyBhTSwgRXJjMTE1NUJ1cm5hYmxlIGFzIGFOLCBFcmMxMTU1TGF6eU1pbnRhYmxlIGFzIGFPLCBTdGFuZGFyZEVyYzExNTUgYXMgYVAsIE1hcmtldHBsYWNlRGlyZWN0IGFzIGFRLCBNYXJrZXRwbGFjZUF1Y3Rpb24gYXMgYVIsIENvbnRyYWN0RGVwbG95ZXIgYXMgYVMsIEdhc0Nvc3RFc3RpbWF0b3IgYXMgYVQsIENvbnRyYWN0RXZlbnRzIGFzIGFVLCBDb250cmFjdEludGVyY2VwdG9yIGFzIGFWLCBDb250cmFjdFBsYXRmb3JtRmVlIGFzIGFXLCBDb250cmFjdFB1Ymxpc2hlZE1ldGFkYXRhIGFzIGFYLCBDb250cmFjdE93bmVyIGFzIGFZLCBUcmFuc2FjdGlvblRhc2sgYXMgYVosIFVzZXJXYWxsZXQgYXMgYV8sIExvZ2luT3B0aW9uc1NjaGVtYSBhcyBhYSwgTG9naW5QYXlsb2FkRGF0YVNjaGVtYSBhcyBhYiwgTG9naW5QYXlsb2FkU2NoZW1hIGFzIGFjLCBWZXJpZnlPcHRpb25zU2NoZW1hIGFzIGFkLCBBdXRoZW50aWNhdGlvbk9wdGlvbnNTY2hlbWEgYXMgYWUsIEF1dGhlbnRpY2F0aW9uUGF5bG9hZERhdGFTY2hlbWEgYXMgYWYsIEF1dGhlbnRpY2F0aW9uUGF5bG9hZFNjaGVtYSBhcyBhZywgV2FsbGV0QXV0aGVudGljYXRvciBhcyBhaCwgQ29udHJhY3RFbmNvZGVyIGFzIGFpLCBDb250cmFjdE1ldGFkYXRhIGFzIGFqLCBDb250cmFjdFJvbGVzIGFzIGFrLCBDb250cmFjdFJveWFsdHkgYXMgYWwsIENvbnRyYWN0UHJpbWFyeVNhbGUgYXMgYW0sIERlbGF5ZWRSZXZlYWwgYXMgYW4sIERyb3BDbGFpbUNvbmRpdGlvbnMgYXMgYW8sIERyb3BFcmMxMTU1Q2xhaW1Db25kaXRpb25zIGFzIGFwLCBEcm9wRXJjMTE1NUhpc3RvcnkgYXMgYXEsIEVyYzIwIGFzIGFyLCBFcmMyME1pbnRhYmxlIGFzIGFzLCBFcmMyMEJhdGNoTWludGFibGUgYXMgYXQsIFRva2VuRVJDMjBIaXN0b3J5IGFzIGF1LCBFcmMyMFNpZ25hdHVyZU1pbnRhYmxlIGFzIGF2LCBFcmMyMEJ1cm5hYmxlIGFzIGF3LCBTdGFuZGFyZEVyYzIwIGFzIGF4LCBFcmM3MjEgYXMgYXksIEVyYzcyMUxhenlNaW50YWJsZSBhcyBheiwgQ2xhaW1Db25kaXRpb25JbnB1dFNjaGVtYSBhcyBiLCBBUFBST1ZFRF9JTVBMRU1FTlRBVElPTlMgYXMgYiQsIExpc3RpbmdUeXBlIGFzIGIwLCBQcm9wb3NhbFN0YXRlIGFzIGIxLCBWb3RlVHlwZSBhcyBiMiwgQ2xhaW1FbGlnaWJpbGl0eSBhcyBiMywgZmV0Y2hDdXJyZW5jeVZhbHVlIGFzIGI0LCBmZXRjaEN1cnJlbmN5TWV0YWRhdGEgYXMgYjUsIG5vcm1hbGl6ZVByaWNlVmFsdWUgYXMgYjYsIGNvbnZlcnRUb1JlYWRhYmxlUXVhbnRpdHkgYXMgYjcsIE5vdEZvdW5kRXJyb3IgYXMgYjgsIEludmFsaWRBZGRyZXNzRXJyb3IgYXMgYjksIGV4dHJhY3RDb25zdHJ1Y3RvclBhcmFtcyBhcyBiQSwgZXh0cmFjdEZ1bmN0aW9ucyBhcyBiQiwgZXh0cmFjdENvbnN0cnVjdG9yUGFyYW1zRnJvbUFiaSBhcyBiQywgZXh0cmFjdEZ1bmN0aW9uUGFyYW1zRnJvbUFiaSBhcyBiRCwgZXh0cmFjdEZ1bmN0aW9uc0Zyb21BYmkgYXMgYkUsIGV4dHJhY3RFdmVudHNGcm9tQWJpIGFzIGJGLCBleHRyYWN0TWluaW1hbFByb3h5SW1wbGVtZW50YXRpb25BZGRyZXNzIGFzIGJHLCByZXNvbHZlQ29udHJhY3RVcmlGcm9tQWRkcmVzcyBhcyBiSCwgZXh0cmFjdElQRlNIYXNoRnJvbUJ5dGVjb2RlIGFzIGJJLCBmZXRjaENvbnRyYWN0TWV0YWRhdGFGcm9tQWRkcmVzcyBhcyBiSiwgZmV0Y2hDb250cmFjdE1ldGFkYXRhIGFzIGJLLCBmZXRjaFNvdXJjZUZpbGVzRnJvbU1ldGFkYXRhIGFzIGJMLCBmZXRjaFJhd1ByZWRlcGxveU1ldGFkYXRhIGFzIGJNLCBmZXRjaFByZURlcGxveU1ldGFkYXRhIGFzIGJOLCBmZXRjaEV4dGVuZGVkUmVsZWFzZU1ldGFkYXRhIGFzIGJPLCBkZXRlY3RGZWF0dXJlcyBhcyBiUCwgZ2V0QWxsRGV0ZWN0ZWRGZWF0dXJlcyBhcyBiUSwgZ2V0QWxsRGV0ZWN0ZWRGZWF0dXJlTmFtZXMgYXMgYlIsIGlzRmVhdHVyZUVuYWJsZWQgYXMgYlMsIGFzc2VydEVuYWJsZWQgYXMgYlQsIGRldGVjdENvbnRyYWN0RmVhdHVyZSBhcyBiVSwgaGFzRnVuY3Rpb24gYXMgYlYsIHRvU2VtdmVyIGFzIGJXLCBpc0luY3JlbWVudGFsVmVyc2lvbiBhcyBiWCwgaXNEb3duZ3JhZGVWZXJzaW9uIGFzIGJZLCBPWl9ERUZFTkRFUl9GT1JXQVJERVJfQUREUkVTUyBhcyBiWiwgQ09OVFJBQ1RfQUREUkVTU0VTIGFzIGJfLCBNaXNzaW5nUm9sZUVycm9yIGFzIGJhLCBBc3NldE5vdEZvdW5kRXJyb3IgYXMgYmIsIFVwbG9hZEVycm9yIGFzIGJjLCBGaWxlTmFtZU1pc3NpbmdFcnJvciBhcyBiZCwgRHVwbGljYXRlRmlsZU5hbWVFcnJvciBhcyBiZSwgTm90RW5vdWdoVG9rZW5zRXJyb3IgYXMgYmYsIE1pc3NpbmdPd25lclJvbGVFcnJvciBhcyBiZywgUXVhbnRpdHlBYm92ZUxpbWl0RXJyb3IgYXMgYmgsIEZldGNoRXJyb3IgYXMgYmksIER1cGxpY2F0ZUxlYWZzRXJyb3IgYXMgYmosIEF1Y3Rpb25BbHJlYWR5U3RhcnRlZEVycm9yIGFzIGJrLCBGdW5jdGlvbkRlcHJlY2F0ZWRFcnJvciBhcyBibCwgTGlzdGluZ05vdEZvdW5kRXJyb3IgYXMgYm0sIFdyb25nTGlzdGluZ1R5cGVFcnJvciBhcyBibiwgUmVzdHJpY3RlZFRyYW5zZmVyRXJyb3IgYXMgYm8sIEFkbWluUm9sZU1pc3NpbmdFcnJvciBhcyBicCwgQXVjdGlvbkhhc05vdEVuZGVkRXJyb3IgYXMgYnEsIEV4dGVuc2lvbk5vdEltcGxlbWVudGVkRXJyb3IgYXMgYnIsIFRyYW5zYWN0aW9uRXJyb3IgYXMgYnMsIGNvbnZlcnRUb1RXRXJyb3IgYXMgYnQsIGluY2x1ZGVzRXJyb3JNZXNzYWdlIGFzIGJ1LCBjcmVhdGVTbmFwc2hvdCBhcyBidiwgQUxMX1JPTEVTIGFzIGJ3LCBnZXRSb2xlSGFzaCBhcyBieCwgbWF0Y2hlc1ByZWJ1aWx0QWJpIGFzIGJ5LCBoYXNNYXRjaGluZ0FiaSBhcyBieiwgQ2xhaW1Db25kaXRpb25JbnB1dEFycmF5IGFzIGMsIGdldEFwcHJvdmVkSW1wbGVtZW50YXRpb24gYXMgYzAsIGdldENvbnRyYWN0QWRkcmVzc0J5Q2hhaW5JZCBhcyBjMSwgZ2V0Q29udHJhY3RQdWJsaXNoZXJBZGRyZXNzIGFzIGMyLCBnZXREZWZhdWx0VHJ1c3RlZEZvcndhcmRlcnMgYXMgYzMsIEludGVyZmFjZUlkX0lFUkM3MjEgYXMgYzQsIEludGVyZmFjZUlkX0lFUkMxMTU1IGFzIGM1LCBOQVRJVkVfVE9LRU5fQUREUkVTUyBhcyBjNiwgTkFUSVZFX1RPS0VOUyBhcyBjNywgZ2V0TmF0aXZlVG9rZW5CeUNoYWluSWQgYXMgYzgsIEV2ZW50VHlwZSBhcyBjOSwgUGFwZXJDaGVja291dCBhcyBjQSwgQ29udHJhY3RXcmFwcGVyIGFzIGNCLCBEcm9wRXJjMTE1NUNvbnRyYWN0U2NoZW1hIGFzIGNDLCBUb2tlbkVyYzExNTVDb250cmFjdFNjaGVtYSBhcyBjRCwgTWFya2V0cGxhY2VDb250cmFjdFNjaGVtYSBhcyBjRSwgbWFwT2ZmZXIgYXMgY0YsIGlzTmF0aXZlVG9rZW4gYXMgY0csIE11bHRpd3JhcENvbnRyYWN0U2NoZW1hIGFzIGNILCB1cGxvYWRPckV4dHJhY3RVUkkgYXMgY0ksIGhhc0VSQzIwQWxsb3dhbmNlIGFzIGNKLCBpc1Rva2VuQXBwcm92ZWRGb3JUcmFuc2ZlciBhcyBjSywgVG9rZW5FcmM3MjFDb250cmFjdFNjaGVtYSBhcyBjTCwgRHJvcEVyYzcyMUNvbnRyYWN0U2NoZW1hIGFzIGNNLCBGRUFUVVJFX05GVF9SRVZFQUxBQkxFIGFzIGNOLCBBZGRyZXNzU2NoZW1hIGFzIGNPLCBCaWdOdW1iZXJpc2hTY2hlbWEgYXMgY1AsIFJhd0RhdGVTY2hlbWEgYXMgY1EsIFBhY2tDb250cmFjdFNjaGVtYSBhcyBjUiwgU3BsaXRzQ29udHJhY3RTY2hlbWEgYXMgY1MsIERyb3BFcmMyMENvbnRyYWN0U2NoZW1hIGFzIGNULCBUb2tlbkVyYzIwQ29udHJhY3RTY2hlbWEgYXMgY1UsIFZvdGVDb250cmFjdFNjaGVtYSBhcyBjViwgREVGQVVMVF9JUEZTX0dBVEVXQVkgYXMgY2EsIENIQUlOX05BTUVfVE9fSUQgYXMgY2IsIENIQUlOX0lEX1RPX05BTUUgYXMgY2MsIERFRkFVTFRfUlBDX1VSTFMgYXMgY2QsIGdldFByb3ZpZGVyRm9yTmV0d29yayBhcyBjZSwgZ2V0UmVhZE9ubHlQcm92aWRlciBhcyBjZiwgRWRpdGlvbkRyb3BJbml0aWFsaXplciBhcyBjZywgRWRpdGlvbkluaXRpYWxpemVyIGFzIGNoLCBNYXJrZXRwbGFjZUluaXRpYWxpemVyIGFzIGNpLCBNdWx0aXdyYXBJbml0aWFsaXplciBhcyBjaiwgTkZUQ29sbGVjdGlvbkluaXRpYWxpemVyIGFzIGNrLCBORlREcm9wSW5pdGlhbGl6ZXIgYXMgY2wsIFBhY2tJbml0aWFsaXplciBhcyBjbSwgU2lnbmF0dXJlRHJvcEluaXRpYWxpemVyIGFzIGNuLCBTcGxpdEluaXRpYWxpemVyIGFzIGNvLCBUb2tlbkRyb3BJbml0aWFsaXplciBhcyBjcCwgVG9rZW5Jbml0aWFsaXplciBhcyBjcSwgVm90ZUluaXRpYWxpemVyIGFzIGNyLCBQUkVCVUlMVF9DT05UUkFDVFNfTUFQIGFzIGNzLCBDT05UUkFDVFNfTUFQIGFzIGN0LCBnZXRDb250cmFjdFR5cGVGb3JSZW1vdGVOYW1lIGFzIGN1LCBnZXRDb250cmFjdE5hbWUgYXMgY3YsIFBBUEVSX0FQSV9VUkwgYXMgY3csIHBhcnNlQ2hhaW5JZFRvUGFwZXJDaGFpbiBhcyBjeCwgZmV0Y2hSZWdpc3RlcmVkQ2hlY2tvdXRJZCBhcyBjeSwgY3JlYXRlQ2hlY2tvdXRMaW5rSW50ZW50IGFzIGN6LCBDbGFpbUNvbmRpdGlvbk91dHB1dFNjaGVtYSBhcyBkLCBDaGFpbklkIGFzIGUsIEVkaXRpb25NZXRhZGF0YVdpdGhPd25lck91dHB1dFNjaGVtYSBhcyBmLCBFZGl0aW9uTWV0YWRhdGFJbnB1dFNjaGVtYSBhcyBnLCBFZGl0aW9uTWV0YWRhdGFJbnB1dE9yVXJpU2NoZW1hIGFzIGgsIENvbW1vbkNvbnRyYWN0T3V0cHV0U2NoZW1hIGFzIGksIENvbW1vblJveWFsdHlTY2hlbWEgYXMgaiwgQ29tbW9uUHJpbWFyeVNhbGVTY2hlbWEgYXMgaywgQ29tbW9uUGxhdGZvcm1GZWVTY2hlbWEgYXMgbCwgQ29tbW9uVHJ1c3RlZEZvcndhcmRlclNjaGVtYSBhcyBtLCBDb21tb25TeW1ib2xTY2hlbWEgYXMgbiwgQ3VycmVuY3lTY2hlbWEgYXMgbywgQ3VycmVuY3lWYWx1ZVNjaGVtYSBhcyBwLCBTaWduYXR1cmUyMFBheWxvYWRJbnB1dCBhcyBxLCBTaWduYXR1cmUyMFBheWxvYWRPdXRwdXQgYXMgciwgU2lnbmF0dXJlNzIxUGF5bG9hZElucHV0IGFzIHMsIFNpZ25hdHVyZTcyMVBheWxvYWRPdXRwdXQgYXMgdCwgU2lnbmF0dXJlMTE1NVBheWxvYWRJbnB1dCBhcyB1LCBTaWduYXR1cmUxMTU1UGF5bG9hZElucHV0V2l0aFRva2VuSWQgYXMgdiwgU2lnbmF0dXJlMTE1NVBheWxvYWRPdXRwdXQgYXMgdywgU2lnbmF0dXJlNzIxV2l0aFF1YW50aXR5SW5wdXQgYXMgeCwgU2lnbmF0dXJlNzIxV2l0aFF1YW50aXR5T3V0cHV0IGFzIHksIE1pbnRSZXF1ZXN0NzIxIGFzIHogfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@thirdweb-dev/sdk/dist/thirdweb-checkout-aa7869f7.esm.js\n"));

/***/ }),

/***/ "./node_modules/@thirdweb-dev/sdk/dist/thirdweb-dev-sdk.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/sdk/dist/thirdweb-dev-sdk.esm.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ALL_ROLES\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bw; },\n/* harmony export */   \"APPROVED_IMPLEMENTATIONS\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.b$; },\n/* harmony export */   \"AbiObjectSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.X; },\n/* harmony export */   \"AbiSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.Y; },\n/* harmony export */   \"AbiTypeSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.W; },\n/* harmony export */   \"AdminRoleMissingError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bp; },\n/* harmony export */   \"AssetNotFoundError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bb; },\n/* harmony export */   \"AuctionAlreadyStartedError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bk; },\n/* harmony export */   \"AuctionHasNotEndedError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bq; },\n/* harmony export */   \"AuthenticationOptionsSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.ae; },\n/* harmony export */   \"AuthenticationPayloadDataSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.af; },\n/* harmony export */   \"AuthenticationPayloadSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.ag; },\n/* harmony export */   \"BYOCContractMetadataSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.N; },\n/* harmony export */   \"BaseSignaturePayloadInput\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.B; },\n/* harmony export */   \"CHAIN_ID_TO_NAME\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.cc; },\n/* harmony export */   \"CHAIN_NAME_TO_ID\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.cb; },\n/* harmony export */   \"CONTRACTS_MAP\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.ct; },\n/* harmony export */   \"CONTRACT_ADDRESSES\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.b_; },\n/* harmony export */   \"ChainId\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.e; },\n/* harmony export */   \"ChainIdToAddressSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__._; },\n/* harmony export */   \"ClaimConditionInputArray\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.c; },\n/* harmony export */   \"ClaimConditionInputSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.b; },\n/* harmony export */   \"ClaimConditionMetadataSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.a; },\n/* harmony export */   \"ClaimConditionOutputSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.d; },\n/* harmony export */   \"ClaimEligibility\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.b3; },\n/* harmony export */   \"CommonContractOutputSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.i; },\n/* harmony export */   \"CommonContractSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.C; },\n/* harmony export */   \"CommonPlatformFeeSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.l; },\n/* harmony export */   \"CommonPrimarySaleSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.k; },\n/* harmony export */   \"CommonRoyaltySchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.j; },\n/* harmony export */   \"CommonSymbolSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.n; },\n/* harmony export */   \"CommonTrustedForwarderSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.m; },\n/* harmony export */   \"CompilerMetadataFetchedSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.a8; },\n/* harmony export */   \"ContractDeployer\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aS; },\n/* harmony export */   \"ContractEncoder\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.ai; },\n/* harmony export */   \"ContractEvents\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aU; },\n/* harmony export */   \"ContractInfoSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.a7; },\n/* harmony export */   \"ContractInterceptor\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aV; },\n/* harmony export */   \"ContractMetadata\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aj; },\n/* harmony export */   \"ContractOwner\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aY; },\n/* harmony export */   \"ContractPlatformFee\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aW; },\n/* harmony export */   \"ContractPrimarySale\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.am; },\n/* harmony export */   \"ContractPublishedMetadata\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aX; },\n/* harmony export */   \"ContractRoles\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.ak; },\n/* harmony export */   \"ContractRoyalty\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.al; },\n/* harmony export */   \"CurrencySchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.o; },\n/* harmony export */   \"CurrencyValueSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.p; },\n/* harmony export */   \"CustomContractDeploy\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.U; },\n/* harmony export */   \"CustomContractInput\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.Q; },\n/* harmony export */   \"CustomContractOutput\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.R; },\n/* harmony export */   \"CustomContractSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.V; },\n/* harmony export */   \"DEFAULT_IPFS_GATEWAY\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.ca; },\n/* harmony export */   \"DEFAULT_RPC_URLS\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.cd; },\n/* harmony export */   \"DelayedReveal\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.an; },\n/* harmony export */   \"DropClaimConditions\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.ao; },\n/* harmony export */   \"DropErc1155ClaimConditions\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.ap; },\n/* harmony export */   \"DropErc1155History\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aq; },\n/* harmony export */   \"DuplicateFileNameError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.be; },\n/* harmony export */   \"DuplicateLeafsError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bj; },\n/* harmony export */   \"EditionDropInitializer\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.cg; },\n/* harmony export */   \"EditionInitializer\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.ch; },\n/* harmony export */   \"EditionMetadataInputOrUriSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.h; },\n/* harmony export */   \"EditionMetadataInputSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.g; },\n/* harmony export */   \"EditionMetadataOutputSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.E; },\n/* harmony export */   \"EditionMetadataWithOwnerOutputSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.f; },\n/* harmony export */   \"Erc1155\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aI; },\n/* harmony export */   \"Erc1155BatchMintable\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aL; },\n/* harmony export */   \"Erc1155Burnable\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aN; },\n/* harmony export */   \"Erc1155Enumerable\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aJ; },\n/* harmony export */   \"Erc1155LazyMintable\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aO; },\n/* harmony export */   \"Erc1155Mintable\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aK; },\n/* harmony export */   \"Erc1155SignatureMintable\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aM; },\n/* harmony export */   \"Erc20\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.ar; },\n/* harmony export */   \"Erc20BatchMintable\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.at; },\n/* harmony export */   \"Erc20Burnable\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aw; },\n/* harmony export */   \"Erc20Mintable\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.as; },\n/* harmony export */   \"Erc20SignatureMintable\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.av; },\n/* harmony export */   \"Erc721\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.ay; },\n/* harmony export */   \"Erc721BatchMintable\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aF; },\n/* harmony export */   \"Erc721Burnable\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aG; },\n/* harmony export */   \"Erc721ClaimableWithConditions\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aA; },\n/* harmony export */   \"Erc721Enumerable\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aD; },\n/* harmony export */   \"Erc721LazyMintable\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.az; },\n/* harmony export */   \"Erc721Mintable\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aE; },\n/* harmony export */   \"Erc721Supply\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aC; },\n/* harmony export */   \"Erc721WithQuantitySignatureMintable\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aB; },\n/* harmony export */   \"EventType\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.c9; },\n/* harmony export */   \"ExtensionNotImplementedError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.br; },\n/* harmony export */   \"ExtraPublishMetadataSchemaInput\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.a0; },\n/* harmony export */   \"ExtraPublishMetadataSchemaOutput\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.a1; },\n/* harmony export */   \"FactoryDeploymentSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.$; },\n/* harmony export */   \"FetchError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bi; },\n/* harmony export */   \"FileNameMissingError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bd; },\n/* harmony export */   \"FullPublishMetadataSchemaInput\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.a2; },\n/* harmony export */   \"FullPublishMetadataSchemaOutput\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.a3; },\n/* harmony export */   \"FunctionDeprecatedError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bl; },\n/* harmony export */   \"GasCostEstimator\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aT; },\n/* harmony export */   \"GenericRequest\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.G; },\n/* harmony export */   \"InterfaceId_IERC1155\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.c5; },\n/* harmony export */   \"InterfaceId_IERC721\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.c4; },\n/* harmony export */   \"InvalidAddressError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.b9; },\n/* harmony export */   \"ListingNotFoundError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bm; },\n/* harmony export */   \"ListingType\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.b0; },\n/* harmony export */   \"LoginOptionsSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aa; },\n/* harmony export */   \"LoginPayloadDataSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.ab; },\n/* harmony export */   \"LoginPayloadSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.ac; },\n/* harmony export */   \"MarketplaceAuction\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aR; },\n/* harmony export */   \"MarketplaceDirect\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aQ; },\n/* harmony export */   \"MarketplaceInitializer\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.ci; },\n/* harmony export */   \"MerkleSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.F; },\n/* harmony export */   \"MintRequest1155\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.A; },\n/* harmony export */   \"MintRequest20\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.M; },\n/* harmony export */   \"MintRequest721\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.z; },\n/* harmony export */   \"MintRequest721withQuantity\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.D; },\n/* harmony export */   \"MissingOwnerRoleError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bg; },\n/* harmony export */   \"MissingRoleError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.ba; },\n/* harmony export */   \"MultiwrapInitializer\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.cj; },\n/* harmony export */   \"NATIVE_TOKENS\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.c7; },\n/* harmony export */   \"NATIVE_TOKEN_ADDRESS\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.c6; },\n/* harmony export */   \"NFTCollectionInitializer\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.ck; },\n/* harmony export */   \"NFTDropInitializer\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.cl; },\n/* harmony export */   \"NotEnoughTokensError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bf; },\n/* harmony export */   \"NotFoundError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.b8; },\n/* harmony export */   \"OZ_DEFENDER_FORWARDER_ADDRESS\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bZ; },\n/* harmony export */   \"OptionalPropertiesInput\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.O; },\n/* harmony export */   \"PAPER_API_URL\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.cw; },\n/* harmony export */   \"PREBUILT_CONTRACTS_MAP\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.cs; },\n/* harmony export */   \"PackInitializer\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.cm; },\n/* harmony export */   \"PaperCheckout\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.cA; },\n/* harmony export */   \"PartialClaimConditionInputSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.P; },\n/* harmony export */   \"PreDeployMetadata\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.Z; },\n/* harmony export */   \"PreDeployMetadataFetchedSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.a9; },\n/* harmony export */   \"ProfileSchemaInput\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.a4; },\n/* harmony export */   \"ProfileSchemaOutput\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.a5; },\n/* harmony export */   \"ProposalState\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.b1; },\n/* harmony export */   \"PublishedContractSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.a6; },\n/* harmony export */   \"QuantityAboveLimitError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bh; },\n/* harmony export */   \"RestrictedTransferError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bo; },\n/* harmony export */   \"SUPPORTED_CHAIN_IDS\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.S; },\n/* harmony export */   \"Signature1155PayloadInput\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.u; },\n/* harmony export */   \"Signature1155PayloadInputWithTokenId\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.v; },\n/* harmony export */   \"Signature1155PayloadOutput\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.w; },\n/* harmony export */   \"Signature20PayloadInput\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.q; },\n/* harmony export */   \"Signature20PayloadOutput\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.r; },\n/* harmony export */   \"Signature721PayloadInput\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.s; },\n/* harmony export */   \"Signature721PayloadOutput\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.t; },\n/* harmony export */   \"Signature721WithQuantityInput\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.x; },\n/* harmony export */   \"Signature721WithQuantityOutput\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.y; },\n/* harmony export */   \"SignatureDropInitializer\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.cn; },\n/* harmony export */   \"SnapshotEntryInput\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.H; },\n/* harmony export */   \"SnapshotEntryWithProofSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.J; },\n/* harmony export */   \"SnapshotInfoSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.L; },\n/* harmony export */   \"SnapshotInputSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.I; },\n/* harmony export */   \"SnapshotSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.K; },\n/* harmony export */   \"SplitInitializer\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.co; },\n/* harmony export */   \"StandardErc1155\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aP; },\n/* harmony export */   \"StandardErc20\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.ax; },\n/* harmony export */   \"StandardErc721\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aH; },\n/* harmony export */   \"ThirdwebSDK\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.a$; },\n/* harmony export */   \"TokenDropInitializer\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.cp; },\n/* harmony export */   \"TokenERC20History\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.au; },\n/* harmony export */   \"TokenInitializer\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.cq; },\n/* harmony export */   \"TokenMintInputSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.T; },\n/* harmony export */   \"TransactionError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bs; },\n/* harmony export */   \"TransactionTask\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.aZ; },\n/* harmony export */   \"UploadError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bc; },\n/* harmony export */   \"UserWallet\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.a_; },\n/* harmony export */   \"VerifyOptionsSchema\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.ad; },\n/* harmony export */   \"VoteInitializer\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.cr; },\n/* harmony export */   \"VoteType\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.b2; },\n/* harmony export */   \"WalletAuthenticator\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.ah; },\n/* harmony export */   \"WrongListingTypeError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bn; },\n/* harmony export */   \"assertEnabled\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bT; },\n/* harmony export */   \"convertToReadableQuantity\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.b7; },\n/* harmony export */   \"convertToTWError\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bt; },\n/* harmony export */   \"createCheckoutLinkIntent\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.cz; },\n/* harmony export */   \"createSnapshot\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bv; },\n/* harmony export */   \"detectContractFeature\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bU; },\n/* harmony export */   \"detectFeatures\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bP; },\n/* harmony export */   \"extractConstructorParams\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bA; },\n/* harmony export */   \"extractConstructorParamsFromAbi\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bC; },\n/* harmony export */   \"extractEventsFromAbi\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bF; },\n/* harmony export */   \"extractFunctionParamsFromAbi\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bD; },\n/* harmony export */   \"extractFunctions\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bB; },\n/* harmony export */   \"extractFunctionsFromAbi\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bE; },\n/* harmony export */   \"extractIPFSHashFromBytecode\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bI; },\n/* harmony export */   \"extractMinimalProxyImplementationAddress\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bG; },\n/* harmony export */   \"fetchContractMetadata\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bK; },\n/* harmony export */   \"fetchContractMetadataFromAddress\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bJ; },\n/* harmony export */   \"fetchCurrencyMetadata\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.b5; },\n/* harmony export */   \"fetchCurrencyValue\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.b4; },\n/* harmony export */   \"fetchExtendedReleaseMetadata\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bO; },\n/* harmony export */   \"fetchPreDeployMetadata\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bN; },\n/* harmony export */   \"fetchRawPredeployMetadata\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bM; },\n/* harmony export */   \"fetchRegisteredCheckoutId\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.cy; },\n/* harmony export */   \"fetchSourceFilesFromMetadata\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bL; },\n/* harmony export */   \"getAllDetectedFeatureNames\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bR; },\n/* harmony export */   \"getAllDetectedFeatures\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bQ; },\n/* harmony export */   \"getApprovedImplementation\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.c0; },\n/* harmony export */   \"getContractAddressByChainId\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.c1; },\n/* harmony export */   \"getContractName\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.cv; },\n/* harmony export */   \"getContractPublisherAddress\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.c2; },\n/* harmony export */   \"getContractTypeForRemoteName\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.cu; },\n/* harmony export */   \"getDefaultTrustedForwarders\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.c3; },\n/* harmony export */   \"getNativeTokenByChainId\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.c8; },\n/* harmony export */   \"getProviderForNetwork\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.ce; },\n/* harmony export */   \"getReadOnlyProvider\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.cf; },\n/* harmony export */   \"getRoleHash\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bx; },\n/* harmony export */   \"hasFunction\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bV; },\n/* harmony export */   \"hasMatchingAbi\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bz; },\n/* harmony export */   \"includesErrorMessage\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bu; },\n/* harmony export */   \"isDowngradeVersion\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bY; },\n/* harmony export */   \"isFeatureEnabled\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bS; },\n/* harmony export */   \"isIncrementalVersion\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bX; },\n/* harmony export */   \"matchesPrebuiltAbi\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.by; },\n/* harmony export */   \"normalizePriceValue\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.b6; },\n/* harmony export */   \"parseChainIdToPaperChain\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.cx; },\n/* harmony export */   \"resolveContractUriFromAddress\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bH; },\n/* harmony export */   \"toSemver\": function() { return /* reexport safe */ _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__.bW; }\n/* harmony export */ });\n/* harmony import */ var _thirdweb_checkout_aa7869f7_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./thirdweb-checkout-aa7869f7.esm.js */ \"./node_modules/@thirdweb-dev/sdk/dist/thirdweb-checkout-aa7869f7.esm.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IERC165_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IERC165.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC165.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IERC721_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IERC721.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IERC1155_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IERC1155.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155.json\");\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tiny-invariant */ \"./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IThirdwebContract_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IThirdwebContract.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IThirdwebContract.json\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! eventemitter3 */ \"./node_modules/@thirdweb-dev/sdk/node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cross-fetch */ \"./node_modules/cross-fetch/dist/browser-ponyfill.js\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(cross_fetch__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_Forwarder_json__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/Forwarder.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/Forwarder.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_DropERC20_V2_json__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/DropERC20_V2.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/DropERC20_V2.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IBurnableERC20_json__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IBurnableERC20.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IBurnableERC20.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IDrop_json__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IDrop.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IDrop.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IDropSinglePhase_json__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IDropSinglePhase_V1_json__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase_V1.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase_V1.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IERC20_json__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IERC20.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IMintableERC20_json__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IMintableERC20.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IMintableERC20.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IMulticall_json__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IMulticall.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IMulticall.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_ISignatureMintERC20_json__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC20.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC20.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_DropERC721_V3_json__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/DropERC721_V3.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/DropERC721_V3.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IBurnableERC721_json__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IBurnableERC721.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IBurnableERC721.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IClaimableERC721_json__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IClaimableERC721.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IClaimableERC721.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IDelayedReveal_json__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IDelayedReveal.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IDelayedReveal.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IERC721Enumerable_json__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IERC721Enumerable.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721Enumerable.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IERC721Supply_json__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IERC721Supply.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721Supply.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_ILazyMint_json__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/ILazyMint.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/ILazyMint.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IMintableERC721_json__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IMintableERC721.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IMintableERC721.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_ISignatureMintERC721_json__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_ISignatureMintERC721_V1_json__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721_V1.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721_V1.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_LazyMintWithTier_json__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/LazyMintWithTier.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/LazyMintWithTier.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_DropERC1155_V2_json__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/DropERC1155_V2.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/DropERC1155_V2.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IBurnableERC1155_json__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IBurnableERC1155.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IBurnableERC1155.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IClaimableERC1155_json__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IClaimableERC1155.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IClaimableERC1155.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IDrop1155_json__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IDrop1155.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IDrop1155.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IDropSinglePhase1155_json__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IDropSinglePhase1155_V1_json__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155_V1.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155_V1.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IERC1155Enumerable_json__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IERC1155Enumerable.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155Enumerable.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IMintableERC1155_json__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IMintableERC1155.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IMintableERC1155.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_ISignatureMintERC1155_json__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC1155.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC1155.json\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! bs58 */ \"./node_modules/@thirdweb-dev/sdk/node_modules/bs58/index.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_39___default = /*#__PURE__*/__webpack_require__.n(bs58__WEBPACK_IMPORTED_MODULE_39__);\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IERC20Metadata_json__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IERC20Metadata.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20Metadata.json\");\n/* harmony import */ var merkletreejs__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! merkletreejs */ \"./node_modules/merkletreejs/dist/index.js\");\n/* harmony import */ var merkletreejs__WEBPACK_IMPORTED_MODULE_41___default = /*#__PURE__*/__webpack_require__.n(merkletreejs__WEBPACK_IMPORTED_MODULE_41__);\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! fast-deep-equal */ \"./node_modules/fast-deep-equal/index.js\");\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_42___default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal__WEBPACK_IMPORTED_MODULE_42__);\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IERC721Metadata_json__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IERC1155Metadata_json__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IDelayedRevealDeprecated_json__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IDelayedRevealDeprecated.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IDelayedRevealDeprecated.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_TWFactory_json__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/TWFactory.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/TWFactory.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_TWRegistry_json__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/TWRegistry.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/TWRegistry.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_ContractPublisher_json__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/ContractPublisher.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/ContractPublisher.json\");\n/* harmony import */ var _thirdweb_dev_storage__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! @thirdweb-dev/storage */ \"./node_modules/@thirdweb-dev/storage/dist/thirdweb-dev-storage.esm.js\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_ERC2771Context_json__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/ERC2771Context.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/ERC2771Context.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IAppURI_json__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IAppURI.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IAppURI.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IContractMetadata_json__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IContractMetadata.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IContractMetadata.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IPermissions_json__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IPermissions.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IPermissions.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IPermissionsEnumerable_json__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IPermissionsEnumerable.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IPermissionsEnumerable.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IPlatformFee_json__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IPlatformFee.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IPlatformFee.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IPrimarySale_json__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IPrimarySale.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IPrimarySale.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_IRoyalty_json__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/IRoyalty.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IRoyalty.json\");\n/* harmony import */ var _thirdweb_dev_contracts_js_dist_abis_Ownable_json__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! @thirdweb-dev/contracts-js/dist/abis/Ownable.json */ \"./node_modules/@thirdweb-dev/contracts-js/dist/abis/Ownable.json\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// handle browser vs node global\nglobalThis.global = globalThis;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi9zZGsvZGlzdC90aGlyZHdlYi1kZXYtc2RrLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW0vTDtBQUN0K0w7QUFDMEI7QUFDeEI7QUFDQztBQUMwQjtBQUNpQjtBQUNBO0FBQ0M7QUFDcEM7QUFDNkM7QUFDOUM7QUFDRjtBQUN3QztBQUNHO0FBQ0U7QUFDVDtBQUNXO0FBQ0c7QUFDYjtBQUNRO0FBQ0o7QUFDUztBQUNOO0FBQ0U7QUFDQztBQUNGO0FBQ0c7QUFDSjtBQUNKO0FBQ007QUFDSztBQUNHO0FBQ1A7QUFDRjtBQUNFO0FBQ0M7QUFDUjtBQUNXO0FBQ0c7QUFDTDtBQUNGO0FBQ0s7QUFDM0Q7QUFDb0Q7QUFDNUM7QUFDRztBQUNYO0FBQ3FEO0FBQ0M7QUFDUTtBQUNmO0FBQ0M7QUFDTztBQUN0QztBQUNtQztBQUNQO0FBQ1U7QUFDTDtBQUNVO0FBQ1Y7QUFDQTtBQUNKO0FBQ0Q7O0FBRTNEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aGlyZHdlYi1kZXYvc2RrL2Rpc3QvdGhpcmR3ZWItZGV2LXNkay5lc20uanM/NGI5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBidyBhcyBBTExfUk9MRVMsIGIkIGFzIEFQUFJPVkVEX0lNUExFTUVOVEFUSU9OUywgWCBhcyBBYmlPYmplY3RTY2hlbWEsIFkgYXMgQWJpU2NoZW1hLCBXIGFzIEFiaVR5cGVTY2hlbWEsIGJwIGFzIEFkbWluUm9sZU1pc3NpbmdFcnJvciwgYmIgYXMgQXNzZXROb3RGb3VuZEVycm9yLCBiayBhcyBBdWN0aW9uQWxyZWFkeVN0YXJ0ZWRFcnJvciwgYnEgYXMgQXVjdGlvbkhhc05vdEVuZGVkRXJyb3IsIGFlIGFzIEF1dGhlbnRpY2F0aW9uT3B0aW9uc1NjaGVtYSwgYWYgYXMgQXV0aGVudGljYXRpb25QYXlsb2FkRGF0YVNjaGVtYSwgYWcgYXMgQXV0aGVudGljYXRpb25QYXlsb2FkU2NoZW1hLCBOIGFzIEJZT0NDb250cmFjdE1ldGFkYXRhU2NoZW1hLCBCIGFzIEJhc2VTaWduYXR1cmVQYXlsb2FkSW5wdXQsIGNjIGFzIENIQUlOX0lEX1RPX05BTUUsIGNiIGFzIENIQUlOX05BTUVfVE9fSUQsIGN0IGFzIENPTlRSQUNUU19NQVAsIGJfIGFzIENPTlRSQUNUX0FERFJFU1NFUywgZSBhcyBDaGFpbklkLCBfIGFzIENoYWluSWRUb0FkZHJlc3NTY2hlbWEsIGMgYXMgQ2xhaW1Db25kaXRpb25JbnB1dEFycmF5LCBiIGFzIENsYWltQ29uZGl0aW9uSW5wdXRTY2hlbWEsIGEgYXMgQ2xhaW1Db25kaXRpb25NZXRhZGF0YVNjaGVtYSwgZCBhcyBDbGFpbUNvbmRpdGlvbk91dHB1dFNjaGVtYSwgYjMgYXMgQ2xhaW1FbGlnaWJpbGl0eSwgaSBhcyBDb21tb25Db250cmFjdE91dHB1dFNjaGVtYSwgQyBhcyBDb21tb25Db250cmFjdFNjaGVtYSwgbCBhcyBDb21tb25QbGF0Zm9ybUZlZVNjaGVtYSwgayBhcyBDb21tb25QcmltYXJ5U2FsZVNjaGVtYSwgaiBhcyBDb21tb25Sb3lhbHR5U2NoZW1hLCBuIGFzIENvbW1vblN5bWJvbFNjaGVtYSwgbSBhcyBDb21tb25UcnVzdGVkRm9yd2FyZGVyU2NoZW1hLCBhOCBhcyBDb21waWxlck1ldGFkYXRhRmV0Y2hlZFNjaGVtYSwgYVMgYXMgQ29udHJhY3REZXBsb3llciwgYWkgYXMgQ29udHJhY3RFbmNvZGVyLCBhVSBhcyBDb250cmFjdEV2ZW50cywgYTcgYXMgQ29udHJhY3RJbmZvU2NoZW1hLCBhViBhcyBDb250cmFjdEludGVyY2VwdG9yLCBhaiBhcyBDb250cmFjdE1ldGFkYXRhLCBhWSBhcyBDb250cmFjdE93bmVyLCBhVyBhcyBDb250cmFjdFBsYXRmb3JtRmVlLCBhbSBhcyBDb250cmFjdFByaW1hcnlTYWxlLCBhWCBhcyBDb250cmFjdFB1Ymxpc2hlZE1ldGFkYXRhLCBhayBhcyBDb250cmFjdFJvbGVzLCBhbCBhcyBDb250cmFjdFJveWFsdHksIG8gYXMgQ3VycmVuY3lTY2hlbWEsIHAgYXMgQ3VycmVuY3lWYWx1ZVNjaGVtYSwgVSBhcyBDdXN0b21Db250cmFjdERlcGxveSwgUSBhcyBDdXN0b21Db250cmFjdElucHV0LCBSIGFzIEN1c3RvbUNvbnRyYWN0T3V0cHV0LCBWIGFzIEN1c3RvbUNvbnRyYWN0U2NoZW1hLCBjYSBhcyBERUZBVUxUX0lQRlNfR0FURVdBWSwgY2QgYXMgREVGQVVMVF9SUENfVVJMUywgYW4gYXMgRGVsYXllZFJldmVhbCwgYW8gYXMgRHJvcENsYWltQ29uZGl0aW9ucywgYXAgYXMgRHJvcEVyYzExNTVDbGFpbUNvbmRpdGlvbnMsIGFxIGFzIERyb3BFcmMxMTU1SGlzdG9yeSwgYmUgYXMgRHVwbGljYXRlRmlsZU5hbWVFcnJvciwgYmogYXMgRHVwbGljYXRlTGVhZnNFcnJvciwgY2cgYXMgRWRpdGlvbkRyb3BJbml0aWFsaXplciwgY2ggYXMgRWRpdGlvbkluaXRpYWxpemVyLCBoIGFzIEVkaXRpb25NZXRhZGF0YUlucHV0T3JVcmlTY2hlbWEsIGcgYXMgRWRpdGlvbk1ldGFkYXRhSW5wdXRTY2hlbWEsIEUgYXMgRWRpdGlvbk1ldGFkYXRhT3V0cHV0U2NoZW1hLCBmIGFzIEVkaXRpb25NZXRhZGF0YVdpdGhPd25lck91dHB1dFNjaGVtYSwgYUkgYXMgRXJjMTE1NSwgYUwgYXMgRXJjMTE1NUJhdGNoTWludGFibGUsIGFOIGFzIEVyYzExNTVCdXJuYWJsZSwgYUogYXMgRXJjMTE1NUVudW1lcmFibGUsIGFPIGFzIEVyYzExNTVMYXp5TWludGFibGUsIGFLIGFzIEVyYzExNTVNaW50YWJsZSwgYU0gYXMgRXJjMTE1NVNpZ25hdHVyZU1pbnRhYmxlLCBhciBhcyBFcmMyMCwgYXQgYXMgRXJjMjBCYXRjaE1pbnRhYmxlLCBhdyBhcyBFcmMyMEJ1cm5hYmxlLCBhcyBhcyBFcmMyME1pbnRhYmxlLCBhdiBhcyBFcmMyMFNpZ25hdHVyZU1pbnRhYmxlLCBheSBhcyBFcmM3MjEsIGFGIGFzIEVyYzcyMUJhdGNoTWludGFibGUsIGFHIGFzIEVyYzcyMUJ1cm5hYmxlLCBhQSBhcyBFcmM3MjFDbGFpbWFibGVXaXRoQ29uZGl0aW9ucywgYUQgYXMgRXJjNzIxRW51bWVyYWJsZSwgYXogYXMgRXJjNzIxTGF6eU1pbnRhYmxlLCBhRSBhcyBFcmM3MjFNaW50YWJsZSwgYUMgYXMgRXJjNzIxU3VwcGx5LCBhQiBhcyBFcmM3MjFXaXRoUXVhbnRpdHlTaWduYXR1cmVNaW50YWJsZSwgYzkgYXMgRXZlbnRUeXBlLCBiciBhcyBFeHRlbnNpb25Ob3RJbXBsZW1lbnRlZEVycm9yLCBhMCBhcyBFeHRyYVB1Ymxpc2hNZXRhZGF0YVNjaGVtYUlucHV0LCBhMSBhcyBFeHRyYVB1Ymxpc2hNZXRhZGF0YVNjaGVtYU91dHB1dCwgJCBhcyBGYWN0b3J5RGVwbG95bWVudFNjaGVtYSwgYmkgYXMgRmV0Y2hFcnJvciwgYmQgYXMgRmlsZU5hbWVNaXNzaW5nRXJyb3IsIGEyIGFzIEZ1bGxQdWJsaXNoTWV0YWRhdGFTY2hlbWFJbnB1dCwgYTMgYXMgRnVsbFB1Ymxpc2hNZXRhZGF0YVNjaGVtYU91dHB1dCwgYmwgYXMgRnVuY3Rpb25EZXByZWNhdGVkRXJyb3IsIGFUIGFzIEdhc0Nvc3RFc3RpbWF0b3IsIEcgYXMgR2VuZXJpY1JlcXVlc3QsIGM1IGFzIEludGVyZmFjZUlkX0lFUkMxMTU1LCBjNCBhcyBJbnRlcmZhY2VJZF9JRVJDNzIxLCBiOSBhcyBJbnZhbGlkQWRkcmVzc0Vycm9yLCBibSBhcyBMaXN0aW5nTm90Rm91bmRFcnJvciwgYjAgYXMgTGlzdGluZ1R5cGUsIGFhIGFzIExvZ2luT3B0aW9uc1NjaGVtYSwgYWIgYXMgTG9naW5QYXlsb2FkRGF0YVNjaGVtYSwgYWMgYXMgTG9naW5QYXlsb2FkU2NoZW1hLCBhUiBhcyBNYXJrZXRwbGFjZUF1Y3Rpb24sIGFRIGFzIE1hcmtldHBsYWNlRGlyZWN0LCBjaSBhcyBNYXJrZXRwbGFjZUluaXRpYWxpemVyLCBGIGFzIE1lcmtsZVNjaGVtYSwgQSBhcyBNaW50UmVxdWVzdDExNTUsIE0gYXMgTWludFJlcXVlc3QyMCwgeiBhcyBNaW50UmVxdWVzdDcyMSwgRCBhcyBNaW50UmVxdWVzdDcyMXdpdGhRdWFudGl0eSwgYmcgYXMgTWlzc2luZ093bmVyUm9sZUVycm9yLCBiYSBhcyBNaXNzaW5nUm9sZUVycm9yLCBjaiBhcyBNdWx0aXdyYXBJbml0aWFsaXplciwgYzcgYXMgTkFUSVZFX1RPS0VOUywgYzYgYXMgTkFUSVZFX1RPS0VOX0FERFJFU1MsIGNrIGFzIE5GVENvbGxlY3Rpb25Jbml0aWFsaXplciwgY2wgYXMgTkZURHJvcEluaXRpYWxpemVyLCBiZiBhcyBOb3RFbm91Z2hUb2tlbnNFcnJvciwgYjggYXMgTm90Rm91bmRFcnJvciwgYlogYXMgT1pfREVGRU5ERVJfRk9SV0FSREVSX0FERFJFU1MsIE8gYXMgT3B0aW9uYWxQcm9wZXJ0aWVzSW5wdXQsIGN3IGFzIFBBUEVSX0FQSV9VUkwsIGNzIGFzIFBSRUJVSUxUX0NPTlRSQUNUU19NQVAsIGNtIGFzIFBhY2tJbml0aWFsaXplciwgY0EgYXMgUGFwZXJDaGVja291dCwgUCBhcyBQYXJ0aWFsQ2xhaW1Db25kaXRpb25JbnB1dFNjaGVtYSwgWiBhcyBQcmVEZXBsb3lNZXRhZGF0YSwgYTkgYXMgUHJlRGVwbG95TWV0YWRhdGFGZXRjaGVkU2NoZW1hLCBhNCBhcyBQcm9maWxlU2NoZW1hSW5wdXQsIGE1IGFzIFByb2ZpbGVTY2hlbWFPdXRwdXQsIGIxIGFzIFByb3Bvc2FsU3RhdGUsIGE2IGFzIFB1Ymxpc2hlZENvbnRyYWN0U2NoZW1hLCBiaCBhcyBRdWFudGl0eUFib3ZlTGltaXRFcnJvciwgYm8gYXMgUmVzdHJpY3RlZFRyYW5zZmVyRXJyb3IsIFMgYXMgU1VQUE9SVEVEX0NIQUlOX0lEUywgdSBhcyBTaWduYXR1cmUxMTU1UGF5bG9hZElucHV0LCB2IGFzIFNpZ25hdHVyZTExNTVQYXlsb2FkSW5wdXRXaXRoVG9rZW5JZCwgdyBhcyBTaWduYXR1cmUxMTU1UGF5bG9hZE91dHB1dCwgcSBhcyBTaWduYXR1cmUyMFBheWxvYWRJbnB1dCwgciBhcyBTaWduYXR1cmUyMFBheWxvYWRPdXRwdXQsIHMgYXMgU2lnbmF0dXJlNzIxUGF5bG9hZElucHV0LCB0IGFzIFNpZ25hdHVyZTcyMVBheWxvYWRPdXRwdXQsIHggYXMgU2lnbmF0dXJlNzIxV2l0aFF1YW50aXR5SW5wdXQsIHkgYXMgU2lnbmF0dXJlNzIxV2l0aFF1YW50aXR5T3V0cHV0LCBjbiBhcyBTaWduYXR1cmVEcm9wSW5pdGlhbGl6ZXIsIEggYXMgU25hcHNob3RFbnRyeUlucHV0LCBKIGFzIFNuYXBzaG90RW50cnlXaXRoUHJvb2ZTY2hlbWEsIEwgYXMgU25hcHNob3RJbmZvU2NoZW1hLCBJIGFzIFNuYXBzaG90SW5wdXRTY2hlbWEsIEsgYXMgU25hcHNob3RTY2hlbWEsIGNvIGFzIFNwbGl0SW5pdGlhbGl6ZXIsIGFQIGFzIFN0YW5kYXJkRXJjMTE1NSwgYXggYXMgU3RhbmRhcmRFcmMyMCwgYUggYXMgU3RhbmRhcmRFcmM3MjEsIGEkIGFzIFRoaXJkd2ViU0RLLCBjcCBhcyBUb2tlbkRyb3BJbml0aWFsaXplciwgYXUgYXMgVG9rZW5FUkMyMEhpc3RvcnksIGNxIGFzIFRva2VuSW5pdGlhbGl6ZXIsIFQgYXMgVG9rZW5NaW50SW5wdXRTY2hlbWEsIGJzIGFzIFRyYW5zYWN0aW9uRXJyb3IsIGFaIGFzIFRyYW5zYWN0aW9uVGFzaywgYmMgYXMgVXBsb2FkRXJyb3IsIGFfIGFzIFVzZXJXYWxsZXQsIGFkIGFzIFZlcmlmeU9wdGlvbnNTY2hlbWEsIGNyIGFzIFZvdGVJbml0aWFsaXplciwgYjIgYXMgVm90ZVR5cGUsIGFoIGFzIFdhbGxldEF1dGhlbnRpY2F0b3IsIGJuIGFzIFdyb25nTGlzdGluZ1R5cGVFcnJvciwgYlQgYXMgYXNzZXJ0RW5hYmxlZCwgYjcgYXMgY29udmVydFRvUmVhZGFibGVRdWFudGl0eSwgYnQgYXMgY29udmVydFRvVFdFcnJvciwgY3ogYXMgY3JlYXRlQ2hlY2tvdXRMaW5rSW50ZW50LCBidiBhcyBjcmVhdGVTbmFwc2hvdCwgYlUgYXMgZGV0ZWN0Q29udHJhY3RGZWF0dXJlLCBiUCBhcyBkZXRlY3RGZWF0dXJlcywgYkEgYXMgZXh0cmFjdENvbnN0cnVjdG9yUGFyYW1zLCBiQyBhcyBleHRyYWN0Q29uc3RydWN0b3JQYXJhbXNGcm9tQWJpLCBiRiBhcyBleHRyYWN0RXZlbnRzRnJvbUFiaSwgYkQgYXMgZXh0cmFjdEZ1bmN0aW9uUGFyYW1zRnJvbUFiaSwgYkIgYXMgZXh0cmFjdEZ1bmN0aW9ucywgYkUgYXMgZXh0cmFjdEZ1bmN0aW9uc0Zyb21BYmksIGJJIGFzIGV4dHJhY3RJUEZTSGFzaEZyb21CeXRlY29kZSwgYkcgYXMgZXh0cmFjdE1pbmltYWxQcm94eUltcGxlbWVudGF0aW9uQWRkcmVzcywgYksgYXMgZmV0Y2hDb250cmFjdE1ldGFkYXRhLCBiSiBhcyBmZXRjaENvbnRyYWN0TWV0YWRhdGFGcm9tQWRkcmVzcywgYjUgYXMgZmV0Y2hDdXJyZW5jeU1ldGFkYXRhLCBiNCBhcyBmZXRjaEN1cnJlbmN5VmFsdWUsIGJPIGFzIGZldGNoRXh0ZW5kZWRSZWxlYXNlTWV0YWRhdGEsIGJOIGFzIGZldGNoUHJlRGVwbG95TWV0YWRhdGEsIGJNIGFzIGZldGNoUmF3UHJlZGVwbG95TWV0YWRhdGEsIGN5IGFzIGZldGNoUmVnaXN0ZXJlZENoZWNrb3V0SWQsIGJMIGFzIGZldGNoU291cmNlRmlsZXNGcm9tTWV0YWRhdGEsIGJSIGFzIGdldEFsbERldGVjdGVkRmVhdHVyZU5hbWVzLCBiUSBhcyBnZXRBbGxEZXRlY3RlZEZlYXR1cmVzLCBjMCBhcyBnZXRBcHByb3ZlZEltcGxlbWVudGF0aW9uLCBjMSBhcyBnZXRDb250cmFjdEFkZHJlc3NCeUNoYWluSWQsIGN2IGFzIGdldENvbnRyYWN0TmFtZSwgYzIgYXMgZ2V0Q29udHJhY3RQdWJsaXNoZXJBZGRyZXNzLCBjdSBhcyBnZXRDb250cmFjdFR5cGVGb3JSZW1vdGVOYW1lLCBjMyBhcyBnZXREZWZhdWx0VHJ1c3RlZEZvcndhcmRlcnMsIGM4IGFzIGdldE5hdGl2ZVRva2VuQnlDaGFpbklkLCBjZSBhcyBnZXRQcm92aWRlckZvck5ldHdvcmssIGNmIGFzIGdldFJlYWRPbmx5UHJvdmlkZXIsIGJ4IGFzIGdldFJvbGVIYXNoLCBiViBhcyBoYXNGdW5jdGlvbiwgYnogYXMgaGFzTWF0Y2hpbmdBYmksIGJ1IGFzIGluY2x1ZGVzRXJyb3JNZXNzYWdlLCBiWSBhcyBpc0Rvd25ncmFkZVZlcnNpb24sIGJTIGFzIGlzRmVhdHVyZUVuYWJsZWQsIGJYIGFzIGlzSW5jcmVtZW50YWxWZXJzaW9uLCBieSBhcyBtYXRjaGVzUHJlYnVpbHRBYmksIGI2IGFzIG5vcm1hbGl6ZVByaWNlVmFsdWUsIGN4IGFzIHBhcnNlQ2hhaW5JZFRvUGFwZXJDaGFpbiwgYkggYXMgcmVzb2x2ZUNvbnRyYWN0VXJpRnJvbUFkZHJlc3MsIGJXIGFzIHRvU2VtdmVyIH0gZnJvbSAnLi90aGlyZHdlYi1jaGVja291dC1hYTc4NjlmNy5lc20uanMnO1xuaW1wb3J0ICd6b2QnO1xuaW1wb3J0ICcuL1F1ZXJ5UGFyYW1zLWFjMDE0OWM2LmVzbS5qcyc7XG5pbXBvcnQgJ2JuLmpzJztcbmltcG9ydCAnZXRoZXJzJztcbmltcG9ydCAnLi9kZWZpbmVQcm9wZXJ0eS1lMjRjODJlYS5lc20uanMnO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSUVSQzE2NS5qc29uJztcbmltcG9ydCAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lFUkM3MjEuanNvbic7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JRVJDMTE1NS5qc29uJztcbmltcG9ydCAndGlueS1pbnZhcmlhbnQnO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSVRoaXJkd2ViQ29udHJhY3QuanNvbic7XG5pbXBvcnQgJ2V2ZW50ZW1pdHRlcjMnO1xuaW1wb3J0ICdjcm9zcy1mZXRjaCc7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9Gb3J3YXJkZXIuanNvbic7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9Ecm9wRVJDMjBfVjIuanNvbic7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JQnVybmFibGVFUkMyMC5qc29uJztcbmltcG9ydCAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lEcm9wLmpzb24nO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSURyb3BTaW5nbGVQaGFzZS5qc29uJztcbmltcG9ydCAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lEcm9wU2luZ2xlUGhhc2VfVjEuanNvbic7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JRVJDMjAuanNvbic7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JTWludGFibGVFUkMyMC5qc29uJztcbmltcG9ydCAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lNdWx0aWNhbGwuanNvbic7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JU2lnbmF0dXJlTWludEVSQzIwLmpzb24nO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvRHJvcEVSQzcyMV9WMy5qc29uJztcbmltcG9ydCAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lCdXJuYWJsZUVSQzcyMS5qc29uJztcbmltcG9ydCAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lDbGFpbWFibGVFUkM3MjEuanNvbic7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JRGVsYXllZFJldmVhbC5qc29uJztcbmltcG9ydCAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lFUkM3MjFFbnVtZXJhYmxlLmpzb24nO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSUVSQzcyMVN1cHBseS5qc29uJztcbmltcG9ydCAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lMYXp5TWludC5qc29uJztcbmltcG9ydCAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lNaW50YWJsZUVSQzcyMS5qc29uJztcbmltcG9ydCAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lTaWduYXR1cmVNaW50RVJDNzIxLmpzb24nO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSVNpZ25hdHVyZU1pbnRFUkM3MjFfVjEuanNvbic7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9MYXp5TWludFdpdGhUaWVyLmpzb24nO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvRHJvcEVSQzExNTVfVjIuanNvbic7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JQnVybmFibGVFUkMxMTU1Lmpzb24nO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSUNsYWltYWJsZUVSQzExNTUuanNvbic7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JRHJvcDExNTUuanNvbic7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JRHJvcFNpbmdsZVBoYXNlMTE1NS5qc29uJztcbmltcG9ydCAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lEcm9wU2luZ2xlUGhhc2UxMTU1X1YxLmpzb24nO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSUVSQzExNTVFbnVtZXJhYmxlLmpzb24nO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSU1pbnRhYmxlRVJDMTE1NS5qc29uJztcbmltcG9ydCAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lTaWduYXR1cmVNaW50RVJDMTE1NS5qc29uJztcbmltcG9ydCAnYnM1OCc7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JRVJDMjBNZXRhZGF0YS5qc29uJztcbmltcG9ydCAnbWVya2xldHJlZWpzJztcbmltcG9ydCAnZmFzdC1kZWVwLWVxdWFsJztcbmltcG9ydCAndXVpZCc7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JRVJDNzIxTWV0YWRhdGEuanNvbic7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JRVJDMTE1NU1ldGFkYXRhLmpzb24nO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSURlbGF5ZWRSZXZlYWxEZXByZWNhdGVkLmpzb24nO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvVFdGYWN0b3J5Lmpzb24nO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvVFdSZWdpc3RyeS5qc29uJztcbmltcG9ydCAnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0NvbnRyYWN0UHVibGlzaGVyLmpzb24nO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L3N0b3JhZ2UnO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvRVJDMjc3MUNvbnRleHQuanNvbic7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JQXBwVVJJLmpzb24nO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSUNvbnRyYWN0TWV0YWRhdGEuanNvbic7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JUGVybWlzc2lvbnMuanNvbic7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JUGVybWlzc2lvbnNFbnVtZXJhYmxlLmpzb24nO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSVBsYXRmb3JtRmVlLmpzb24nO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSVByaW1hcnlTYWxlLmpzb24nO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L2NvbnRyYWN0cy1qcy9kaXN0L2FiaXMvSVJveWFsdHkuanNvbic7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9Pd25hYmxlLmpzb24nO1xuXG4vLyBoYW5kbGUgYnJvd3NlciB2cyBub2RlIGdsb2JhbFxuZ2xvYmFsVGhpcy5nbG9iYWwgPSBnbG9iYWxUaGlzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@thirdweb-dev/sdk/dist/thirdweb-dev-sdk.esm.js\n"));

/***/ }),

/***/ "./node_modules/@thirdweb-dev/sdk/node_modules/eventemitter3/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/sdk/node_modules/eventemitter3/index.js ***!
  \****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi9zZGsvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxnQkFBZ0IsWUFBWTtBQUM1Qjs7QUFFQTtBQUNBLDREQUE0RDtBQUM1RCxnRUFBZ0U7QUFDaEUsb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RTtBQUNBLDJEQUEyRCxTQUFTO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw0REFBNEQsWUFBWTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQTZCO0FBQ2pDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aGlyZHdlYi1kZXYvc2RrL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzP2ZkMzMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@thirdweb-dev/sdk/node_modules/eventemitter3/index.js\n"));

/***/ }),

/***/ "./node_modules/@thirdweb-dev/sdk/node_modules/eventemitter3/index.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/sdk/node_modules/eventemitter3/index.mjs ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EventEmitter\": function() { return /* reexport default export from named module */ _index_js__WEBPACK_IMPORTED_MODULE_0__; }\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"./node_modules/@thirdweb-dev/sdk/node_modules/eventemitter3/index.js\");\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_index_js__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi9zZGsvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXgubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFDOztBQUVkO0FBQ3ZCLCtEQUFlLHNDQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdGhpcmR3ZWItZGV2L3Nkay9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5tanM/ZWJiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vaW5kZXguanMnXG5cbmV4cG9ydCB7IEV2ZW50RW1pdHRlciB9XG5leHBvcnQgZGVmYXVsdCBFdmVudEVtaXR0ZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@thirdweb-dev/sdk/node_modules/eventemitter3/index.mjs\n"));

/***/ }),

/***/ "./node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721_V1.json":
/*!****************************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721_V1.json ***!
  \****************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = JSON.parse('[{"inputs":[{"components":[{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"royaltyRecipient","type":"address"},{"internalType":"uint256","name":"royaltyBps","type":"uint256"},{"internalType":"address","name":"primarySaleRecipient","type":"address"},{"internalType":"string","name":"uri","type":"string"},{"internalType":"uint256","name":"price","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint128","name":"validityStartTimestamp","type":"uint128"},{"internalType":"uint128","name":"validityEndTimestamp","type":"uint128"},{"internalType":"bytes32","name":"uid","type":"bytes32"}],"internalType":"struct ITokenERC721.MintRequest","name":"_req","type":"tuple"},{"internalType":"bytes","name":"_signature","type":"bytes"}],"name":"mintWithSignature","outputs":[{"internalType":"uint256","name":"tokenIdMinted","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"royaltyRecipient","type":"address"},{"internalType":"uint256","name":"royaltyBps","type":"uint256"},{"internalType":"address","name":"primarySaleRecipient","type":"address"},{"internalType":"string","name":"uri","type":"string"},{"internalType":"uint256","name":"price","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint128","name":"validityStartTimestamp","type":"uint128"},{"internalType":"uint128","name":"validityEndTimestamp","type":"uint128"},{"internalType":"bytes32","name":"uid","type":"bytes32"}],"internalType":"struct ITokenERC721.MintRequest","name":"_req","type":"tuple"},{"internalType":"bytes","name":"_signature","type":"bytes"}],"name":"verify","outputs":[{"internalType":"bool","name":"","type":"bool"},{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}]');

/***/ })

});